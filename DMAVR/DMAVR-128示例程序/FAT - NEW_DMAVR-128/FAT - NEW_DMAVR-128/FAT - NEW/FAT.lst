Interrupt Vectors
    00000 940C 01BA JMP	__text_start|__start

Program Code (text area)
__text_start|__start:
    001BA EFCF      LDI	R28,0xFF
    001BB E1D0      LDI	R29,0x10
    001BC BFCD      OUT	0x3D,R28
    001BD BFDE      OUT	0x3E,R29
    001BE 51CE      SUBI	R28,0x1E
    001BF 40D0      SBCI	R29,0
    001C0 EA0A      LDI	R16,0xAA
    001C1 8308      ST	Y,R16
    001C2 2400      CLR	R0
    001C3 E6EC      LDI	R30,0x6C
    001C4 E0F2      LDI	R31,2
    001C5 E018      LDI	R17,0x8
    001C6 3AE8      CPI	R30,0xA8
    001C7 07F1      CPC	R31,R17
    001C8 F011      BEQ	0x01CB
    001C9 9201      ST	Z+,R0
    001CA CFFB      RJMP	0x01C6
    001CB 8300      ST	Z,R16
    001CC E0E7      LDI	R30,7
    001CD E0F2      LDI	R31,2
    001CE E0A0      LDI	R26,0
    001CF E0B1      LDI	R27,1
    001D0 E013      LDI	R17,3
    001D1 E000      LDI	R16,0
    001D2 BF0B      OUT	0x3B,R16
    001D3 37E3      CPI	R30,0x73
    001D4 07F1      CPC	R31,R17
    001D5 F021      BEQ	0x01DA
    001D6 95C8      LPM
    001D7 9631      ADIW	R30,1
    001D8 920D      ST	X+,R0
    001D9 CFF9      RJMP	0x01D3
    001DA 940E 0F83 CALL	_main
_exit:
    001DC CFFF      RJMP	_exit
_ReadBlock:
  LBA                  --> Y,+4
    001DD 940E 19E4 CALL	push_arg4
    001DF 9724      SBIW	R28,4
FILE: E:\DMAVR-~3\FAT-NE~1\FAT.C
(0001) //******************************************************************************
(0002) //FAT文件系统相关操作函数
(0003) //支持FAT16文件系统
(0004) //编译环境：ICCAVR 7.22A
(0005) //作者：www.avrgcc.com
(0006) //时间：2010.08.01
(0007) //******************************************************************************
(0008)  
(0009) #include "stdio.h"
(0010) #include <stdlib.h>
(0011) #include "string.h"
(0012) #include "SD.h"
(0013) #include "FAT16.h"
(0014) 
(0015) extern uint8 BUFFER[512];
(0016) 
(0017) uint16 BPB_BytesPerSec;
(0018) uint8 BPB_SecPerClus;
(0019) uint16 BPB_RsvdSecCnt;
(0020) uint8 BPB_NumFATs;
(0021) uint16 BPB_RootEntCnt;
(0022) uint16 BPB_TotSec16;
(0023) uint16 BPB_FATSz16;
(0024) uint32 BPB_HiddSec;
(0025) 
(0026) uint32 BPB_FATSz32;
(0027) uint32 BPB_RootClus;
(0028) uint16 BPB_FSInfo;
(0029) uint8  FAT32_EN;                               //为0则表示FAT16，为1则表示FAT32
(0030) 
(0031) uint16 DirectoryCount = 0,FileCount = 0;       //根目录下文件夹和文件的数量
(0032) 
(0033) /***********************************************************************
(0034) 函数功能：读一个扇区函数
(0035) 操作内容：1、调用MMC/SD卡块读取函数
(0036)           2、函数宏定义参考头文件
(0037) ***********************************************************************/
(0038) 
(0039) void ReadBlock(uint32 LBA)
(0040) {
(0041) 	mmcReadSector(LBA,BUFFER);
    001E0 E887      LDI	R24,0x87
    001E1 E092      LDI	R25,2
    001E2 839B      STD	Y+3,R25
    001E3 838A      STD	Y+2,R24
    001E4 E080      LDI	R24,0
    001E5 E092      LDI	R25,2
    001E6 8399      STD	Y+1,R25
    001E7 8388      ST	Y,R24
    001E8 810C      LDD	R16,Y+4
    001E9 811D      LDD	R17,Y+5
    001EA 812E      LDD	R18,Y+6
    001EB 813F      LDD	R19,Y+7
    001EC 940E 1284 CALL	_mmcReadBlock
(0042)         return;
    001EE 9628      ADIW	R28,0x8
    001EF 9508      RET
_WriteBlock:
  LBA                  --> Y,+4
    001F0 940E 19E4 CALL	push_arg4
    001F2 9724      SBIW	R28,4
(0043) }
(0044) 
(0045) /***********************************************************************
(0046) 函数功能：写一个扇区函数
(0047) 操作内容：1、调用MMC/SD卡块写入函数
(0048)           2、函数宏定义参考头文件
(0049) ***********************************************************************/
(0050) 
(0051) void WriteBlock(uint32 LBA)
(0052) {
(0053) 	mmcWriteSector(LBA,BUFFER);
    001F3 E887      LDI	R24,0x87
    001F4 E092      LDI	R25,2
    001F5 839B      STD	Y+3,R25
    001F6 838A      STD	Y+2,R24
    001F7 E080      LDI	R24,0
    001F8 E092      LDI	R25,2
    001F9 8399      STD	Y+1,R25
    001FA 8388      ST	Y,R24
    001FB 810C      LDD	R16,Y+4
    001FC 811D      LDD	R17,Y+5
    001FD 812E      LDD	R18,Y+6
    001FE 813F      LDD	R19,Y+7
    001FF 940E 1308 CALL	_mmcWriteBlock
(0054)         return;
    00201 9628      ADIW	R28,0x8
    00202 9508      RET
_CopyBytes:
  d                    --> R12
  s                    --> R10
  i                    --> R20
  size                 --> R14
  D                    --> R18
  S                    --> R16
    00203 940E 1AF3 CALL	push_xgset30FC
    00205 84E8      LDD	R14,Y+8
    00206 84F9      LDD	R15,Y+9
(0055) }
(0056) 
(0057) /***********************************************************************
(0058) 函数功能：字节数据复制
(0059) 操作内容：数据复制，按字节方式，size定义大小
(0060) ***********************************************************************/
(0061) 
(0062) void CopyBytes(void* S, void* D, uint16 size)
(0063) {
(0064) 	uint8 *s = S, *d = D;
    00207 0158      MOVW	R10,R16
    00208 0169      MOVW	R12,R18
(0065) 	uint16 i;
(0066) 	for(i = 0; i < size; i++)
    00209 2744      CLR	R20
    0020A 2755      CLR	R21
    0020B C008      RJMP	0x0214
(0067) 		*d++ = *s++;
    0020C 01F5      MOVW	R30,R10
    0020D 01D6      MOVW	R26,R12
    0020E 9001      LD	R0,Z+
    0020F 015F      MOVW	R10,R30
    00210 920D      ST	X+,R0
    00211 016D      MOVW	R12,R26
    00212 5F4F      SUBI	R20,0xFF
    00213 4F5F      SBCI	R21,0xFF
    00214 154E      CP	R20,R14
    00215 055F      CPC	R21,R15
    00216 F3A8      BCS	0x020C
    00217 940C 1ADD JMP	pop_xgset30FC
_CopyWord:
  d                    --> R12
  s                    --> R10
  i                    --> R20
  size                 --> R14
  D                    --> R18
  S                    --> R16
    00219 940E 1AF3 CALL	push_xgset30FC
    0021B 84E8      LDD	R14,Y+8
    0021C 84F9      LDD	R15,Y+9
(0068) }
(0069) 
(0070) /***********************************************************************
(0071) 函数功能：字数据复制
(0072) 操作内容：数据复制，按字方式，size定义大小
(0073) ***********************************************************************/
(0074) 
(0075) void CopyWord(void* S, void* D, uint16 size)
(0076) {
(0077) 	uint16 *s = S, *d = D;
    0021D 0158      MOVW	R10,R16
    0021E 0169      MOVW	R12,R18
(0078) 	uint16 i;
(0079) 	for(i = 0; i < size; i++)
    0021F 2744      CLR	R20
    00220 2755      CLR	R21
    00221 C00A      RJMP	0x022C
(0080) 		*d++ = *s++;
    00222 01F5      MOVW	R30,R10
    00223 01D6      MOVW	R26,R12
    00224 9001      LD	R0,Z+
    00225 9011      LD	R1,Z+
    00226 015F      MOVW	R10,R30
    00227 920D      ST	X+,R0
    00228 921D      ST	X+,R1
    00229 016D      MOVW	R12,R26
    0022A 5F4F      SUBI	R20,0xFF
    0022B 4F5F      SBCI	R21,0xFF
    0022C 154E      CP	R20,R14
    0022D 055F      CPC	R21,R15
    0022E F398      BCS	0x0222
    0022F 940C 1ADD JMP	pop_xgset30FC
_IsEqual:
  b                    --> R14
  a                    --> R12
  i                    --> R10
  Size                 --> R20
  B                    --> R18
  A                    --> R16
    00231 940E 1AF3 CALL	push_xgset30FC
    00233 8548      LDD	R20,Y+8
(0081) }
(0082) 
(0083) /***********************************************************************
(0084) 函数功能：数据比较函数
(0085) 操作内容：1、比较数据是否相等，相等返回1，不相等返回0
(0086)           2、参数为起始地址和数据大小
(0087) ***********************************************************************/
(0088) 
(0089) uint8 IsEqual(void* A, void* B, uint8 Size)
(0090) {
(0091) 	uint8 i, *a = A, *b = B;
    00234 0168      MOVW	R12,R16
    00235 0179      MOVW	R14,R18
(0092) 	for(i = 0; i < Size; i++)
    00236 24AA      CLR	R10
    00237 C00F      RJMP	0x0247
(0093) 		if(a[i] != b[i])
    00238 2DEA      MOV	R30,R10
    00239 27FF      CLR	R31
    0023A 0DEE      ADD	R30,R14
    0023B 1DFF      ADC	R31,R15
    0023C 8020      LD	R2,Z
    0023D 2DEA      MOV	R30,R10
    0023E 27FF      CLR	R31
    0023F 0DEC      ADD	R30,R12
    00240 1DFD      ADC	R31,R13
    00241 8030      LD	R3,Z
    00242 1432      CP	R3,R2
    00243 F011      BEQ	0x0246
(0094) 			return 0;              //不相等返回0
    00244 2700      CLR	R16
    00245 C004      RJMP	0x024A
    00246 94A3      INC	R10
    00247 16A4      CP	R10,R20
    00248 F378      BCS	0x0238
(0095) 	return 1;                              //相等返回1
    00249 E001      LDI	R16,1
    0024A 940C 1ADD JMP	pop_xgset30FC
_EmptyBytes:
  data                 --> R10
  i                    --> R20
  size                 --> R18
  D                    --> R16
    0024C 940E 1AFC CALL	push_xgset300C
(0096) }
(0097) 
(0098) /***********************************************************************
(0099) 函数功能：空数据字节填充
(0100) 操作内容：数据全为0，size定义填充0的大小
(0101) ***********************************************************************/
(0102) 
(0103) void EmptyBytes(void* D, uint16 size)
(0104) {
(0105) 	uint16 i;
(0106) 	uint8* data = (uint8*)D;
    0024E 0158      MOVW	R10,R16
(0107) 	for(i = 0; i < size; i++)
    0024F 2744      CLR	R20
    00250 2755      CLR	R21
    00251 C006      RJMP	0x0258
(0108) 	{
(0109) 		*data++ = 0;
    00252 2422      CLR	R2
    00253 01F5      MOVW	R30,R10
    00254 9221      ST	Z+,R2
    00255 015F      MOVW	R10,R30
    00256 5F4F      SUBI	R20,0xFF
    00257 4F5F      SBCI	R21,0xFF
    00258 1742      CP	R20,R18
    00259 0753      CPC	R21,R19
    0025A F3B8      BCS	0x0252
    0025B 940C 1B01 JMP	pop_xgset300C
_FATInit:
  BPB                  --> R20
    0025D 934A      ST	-Y,R20
    0025E 935A      ST	-Y,R21
(0110) 	}
(0111) }
(0112) /***********************************************************************
(0113) 函数功能：写入MMC/SD卡FAT文件系统BPB(BIOS Parameter Block)数据结构
(0114) 操作内容：1、BPB数据结构体参考头文件定义
(0115)           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
(0116) ***********************************************************************/
(0117) void FATInit(void)
(0118) {
(0119) 	FAT_BPB* BPB = (FAT_BPB*)BUFFER;
    0025F E847      LDI	R20,0x87
    00260 E052      LDI	R21,2
(0120) 		
(0121) 	BPB->BPB_BytesPerSec = 0x0200;          //每个扇区512字节
    00261 E080      LDI	R24,0
    00262 E092      LDI	R25,2
    00263 01FA      MOVW	R30,R20
    00264 8794      STD	Z+12,R25
    00265 8783      STD	Z+11,R24
(0122) 	BPB->BPB_SecPerClus  = 0x20;            //每个簇8个扇区
    00266 E280      LDI	R24,0x20
    00267 8785      STD	Z+13,R24
(0123) 	BPB->BPB_RsvdSecCnt  = 0x06;          //一个保留扇区
    00268 E086      LDI	R24,6
    00269 E090      LDI	R25,0
    0026A 8797      STD	Z+15,R25
    0026B 8786      STD	Z+14,R24
(0124) 	BPB->BPB_NumFATs     = 0x02;            //2个FAT表
    0026C E082      LDI	R24,2
    0026D 8B80      STD	Z+16,R24
(0125) 	BPB->BPB_RootEntCnt  = 0x200;          //512目录项个数
    0026E E080      LDI	R24,0
    0026F E092      LDI	R25,2
    00270 8B92      STD	Z+18,R25
    00271 8B81      STD	Z+17,R24
(0126) 	BPB->BPB_TotSec16    = 0x00;          //总扇区数
    00272 2422      CLR	R2
    00273 2433      CLR	R3
    00274 8A34      STD	Z+20,R3
    00275 8A23      STD	Z+19,R2
(0127) 	BPB->BPB_FATSz16     = 0xF1;            //一个FAT表所占的扇区数
    00276 EF81      LDI	R24,0xF1
    00277 E090      LDI	R25,0
    00278 8B97      STD	Z+23,R25
    00279 8B86      STD	Z+22,R24
(0128) 	BPB->BPB_HiddSec     = 0xFD;      //本FAT表前隐藏的扇区数
    0027A 967C      ADIW	R30,0x1C
    0027B EF8D      LDI	R24,0xFD
    0027C 8380      ST	Z,R24
    0027D E080      LDI	R24,0
    0027E 8381      STD	Z+1,R24
    0027F 8382      STD	Z+2,R24
    00280 8383      STD	Z+3,R24
(0129) 	
(0130) 	WriteBlock(253);                          //写引导区
    00281 EF0D      LDI	R16,0xFD
    00282 E010      LDI	R17,0
    00283 E020      LDI	R18,0
    00284 E030      LDI	R19,0
    00285 DF6A      RCALL	_WriteBlock
    00286 9159      LD	R21,Y+
    00287 9149      LD	R20,Y+
    00288 9508      RET
_ReadBPB:
  BPB                  --> R20
    00289 934A      ST	-Y,R20
    0028A 935A      ST	-Y,R21
(0131) }
(0132) 
(0133) 
(0134) /***********************************************************************
(0135) 函数功能：读取FAT16文件系统BPB(BIOS Parameter Block)数据结构
(0136) 操作内容：1、BPB数据结构体参考头文件定义
(0137)           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
(0138) ***********************************************************************/
(0139) 
(0140) void ReadBPB(void)
(0141) {
(0142) 	FAT_BPB* BPB = (FAT_BPB*)BUFFER;
    0028B E847      LDI	R20,0x87
    0028C E052      LDI	R21,2
(0143) 	//ReadBlock(0);
(0144) 	ReadBlock(253);                 //获取参数，将BPB区数据读入缓冲区
    0028D EF0D      LDI	R16,0xFD
    0028E E010      LDI	R17,0
    0028F E020      LDI	R18,0
    00290 E030      LDI	R19,0
    00291 DF4B      RCALL	_ReadBlock
(0145)         
(0146) 	BPB_BytesPerSec = BPB->BPB_BytesPerSec;   //这些记录了数据结构  
    00292 01FA      MOVW	R30,R20
    00293 8423      LDD	R2,Z+11
    00294 8434      LDD	R3,Z+12
    00295 9230 0286 STS	BPB_BytesPerSec+1,R3
    00297 9220 0285 STS	BPB_BytesPerSec,R2
(0147) 	BPB_SecPerClus = BPB->BPB_SecPerClus;     //每簇扇区数，格式化时可以选每个簇的大小，如2K，32K
    00299 8425      LDD	R2,Z+13
    0029A 9220 0284 STS	BPB_SecPerClus,R2
(0148) 	BPB_RsvdSecCnt = BPB->BPB_RsvdSecCnt;     //MMC/SD卡格式化后，保留为6个扇区
    0029C 8426      LDD	R2,Z+14
    0029D 8437      LDD	R3,Z+15
    0029E 9230 0283 STS	BPB_RsvdSecCnt+1,R3
    002A0 9220 0282 STS	BPB_RsvdSecCnt,R2
(0149) 	BPB_NumFATs = BPB->BPB_NumFATs;           //2个FAT表，如果一个FAT表损坏，可以用另外一个
    002A2 8820      LDD	R2,Z+16
    002A3 9220 0281 STS	BPB_NumFATs,R2
(0150) 	BPB_RootEntCnt = BPB->BPB_RootEntCnt;
    002A5 8821      LDD	R2,Z+17
    002A6 8832      LDD	R3,Z+18
    002A7 9230 0280 STS	BPB_RootEntCnt+1,R3
    002A9 9220 027F STS	BPB_RootEntCnt,R2
(0151) 	BPB_TotSec16 = BPB->BPB_TotSec16;         //如果为0，BPB_FATSz16记录扇区总数
    002AB 8823      LDD	R2,Z+19
    002AC 8834      LDD	R3,Z+20
    002AD 9230 027E STS	BPB_TotSec16+1,R3
    002AF 9220 027D STS	BPB_TotSec16,R2
(0152) 	BPB_FATSz16 = BPB->BPB_FATSz16;           //FAT占用扇区总数，FAT32为0，FAT16不为0
    002B1 8826      LDD	R2,Z+22
    002B2 8837      LDD	R3,Z+23
    002B3 9230 027C STS	BPB_FATSz16+1,R3
    002B5 9220 027B STS	BPB_FATSz16,R2
(0153) 	BPB_HiddSec = BPB->BPB_HiddSec;           //隐藏扇区，默认为0
    002B7 8C24      LDD	R2,Z+28
    002B8 8C35      LDD	R3,Z+29
    002B9 8C46      LDD	R4,Z+30
    002BA 8C57      LDD	R5,Z+31
    002BB 9230 0278 STS	BPB_HiddSec+1,R3
    002BD 9220 0277 STS	BPB_HiddSec,R2
    002BF 9250 027A STS	BPB_HiddSec+3,R5
    002C1 9240 0279 STS	BPB_HiddSec+2,R4
    002C3 9159      LD	R21,Y+
    002C4 9149      LD	R20,Y+
    002C5 9508      RET
_ReadBPB32:
  BPB                  --> R20
    002C6 934A      ST	-Y,R20
    002C7 935A      ST	-Y,R21
(0154) 
(0155) }
(0156) 
(0157) /***********************************************************************
(0158) 函数功能：读取FAT32文件系统BPB(BIOS Parameter Block)数据结构
(0159) 操作内容：1、BPB数据结构体参考头文件定义
(0160)           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
(0161) ***********************************************************************/
(0162) 
(0163) void ReadBPB32(void)
(0164) {
(0165) 	FAT32_BPB* BPB = (FAT32_BPB*)BUFFER;
    002C8 E847      LDI	R20,0x87
    002C9 E052      LDI	R21,2
(0166) 	ReadBlock(253);                             //获取参数，将BPB区数据读入缓冲区
    002CA EF0D      LDI	R16,0xFD
    002CB E010      LDI	R17,0
    002CC E020      LDI	R18,0
    002CD E030      LDI	R19,0
    002CE DF0E      RCALL	_ReadBlock
(0167)         
(0168) 	BPB_BytesPerSec = BPB->BPB_BytesPerSec;   //这些记录了数据结构  
    002CF 01FA      MOVW	R30,R20
    002D0 8423      LDD	R2,Z+11
    002D1 8434      LDD	R3,Z+12
    002D2 9230 0286 STS	BPB_BytesPerSec+1,R3
    002D4 9220 0285 STS	BPB_BytesPerSec,R2
(0169) 	BPB_SecPerClus = BPB->BPB_SecPerClus;     //每簇扇区数，格式化时可以选每个簇的大小，如2K，32K
    002D6 8425      LDD	R2,Z+13
    002D7 9220 0284 STS	BPB_SecPerClus,R2
(0170) 	BPB_RsvdSecCnt = BPB->BPB_RsvdSecCnt;     //MMC/SD卡格式化后，保留为6个扇区
    002D9 8426      LDD	R2,Z+14
    002DA 8437      LDD	R3,Z+15
    002DB 9230 0283 STS	BPB_RsvdSecCnt+1,R3
    002DD 9220 0282 STS	BPB_RsvdSecCnt,R2
(0171) 	BPB_NumFATs = BPB->BPB_NumFATs;           //2个FAT表，如果一个FAT表损坏，可以用另外一个
    002DF 8820      LDD	R2,Z+16
    002E0 9220 0281 STS	BPB_NumFATs,R2
(0172) 	BPB_RootEntCnt = BPB->BPB_RootEntCnt;
    002E2 8821      LDD	R2,Z+17
    002E3 8832      LDD	R3,Z+18
    002E4 9230 0280 STS	BPB_RootEntCnt+1,R3
    002E6 9220 027F STS	BPB_RootEntCnt,R2
(0173) 	BPB_TotSec16 = BPB->BPB_TotSec16;         //如果为0，BPB_FATSz16记录扇区总数
    002E8 8823      LDD	R2,Z+19
    002E9 8834      LDD	R3,Z+20
    002EA 9230 027E STS	BPB_TotSec16+1,R3
    002EC 9220 027D STS	BPB_TotSec16,R2
(0174) 	BPB_FATSz16 = BPB->BPB_FATSz16;           //FAT占用扇区总数，FAT32为0，FAT16不为0
    002EE 8826      LDD	R2,Z+22
    002EF 8837      LDD	R3,Z+23
    002F0 9230 027C STS	BPB_FATSz16+1,R3
    002F2 9220 027B STS	BPB_FATSz16,R2
(0175) 	BPB_HiddSec = BPB->BPB_HiddSec;           //隐藏扇区，默认为0
    002F4 8C24      LDD	R2,Z+28
    002F5 8C35      LDD	R3,Z+29
    002F6 8C46      LDD	R4,Z+30
    002F7 8C57      LDD	R5,Z+31
    002F8 9230 0278 STS	BPB_HiddSec+1,R3
    002FA 9220 0277 STS	BPB_HiddSec,R2
    002FC 9250 027A STS	BPB_HiddSec+3,R5
    002FE 9240 0279 STS	BPB_HiddSec+2,R4
(0176)         
(0177)         BPB_FATSz32 = BPB->BPB_FATSz32;
    00300 A024      LDD	R2,Z+36
    00301 A035      LDD	R3,Z+37
    00302 A046      LDD	R4,Z+38
    00303 A057      LDD	R5,Z+39
    00304 9230 0274 STS	BPB_FATSz32+1,R3
    00306 9220 0273 STS	BPB_FATSz32,R2
    00308 9250 0276 STS	BPB_FATSz32+3,R5
    0030A 9240 0275 STS	BPB_FATSz32+2,R4
(0178)         BPB_RootClus =BPB->BPB_RootClus;
    0030C A424      LDD	R2,Z+44
    0030D A435      LDD	R3,Z+45
    0030E A446      LDD	R4,Z+46
    0030F A457      LDD	R5,Z+47
    00310 9230 0270 STS	BPB_RootClus+1,R3
    00312 9220 026F STS	BPB_RootClus,R2
    00314 9250 0272 STS	BPB_RootClus+3,R5
    00316 9240 0271 STS	BPB_RootClus+2,R4
(0179)         BPB_FSInfo = BPB->BPB_FSInfo;
    00318 A820      LDD	R2,Z+48
    00319 A831      LDD	R3,Z+49
    0031A 9230 026E STS	BPB_FSInfo+1,R3
    0031C 9220 026D STS	BPB_FSInfo,R2
    0031E 9159      LD	R21,Y+
    0031F 9149      LD	R20,Y+
    00320 9508      RET
(0180) }
(0181) 
(0182) 
(0183) 
(0184) /***********************************************************************
(0185) 函数功能：获取FAT表扇区号，支持FAT16/32
(0186) 操作内容：1、FAT表扇区号为隐藏扇区+保留扇区
(0187)           2、隐藏扇区默认为0
(0188) ***********************************************************************/
(0189) 
(0190) uint32 FATStartSec(void)
(0191) {
(0192)     return BPB_RsvdSecCnt + BPB_HiddSec; //????????????????????????????
_FATStartSec:
    00321 9040 0279 LDS	R4,BPB_HiddSec+2
    00323 9050 027A LDS	R5,BPB_HiddSec+3
    00325 9020 0277 LDS	R2,BPB_HiddSec
    00327 9030 0278 LDS	R3,BPB_HiddSec+1
    00329 9100 0282 LDS	R16,BPB_RsvdSecCnt
    0032B 9110 0283 LDS	R17,BPB_RsvdSecCnt+1
    0032D 2722      CLR	R18
    0032E 2733      CLR	R19
    0032F 0D02      ADD	R16,R2
    00330 1D13      ADC	R17,R3
    00331 1D24      ADC	R18,R4
    00332 1D35      ADC	R19,R5
    00333 9508      RET
_DirStartSec:
  FATSz                --> Y,+0
    00334 9724      SBIW	R28,4
(0193) }
(0194) 
(0195) /***********************************************************************
(0196) 函数功能：获取根目录开始扇区号，支持FAT32
(0197) 操作内容：1、根目录扇区数是固定的
(0198)           2、根目录扇区紧接着FAT表之后
(0199) ***********************************************************************/
(0200) 
(0201) uint32 DirStartSec(void)
(0202) {
(0203)   uint32 FATSz;
(0204)   if(FAT32_EN==0)
    00335 9020 026C LDS	R2,FAT32_EN
    00337 2022      TST	R2
    00338 F459      BNE	0x0344
(0205)     FATSz=BPB_FATSz16;
    00339 9020 027B LDS	R2,BPB_FATSz16
    0033B 9030 027C LDS	R3,BPB_FATSz16+1
    0033D 2444      CLR	R4
    0033E 2455      CLR	R5
    0033F 8228      ST	Y,R2
    00340 8239      STD	Y+1,R3
    00341 824A      STD	Y+2,R4
    00342 825B      STD	Y+3,R5
    00343 C00C      RJMP	0x0350
(0206)   else
(0207)     FATSz=BPB_FATSz32;
    00344 9040 0275 LDS	R4,BPB_FATSz32+2
    00346 9050 0276 LDS	R5,BPB_FATSz32+3
    00348 9020 0273 LDS	R2,BPB_FATSz32
    0034A 9030 0274 LDS	R3,BPB_FATSz32+1
    0034C 8228      ST	Y,R2
    0034D 8239      STD	Y+1,R3
    0034E 824A      STD	Y+2,R4
    0034F 825B      STD	Y+3,R5
(0208)     return BPB_HiddSec+BPB_RsvdSecCnt + BPB_NumFATs * FATSz;             //保留扇区+FAT表数×FAT占用扇区数   ??????????????????????
    00350 8028      LD	R2,Y
    00351 8039      LDD	R3,Y+1
    00352 804A      LDD	R4,Y+2
    00353 805B      LDD	R5,Y+3
    00354 9100 0281 LDS	R16,BPB_NumFATs
    00356 2711      CLR	R17
    00357 2722      CLR	R18
    00358 2733      CLR	R19
    00359 925A      ST	-Y,R5
    0035A 924A      ST	-Y,R4
    0035B 923A      ST	-Y,R3
    0035C 922A      ST	-Y,R2
    0035D 940E 1A9D CALL	empy32u|empy32s
    0035F 0118      MOVW	R2,R16
    00360 0129      MOVW	R4,R18
    00361 9060 0282 LDS	R6,BPB_RsvdSecCnt
    00363 9070 0283 LDS	R7,BPB_RsvdSecCnt+1
    00365 2488      CLR	R8
    00366 2499      CLR	R9
    00367 9120 0279 LDS	R18,BPB_HiddSec+2
    00369 9130 027A LDS	R19,BPB_HiddSec+3
    0036B 9100 0277 LDS	R16,BPB_HiddSec
    0036D 9110 0278 LDS	R17,BPB_HiddSec+1
    0036F 0D06      ADD	R16,R6
    00370 1D17      ADC	R17,R7
    00371 1D28      ADC	R18,R8
    00372 1D39      ADC	R19,R9
    00373 0D02      ADD	R16,R2
    00374 1D13      ADC	R17,R3
    00375 1D24      ADC	R18,R4
    00376 1D35      ADC	R19,R5
    00377 9624      ADIW	R28,4
    00378 9508      RET
(0209) }
(0210) 
(0211) /***********************************************************************
(0212) 函数功能：获取数据区开始扇区号，支持FAT32
(0213) 操作内容：1、计算数据开始扇区号
(0214)           2、FAT32系统下BPB_RootEntCnt=0
(0215) ***********************************************************************/
(0216) 
(0217) uint32 DataStartSec(void)
(0218) {
(0219) 	return (uint32)(DirStartSec() + (BPB_RootEntCnt * 32) / BPB_BytesPerSec); //乘以32是因为根目录是32位长度文件
_DataStartSec:
    00379 DFBA      RCALL	_DirStartSec
    0037A 0118      MOVW	R2,R16
    0037B 0129      MOVW	R4,R18
    0037C 9120 027F LDS	R18,BPB_RootEntCnt
    0037E 9130 0280 LDS	R19,BPB_RootEntCnt+1
    00380 E200      LDI	R16,0x20
    00381 E010      LDI	R17,0
    00382 940E 1A8D CALL	empy16s
    00384 9120 0285 LDS	R18,BPB_BytesPerSec
    00386 9130 0286 LDS	R19,BPB_BytesPerSec+1
    00388 940E 1A09 CALL	div16u
    0038A 0138      MOVW	R6,R16
    0038B 2488      CLR	R8
    0038C 2499      CLR	R9
    0038D 0181      MOVW	R16,R2
    0038E 0192      MOVW	R18,R4
    0038F 0D06      ADD	R16,R6
    00390 1D17      ADC	R17,R7
    00391 1D28      ADC	R18,R8
    00392 1D39      ADC	R19,R9
    00393 9508      RET
(0220) }
(0221) 
(0222) /***********************************************************************
(0223) 函数功能：根目录占用扇区数，FAT16有效
(0224) 操作内容：1、计算根目录占用扇区数
(0225)           2、根目录为长度为32位的“文件”
(0226)           3、不是真正文件，类似文件
(0227) ***********************************************************************/
(0228) 
(0229) uint16 GetDirSecCount(void)
(0230) {
(0231) 	return BPB_RootEntCnt * 32 / BPB_BytesPerSec;
_GetDirSecCount:
    00394 9120 027F LDS	R18,BPB_RootEntCnt
    00396 9130 0280 LDS	R19,BPB_RootEntCnt+1
    00398 E200      LDI	R16,0x20
    00399 E010      LDI	R17,0
    0039A 940E 1A8D CALL	empy16s
    0039C 9120 0285 LDS	R18,BPB_BytesPerSec
    0039E 9130 0286 LDS	R19,BPB_BytesPerSec+1
    003A0 940C 1A09 JMP	div16u
(0232) }
(0233) 
(0234) /***********************************************************************
(0235) 函数功能：根目录所在第一个簇的簇号，FAT32有效
(0236) 操作内容：1、FAT32根目录项是不确定的，FAT16为固定值512
(0237)           2、根目录项不限制
(0238) ***********************************************************************/
(0239) uint32 GetDirStartClus(void)
(0240) {
(0241) 	return BPB_RootClus;
_GetDirStartClus:
    003A2 9120 0271 LDS	R18,BPB_RootClus+2
    003A4 9130 0272 LDS	R19,BPB_RootClus+3
    003A6 9100 026F LDS	R16,BPB_RootClus
    003A8 9110 0270 LDS	R17,BPB_RootClus+1
    003AA 9508      RET
_ClusConvLBA:
  ClusID               --> R20
    003AB 934A      ST	-Y,R20
    003AC 935A      ST	-Y,R21
    003AD 01A8      MOVW	R20,R16
(0242) }
(0243) 
(0244) /***********************************************************************
(0245) 函数功能：获取一个给定的簇的扇区开始地址
(0246) 操作内容：1、计算簇开始扇区号    
(0247)           2、它是针对FAT卷扇区0的偏移量
(0248)           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
(0249) ***********************************************************************/
(0250) 
(0251) uint32 ClusConvLBA(uint16 ClusID)
(0252) {
(0253) 	return DataStartSec() + BPB_SecPerClus * (ClusID - 2);
    003AE DFCA      RCALL	_DataStartSec
    003AF 0118      MOVW	R2,R16
    003B0 0129      MOVW	R4,R18
    003B1 019A      MOVW	R18,R20
    003B2 5022      SUBI	R18,2
    003B3 4030      SBCI	R19,0
    003B4 9100 0284 LDS	R16,BPB_SecPerClus
    003B6 2711      CLR	R17
    003B7 940E 1A8D CALL	empy16s
    003B9 0138      MOVW	R6,R16
    003BA 2488      CLR	R8
    003BB 2499      CLR	R9
    003BC 0181      MOVW	R16,R2
    003BD 0192      MOVW	R18,R4
    003BE 0D06      ADD	R16,R6
    003BF 1D17      ADC	R17,R7
    003C0 1D28      ADC	R18,R8
    003C1 1D39      ADC	R19,R9
    003C2 9159      LD	R21,Y+
    003C3 9149      LD	R20,Y+
    003C4 9508      RET
(0254) }
(0255) 
(0256) /***********************************************************************
(0257) 函数功能：判断文件系统类型，FAT16/FAT32中的一种，FAT12目前基本不用了
(0258) 操作内容：1、实际上文件系统类型的判断只有唯一的方法：判断簇的大小   
(0259)           2、FAT12的簇数最大4084，FAT16最大65524，FAT32大于65524
(0260)           3、簇数完全由BPB信息确定，可以计算
(0261)           4、考虑到FAT32文件系统不存在固定的FAT表区，因此FATSz16=0
(0262)           5、通过FATSz16是否为0即可判断是FAT16还是FAT32
(0263) ***********************************************************************/
(0264) void FATSystemType(void)
(0265) { 
(0266)   if(BPB_FATSz16!=0)
_FATSystemType:
    003C5 9020 027B LDS	R2,BPB_FATSz16
    003C7 9030 027C LDS	R3,BPB_FATSz16+1
    003C9 2022      TST	R2
    003CA F411      BNE	0x03CD
    003CB 2033      TST	R3
    003CC F021      BEQ	0x03D1
(0267)     FAT32_EN=0;                            //FAT16文件系统
    003CD 2422      CLR	R2
    003CE 9220 026C STS	FAT32_EN,R2
    003D0 C003      RJMP	0x03D4
(0268)   else 
(0269)     FAT32_EN=1;                            //FAT32文件系统
    003D1 E081      LDI	R24,1
    003D2 9380 026C STS	FAT32_EN,R24
    003D4 9508      RET
_ReadFAT:
  RAM                  --> R20
  Index                --> R22
    003D5 940E 1B06 CALL	push_xgsetF000
    003D7 01B8      MOVW	R22,R16
(0270)   
(0271)   //return FAT32_EN;
(0272) /*    FATSz=BPB_FATSz32;
(0273)   if(BPB_TotSec16!=0) 
(0274)     TotSec=BPB_TotSec16;
(0275)   else
(0276)     TotSec=BPB_TotSec32;
(0277)   DataSec=TotSec-(BPB_RsvdSecCnt+BPB_NumFATs*FATSz)+RootDirSectors);
(0278)   CountofClusters=Data / BPB_SecPerClus;  */
(0279) }
(0280) 
(0281) /***********************************************************************
(0282) 函数功能：读取文件分配表的指定项，第一个FAT表FAT1
(0283) 操作内容：1、FAT表位于启动扇区之后，一般是2个   
(0284)           2、它用来管理文件簇，每个文件对应一个FAT表
(0285)           3、FAT16系统可以管理2^16个文件簇
(0286)           4、记录磁盘中有关文件如何被分散存储在不同扇区的信息
(0287)           5、每个文件的FAT表占2个字节，FAT32系统是4个字节
(0288) ***********************************************************************/
(0289) 
(0290) uint16 ReadFAT(uint16 Index)
(0291) {
(0292) 	uint16 *RAM = (uint16*)BUFFER;
    003D8 E847      LDI	R20,0x87
    003D9 E052      LDI	R21,2
(0293) 	ReadBlock(BPB_HiddSec+BPB_RsvdSecCnt + Index / 256);//?????????????
    003DA 9020 0282 LDS	R2,BPB_RsvdSecCnt
    003DC 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    003DE 2444      CLR	R4
    003DF 2455      CLR	R5
    003E0 9120 0279 LDS	R18,BPB_HiddSec+2
    003E2 9130 027A LDS	R19,BPB_HiddSec+3
    003E4 9100 0277 LDS	R16,BPB_HiddSec
    003E6 9110 0278 LDS	R17,BPB_HiddSec+1
    003E8 0D02      ADD	R16,R2
    003E9 1D13      ADC	R17,R3
    003EA 1D24      ADC	R18,R4
    003EB 1D35      ADC	R19,R5
    003EC 011B      MOVW	R2,R22
    003ED 2C23      MOV	R2,R3
    003EE 2433      CLR	R3
    003EF 2444      CLR	R4
    003F0 2455      CLR	R5
    003F1 0D02      ADD	R16,R2
    003F2 1D13      ADC	R17,R3
    003F3 1D24      ADC	R18,R4
    003F4 1D35      ADC	R19,R5
    003F5 DDE7      RCALL	_ReadBlock
(0294) 	return RAM[Index % 256];                //求余数以后就是对应扇区内的偏移量，占2个字节
    003F6 01FB      MOVW	R30,R22
    003F7 70F0      ANDI	R31,0
    003F8 0FEE      LSL	R30
    003F9 1FFF      ROL	R31
    003FA 0FE4      ADD	R30,R20
    003FB 1FF5      ADC	R31,R21
    003FC 8100      LD	R16,Z
    003FD 8111      LDD	R17,Z+1
    003FE 940C 1B0B JMP	pop_xgsetF000
_Read32FAT:
  RAM                  --> R10
  Index                --> Y,+6
    00400 940E 19E4 CALL	push_arg4
    00402 940E 1B10 CALL	push_xgsetF00C
(0295) }
(0296) 
(0297) uint32 Read32FAT(uint32 Index)
(0298) {
(0299) 	uint32 *RAM = (uint32*)BUFFER;
    00404 E887      LDI	R24,0x87
    00405 E092      LDI	R25,2
    00406 015C      MOVW	R10,R24
(0300) 	ReadBlock(BPB_HiddSec + BPB_RsvdSecCnt + Index / 128);
    00407 E087      LDI	R24,7
    00408 E090      LDI	R25,0
    00409 810E      LDD	R16,Y+6
    0040A 811F      LDD	R17,Y+7
    0040B 8528      LDD	R18,Y+8
    0040C 8539      LDD	R19,Y+9
    0040D 938A      ST	-Y,R24
    0040E 940E 1B8F CALL	lsr32
    00410 9020 0282 LDS	R2,BPB_RsvdSecCnt
    00412 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    00414 2444      CLR	R4
    00415 2455      CLR	R5
    00416 9080 0279 LDS	R8,BPB_HiddSec+2
    00418 9090 027A LDS	R9,BPB_HiddSec+3
    0041A 9060 0277 LDS	R6,BPB_HiddSec
    0041C 9070 0278 LDS	R7,BPB_HiddSec+1
    0041E 0C62      ADD	R6,R2
    0041F 1C73      ADC	R7,R3
    00420 1C84      ADC	R8,R4
    00421 1C95      ADC	R9,R5
    00422 0E60      ADD	R6,R16
    00423 1E71      ADC	R7,R17
    00424 1E82      ADC	R8,R18
    00425 1E93      ADC	R9,R19
    00426 0183      MOVW	R16,R6
    00427 0194      MOVW	R18,R8
    00428 DDB4      RCALL	_ReadBlock
(0301) 	return RAM[Index % 128];                //求余数以后就是对应扇区内的偏移量，占4个字节
    00429 E74F      LDI	R20,0x7F
    0042A E050      LDI	R21,0
    0042B E060      LDI	R22,0
    0042C E070      LDI	R23,0
    0042D 810E      LDD	R16,Y+6
    0042E 811F      LDD	R17,Y+7
    0042F 8528      LDD	R18,Y+8
    00430 8539      LDD	R19,Y+9
    00431 2304      AND	R16,R20
    00432 2315      AND	R17,R21
    00433 2326      AND	R18,R22
    00434 2337      AND	R19,R23
    00435 E082      LDI	R24,2
    00436 E090      LDI	R25,0
    00437 938A      ST	-Y,R24
    00438 940E 1B7C CALL	lsl32
    0043A 01F8      MOVW	R30,R16
    0043B 0DEA      ADD	R30,R10
    0043C 1DFB      ADC	R31,R11
    0043D 8100      LD	R16,Z
    0043E 8111      LDD	R17,Z+1
    0043F 8122      LDD	R18,Z+2
    00440 8133      LDD	R19,Z+3
    00441 940E 1B17 CALL	pop_xgsetF00C
    00443 9624      ADIW	R28,4
    00444 9508      RET
_WriteFAT:
  RAM                  --> R20
  SecID                --> Y,+0
  Value                --> R10
  Index                --> R22
    00445 940E 1B10 CALL	push_xgsetF00C
    00447 0159      MOVW	R10,R18
    00448 01B8      MOVW	R22,R16
    00449 9724      SBIW	R28,4
(0302) }
(0303) 
(0304) 
(0305) 
(0306) /***********************************************************************
(0307) 函数功能：写文件分配表的指定项，第一个FAT表FAT1
(0308) 操作内容：1、FAT表位于启动扇区之后，一般是2个   
(0309)           2、它用来管理文件簇，每个文件对应一个FAT表
(0310)           3、FAT16系统可以管理2^16个文件簇
(0311) ***********************************************************************/
(0312) 
(0313) void WriteFAT(uint16 Index, uint16 Value)
(0314) {
(0315) 	uint16 *RAM = (uint16*)BUFFER;
    0044A E847      LDI	R20,0x87
    0044B E052      LDI	R21,2
(0316) 	uint32 SecID;
(0317) 	SecID = BPB_HiddSec + BPB_RsvdSecCnt + Index / 256;    //扇区号，将写入FAT值到对应扇区???????????????????????
    0044C 9020 0282 LDS	R2,BPB_RsvdSecCnt
    0044E 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    00450 2444      CLR	R4
    00451 2455      CLR	R5
    00452 9080 0279 LDS	R8,BPB_HiddSec+2
    00454 9090 027A LDS	R9,BPB_HiddSec+3
    00456 9060 0277 LDS	R6,BPB_HiddSec
    00458 9070 0278 LDS	R7,BPB_HiddSec+1
    0045A 0C62      ADD	R6,R2
    0045B 1C73      ADC	R7,R3
    0045C 1C84      ADC	R8,R4
    0045D 1C95      ADC	R9,R5
    0045E 011B      MOVW	R2,R22
    0045F 2C23      MOV	R2,R3
    00460 2433      CLR	R3
    00461 2444      CLR	R4
    00462 2455      CLR	R5
    00463 0C62      ADD	R6,R2
    00464 1C73      ADC	R7,R3
    00465 1C84      ADC	R8,R4
    00466 1C95      ADC	R9,R5
    00467 8268      ST	Y,R6
    00468 8279      STD	Y+1,R7
    00469 828A      STD	Y+2,R8
    0046A 829B      STD	Y+3,R9
(0318) 	ReadBlock(SecID);
    0046B 8108      LD	R16,Y
    0046C 8119      LDD	R17,Y+1
    0046D 812A      LDD	R18,Y+2
    0046E 813B      LDD	R19,Y+3
    0046F DD6D      RCALL	_ReadBlock
(0319) 	RAM[Index % 256] = Value;                //这是文件对应FAT表的值
    00470 01FB      MOVW	R30,R22
    00471 70F0      ANDI	R31,0
    00472 0FEE      LSL	R30
    00473 1FFF      ROL	R31
    00474 0FE4      ADD	R30,R20
    00475 1FF5      ADC	R31,R21
    00476 82B1      STD	Z+1,R11
    00477 82A0      ST	Z,R10
(0320) 	WriteBlock(SecID);
    00478 8108      LD	R16,Y
    00479 8119      LDD	R17,Y+1
    0047A 812A      LDD	R18,Y+2
    0047B 813B      LDD	R19,Y+3
    0047C DD73      RCALL	_WriteBlock
    0047D 9624      ADIW	R28,4
    0047E 940C 1B17 JMP	pop_xgsetF00C
_Write32FAT:
  RAM                  --> R10
  SecID                --> Y,+0
  Value                --> Y,+14
  Index                --> Y,+10
    00480 940E 19E4 CALL	push_arg4
    00482 940E 1B10 CALL	push_xgsetF00C
    00484 9724      SBIW	R28,4
(0321) }
(0322) 
(0323) void Write32FAT(uint32 Index, uint32 Value)
(0324) {
(0325)         uint32 *RAM = (uint32*)BUFFER;
    00485 E887      LDI	R24,0x87
    00486 E092      LDI	R25,2
    00487 015C      MOVW	R10,R24
(0326) 	uint32 SecID;
(0327) 	SecID = BPB_HiddSec + BPB_RsvdSecCnt + Index / 128;    //扇区号，将写入FAT值到对应扇区
    00488 E087      LDI	R24,7
    00489 E090      LDI	R25,0
    0048A 850A      LDD	R16,Y+10
    0048B 851B      LDD	R17,Y+11
    0048C 852C      LDD	R18,Y+12
    0048D 853D      LDD	R19,Y+13
    0048E 938A      ST	-Y,R24
    0048F 940E 1B8F CALL	lsr32
    00491 9020 0282 LDS	R2,BPB_RsvdSecCnt
    00493 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    00495 2444      CLR	R4
    00496 2455      CLR	R5
    00497 9080 0279 LDS	R8,BPB_HiddSec+2
    00499 9090 027A LDS	R9,BPB_HiddSec+3
    0049B 9060 0277 LDS	R6,BPB_HiddSec
    0049D 9070 0278 LDS	R7,BPB_HiddSec+1
    0049F 0C62      ADD	R6,R2
    004A0 1C73      ADC	R7,R3
    004A1 1C84      ADC	R8,R4
    004A2 1C95      ADC	R9,R5
    004A3 0E60      ADD	R6,R16
    004A4 1E71      ADC	R7,R17
    004A5 1E82      ADC	R8,R18
    004A6 1E93      ADC	R9,R19
    004A7 8268      ST	Y,R6
    004A8 8279      STD	Y+1,R7
    004A9 828A      STD	Y+2,R8
    004AA 829B      STD	Y+3,R9
(0328) 	ReadBlock(SecID);
    004AB 8108      LD	R16,Y
    004AC 8119      LDD	R17,Y+1
    004AD 812A      LDD	R18,Y+2
    004AE 813B      LDD	R19,Y+3
    004AF DD2D      RCALL	_ReadBlock
(0329) 	RAM[Index % 128] = Value;                //这是文件对应FAT表的值
    004B0 E74F      LDI	R20,0x7F
    004B1 E050      LDI	R21,0
    004B2 E060      LDI	R22,0
    004B3 E070      LDI	R23,0
    004B4 850A      LDD	R16,Y+10
    004B5 851B      LDD	R17,Y+11
    004B6 852C      LDD	R18,Y+12
    004B7 853D      LDD	R19,Y+13
    004B8 2304      AND	R16,R20
    004B9 2315      AND	R17,R21
    004BA 2326      AND	R18,R22
    004BB 2337      AND	R19,R23
    004BC E082      LDI	R24,2
    004BD E090      LDI	R25,0
    004BE 938A      ST	-Y,R24
    004BF 940E 1B7C CALL	lsl32
    004C1 01F8      MOVW	R30,R16
    004C2 0DEA      ADD	R30,R10
    004C3 1DFB      ADC	R31,R11
    004C4 842E      LDD	R2,Y+14
    004C5 843F      LDD	R3,Y+15
    004C6 8848      LDD	R4,Y+16
    004C7 8859      LDD	R5,Y+17
    004C8 8220      ST	Z,R2
    004C9 8231      STD	Z+1,R3
    004CA 8242      STD	Z+2,R4
    004CB 8253      STD	Z+3,R5
(0330) 	WriteBlock(SecID);
    004CC 8108      LD	R16,Y
    004CD 8119      LDD	R17,Y+1
    004CE 812A      LDD	R18,Y+2
    004CF 813B      LDD	R19,Y+3
    004D0 DD1F      RCALL	_WriteBlock
    004D1 9624      ADIW	R28,4
    004D2 940E 1B17 CALL	pop_xgsetF00C
    004D4 9624      ADIW	R28,4
    004D5 9508      RET
_WriteFAT2:
  RAM                  --> R20
  SecID                --> Y,+0
  Value                --> R10
  Index                --> R22
    004D6 940E 1B10 CALL	push_xgsetF00C
    004D8 0159      MOVW	R10,R18
    004D9 01B8      MOVW	R22,R16
    004DA 9724      SBIW	R28,4
(0331) }
(0332) 
(0333) 
(0334) 
(0335) /***********************************************************************
(0336) 函数功能：写文件分配表的指定项，第二个FAT表FAT2
(0337) 操作内容：1、FAT表位于启动扇区之后，一般是2个   
(0338)           2、它用来管理文件簇，每个文件对应一个FAT表
(0339)           3、FAT16系统可以管理2^16个文件簇
(0340) ***********************************************************************/
(0341) 
(0342) void WriteFAT2(uint16 Index, uint16 Value)
(0343) {
(0344) 	uint16 *RAM = (uint16*)BUFFER;
    004DB E847      LDI	R20,0x87
    004DC E052      LDI	R21,2
(0345) 	uint32 SecID;
(0346) 	SecID = BPB_RsvdSecCnt + BPB_FATSz16 + Index / 256;   //第二个FAT表紧跟在第一个FAT表后面
    004DD 9020 027B LDS	R2,BPB_FATSz16
    004DF 9030 027C LDS	R3,BPB_FATSz16+1
    004E1 9040 0282 LDS	R4,BPB_RsvdSecCnt
    004E3 9050 0283 LDS	R5,BPB_RsvdSecCnt+1
    004E5 0C42      ADD	R4,R2
    004E6 1C53      ADC	R5,R3
    004E7 011B      MOVW	R2,R22
    004E8 2C23      MOV	R2,R3
    004E9 2433      CLR	R3
    004EA 0C42      ADD	R4,R2
    004EB 1C53      ADC	R5,R3
    004EC 0112      MOVW	R2,R4
    004ED 2444      CLR	R4
    004EE 2455      CLR	R5
    004EF 8228      ST	Y,R2
    004F0 8239      STD	Y+1,R3
    004F1 824A      STD	Y+2,R4
    004F2 825B      STD	Y+3,R5
(0347) 	ReadBlock(SecID);
    004F3 8108      LD	R16,Y
    004F4 8119      LDD	R17,Y+1
    004F5 812A      LDD	R18,Y+2
    004F6 813B      LDD	R19,Y+3
    004F7 DCE5      RCALL	_ReadBlock
(0348) 	RAM[Index % 256] = Value;
    004F8 01FB      MOVW	R30,R22
    004F9 70F0      ANDI	R31,0
    004FA 0FEE      LSL	R30
    004FB 1FFF      ROL	R31
    004FC 0FE4      ADD	R30,R20
    004FD 1FF5      ADC	R31,R21
    004FE 82B1      STD	Z+1,R11
    004FF 82A0      ST	Z,R10
(0349) 	WriteBlock(SecID);
    00500 8108      LD	R16,Y
    00501 8119      LDD	R17,Y+1
    00502 812A      LDD	R18,Y+2
    00503 813B      LDD	R19,Y+3
    00504 DCEB      RCALL	_WriteBlock
    00505 9624      ADIW	R28,4
    00506 940C 1B17 JMP	pop_xgsetF00C
_Write32FAT2:
  RAM                  --> R10
  SecID                --> Y,+0
  Value                --> Y,+14
  Index                --> Y,+10
    00508 940E 19E4 CALL	push_arg4
    0050A 940E 1B10 CALL	push_xgsetF00C
    0050C 9724      SBIW	R28,4
(0350) }
(0351) 
(0352) void Write32FAT2(uint32 Index, uint32 Value)
(0353) {
(0354)         uint32 *RAM = (uint32*)BUFFER;
    0050D E887      LDI	R24,0x87
    0050E E092      LDI	R25,2
    0050F 015C      MOVW	R10,R24
(0355) 	uint32 SecID;
(0356) 	SecID = BPB_RsvdSecCnt + BPB_FATSz16 + Index / 128;    //扇区号，将写入FAT值到对应扇区
    00510 E087      LDI	R24,7
    00511 E090      LDI	R25,0
    00512 850A      LDD	R16,Y+10
    00513 851B      LDD	R17,Y+11
    00514 852C      LDD	R18,Y+12
    00515 853D      LDD	R19,Y+13
    00516 938A      ST	-Y,R24
    00517 940E 1B8F CALL	lsr32
    00519 9020 027B LDS	R2,BPB_FATSz16
    0051B 9030 027C LDS	R3,BPB_FATSz16+1
    0051D 9040 0282 LDS	R4,BPB_RsvdSecCnt
    0051F 9050 0283 LDS	R5,BPB_RsvdSecCnt+1
    00521 0C42      ADD	R4,R2
    00522 1C53      ADC	R5,R3
    00523 0112      MOVW	R2,R4
    00524 2444      CLR	R4
    00525 2455      CLR	R5
    00526 0E20      ADD	R2,R16
    00527 1E31      ADC	R3,R17
    00528 1E42      ADC	R4,R18
    00529 1E53      ADC	R5,R19
    0052A 8228      ST	Y,R2
    0052B 8239      STD	Y+1,R3
    0052C 824A      STD	Y+2,R4
    0052D 825B      STD	Y+3,R5
(0357) 	ReadBlock(SecID);
    0052E 8108      LD	R16,Y
    0052F 8119      LDD	R17,Y+1
    00530 812A      LDD	R18,Y+2
    00531 813B      LDD	R19,Y+3
    00532 DCAA      RCALL	_ReadBlock
(0358) 	RAM[Index % 128] = Value;                              //这是文件对应FAT表的值
    00533 E74F      LDI	R20,0x7F
    00534 E050      LDI	R21,0
    00535 E060      LDI	R22,0
    00536 E070      LDI	R23,0
    00537 850A      LDD	R16,Y+10
    00538 851B      LDD	R17,Y+11
    00539 852C      LDD	R18,Y+12
    0053A 853D      LDD	R19,Y+13
    0053B 2304      AND	R16,R20
    0053C 2315      AND	R17,R21
    0053D 2326      AND	R18,R22
    0053E 2337      AND	R19,R23
    0053F E082      LDI	R24,2
    00540 E090      LDI	R25,0
    00541 938A      ST	-Y,R24
    00542 940E 1B7C CALL	lsl32
    00544 01F8      MOVW	R30,R16
    00545 0DEA      ADD	R30,R10
    00546 1DFB      ADC	R31,R11
    00547 842E      LDD	R2,Y+14
    00548 843F      LDD	R3,Y+15
    00549 8848      LDD	R4,Y+16
    0054A 8859      LDD	R5,Y+17
    0054B 8220      ST	Z,R2
    0054C 8231      STD	Z+1,R3
    0054D 8242      STD	Z+2,R4
    0054E 8253      STD	Z+3,R5
(0359) 	WriteBlock(SecID);
    0054F 8108      LD	R16,Y
    00550 8119      LDD	R17,Y+1
    00551 812A      LDD	R18,Y+2
    00552 813B      LDD	R19,Y+3
    00553 DC9C      RCALL	_WriteBlock
    00554 9624      ADIW	R28,4
    00555 940E 1B17 CALL	pop_xgsetF00C
    00557 9624      ADIW	R28,4
    00558 9508      RET
_GetEmptyDIR:
  DirStart             --> R12
  DirSecCut            --> R10
  i                    --> R22
  ID                   --> R20
  m                    --> R14
    00559 940E 1AF1 CALL	push_xgsetF0FC
(0360) }
(0361) 
(0362) /***********************************************************************
(0363) 函数功能：获取根目录中可以使用的一项
(0364) 操作内容：1、计算簇开始扇区号    
(0365)           2、它是针对FAT卷扇区0的偏移量
(0366)           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
(0367)           4、实际上如果FileName[0]=0x00或者0xE5，均表示为可以使用项，但意义不一样
(0368)           5、0x00表示之后都是空，没有目录，可以不再查询；0xE5表示此目录项为空，可以使用
(0369) ***********************************************************************/
(0370) 
(0371) uint16 GetEmptyDIR()
(0372) {
(0373) 	uint16 DirSecCut, DirStart, i, m, ID = 0;
    0055B 2744      CLR	R20
    0055C 2755      CLR	R21
(0374) 	DirSecCut = 32;               //GetDirSecCount();     //根目录扇区总数，这里限制FAT16和FAT32都最多为512个根目录项
    0055D E280      LDI	R24,0x20
    0055E E090      LDI	R25,0
    0055F 015C      MOVW	R10,R24
(0375) 	DirStart = DirStartSec();                                            //根目录开始扇区地址,FAT16为512
    00560 DDD3      RCALL	_DirStartSec
    00561 0168      MOVW	R12,R16
(0376) 	for(i = 0; i < DirSecCut; i++)                                       //在整个扇区空间搜索
    00562 2766      CLR	R22
    00563 2777      CLR	R23
    00564 C028      RJMP	0x058D
(0377) 	{
(0378) 		ReadBlock(DirStart + i);                                     //读根目录扇区
    00565 0186      MOVW	R16,R12
    00566 0F06      ADD	R16,R22
    00567 1F17      ADC	R17,R23
    00568 2722      CLR	R18
    00569 2733      CLR	R19
    0056A DC72      RCALL	_ReadBlock
(0379) 		for(m = 0; m < 16; m++)
    0056B 24EE      CLR	R14
    0056C 24FF      CLR	R15
    0056D C018      RJMP	0x0586
(0380) 		{
(0381) 			if((BUFFER[m * 32] == 0) || (BUFFER[m * 32] == 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
    0056E E200      LDI	R16,0x20
    0056F E010      LDI	R17,0
    00570 0197      MOVW	R18,R14
    00571 940E 1A8D CALL	empy16s
    00573 E887      LDI	R24,0x87
    00574 E092      LDI	R25,2
    00575 01F8      MOVW	R30,R16
    00576 0FE8      ADD	R30,R24
    00577 1FF9      ADC	R31,R25
    00578 8020      LD	R2,Z
    00579 2433      CLR	R3
    0057A 2022      TST	R2
    0057B F019      BEQ	0x057F
    0057C 2D82      MOV	R24,R2
    0057D 3E85      CPI	R24,0xE5
    0057E F411      BNE	0x0581
(0382) 				return ID;                                   //返回可以使用扇区ID
    0057F 018A      MOVW	R16,R20
    00580 C010      RJMP	0x0591
(0383) 			else
(0384) 				ID++;
    00581 5F4F      SUBI	R20,0xFF
    00582 4F5F      SBCI	R21,0xFF
    00583 01C7      MOVW	R24,R14
    00584 9601      ADIW	R24,1
    00585 017C      MOVW	R14,R24
    00586 01C7      MOVW	R24,R14
    00587 3180      CPI	R24,0x10
    00588 E0E0      LDI	R30,0
    00589 079E      CPC	R25,R30
    0058A F318      BCS	0x056E
    0058B 5F6F      SUBI	R22,0xFF
    0058C 4F7F      SBCI	R23,0xFF
    0058D 156A      CP	R22,R10
    0058E 057B      CPC	R23,R11
    0058F F2A8      BCS	0x0565
(0385) 		}
(0386) 	}
(0387) 	return ID;                                                            //表示没有空闲可以使用的项
    00590 018A      MOVW	R16,R20
    00591 940C 1AE6 JMP	pop_xgsetF0FC
_GetDirectoryEmptyDIR:
  DirStart             --> R12
  DirSecCut            --> R10
  i                    --> R22
  ID                   --> R20
  m                    --> R14
  ClusID               --> R12
    00593 940E 1AF1 CALL	push_xgsetF0FC
    00595 0168      MOVW	R12,R16
(0388) }
(0389) 
(0390) /***********************************************************************
(0391) 函数功能：获取子目录中可以使用的一项
(0392) 操作内容：1、计算簇开始扇区号    
(0393)           2、它是针对父目录所在开始簇的偏移量
(0394)           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
(0395)           4、实际上如果FileName[0]=0x00或者0xE5，均表示为可以使用项，但意义不一样
(0396)           5、0x00表示之后都是空，没有目录，可以不再查询；0xE5表示此目录项为空，可以使用
(0397) ***********************************************************************/
(0398) 
(0399) uint16 GetDirectoryEmptyDIR(uint16 ClusID)
(0400) {
(0401) 	uint16 DirSecCut, DirStart, i, m, ID = 0;
    00596 2744      CLR	R20
    00597 2755      CLR	R21
(0402) 	DirSecCut = BPB_SecPerClus*16;                                       //一个文件夹的子文件的目录项，一般一个文件夹占一簇，总项数为扇区数×每扇区的项数
    00598 9110 0284 LDS	R17,BPB_SecPerClus
    0059A E100      LDI	R16,0x10
    0059B 0301      MULSU	R16,R17
    0059C 0150      MOVW	R10,R0
(0403) 	DirStart = ClusConvLBA(ClusID);                                      //父文件夹的起始簇扇区地址
    0059D 0186      MOVW	R16,R12
    0059E DE0C      RCALL	_ClusConvLBA
    0059F 0168      MOVW	R12,R16
(0404) 	for(i = 0; i < DirSecCut; i++)                                       //在整个扇区空间搜索
    005A0 2766      CLR	R22
    005A1 2777      CLR	R23
    005A2 C028      RJMP	0x05CB
(0405) 	{
(0406) 		ReadBlock(DirStart + i);                                     //读目录扇区
    005A3 0186      MOVW	R16,R12
    005A4 0F06      ADD	R16,R22
    005A5 1F17      ADC	R17,R23
    005A6 2722      CLR	R18
    005A7 2733      CLR	R19
    005A8 DC34      RCALL	_ReadBlock
(0407) 		for(m = 0; m < 16; m++)
    005A9 24EE      CLR	R14
    005AA 24FF      CLR	R15
    005AB C018      RJMP	0x05C4
(0408) 		{
(0409) 			if((BUFFER[m * 32] == 0) || (BUFFER[m * 32] == 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
    005AC E200      LDI	R16,0x20
    005AD E010      LDI	R17,0
    005AE 0197      MOVW	R18,R14
    005AF 940E 1A8D CALL	empy16s
    005B1 E887      LDI	R24,0x87
    005B2 E092      LDI	R25,2
    005B3 01F8      MOVW	R30,R16
    005B4 0FE8      ADD	R30,R24
    005B5 1FF9      ADC	R31,R25
    005B6 8020      LD	R2,Z
    005B7 2433      CLR	R3
    005B8 2022      TST	R2
    005B9 F019      BEQ	0x05BD
    005BA 2D82      MOV	R24,R2
    005BB 3E85      CPI	R24,0xE5
    005BC F411      BNE	0x05BF
(0410) 				return ID;                                   //返回可以使用扇区ID，即偏移量
    005BD 018A      MOVW	R16,R20
    005BE C010      RJMP	0x05CF
(0411) 			else
(0412) 				ID++;
    005BF 5F4F      SUBI	R20,0xFF
    005C0 4F5F      SBCI	R21,0xFF
    005C1 01C7      MOVW	R24,R14
    005C2 9601      ADIW	R24,1
    005C3 017C      MOVW	R14,R24
    005C4 01C7      MOVW	R24,R14
    005C5 3180      CPI	R24,0x10
    005C6 E0E0      LDI	R30,0
    005C7 079E      CPC	R25,R30
    005C8 F318      BCS	0x05AC
    005C9 5F6F      SUBI	R22,0xFF
    005CA 4F7F      SBCI	R23,0xFF
    005CB 156A      CP	R22,R10
    005CC 057B      CPC	R23,R11
    005CD F2A8      BCS	0x05A3
(0413) 		}
(0414) 	}
(0415) 	return ID;                                                            //表示没有空闲可以使用的项
    005CE 018A      MOVW	R16,R20
    005CF 940C 1AE6 JMP	pop_xgsetF0FC
_GetFileID:
  DirStart             --> R10
  DirSecCut            --> R22
  i                    --> R20
  Index                --> R14
  m                    --> R12
  ID                   --> Y,+13
  Name                 --> Y,+11
    005D1 940E 19E4 CALL	push_arg4
    005D3 940E 1AF1 CALL	push_xgsetF0FC
    005D5 9721      SBIW	R28,1
(0416) }
(0417) 
(0418) /***********************************************************************
(0419) 函数功能：获得和文件名对应的根目录项以及该目录的位置
(0420) 操作内容：1、比较文件名相符   
(0421)           2、每个文件都有对应的FAT表
(0422)           3、ID的首地址是对应的根目录项的首地址，类型为DIR(见头文件fat.h)
(0423) ***********************************************************************/
(0424) 
(0425) uint8 GetFileID(uint8 Name[11], DIR* ID)
(0426) {
(0427) 	uint16 DirSecCut, DirStart, i, m,Index;
(0428) 	DirSecCut = 32;                                  //GetDirSecCount();根目录总扇区数，这里将FAT16/32统一到512个根目录项
    005D6 E260      LDI	R22,0x20
    005D7 E070      LDI	R23,0
(0429) 	DirStart = DirStartSec();                       //根目录开始扇区
    005D8 DD5B      RCALL	_DirStartSec
    005D9 0158      MOVW	R10,R16
(0430) 	for(i = 0; i < DirSecCut; i++)
    005DA 2744      CLR	R20
    005DB 2755      CLR	R21
    005DC C043      RJMP	0x0620
(0431) 	{
(0432) 		ReadBlock(DirStart + i);                //读取扇区数据
    005DD 0185      MOVW	R16,R10
    005DE 0F04      ADD	R16,R20
    005DF 1F15      ADC	R17,R21
    005E0 2722      CLR	R18
    005E1 2733      CLR	R19
    005E2 DBFA      RCALL	_ReadBlock
(0433) 		for(m = 0; m <16; m++)                  //一个扇区里面有16个项，因为每个项的长度是32位
    005E3 24CC      CLR	R12
    005E4 24DD      CLR	R13
    005E5 C032      RJMP	0x0618
(0434) 		{
(0435) 			if(IsEqual(Name, &((DIR*)&BUFFER[m * 32])->FileName, 11))   //进行比较，相等返回index
    005E6 E08B      LDI	R24,0xB
    005E7 8388      ST	Y,R24
    005E8 E200      LDI	R16,0x20
    005E9 E010      LDI	R17,0
    005EA 0196      MOVW	R18,R12
    005EB 940E 1A8D CALL	empy16s
    005ED 0198      MOVW	R18,R16
    005EE E887      LDI	R24,0x87
    005EF E092      LDI	R25,2
    005F0 0F28      ADD	R18,R24
    005F1 1F39      ADC	R19,R25
    005F2 850B      LDD	R16,Y+11
    005F3 851C      LDD	R17,Y+12
    005F4 DC3C      RCALL	_IsEqual
    005F5 2300      TST	R16
    005F6 F0F1      BEQ	0x0615
(0436) 			{
(0437) 				*ID = *((DIR*)&BUFFER[m * 32]);   //ID实际就是根目录项
    005F7 E200      LDI	R16,0x20
    005F8 E010      LDI	R17,0
    005F9 0196      MOVW	R18,R12
    005FA 940E 1A8D CALL	empy16s
    005FC 0118      MOVW	R2,R16
    005FD E887      LDI	R24,0x87
    005FE E092      LDI	R25,2
    005FF 0E28      ADD	R2,R24
    00600 1E39      ADC	R3,R25
    00601 844D      LDD	R4,Y+13
    00602 845E      LDD	R5,Y+14
    00603 E200      LDI	R16,0x20
    00604 E010      LDI	R17,0
    00605 925A      ST	-Y,R5
    00606 924A      ST	-Y,R4
    00607 923A      ST	-Y,R3
    00608 922A      ST	-Y,R2
    00609 940E 1B9B CALL	asgnblk
(0438)                                 Index = i*16+m;                   //FAT16下一般最大是511，也就是说FAT16下根目录项数一般为512，为保证兼容性
    0060B E100      LDI	R16,0x10
    0060C E010      LDI	R17,0
    0060D 019A      MOVW	R18,R20
    0060E 940E 1A8D CALL	empy16s
    00610 0178      MOVW	R14,R16
    00611 0CEC      ADD	R14,R12
    00612 1CFD      ADC	R15,R13
(0439) 				return Index;                     //找到对应的目录项,返回目录的位置.
    00613 2D0E      MOV	R16,R14
    00614 C010      RJMP	0x0625
    00615 01C6      MOVW	R24,R12
    00616 9601      ADIW	R24,1
    00617 016C      MOVW	R12,R24
    00618 01C6      MOVW	R24,R12
    00619 3180      CPI	R24,0x10
    0061A E0E0      LDI	R30,0
    0061B 079E      CPC	R25,R30
    0061C F408      BCC	0x061E
    0061D CFC8      RJMP	0x05E6
    0061E 5F4F      SUBI	R20,0xFF
    0061F 4F5F      SBCI	R21,0xFF
    00620 1746      CP	R20,R22
    00621 0757      CPC	R21,R23
    00622 F408      BCC	0x0624
    00623 CFB9      RJMP	0x05DD
(0440) 			}
(0441) 		}
(0442) 	}
(0443) 	return 0;                                         //没有找到对应的目录项,返回0.
    00624 2700      CLR	R16
    00625 9621      ADIW	R28,1
    00626 940E 1AE6 CALL	pop_xgsetF0FC
    00628 9624      ADIW	R28,4
    00629 9508      RET
_GetFileID32:
  DirStart             --> R10
  DirSecCut            --> R22
  i                    --> R20
  Index                --> R14
  m                    --> R12
  ID                   --> Y,+13
  Name                 --> Y,+11
    0062A 940E 19E4 CALL	push_arg4
    0062C 940E 1AF1 CALL	push_xgsetF0FC
    0062E 9721      SBIW	R28,1
(0444) }
(0445) 
(0446) uint8 GetFileID32(uint8 Name[11], DIR32* ID)
(0447) {
(0448) 	uint16 DirSecCut, DirStart, i, m,Index;
(0449) 	DirSecCut = 32;                                  //GetDirSecCount();根目录总扇区数，这里将FAT16/32统一到512个根目录项
    0062F E260      LDI	R22,0x20
    00630 E070      LDI	R23,0
(0450) 	DirStart = DirStartSec();                       //根目录开始扇区
    00631 DD02      RCALL	_DirStartSec
    00632 0158      MOVW	R10,R16
(0451) 	for(i = 0; i < DirSecCut; i++)
    00633 2744      CLR	R20
    00634 2755      CLR	R21
    00635 C043      RJMP	0x0679
(0452) 	{
(0453) 		ReadBlock(DirStart + i);                //读取扇区数据
    00636 0185      MOVW	R16,R10
    00637 0F04      ADD	R16,R20
    00638 1F15      ADC	R17,R21
    00639 2722      CLR	R18
    0063A 2733      CLR	R19
    0063B DBA1      RCALL	_ReadBlock
(0454) 		for(m = 0; m <16; m++)                  //一个扇区里面有16个项，因为每个项的长度是32位
    0063C 24CC      CLR	R12
    0063D 24DD      CLR	R13
    0063E C032      RJMP	0x0671
(0455) 		{
(0456) 			if(IsEqual(Name, &((DIR32*)&BUFFER[m * 32])->FileName, 11))   //进行比较，相等返回1
    0063F E08B      LDI	R24,0xB
    00640 8388      ST	Y,R24
    00641 E200      LDI	R16,0x20
    00642 E010      LDI	R17,0
    00643 0196      MOVW	R18,R12
    00644 940E 1A8D CALL	empy16s
    00646 0198      MOVW	R18,R16
    00647 E887      LDI	R24,0x87
    00648 E092      LDI	R25,2
    00649 0F28      ADD	R18,R24
    0064A 1F39      ADC	R19,R25
    0064B 850B      LDD	R16,Y+11
    0064C 851C      LDD	R17,Y+12
    0064D DBE3      RCALL	_IsEqual
    0064E 2300      TST	R16
    0064F F0F1      BEQ	0x066E
(0457) 			{
(0458) 				*ID = *((DIR32*)&BUFFER[m * 32]);   //ID实际就是根目录项
    00650 E200      LDI	R16,0x20
    00651 E010      LDI	R17,0
    00652 0196      MOVW	R18,R12
    00653 940E 1A8D CALL	empy16s
    00655 0118      MOVW	R2,R16
    00656 E887      LDI	R24,0x87
    00657 E092      LDI	R25,2
    00658 0E28      ADD	R2,R24
    00659 1E39      ADC	R3,R25
    0065A 844D      LDD	R4,Y+13
    0065B 845E      LDD	R5,Y+14
    0065C E10E      LDI	R16,0x1E
    0065D E010      LDI	R17,0
    0065E 925A      ST	-Y,R5
    0065F 924A      ST	-Y,R4
    00660 923A      ST	-Y,R3
    00661 922A      ST	-Y,R2
    00662 940E 1B9B CALL	asgnblk
(0459)                                 Index = i*16+m;                   //FAT16下一般最大是511，也就是说FAT16下根目录项数一般为512，为保证兼容性
    00664 E100      LDI	R16,0x10
    00665 E010      LDI	R17,0
    00666 019A      MOVW	R18,R20
    00667 940E 1A8D CALL	empy16s
    00669 0178      MOVW	R14,R16
    0066A 0CEC      ADD	R14,R12
    0066B 1CFD      ADC	R15,R13
(0460) 				return Index;                     //找到对应的目录项,返回目录的位置.
    0066C 2D0E      MOV	R16,R14
    0066D C010      RJMP	0x067E
    0066E 01C6      MOVW	R24,R12
    0066F 9601      ADIW	R24,1
    00670 016C      MOVW	R12,R24
    00671 01C6      MOVW	R24,R12
    00672 3180      CPI	R24,0x10
    00673 E0E0      LDI	R30,0
    00674 079E      CPC	R25,R30
    00675 F408      BCC	0x0677
    00676 CFC8      RJMP	0x063F
    00677 5F4F      SUBI	R20,0xFF
    00678 4F5F      SBCI	R21,0xFF
    00679 1746      CP	R20,R22
    0067A 0757      CPC	R21,R23
    0067B F408      BCC	0x067D
    0067C CFB9      RJMP	0x0636
(0461) 			}
(0462) 		}
(0463) 	}
(0464) 	return 0;                                         //没有找到对应的目录项,返回0.
    0067D 2700      CLR	R16
    0067E 9621      ADIW	R28,1
    0067F 940E 1AE6 CALL	pop_xgsetF0FC
    00681 9624      ADIW	R28,4
    00682 9508      RET
_GetNextFAT:
  FAT_Count            --> R10
  i                    --> R20
    00683 940E 1AFC CALL	push_xgset300C
(0465) }
(0466) 
(0467) /***********************************************************************
(0468) 函数功能：获取一个空的FAT项
(0469) 操作内容：1、用来准备写入FAT表    
(0470)           2、每个文件都有对应的FAT表
(0471) ***********************************************************************/
(0472) 
(0473) uint16 GetNextFAT(void)
(0474) {
(0475) 	uint16 FAT_Count, i;
(0476) 	FAT_Count = BPB_FATSz16 * 256;                      //FAT表总项数，一个扇区是256个项，FAT16一个项是2个字节
    00685 9120 027B LDS	R18,BPB_FATSz16
    00687 9130 027C LDS	R19,BPB_FATSz16+1
    00689 E000      LDI	R16,0
    0068A E011      LDI	R17,1
    0068B 940E 1A8D CALL	empy16s
    0068D 0158      MOVW	R10,R16
(0477) 	for(i = 0; i < FAT_Count; i++)
    0068E 2744      CLR	R20
    0068F 2755      CLR	R21
    00690 C009      RJMP	0x069A
(0478) 	{
(0479) 		if(ReadFAT(i) == 0)                         //为0表示空，可以作为新创建的文件的FAT项
    00691 018A      MOVW	R16,R20
    00692 DD42      RCALL	_ReadFAT
    00693 3000      CPI	R16,0
    00694 0701      CPC	R16,R17
    00695 F411      BNE	0x0698
(0480) 			return i;
    00696 018A      MOVW	R16,R20
    00697 C007      RJMP	0x069F
    00698 5F4F      SUBI	R20,0xFF
    00699 4F5F      SBCI	R21,0xFF
    0069A 154A      CP	R20,R10
    0069B 055B      CPC	R21,R11
    0069C F3A0      BCS	0x0691
(0481) 	}
(0482) 	return 0;
    0069D 2700      CLR	R16
    0069E 2711      CLR	R17
    0069F 940C 1B01 JMP	pop_xgset300C
_GetNext32FAT:
  FAT_Count            --> Y,+4
  i                    --> Y,+0
    006A1 940E 1B06 CALL	push_xgsetF000
    006A3 9728      SBIW	R28,0x8
(0483) }
(0484) 
(0485) uint32 GetNext32FAT(void)
(0486) {
(0487) 	uint32 FAT_Count, i;
(0488) 	FAT_Count = BPB_FATSz32 * 128;                      //FAT表总项数，一个扇区是128个项，FAT32一个项是4个字节
    006A4 9040 0275 LDS	R4,BPB_FATSz32+2
    006A6 9050 0276 LDS	R5,BPB_FATSz32+3
    006A8 9020 0273 LDS	R2,BPB_FATSz32
    006AA 9030 0274 LDS	R3,BPB_FATSz32+1
    006AC E840      LDI	R20,0x80
    006AD E050      LDI	R21,0
    006AE E060      LDI	R22,0
    006AF E070      LDI	R23,0
    006B0 925A      ST	-Y,R5
    006B1 924A      ST	-Y,R4
    006B2 923A      ST	-Y,R3
    006B3 922A      ST	-Y,R2
    006B4 018A      MOVW	R16,R20
    006B5 019B      MOVW	R18,R22
    006B6 940E 1A9D CALL	empy32u|empy32s
    006B8 830C      STD	Y+4,R16
    006B9 831D      STD	Y+5,R17
    006BA 832E      STD	Y+6,R18
    006BB 833F      STD	Y+7,R19
(0489) 	for(i = 0; i < FAT_Count; i++)
    006BC E080      LDI	R24,0
    006BD 8388      ST	Y,R24
    006BE 8389      STD	Y+1,R24
    006BF 838A      STD	Y+2,R24
    006C0 838B      STD	Y+3,R24
    006C1 C020      RJMP	0x06E2
(0490) 	{
(0491) 		if(Read32FAT(i) == 0)                         //为0表示空，可以作为新创建的文件的FAT项
    006C2 8108      LD	R16,Y
    006C3 8119      LDD	R17,Y+1
    006C4 812A      LDD	R18,Y+2
    006C5 813B      LDD	R19,Y+3
    006C6 DD39      RCALL	_Read32FAT
    006C7 9488      BCLR	0
    006C8 2300      TST	R16
    006C9 0710      CPC	R17,R16
    006CA 0720      CPC	R18,R16
    006CB 0730      CPC	R19,R16
    006CC F429      BNE	0x06D2
(0492) 			return i;
    006CD 8108      LD	R16,Y
    006CE 8119      LDD	R17,Y+1
    006CF 812A      LDD	R18,Y+2
    006D0 813B      LDD	R19,Y+3
    006D1 C021      RJMP	0x06F3
    006D2 E041      LDI	R20,1
    006D3 E050      LDI	R21,0
    006D4 E060      LDI	R22,0
    006D5 E070      LDI	R23,0
    006D6 8028      LD	R2,Y
    006D7 8039      LDD	R3,Y+1
    006D8 804A      LDD	R4,Y+2
    006D9 805B      LDD	R5,Y+3
    006DA 0E24      ADD	R2,R20
    006DB 1E35      ADC	R3,R21
    006DC 1E46      ADC	R4,R22
    006DD 1E57      ADC	R5,R23
    006DE 8228      ST	Y,R2
    006DF 8239      STD	Y+1,R3
    006E0 824A      STD	Y+2,R4
    006E1 825B      STD	Y+3,R5
    006E2 802C      LDD	R2,Y+4
    006E3 803D      LDD	R3,Y+5
    006E4 804E      LDD	R4,Y+6
    006E5 805F      LDD	R5,Y+7
    006E6 8068      LD	R6,Y
    006E7 8079      LDD	R7,Y+1
    006E8 808A      LDD	R8,Y+2
    006E9 809B      LDD	R9,Y+3
    006EA 1462      CP	R6,R2
    006EB 0473      CPC	R7,R3
    006EC 0484      CPC	R8,R4
    006ED 0495      CPC	R9,R5
    006EE F298      BCS	0x06C2
(0493) 	}
(0494) 	return 0;
    006EF E000      LDI	R16,0
    006F0 E010      LDI	R17,0
    006F1 E020      LDI	R18,0
    006F2 E030      LDI	R19,0
    006F3 9628      ADIW	R28,0x8
    006F4 940C 1B0B JMP	pop_xgsetF000
_ReadDIR:
  DirStart             --> Y,+2
  Value                --> R10
  Index                --> R20
    006F6 940E 1AFC CALL	push_xgset300C
    006F8 0159      MOVW	R10,R18
    006F9 01A8      MOVW	R20,R16
    006FA 9726      SBIW	R28,6
(0495) }
(0496) 
(0497) /***********************************************************************
(0498) 函数功能：读取根目录的指定项
(0499) 操作内容：1、读取指定项的根目录数据   
(0500)           2、一个项的长度是32位，类似一个“文件”
(0501) ***********************************************************************/
(0502) 
(0503) void ReadDIR(uint16 Index, DIR* Value)
(0504) {
(0505) 	uint32 DirStart = DirStartSec();
    006FB DC38      RCALL	_DirStartSec
    006FC 830A      STD	Y+2,R16
    006FD 831B      STD	Y+3,R17
    006FE 832C      STD	Y+4,R18
    006FF 833D      STD	Y+5,R19
(0506) 	ReadBlock(DirStart + Index / 16);
    00700 011A      MOVW	R2,R20
    00701 9436      LSR	R3
    00702 9427      ROR	R2
    00703 9436      LSR	R3
    00704 9427      ROR	R2
    00705 9436      LSR	R3
    00706 9427      ROR	R2
    00707 9436      LSR	R3
    00708 9427      ROR	R2
    00709 2444      CLR	R4
    0070A 2455      CLR	R5
    0070B 810A      LDD	R16,Y+2
    0070C 811B      LDD	R17,Y+3
    0070D 812C      LDD	R18,Y+4
    0070E 813D      LDD	R19,Y+5
    0070F 0D02      ADD	R16,R2
    00710 1D13      ADC	R17,R3
    00711 1D24      ADC	R18,R4
    00712 1D35      ADC	R19,R5
    00713 DAC9      RCALL	_ReadBlock
(0507) 	CopyBytes(&BUFFER[(Index % 16) * 32], Value, 32);
    00714 E280      LDI	R24,0x20
    00715 E090      LDI	R25,0
    00716 8399      STD	Y+1,R25
    00717 8388      ST	Y,R24
    00718 01CA      MOVW	R24,R20
    00719 708F      ANDI	R24,0xF
    0071A 7090      ANDI	R25,0
    0071B E200      LDI	R16,0x20
    0071C E010      LDI	R17,0
    0071D 92AF      PUSH	R10
    0071E 92BF      PUSH	R11
    0071F 019C      MOVW	R18,R24
    00720 940E 1A8D CALL	empy16s
    00722 0118      MOVW	R2,R16
    00723 913F      POP	R19
    00724 912F      POP	R18
    00725 E887      LDI	R24,0x87
    00726 E092      LDI	R25,2
    00727 0E28      ADD	R2,R24
    00728 1E39      ADC	R3,R25
    00729 0181      MOVW	R16,R2
    0072A DAD8      RCALL	_CopyBytes
    0072B 9626      ADIW	R28,6
    0072C 940C 1B01 JMP	pop_xgset300C
_WriteDIR:
  LBA                  --> Y,+2
  Value                --> R10
  Index                --> R20
    0072E 940E 1AFC CALL	push_xgset300C
    00730 0159      MOVW	R10,R18
    00731 01A8      MOVW	R20,R16
    00732 9726      SBIW	R28,6
(0508) }
(0509) 
(0510) 
(0511) /***********************************************************************
(0512) 函数功能：写根目录的指定项
(0513) 操作内容：1、新建文件时，查找到可用根目录项后进行写入   
(0514)           2、一个项的长度是32位，类似一个“文件”
(0515) ***********************************************************************/
(0516) 
(0517) void WriteDIR(uint16 Index, DIR* Value)
(0518) {
(0519) 	uint32 LBA = DirStartSec() + Index / 16;
    00733 DC00      RCALL	_DirStartSec
    00734 011A      MOVW	R2,R20
    00735 9436      LSR	R3
    00736 9427      ROR	R2
    00737 9436      LSR	R3
    00738 9427      ROR	R2
    00739 9436      LSR	R3
    0073A 9427      ROR	R2
    0073B 9436      LSR	R3
    0073C 9427      ROR	R2
    0073D 2444      CLR	R4
    0073E 2455      CLR	R5
    0073F 0138      MOVW	R6,R16
    00740 0149      MOVW	R8,R18
    00741 0C62      ADD	R6,R2
    00742 1C73      ADC	R7,R3
    00743 1C84      ADC	R8,R4
    00744 1C95      ADC	R9,R5
    00745 826A      STD	Y+2,R6
    00746 827B      STD	Y+3,R7
    00747 828C      STD	Y+4,R8
    00748 829D      STD	Y+5,R9
(0520) 	ReadBlock(LBA);
    00749 810A      LDD	R16,Y+2
    0074A 811B      LDD	R17,Y+3
    0074B 812C      LDD	R18,Y+4
    0074C 813D      LDD	R19,Y+5
    0074D DA8F      RCALL	_ReadBlock
(0521) 	CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
    0074E E280      LDI	R24,0x20
    0074F E090      LDI	R25,0
    00750 8399      STD	Y+1,R25
    00751 8388      ST	Y,R24
    00752 019A      MOVW	R18,R20
    00753 702F      ANDI	R18,0xF
    00754 7030      ANDI	R19,0
    00755 E200      LDI	R16,0x20
    00756 E010      LDI	R17,0
    00757 940E 1A8D CALL	empy16s
    00759 0198      MOVW	R18,R16
    0075A E887      LDI	R24,0x87
    0075B E092      LDI	R25,2
    0075C 0F28      ADD	R18,R24
    0075D 1F39      ADC	R19,R25
    0075E 0185      MOVW	R16,R10
    0075F DAA3      RCALL	_CopyBytes
(0522) 	WriteBlock(LBA);
    00760 810A      LDD	R16,Y+2
    00761 811B      LDD	R17,Y+3
    00762 812C      LDD	R18,Y+4
    00763 813D      LDD	R19,Y+5
    00764 DA8B      RCALL	_WriteBlock
    00765 9626      ADIW	R28,6
    00766 940C 1B01 JMP	pop_xgset300C
_WriteDIR32:
  LBA                  --> Y,+2
  Value                --> R10
  Index                --> R20
    00768 940E 1AFC CALL	push_xgset300C
    0076A 0159      MOVW	R10,R18
    0076B 01A8      MOVW	R20,R16
    0076C 9726      SBIW	R28,6
(0523) }
(0524) 
(0525) void WriteDIR32(uint16 Index, DIR32* Value)
(0526) {
(0527) 	uint32 LBA = DirStartSec() + Index / 16;
    0076D DBC6      RCALL	_DirStartSec
    0076E 011A      MOVW	R2,R20
    0076F 9436      LSR	R3
    00770 9427      ROR	R2
    00771 9436      LSR	R3
    00772 9427      ROR	R2
    00773 9436      LSR	R3
    00774 9427      ROR	R2
    00775 9436      LSR	R3
    00776 9427      ROR	R2
    00777 2444      CLR	R4
    00778 2455      CLR	R5
    00779 0138      MOVW	R6,R16
    0077A 0149      MOVW	R8,R18
    0077B 0C62      ADD	R6,R2
    0077C 1C73      ADC	R7,R3
    0077D 1C84      ADC	R8,R4
    0077E 1C95      ADC	R9,R5
    0077F 826A      STD	Y+2,R6
    00780 827B      STD	Y+3,R7
    00781 828C      STD	Y+4,R8
    00782 829D      STD	Y+5,R9
(0528) 	ReadBlock(LBA);
    00783 810A      LDD	R16,Y+2
    00784 811B      LDD	R17,Y+3
    00785 812C      LDD	R18,Y+4
    00786 813D      LDD	R19,Y+5
    00787 DA55      RCALL	_ReadBlock
(0529) 	CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
    00788 E280      LDI	R24,0x20
    00789 E090      LDI	R25,0
    0078A 8399      STD	Y+1,R25
    0078B 8388      ST	Y,R24
    0078C 019A      MOVW	R18,R20
    0078D 702F      ANDI	R18,0xF
    0078E 7030      ANDI	R19,0
    0078F E200      LDI	R16,0x20
    00790 E010      LDI	R17,0
    00791 940E 1A8D CALL	empy16s
    00793 0198      MOVW	R18,R16
    00794 E887      LDI	R24,0x87
    00795 E092      LDI	R25,2
    00796 0F28      ADD	R18,R24
    00797 1F39      ADC	R19,R25
    00798 0185      MOVW	R16,R10
    00799 DA69      RCALL	_CopyBytes
(0530) 	WriteBlock(LBA);
    0079A 810A      LDD	R16,Y+2
    0079B 811B      LDD	R17,Y+3
    0079C 812C      LDD	R18,Y+4
    0079D 813D      LDD	R19,Y+5
    0079E DA51      RCALL	_WriteBlock
    0079F 9626      ADIW	R28,6
    007A0 940C 1B01 JMP	pop_xgset300C
_WriteDirectoryDIR:
  LBA                  --> Y,+2
  Value                --> R10
  Index                --> R20
  ClusID               --> R12
    007A2 940E 1B1E CALL	push_xgset303C
    007A4 01A9      MOVW	R20,R18
    007A5 0168      MOVW	R12,R16
    007A6 9726      SBIW	R28,6
    007A7 84AC      LDD	R10,Y+12
    007A8 84BD      LDD	R11,Y+13
(0531) }
(0532) 
(0533) /***********************************************************************
(0534) 函数功能：写子目录的“.”和“..”项内容
(0535) 操作内容：1、一共是2个32Bytes  
(0536)           2、一个项的长度是32位，类似一个“文件”
(0537)           3、起始地址是子目录的起始簇地址
(0538) ***********************************************************************/
(0539) 
(0540) void WriteDirectoryDIR(uint16 ClusID, uint16 Index, DIR* Value)
(0541) {
(0542) 	uint32 LBA = ClusConvLBA(ClusID);
    007A9 0186      MOVW	R16,R12
    007AA DC00      RCALL	_ClusConvLBA
    007AB 830A      STD	Y+2,R16
    007AC 831B      STD	Y+3,R17
    007AD 832C      STD	Y+4,R18
    007AE 833D      STD	Y+5,R19
(0543) 	ReadBlock(LBA);
    007AF 810A      LDD	R16,Y+2
    007B0 811B      LDD	R17,Y+3
    007B1 812C      LDD	R18,Y+4
    007B2 813D      LDD	R19,Y+5
    007B3 DA29      RCALL	_ReadBlock
(0544) 	CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
    007B4 E280      LDI	R24,0x20
    007B5 E090      LDI	R25,0
    007B6 8399      STD	Y+1,R25
    007B7 8388      ST	Y,R24
    007B8 019A      MOVW	R18,R20
    007B9 702F      ANDI	R18,0xF
    007BA 7030      ANDI	R19,0
    007BB E200      LDI	R16,0x20
    007BC E010      LDI	R17,0
    007BD 940E 1A8D CALL	empy16s
    007BF 0198      MOVW	R18,R16
    007C0 E887      LDI	R24,0x87
    007C1 E092      LDI	R25,2
    007C2 0F28      ADD	R18,R24
    007C3 1F39      ADC	R19,R25
    007C4 0185      MOVW	R16,R10
    007C5 DA3D      RCALL	_CopyBytes
(0545) 	WriteBlock(LBA);
    007C6 810A      LDD	R16,Y+2
    007C7 811B      LDD	R17,Y+3
    007C8 812C      LDD	R18,Y+4
    007C9 813D      LDD	R19,Y+5
    007CA DA25      RCALL	_WriteBlock
    007CB 9626      ADIW	R28,6
    007CC 940C 1B25 JMP	pop_xgset303C
_WriteDirectoryDIR32:
  LBA                  --> Y,+2
  Value                --> R10
  Index                --> R20
    007CE 940E 1AFC CALL	push_xgset300C
    007D0 0159      MOVW	R10,R18
    007D1 01A8      MOVW	R20,R16
    007D2 9726      SBIW	R28,6
(0546) }
(0547) 
(0548) void WriteDirectoryDIR32(uint16 Index, DIR32* Value)
(0549) {
(0550) 	uint32 LBA = DirStartSec() + Index / 16;
    007D3 DB60      RCALL	_DirStartSec
    007D4 011A      MOVW	R2,R20
    007D5 9436      LSR	R3
    007D6 9427      ROR	R2
    007D7 9436      LSR	R3
    007D8 9427      ROR	R2
    007D9 9436      LSR	R3
    007DA 9427      ROR	R2
    007DB 9436      LSR	R3
    007DC 9427      ROR	R2
    007DD 2444      CLR	R4
    007DE 2455      CLR	R5
    007DF 0138      MOVW	R6,R16
    007E0 0149      MOVW	R8,R18
    007E1 0C62      ADD	R6,R2
    007E2 1C73      ADC	R7,R3
    007E3 1C84      ADC	R8,R4
    007E4 1C95      ADC	R9,R5
    007E5 826A      STD	Y+2,R6
    007E6 827B      STD	Y+3,R7
    007E7 828C      STD	Y+4,R8
    007E8 829D      STD	Y+5,R9
(0551) 	ReadBlock(LBA);
    007E9 810A      LDD	R16,Y+2
    007EA 811B      LDD	R17,Y+3
    007EB 812C      LDD	R18,Y+4
    007EC 813D      LDD	R19,Y+5
    007ED D9EF      RCALL	_ReadBlock
(0552) 	CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
    007EE E280      LDI	R24,0x20
    007EF E090      LDI	R25,0
    007F0 8399      STD	Y+1,R25
    007F1 8388      ST	Y,R24
    007F2 019A      MOVW	R18,R20
    007F3 702F      ANDI	R18,0xF
    007F4 7030      ANDI	R19,0
    007F5 E200      LDI	R16,0x20
    007F6 E010      LDI	R17,0
    007F7 940E 1A8D CALL	empy16s
    007F9 0198      MOVW	R18,R16
    007FA E887      LDI	R24,0x87
    007FB E092      LDI	R25,2
    007FC 0F28      ADD	R18,R24
    007FD 1F39      ADC	R19,R25
    007FE 0185      MOVW	R16,R10
    007FF DA03      RCALL	_CopyBytes
(0553) 	WriteBlock(LBA);
    00800 810A      LDD	R16,Y+2
    00801 811B      LDD	R17,Y+3
    00802 812C      LDD	R18,Y+4
    00803 813D      LDD	R19,Y+5
    00804 D9EB      RCALL	_WriteBlock
    00805 9626      ADIW	R28,6
    00806 940C 1B01 JMP	pop_xgset300C
_GetFileCrtDate:
  FileCrtDate          --> R10
  Day                  --> R10
  Month                --> R12
  Year                 --> R20
    00808 940E 1B1E CALL	push_xgset303C
    0080A 2EC2      MOV	R12,R18
    0080B 01A8      MOVW	R20,R16
    0080C 80AE      LDD	R10,Y+6
(0554) }
(0555) 
(0556) /***********************************************************************
(0557) 函数功能：文件修改日期转换为对应格式，如2010年07月01日转换为0x3CE1
(0558) 操作内容：1、修改日期计算公式   
(0559)           2、日期数据为2个字节长度
(0560)           3、可配合实时时钟使用，这样可以得到实时的更改日期
(0561) ***********************************************************************/
(0562) uint16 GetFileCrtDate(uint16 Year, uint8 Month, uint8 Day)//年、月、日
(0563) {
(0564)         uint16 FileCrtDate;
(0565)         FileCrtDate=(Year-1980)*512+Month*32+Day;    // 0~4位为日(1~31)，5～8位为月(1~12)，9～15位为年(0~127)，相对于1980年1月1日的偏移量
    0080D E200      LDI	R16,0x20
    0080E 2D1C      MOV	R17,R12
    0080F 0301      MULSU	R16,R17
    00810 0110      MOVW	R2,R0
    00811 019A      MOVW	R18,R20
    00812 5B2C      SUBI	R18,0xBC
    00813 4037      SBCI	R19,7
    00814 E000      LDI	R16,0
    00815 E012      LDI	R17,2
    00816 940E 1A8D CALL	empy16s
    00818 0128      MOVW	R4,R16
    00819 0C42      ADD	R4,R2
    0081A 1C53      ADC	R5,R3
    0081B 2C2A      MOV	R2,R10
    0081C 2433      CLR	R3
    0081D 0C42      ADD	R4,R2
    0081E 1C53      ADC	R5,R3
    0081F 0152      MOVW	R10,R4
(0566)         return FileCrtDate;
    00820 0182      MOVW	R16,R4
    00821 940C 1B25 JMP	pop_xgset303C
_GetFileCrtTime:
  FileCrtTime          --> R10
  Sec                  --> R10
  Min                  --> R14
  Hour                 --> R12
    00823 940E 1AF5 CALL	push_xgset00FC
    00825 2EE2      MOV	R14,R18
    00826 2EC0      MOV	R12,R16
    00827 80AE      LDD	R10,Y+6
(0567) }
(0568) 
(0569) /***********************************************************************
(0570) 函数功能：文件修改时间转换为对应格式
(0571) 操作内容：1、修改时间计算公式   
(0572)           2、时间数据为2个字节长度
(0573)           3、可配合实时时钟使用，这样可以得到实时的更改时间
(0574) ***********************************************************************/
(0575) 
(0576) uint16 GetFileCrtTime(uint8 Hour, uint8 Min, uint8 Sec)//时、分、秒
(0577) {
(0578)         uint16 FileCrtTime;
(0579)         FileCrtTime=Hour*2048+Min*32+Sec/2;       // 0~4位为秒，2秒为1个单位(0~29)，5～10位为分(0~59)，11～15位为时(0~23)
    00828 E200      LDI	R16,0x20
    00829 2D1E      MOV	R17,R14
    0082A 0301      MULSU	R16,R17
    0082B 0110      MOVW	R2,R0
    0082C 2D2C      MOV	R18,R12
    0082D 2733      CLR	R19
    0082E E000      LDI	R16,0
    0082F E018      LDI	R17,0x8
    00830 940E 1A8D CALL	empy16s
    00832 0128      MOVW	R4,R16
    00833 0C42      ADD	R4,R2
    00834 1C53      ADC	R5,R3
    00835 E022      LDI	R18,2
    00836 E030      LDI	R19,0
    00837 2D0A      MOV	R16,R10
    00838 2711      CLR	R17
    00839 940E 19ED CALL	div16s
    0083B 0E40      ADD	R4,R16
    0083C 1E51      ADC	R5,R17
    0083D 0152      MOVW	R10,R4
(0580)         return FileCrtTime;
    0083E 0182      MOVW	R16,R4
    0083F 940C 1AD6 JMP	pop_xgset00FC
_CreateDirectoryFile:
  Index                --> R20
  ClusIDFile           --> R12
  FileCrtTime          --> Y,+36
  FileCrtDate          --> Y,+34
  FileCrtTimeTmp       --> R20
  FileCrtDateTmp       --> R20
  ClusID               --> R10
  FileDir              --> Y,+2
  FileName             --> R14
  DirectoryName        --> R20
    00841 940E 1AF3 CALL	push_xgset30FC
    00843 0179      MOVW	R14,R18
    00844 01A8      MOVW	R20,R16
    00845 97A6      SBIW	R28,0x26
(0581) }
(0582) 
(0583) 
(0584) 
(0585) /***********************************************************************
(0586) 函数功能：创建一个子空文件
(0587) 操作内容：1、文件名必须是数字或者大写字母，小于8位则用空格，扩展名为空格 
(0588)           2、文件大小事先不用设置,均为0;
(0589)           3、创建子文件的过程实际就是写子目录和FAT表，这里不写文件里的数据
(0590)           4、这里文件名为短名，8个字节，也就是8个字符
(0591)           5、子文件的目录写在其父目录的起始簇的空白目录项
(0592) ***********************************************************************/
(0593) void CreateDirectoryFile(uint8 DirectoryName[11], uint8 FileName[11])  //父文件夹名和新建文件名，短文件名
(0594) {
(0595) 	uint16 ClusID,ClusIDFile,Index;
(0596)         DIR FileDir;
(0597)         uint16 FileCrtDateTmp,FileCrtTimeTmp;                 //双字节数据       
(0598)         uint8 FileCrtDate[2],FileCrtTime[2];                  //单字节时间日期数据
(0599)  
(0600) 	FileDir.FilePosit.Start = GetNextFAT();               //得到一个空的FAT项，下面用来写对应文件的FAT表       
    00846 DE3C      RCALL	_GetNextFAT
    00847 8F1D      STD	Y+29,R17
    00848 8F0C      STD	Y+28,R16
(0601) 	ClusID = FileDir.FilePosit.Start;                     //文件簇开始簇号，这是子文件的起始簇地址
    00849 0158      MOVW	R10,R16
(0602)         ClusIDFile = FileDir.FilePosit.Start;                 //暂存下来，以备后面写入
    0084A 0165      MOVW	R12,R10
(0603) 
(0604) 	WriteFAT(ClusID, 0xffff);                             //写对应文件的FAT表1，即FAT1,0xffff表示文件结束
    0084B EF2F      LDI	R18,0xFF
    0084C EF3F      LDI	R19,0xFF
    0084D DBF7      RCALL	_WriteFAT
(0605)         WriteFAT2(ClusID, 0xffff);                            //写对应文件的FAT表2，即FAT2，0xffff表示文件结束     
    0084E EF2F      LDI	R18,0xFF
    0084F EF3F      LDI	R19,0xFF
    00850 0185      MOVW	R16,R10
    00851 DC84      RCALL	_WriteFAT2
(0606)                              
(0607)         Index = GetFileID(DirectoryName,&FileDir);            //搜索得到文件夹的属性，主要是获得起始簇位置，方便写文件的目录项
    00852 019E      MOVW	R18,R28
    00853 5F2E      SUBI	R18,0xFE
    00854 4F3F      SBCI	R19,0xFF
    00855 018A      MOVW	R16,R20
    00856 DD7A      RCALL	_GetFileID
    00857 2F40      MOV	R20,R16
    00858 2755      CLR	R21
(0608)         ReadDIR(Index, &FileDir);                             //读取父文件夹的目录项，只需要其起始簇
    00859 019E      MOVW	R18,R28
    0085A 5F2E      SUBI	R18,0xFE
    0085B 4F3F      SBCI	R19,0xFF
    0085C 018A      MOVW	R16,R20
    0085D DE98      RCALL	_ReadDIR
(0609)         
(0610)         FileCrtDateTmp=GetFileCrtDate(2010,7,2);              //文件修改日期2010年7月2日
    0085E E082      LDI	R24,2
    0085F 8388      ST	Y,R24
    00860 E027      LDI	R18,7
    00861 ED0A      LDI	R16,0xDA
    00862 E017      LDI	R17,7
    00863 DFA4      RCALL	_GetFileCrtDate
    00864 01A8      MOVW	R20,R16
(0611)         FileCrtDate[0]=(uint8)FileCrtDateTmp&0x00ff;          //低字节提取
    00865 2F84      MOV	R24,R20
    00866 7F8F      ANDI	R24,0xFF
    00867 A38A      STD	Y+34,R24
(0612)         FileCrtDate[1]=(uint8)(FileCrtDateTmp>>8);            //高字节提取       
    00868 011A      MOVW	R2,R20
    00869 2C23      MOV	R2,R3
    0086A 2433      CLR	R3
    0086B A22B      STD	Y+35,R2
(0613)         FileCrtTimeTmp=GetFileCrtTime(21,20,10);              //文件修改时间21点20分10秒
    0086C E08A      LDI	R24,0xA
    0086D 8388      ST	Y,R24
    0086E E124      LDI	R18,0x14
    0086F E105      LDI	R16,0x15
    00870 DFB2      RCALL	_GetFileCrtTime
    00871 01A8      MOVW	R20,R16
(0614)         FileCrtTime[0]=(uint8)FileCrtTimeTmp&0x00ff;          //低字节提取
    00872 2F84      MOV	R24,R20
    00873 7F8F      ANDI	R24,0xFF
    00874 A38C      STD	Y+36,R24
(0615)         FileCrtTime[1]=(uint8)(FileCrtTimeTmp>>8);            //高字节提取      
    00875 011A      MOVW	R2,R20
    00876 2C23      MOV	R2,R3
    00877 2433      CLR	R3
    00878 A22D      STD	Y+37,R2
(0616)         
(0617)         CopyBytes(FileName, &FileDir.FileName, 11);           //写入文件名
    00879 E08B      LDI	R24,0xB
    0087A E090      LDI	R25,0
    0087B 8399      STD	Y+1,R25
    0087C 8388      ST	Y,R24
    0087D 019E      MOVW	R18,R28
    0087E 5F2E      SUBI	R18,0xFE
    0087F 4F3F      SBCI	R19,0xFF
    00880 0187      MOVW	R16,R14
    00881 D981      RCALL	_CopyBytes
(0618)         
(0619)         CopyBytes(FileCrtDate, &FileDir.FileCrtDate, 2);       //写入文件创建日期
    00882 E082      LDI	R24,2
    00883 E090      LDI	R25,0
    00884 8399      STD	Y+1,R25
    00885 8388      ST	Y,R24
    00886 019E      MOVW	R18,R28
    00887 5E2E      SUBI	R18,0xEE
    00888 4F3F      SBCI	R19,0xFF
    00889 018E      MOVW	R16,R28
    0088A 5D0E      SUBI	R16,0xDE
    0088B 4F1F      SBCI	R17,0xFF
    0088C D976      RCALL	_CopyBytes
(0620)         CopyBytes(FileCrtTime, &FileDir.FileCrtTime, 2);       //写入文件创建时间
    0088D E082      LDI	R24,2
    0088E E090      LDI	R25,0
    0088F 8399      STD	Y+1,R25
    00890 8388      ST	Y,R24
    00891 019E      MOVW	R18,R28
    00892 5F20      SUBI	R18,0xF0
    00893 4F3F      SBCI	R19,0xFF
    00894 018E      MOVW	R16,R28
    00895 5D0C      SUBI	R16,0xDC
    00896 4F1F      SBCI	R17,0xFF
    00897 D96B      RCALL	_CopyBytes
(0621)         
(0622)         FileDir.FileAttrib = 0x20;                             //文件属性填充，0x10为子目录属性，即文件夹       
    00898 E280      LDI	R24,0x20
    00899 878D      STD	Y+13,R24
(0623)        
(0624)         ClusID = FileDir.FilePosit.Start;                      //父文件夹的开始簇号，子文件目录项写入这个簇中
    0089A 8CAC      LDD	R10,Y+28
    0089B 8CBD      LDD	R11,Y+29
(0625)         FileDir.FilePosit.Start=ClusIDFile;                    //新建文件的起始簇
    0089C 8EDD      STD	Y+29,R13
    0089D 8ECC      STD	Y+28,R12
(0626)         WriteDirectoryDIR(ClusID,GetDirectoryEmptyDIR(ClusID),&FileDir);//需要扫描父目录的起始簇中空白可以写入子目录的项
    0089E 0185      MOVW	R16,R10
    0089F DCF3      RCALL	_GetDirectoryEmptyDIR
    008A0 0168      MOVW	R12,R16
    008A1 01CE      MOVW	R24,R28
    008A2 9602      ADIW	R24,2
    008A3 8399      STD	Y+1,R25
    008A4 8388      ST	Y,R24
    008A5 0196      MOVW	R18,R12
    008A6 0185      MOVW	R16,R10
    008A7 DEFA      RCALL	_WriteDirectoryDIR
    008A8 96A6      ADIW	R28,0x26
    008A9 940C 1ADD JMP	pop_xgset30FC
_CreateFile:
  DirectoryDIRFileName1 --> Y,+49
  DirectoryDIRFileName0 --> Y,+38
  FileCrtTime          --> Y,+36
  FileCrtDate          --> Y,+34
  FileCrtTimeTmp       --> R14
  FileCrtDateTmp       --> R14
  ClusID               --> R10
  FileDir              --> Y,+2
  FileAttrib           --> R10
  FileName             --> R12
    008AB 940E 1AF5 CALL	push_xgset00FC
    008AD 2EA2      MOV	R10,R18
    008AE 0168      MOVW	R12,R16
    008AF 97EC      SBIW	R28,0x3C
(0627)         
(0628) }
(0629) 
(0630) 
(0631) /***********************************************************************
(0632) 函数功能：在根目录创建一个空文件或文件夹
(0633) 操作内容：1、FileName文件名必须是数字或者大写字母，扩展名也是如此   
(0634)           2、文件大小事先不用设置,均为0;
(0635)           3、创建文件的过程实际就是写根目录和FAT表，这里不写文件里的数据
(0636)           4、这里文件名为短名，8个字节，也就是8个字符
(0637)           5、第二个参数为属性，0x10为文件夹，0x20为文件
(0638)           6、该文件夹只建立于根目录下，可以更改
(0639)           7、根目录，没有"."和".."项，如果是子目录，也就是文件夹，则有
(0640) ***********************************************************************/
(0641) 
(0642) void CreateFile(uint8 FileName[11], uint8 FileAttrib)
(0643) {
(0644) 	uint16 ClusID;
(0645)         DIR FileDir;
(0646)         uint8 DirectoryDIRFileName0[11]=".          ";
    008B0 E084      LDI	R24,4
    008B1 E091      LDI	R25,1
    008B2 01FE      MOVW	R30,R28
    008B3 96B6      ADIW	R30,0x26
    008B4 E00B      LDI	R16,0xB
    008B5 E010      LDI	R17,0
    008B6 93FA      ST	-Y,R31
    008B7 93EA      ST	-Y,R30
    008B8 939A      ST	-Y,R25
    008B9 938A      ST	-Y,R24
    008BA 940E 1B9B CALL	asgnblk
(0647)         uint8 DirectoryDIRFileName1[11]="..         ";
    008BC E08F      LDI	R24,0xF
    008BD E091      LDI	R25,1
    008BE 01FE      MOVW	R30,R28
    008BF 96F1      ADIW	R30,0x31
    008C0 E00B      LDI	R16,0xB
    008C1 E010      LDI	R17,0
    008C2 93FA      ST	-Y,R31
    008C3 93EA      ST	-Y,R30
    008C4 939A      ST	-Y,R25
    008C5 938A      ST	-Y,R24
    008C6 940E 1B9B CALL	asgnblk
(0648)         
(0649)         uint16 FileCrtDateTmp,FileCrtTimeTmp;                 //双字节数据       
(0650)         uint8 FileCrtDate[2],FileCrtTime[2];                  //单字节时间日期数据
(0651)         
(0652)         FileCrtDateTmp=GetFileCrtDate(2012,5,2);              //文件修改日期2010年7月2日
    008C8 E082      LDI	R24,2
    008C9 8388      ST	Y,R24
    008CA E025      LDI	R18,5
    008CB ED0C      LDI	R16,0xDC
    008CC E017      LDI	R17,7
    008CD DF3A      RCALL	_GetFileCrtDate
    008CE 0178      MOVW	R14,R16
(0653)         FileCrtDate[0]=(uint8)FileCrtDateTmp&0x00ff;          //低字节提取
    008CF 2D8E      MOV	R24,R14
    008D0 7F8F      ANDI	R24,0xFF
    008D1 A38A      STD	Y+34,R24
(0654)         FileCrtDate[1]=(uint8)(FileCrtDateTmp>>8);            //高字节提取
    008D2 0117      MOVW	R2,R14
    008D3 2C23      MOV	R2,R3
    008D4 2433      CLR	R3
    008D5 A22B      STD	Y+35,R2
(0655)         
(0656)         FileCrtTimeTmp=GetFileCrtTime(21,20,10);              //文件修改时间21点20分10秒
    008D6 E08A      LDI	R24,0xA
    008D7 8388      ST	Y,R24
    008D8 E124      LDI	R18,0x14
    008D9 E105      LDI	R16,0x15
    008DA DF48      RCALL	_GetFileCrtTime
    008DB 0178      MOVW	R14,R16
(0657)         FileCrtTime[0]=(uint8)FileCrtTimeTmp&0x00ff;          //低字节提取
    008DC 2D8E      MOV	R24,R14
    008DD 7F8F      ANDI	R24,0xFF
    008DE A38C      STD	Y+36,R24
(0658)         FileCrtTime[1]=(uint8)(FileCrtTimeTmp>>8);            //高字节提取
    008DF 0117      MOVW	R2,R14
    008E0 2C23      MOV	R2,R3
    008E1 2433      CLR	R3
    008E2 A22D      STD	Y+37,R2
(0659)         
(0660)         
(0661) 	//ClusNum = Size / (BPB_SecPerClus * 512) + 1;
(0662) 	EmptyBytes(&FileDir, sizeof(DIR));                          //先全部填充0
    008E3 E220      LDI	R18,0x20
    008E4 E030      LDI	R19,0
    008E5 018E      MOVW	R16,R28
    008E6 5F0E      SUBI	R16,0xFE
    008E7 4F1F      SBCI	R17,0xFF
    008E8 D963      RCALL	_EmptyBytes
(0663)         CopyBytes(FileName, &FileDir.FileName, 11);                 //写入文件名
    008E9 E08B      LDI	R24,0xB
    008EA E090      LDI	R25,0
    008EB 8399      STD	Y+1,R25
    008EC 8388      ST	Y,R24
    008ED 019E      MOVW	R18,R28
    008EE 5F2E      SUBI	R18,0xFE
    008EF 4F3F      SBCI	R19,0xFF
    008F0 0186      MOVW	R16,R12
    008F1 D911      RCALL	_CopyBytes
(0664)         
(0665)         FileDir.FileAttrib = FileAttrib;                            //文件属性填充，0x10则为文件夹，0x20则为文件
    008F2 86AD      STD	Y+13,R10
(0666)         
(0667)         CopyBytes(FileCrtDate, &FileDir.FileCrtDate, 2);            //写入文件创建日期
    008F3 E082      LDI	R24,2
    008F4 E090      LDI	R25,0
    008F5 8399      STD	Y+1,R25
    008F6 8388      ST	Y,R24
    008F7 019E      MOVW	R18,R28
    008F8 5E2E      SUBI	R18,0xEE
    008F9 4F3F      SBCI	R19,0xFF
    008FA 018E      MOVW	R16,R28
    008FB 5D0E      SUBI	R16,0xDE
    008FC 4F1F      SBCI	R17,0xFF
    008FD D905      RCALL	_CopyBytes
(0668)         CopyBytes(FileCrtTime, &FileDir.FileCrtTime, 2);            //写入文件创建时间
    008FE E082      LDI	R24,2
    008FF E090      LDI	R25,0
    00900 8399      STD	Y+1,R25
    00901 8388      ST	Y,R24
    00902 019E      MOVW	R18,R28
    00903 5F20      SUBI	R18,0xF0
    00904 4F3F      SBCI	R19,0xFF
    00905 018E      MOVW	R16,R28
    00906 5D0C      SUBI	R16,0xDC
    00907 4F1F      SBCI	R17,0xFF
    00908 D8FA      RCALL	_CopyBytes
(0669)         
(0670) 	//FileDir.FilePosit.Size = 0;
(0671) 	FileDir.FilePosit.Start = GetNextFAT();                     //得到一个空的FAT项，下面用来写对应文件的FAT表
    00909 DD79      RCALL	_GetNextFAT
    0090A 0158      MOVW	R10,R16
    0090B 8EBD      STD	Y+29,R11
    0090C 8EAC      STD	Y+28,R10
(0672)         
(0673) 	ClusID = FileDir.FilePosit.Start;                           //文件簇开始簇号
(0674) 
(0675) 	WriteFAT(ClusID, 0xffff);                                   //写对应文件的FAT表1，即FAT1,0xffff表示文件结束
    0090D EF2F      LDI	R18,0xFF
    0090E EF3F      LDI	R19,0xFF
    0090F DB35      RCALL	_WriteFAT
(0676)         WriteFAT2(ClusID, 0xffff);                                  //写对应文件的FAT表2，即FAT2，0xffff表示文件结束
    00910 EF2F      LDI	R18,0xFF
    00911 EF3F      LDI	R19,0xFF
    00912 0185      MOVW	R16,R10
    00913 DBC2      RCALL	_WriteFAT2
(0677) 	WriteDIR(GetEmptyDIR(), &FileDir);                          //写根目录指定项，首先搜索可以使用项，再写入
    00914 DC44      RCALL	_GetEmptyDIR
    00915 0168      MOVW	R12,R16
    00916 019E      MOVW	R18,R28
    00917 5F2E      SUBI	R18,0xFE
    00918 4F3F      SBCI	R19,0xFF
    00919 DE14      RCALL	_WriteDIR
(0678)         
(0679)     
(0680)   if(FileDir.FileAttrib==0x10)                                      //如果是建立文件夹，则写“.”项和“..项”
    0091A 858D      LDD	R24,Y+13
    0091B 3180      CPI	R24,0x10
    0091C F551      BNE	0x0947
(0681)      {
(0682)         CopyBytes(DirectoryDIRFileName0, &FileDir.FileName, 11);    //写入".项目录内容"，该项为自身目录项内容
    0091D E08B      LDI	R24,0xB
    0091E E090      LDI	R25,0
    0091F 8399      STD	Y+1,R25
    00920 8388      ST	Y,R24
    00921 019E      MOVW	R18,R28
    00922 5F2E      SUBI	R18,0xFE
    00923 4F3F      SBCI	R19,0xFF
    00924 018E      MOVW	R16,R28
    00925 5D0A      SUBI	R16,0xDA
    00926 4F1F      SBCI	R17,0xFF
    00927 D8DB      RCALL	_CopyBytes
(0683)         WriteDirectoryDIR(ClusID,0,&FileDir);                       //写入，地址为新建目录的起始簇地址的前2个32Bytes，这项为第0个
    00928 01CE      MOVW	R24,R28
    00929 9602      ADIW	R24,2
    0092A 8399      STD	Y+1,R25
    0092B 8388      ST	Y,R24
    0092C 2722      CLR	R18
    0092D 2733      CLR	R19
    0092E 0185      MOVW	R16,R10
    0092F DE72      RCALL	_WriteDirectoryDIR
(0684)         
(0685)         CopyBytes(DirectoryDIRFileName1, &FileDir.FileName, 11);    //写入"..项目录内容"，该项为与父目录关系，起始簇地址为父目录的起始簇地址
    00930 E08B      LDI	R24,0xB
    00931 E090      LDI	R25,0
    00932 8399      STD	Y+1,R25
    00933 8388      ST	Y,R24
    00934 019E      MOVW	R18,R28
    00935 5F2E      SUBI	R18,0xFE
    00936 4F3F      SBCI	R19,0xFF
    00937 018E      MOVW	R16,R28
    00938 5C0F      SUBI	R16,0xCF
    00939 4F1F      SBCI	R17,0xFF
    0093A D8C8      RCALL	_CopyBytes
(0686)         FileDir.FilePosit.Start=0x0000;                             //文件夹位于根目录下，可更改为文件夹的父文件夹起始簇地址
    0093B 2422      CLR	R2
    0093C 2433      CLR	R3
    0093D 8E3D      STD	Y+29,R3
    0093E 8E2C      STD	Y+28,R2
(0687)         WriteDirectoryDIR(ClusID,1,&FileDir);                       //写入，地址为新建目录的起始簇地址的前2个32Bytes，这项为第1个
    0093F 01CE      MOVW	R24,R28
    00940 9602      ADIW	R24,2
    00941 8399      STD	Y+1,R25
    00942 8388      ST	Y,R24
    00943 E021      LDI	R18,1
    00944 E030      LDI	R19,0
    00945 0185      MOVW	R16,R10
    00946 DE5B      RCALL	_WriteDirectoryDIR
(0688)      }
    00947 96EC      ADIW	R28,0x3C
    00948 940C 1AD6 JMP	pop_xgset00FC
_FAT32CreateFile:
  FileWrTime           --> Y,+40
  FileWrData           --> Y,+38
  FileWrTimeTmp        --> R12
  FileWrDataTmp        --> R12
  ClusID               --> Y,+34
  FileDir              --> Y,+4
  FileName             --> R10
    0094A 940E 1AF7 CALL	push_xgset003C
    0094C 0158      MOVW	R10,R16
    0094D 97AA      SBIW	R28,0x2A
(0689) }
(0690) 
(0691) void FAT32CreateFile(uint8 FileName[11])
(0692) {
(0693) 	uint32 ClusID;
(0694)         DIR32 FileDir;
(0695)         uint16 FileWrDataTmp,FileWrTimeTmp;                         //双字节数据       
(0696)         uint8 FileWrData[2],FileWrTime[2];                          //单字节时间日期数据
(0697)         
(0698)         FileWrDataTmp=GetFileCrtDate(2012,5,2);                     //文件修改日期2010年7月2日
    0094E E082      LDI	R24,2
    0094F 8388      ST	Y,R24
    00950 E025      LDI	R18,5
    00951 ED0C      LDI	R16,0xDC
    00952 E017      LDI	R17,7
    00953 DEB4      RCALL	_GetFileCrtDate
    00954 0168      MOVW	R12,R16
(0699)         FileWrData[0]=(uint8)FileWrDataTmp&0x00ff;                  //低字节提取
    00955 2D8C      MOV	R24,R12
    00956 7F8F      ANDI	R24,0xFF
    00957 A38E      STD	Y+38,R24
(0700)         FileWrData[1]=(uint8)(FileWrDataTmp>>8);                    //高字节提取
    00958 0116      MOVW	R2,R12
    00959 2C23      MOV	R2,R3
    0095A 2433      CLR	R3
    0095B A22F      STD	Y+39,R2
(0701)         
(0702)         FileWrTimeTmp=GetFileCrtTime(21,20,10);                     //文件修改时间21点20分10秒
    0095C E08A      LDI	R24,0xA
    0095D 8388      ST	Y,R24
    0095E E124      LDI	R18,0x14
    0095F E105      LDI	R16,0x15
    00960 DEC2      RCALL	_GetFileCrtTime
    00961 0168      MOVW	R12,R16
(0703)         FileWrTime[0]=(uint8)FileWrTimeTmp&0x00ff;                  //低字节提取
    00962 2D8C      MOV	R24,R12
    00963 7F8F      ANDI	R24,0xFF
    00964 A788      STD	Y+40,R24
(0704)         FileWrTime[1]=(uint8)(FileWrTimeTmp>>8);                    //高字节提取
    00965 0116      MOVW	R2,R12
    00966 2C23      MOV	R2,R3
    00967 2433      CLR	R3
    00968 A629      STD	Y+41,R2
(0705)                 
(0706) 	//ClusNum = Size / (BPB_SecPerClus * 512) + 1;
(0707) 	EmptyBytes(&FileDir, sizeof(DIR));                          //先全部填充0
    00969 E220      LDI	R18,0x20
    0096A E030      LDI	R19,0
    0096B 018E      MOVW	R16,R28
    0096C 5F0C      SUBI	R16,0xFC
    0096D 4F1F      SBCI	R17,0xFF
    0096E D8DD      RCALL	_EmptyBytes
(0708)         CopyBytes(FileName, &FileDir.FileName, 11);                 //写入文件名
    0096F E08B      LDI	R24,0xB
    00970 E090      LDI	R25,0
    00971 8399      STD	Y+1,R25
    00972 8388      ST	Y,R24
    00973 019E      MOVW	R18,R28
    00974 5F2C      SUBI	R18,0xFC
    00975 4F3F      SBCI	R19,0xFF
    00976 0185      MOVW	R16,R10
    00977 D88B      RCALL	_CopyBytes
(0709)         
(0710)         FileDir.FileAttrib = 0x20;                                  //文件属性填充
    00978 E280      LDI	R24,0x20
    00979 878F      STD	Y+15,R24
(0711)         
(0712)         CopyBytes(FileWrData, &FileDir.DIR_WrtDate, 2);             //写入文件修改日期
    0097A E082      LDI	R24,2
    0097B E090      LDI	R25,0
    0097C 8399      STD	Y+1,R25
    0097D 8388      ST	Y,R24
    0097E 019E      MOVW	R18,R28
    0097F 5E24      SUBI	R18,0xE4
    00980 4F3F      SBCI	R19,0xFF
    00981 018E      MOVW	R16,R28
    00982 5D0A      SUBI	R16,0xDA
    00983 4F1F      SBCI	R17,0xFF
    00984 D87E      RCALL	_CopyBytes
(0713)         CopyBytes(FileWrTime, &FileDir.DIR_WrtTime, 2);             //写入文件修改时间
    00985 E082      LDI	R24,2
    00986 E090      LDI	R25,0
    00987 8399      STD	Y+1,R25
    00988 8388      ST	Y,R24
    00989 019E      MOVW	R18,R28
    0098A 5E26      SUBI	R18,0xE6
    0098B 4F3F      SBCI	R19,0xFF
    0098C 018E      MOVW	R16,R28
    0098D 5D08      SUBI	R16,0xD8
    0098E 4F1F      SBCI	R17,0xFF
    0098F D873      RCALL	_CopyBytes
(0714)         
(0715) 	//FileDir.FilePosit.Size = 0;
(0716) 	ClusID = GetNext32FAT();                                    //得到一个空的FAT项，下面用来写对应文件的FAT表
    00990 DD10      RCALL	_GetNext32FAT
    00991 A30A      STD	Y+34,R16
    00992 A31B      STD	Y+35,R17
    00993 A32C      STD	Y+36,R18
    00994 A33D      STD	Y+37,R19
(0717)         
(0718) 	FileDir.DIR_FstClusHI=(uint16)(ClusID>>16);                 //文件开始簇高字
    00995 A02A      LDD	R2,Y+34
    00996 A03B      LDD	R3,Y+35
    00997 A04C      LDD	R4,Y+36
    00998 A05D      LDD	R5,Y+37
    00999 0112      MOVW	R2,R4
    0099A 8E39      STD	Y+25,R3
    0099B 8E28      STD	Y+24,R2
(0719)         FileDir.DIR_FstClusLo=(uint16)ClusID&0x0000ffff;            //文件簇开始簇号低字
    0099C A02A      LDD	R2,Y+34
    0099D A03B      LDD	R3,Y+35
    0099E 8E3F      STD	Y+31,R3
    0099F 8E2E      STD	Y+30,R2
(0720) 
(0721) 	Write32FAT(ClusID, 0xffffffff);                             //写对应文件的FAT表1，即FAT1,0x0fffffff表示文件结束
    009A0 EF8F      LDI	R24,0xFF
    009A1 8388      ST	Y,R24
    009A2 8389      STD	Y+1,R24
    009A3 838A      STD	Y+2,R24
    009A4 838B      STD	Y+3,R24
    009A5 A10A      LDD	R16,Y+34
    009A6 A11B      LDD	R17,Y+35
    009A7 A12C      LDD	R18,Y+36
    009A8 A13D      LDD	R19,Y+37
    009A9 DAD6      RCALL	_Write32FAT
(0722)         Write32FAT2(ClusID, 0xffffffff);                            //写对应文件的FAT表2，即FAT2,0x0fffffff表示文件结束
    009AA EF8F      LDI	R24,0xFF
    009AB 8388      ST	Y,R24
    009AC 8389      STD	Y+1,R24
    009AD 838A      STD	Y+2,R24
    009AE 838B      STD	Y+3,R24
    009AF A10A      LDD	R16,Y+34
    009B0 A11B      LDD	R17,Y+35
    009B1 A12C      LDD	R18,Y+36
    009B2 A13D      LDD	R19,Y+37
    009B3 DB54      RCALL	_Write32FAT2
(0723) 	WriteDIR32(GetEmptyDIR(), &FileDir);                        //写根目录指定项，首先搜索可以使用项，再写入
    009B4 DBA4      RCALL	_GetEmptyDIR
    009B5 0158      MOVW	R10,R16
    009B6 019E      MOVW	R18,R28
    009B7 5F2C      SUBI	R18,0xFC
    009B8 4F3F      SBCI	R19,0xFF
    009B9 DDAE      RCALL	_WriteDIR32
    009BA 96AA      ADIW	R28,0x2A
    009BB 940C 1AD1 JMP	pop_xgset003C
_DelFile:
  Index                --> R10
  ClusID               --> R12
  FileDir              --> Y,+0
  Name                 --> R10
    009BD 940E 1AF7 CALL	push_xgset003C
    009BF 0158      MOVW	R10,R16
    009C0 97A0      SBIW	R28,0x20
(0724) }
(0725) 
(0726) /***********************************************************************
(0727) 函数功能：删除文件
(0728) 操作内容：1、FileName文件名必须是数字或者大写字母，扩展名也是如此   
(0729)           2、先搜索文件目录项及位置，采取比较匹配的方法
(0730)           3、文件名的第一个字节写0xE5，表示此目录下无文件
(0731)           4、清FAT表，写根目录
(0732) ***********************************************************************/
(0733) 
(0734) void DelFile(uint8 Name[11])
(0735) {
(0736)       DIR FileDir;
(0737)       uint16 ClusID,Index;
(0738)       Index = GetFileID(Name,&FileDir);                      //搜索得到文件所在根目录项位置
    009C1 019E      MOVW	R18,R28
    009C2 0185      MOVW	R16,R10
    009C3 DC0D      RCALL	_GetFileID
    009C4 2EA0      MOV	R10,R16
    009C5 24BB      CLR	R11
(0739)       FileDir.FileName.NAME[0] = 0xE5;                       //删除根目录下文件
    009C6 EE85      LDI	R24,0xE5
    009C7 8388      ST	Y,R24
(0740)       ClusID = FileDir.FilePosit.Start;                      //文件所在的簇号
    009C8 8CCA      LDD	R12,Y+26
    009C9 8CDB      LDD	R13,Y+27
(0741)       WriteFAT(ClusID,0x0000);                               //清空对应的FAT表FAT1
    009CA 2722      CLR	R18
    009CB 2733      CLR	R19
    009CC 0186      MOVW	R16,R12
    009CD DA77      RCALL	_WriteFAT
(0742)       WriteFAT2(ClusID,0x0000);                              //使FAT2和FAT1保持一致
    009CE 2722      CLR	R18
    009CF 2733      CLR	R19
    009D0 0186      MOVW	R16,R12
    009D1 DB04      RCALL	_WriteFAT2
(0743)       WriteDIR(Index,&FileDir);                              //写指定根目录项
    009D2 019E      MOVW	R18,R28
    009D3 0185      MOVW	R16,R10
    009D4 DD59      RCALL	_WriteDIR
    009D5 96A0      ADIW	R28,0x20
    009D6 940C 1AD1 JMP	pop_xgset003C
_DelFile32:
  Index                --> R10
  ClusID               --> Y,+34
  FileDir              --> Y,+4
  Name                 --> R10
    009D8 92AA      ST	-Y,R10
    009D9 92BA      ST	-Y,R11
    009DA 0158      MOVW	R10,R16
    009DB 97A6      SBIW	R28,0x26
(0744)       
(0745) }
(0746) 
(0747) void DelFile32(uint8 Name[11])
(0748) {
(0749)       DIR32 FileDir;
(0750)       uint32 ClusID;
(0751)       uint16 Index;
(0752)       Index = GetFileID32(Name,&FileDir);                      //搜索得到文件所在根目录项位置
    009DC 019E      MOVW	R18,R28
    009DD 5F2C      SUBI	R18,0xFC
    009DE 4F3F      SBCI	R19,0xFF
    009DF 0185      MOVW	R16,R10
    009E0 DC49      RCALL	_GetFileID32
    009E1 2EA0      MOV	R10,R16
    009E2 24BB      CLR	R11
(0753)       FileDir.FileName.NAME[0] = 0xE5;                       //删除根目录下文件
    009E3 EE85      LDI	R24,0xE5
    009E4 838C      STD	Y+4,R24
(0754)       ClusID = ((uint32)FileDir.DIR_FstClusHI)<<16+(uint32)FileDir.DIR_FstClusLo;  //文件所在的簇号
    009E5 E180      LDI	R24,0x10
    009E6 E090      LDI	R25,0
    009E7 E0A0      LDI	R26,0
    009E8 E0B0      LDI	R27,0
    009E9 8C2E      LDD	R2,Y+30
    009EA 8C3F      LDD	R3,Y+31
    009EB 2444      CLR	R4
    009EC 2455      CLR	R5
    009ED 0E28      ADD	R2,R24
    009EE 1E39      ADC	R3,R25
    009EF 1E4A      ADC	R4,R26
    009F0 1E5B      ADC	R5,R27
    009F1 8D08      LDD	R16,Y+24
    009F2 8D19      LDD	R17,Y+25
    009F3 2722      CLR	R18
    009F4 2733      CLR	R19
    009F5 922A      ST	-Y,R2
    009F6 940E 1B7C CALL	lsl32
    009F8 A30A      STD	Y+34,R16
    009F9 A31B      STD	Y+35,R17
    009FA A32C      STD	Y+36,R18
    009FB A33D      STD	Y+37,R19
(0755)       Write32FAT(ClusID,0x00000000);                                //清空对应的FAT表FAT1
    009FC E080      LDI	R24,0
    009FD 8388      ST	Y,R24
    009FE 8389      STD	Y+1,R24
    009FF 838A      STD	Y+2,R24
    00A00 838B      STD	Y+3,R24
    00A01 A10A      LDD	R16,Y+34
    00A02 A11B      LDD	R17,Y+35
    00A03 A12C      LDD	R18,Y+36
    00A04 A13D      LDD	R19,Y+37
    00A05 DA7A      RCALL	_Write32FAT
(0756)       Write32FAT2(ClusID,0x00000000);                               //使FAT2和FAT1保持一致
    00A06 E080      LDI	R24,0
    00A07 8388      ST	Y,R24
    00A08 8389      STD	Y+1,R24
    00A09 838A      STD	Y+2,R24
    00A0A 838B      STD	Y+3,R24
    00A0B A10A      LDD	R16,Y+34
    00A0C A11B      LDD	R17,Y+35
    00A0D A12C      LDD	R18,Y+36
    00A0E A13D      LDD	R19,Y+37
    00A0F DAF8      RCALL	_Write32FAT2
(0757)       WriteDIR32(Index,&FileDir);                                   //写指定根目录项
    00A10 019E      MOVW	R18,R28
    00A11 5F2C      SUBI	R18,0xFC
    00A12 4F3F      SBCI	R19,0xFF
    00A13 0185      MOVW	R16,R10
    00A14 DD53      RCALL	_WriteDIR32
    00A15 96A6      ADIW	R28,0x26
    00A16 90B9      LD	R11,Y+
    00A17 90A9      LD	R10,Y+
    00A18 9508      RET
_CopyFAT:
  RsvdSecCnt           --> R12
  FATSz                --> R10
  i                    --> R20
    00A19 940E 1B1E CALL	push_xgset303C
(0758)       
(0759) }
(0760) 
(0761) /***********************************************************************
(0762) 函数功能：复制文件分配表,使其和备份一致
(0763) 操作内容：1、将FAT表FAT1复制到FAT2区域 
(0764)           2、FATSz16表示FAT表占用的扇区数，BPB区获取的值
(0765)           3、备份FAT表
(0766) ***********************************************************************/
(0767) 
(0768) void CopyFAT(void)
(0769) {
(0770) 	uint16 FATSz, RsvdSecCnt, i;
(0771)         if(FAT32_EN==0) 
    00A1B 9020 026C LDS	R2,FAT32_EN
    00A1D 2022      TST	R2
    00A1E F429      BNE	0x0A24
(0772)           FATSz=BPB_FATSz16;
    00A1F 90A0 027B LDS	R10,BPB_FATSz16
    00A21 90B0 027C LDS	R11,BPB_FATSz16+1
    00A23 C004      RJMP	0x0A28
(0773)         else
(0774)           FATSz=BPB_FATSz32;
    00A24 90A0 0273 LDS	R10,BPB_FATSz32
    00A26 90B0 0274 LDS	R11,BPB_FATSz32+1
(0775) 	RsvdSecCnt = BPB_HiddSec + BPB_RsvdSecCnt;
    00A28 9020 0282 LDS	R2,BPB_RsvdSecCnt
    00A2A 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    00A2C 2444      CLR	R4
    00A2D 2455      CLR	R5
    00A2E 9080 0279 LDS	R8,BPB_HiddSec+2
    00A30 9090 027A LDS	R9,BPB_HiddSec+3
    00A32 9060 0277 LDS	R6,BPB_HiddSec
    00A34 9070 0278 LDS	R7,BPB_HiddSec+1
    00A36 0C62      ADD	R6,R2
    00A37 1C73      ADC	R7,R3
    00A38 1C84      ADC	R8,R4
    00A39 1C95      ADC	R9,R5
    00A3A 0163      MOVW	R12,R6
(0776) 	for(i = 0; i < FATSz; i++)
    00A3B 2744      CLR	R20
    00A3C 2755      CLR	R21
    00A3D C012      RJMP	0x0A50
(0777) 	{
(0778) 		ReadBlock(RsvdSecCnt + i);
    00A3E 0186      MOVW	R16,R12
    00A3F 0F04      ADD	R16,R20
    00A40 1F15      ADC	R17,R21
    00A41 2722      CLR	R18
    00A42 2733      CLR	R19
    00A43 940E 01DD CALL	_ReadBlock
(0779) 		WriteBlock(RsvdSecCnt + FATSz + i);
    00A45 0186      MOVW	R16,R12
    00A46 0D0A      ADD	R16,R10
    00A47 1D1B      ADC	R17,R11
    00A48 0F04      ADD	R16,R20
    00A49 1F15      ADC	R17,R21
    00A4A 2722      CLR	R18
    00A4B 2733      CLR	R19
    00A4C 940E 01F0 CALL	_WriteBlock
    00A4E 5F4F      SUBI	R20,0xFF
    00A4F 4F5F      SBCI	R21,0xFF
    00A50 154A      CP	R20,R10
    00A51 055B      CPC	R21,R11
    00A52 F358      BCS	0x0A3E
    00A53 940C 1B25 JMP	pop_xgset303C
_OperateFile:
  BytePerClus          --> Y,+60
  ClusNum              --> Y,+58
  SecPerClus           --> Y,+56
  ClusIDValue          --> R10
  length               --> Y,+40
  Index                --> Y,+54
  ClusNext             --> R12
  LBA                  --> Y,+36
  i                    --> Y,+32
  FileDir              --> Y,+0
  ClusID               --> R14
  data                 --> Y,+52
  m                    --> R10
  Data                 --> R12
  Length               --> Y,+80
  Start                --> Y,+76
  Name                 --> R10
  Write                --> Y,+72
    00A55 940E 19E4 CALL	push_arg4
    00A57 940E 1AF1 CALL	push_xgsetF0FC
    00A59 0159      MOVW	R10,R18
    00A5A 97EE      SBIW	R28,0x3E
    00A5B 01FE      MOVW	R30,R28
    00A5C 5AEC      SUBI	R30,0xAC
    00A5D 4FFF      SBCI	R31,0xFF
    00A5E 80C0      LD	R12,Z
    00A5F 80D1      LDD	R13,Z+1
(0780) 	}
(0781) }
(0782) 
(0783) /***********************************************************************
(0784) 函数功能：FAT16操作文件的数据，支持读写
(0785) 操作内容：1、Write为1是写操作，为0是读操作，Start为开始字节，Length为操作长度 
(0786)           2、Data为操作数据，先写入缓冲区
(0787)           3、需要同步更新FAT表，记录文件所占大小位置
(0788) ***********************************************************************/
(0789) 
(0790) void OperateFile(uint8 Write ,uint8 Name[11], uint32 Start, uint32 Length, void* Data)
(0791) {
(0792) 	uint8 *data = Data;
    00A60 AADD      STD	Y+53,R13
    00A61 AACC      STD	Y+52,R12
(0793) 	uint16 BytePerClus, SecPerClus, ClusNum, ClusNext,ClusID,ClusIDValue ,m,Index;
(0794) 	uint32 LBA, i,length;
(0795) 	DIR FileDir;
(0796) 	SecPerClus = BPB_SecPerClus;
    00A62 9020 0284 LDS	R2,BPB_SecPerClus
    00A64 2433      CLR	R3
    00A65 AE39      STD	Y+57,R3
    00A66 AE28      STD	Y+56,R2
(0797) 	BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
    00A67 9120 0285 LDS	R18,BPB_BytesPerSec
    00A69 9130 0286 LDS	R19,BPB_BytesPerSec+1
    00A6B 2D02      MOV	R16,R2
    00A6C 2711      CLR	R17
    00A6D 940E 1A8D CALL	empy16s
    00A6F AF1D      STD	Y+61,R17
    00A70 AF0C      STD	Y+60,R16
(0798) 	Index = GetFileID(Name, &FileDir);                            //文件根目录位置0～511
    00A71 019E      MOVW	R18,R28
    00A72 0185      MOVW	R16,R10
    00A73 DB5D      RCALL	_GetFileID
    00A74 2E20      MOV	R2,R16
    00A75 2433      CLR	R3
    00A76 AA3F      STD	Y+55,R3
    00A77 AA2E      STD	Y+54,R2
(0799)         length = Length;
    00A78 01DE      MOVW	R26,R28
    00A79 5BA0      SUBI	R26,0xB0
    00A7A 4FBF      SBCI	R27,0xFF
    00A7B 902D      LD	R2,X+
    00A7C 903D      LD	R3,X+
    00A7D 904D      LD	R4,X+
    00A7E 905C      LD	R5,X
    00A7F A628      STD	Y+40,R2
    00A80 A639      STD	Y+41,R3
    00A81 A64A      STD	Y+42,R4
    00A82 A65B      STD	Y+43,R5
(0800) 
(0801) 	//计算开始位置所在簇的簇号
(0802) 	ClusNum = Start / BytePerClus;
    00A83 AC2C      LDD	R2,Y+60
    00A84 AC3D      LDD	R3,Y+61
    00A85 2444      CLR	R4
    00A86 2455      CLR	R5
    00A87 01DE      MOVW	R26,R28
    00A88 5BA4      SUBI	R26,0xB4
    00A89 4FBF      SBCI	R27,0xFF
    00A8A 910D      LD	R16,X+
    00A8B 911D      LD	R17,X+
    00A8C 912D      LD	R18,X+
    00A8D 913C      LD	R19,X
    00A8E 925A      ST	-Y,R5
    00A8F 924A      ST	-Y,R4
    00A90 923A      ST	-Y,R3
    00A91 922A      ST	-Y,R2
    00A92 940E 1A23 CALL	div32u
    00A94 AF1B      STD	Y+59,R17
    00A95 AF0A      STD	Y+58,R16
(0803) 	ClusID = FileDir.FilePosit.Start;
    00A96 8CEA      LDD	R14,Y+26
    00A97 8CFB      LDD	R15,Y+27
(0804) 
(0805) 	for(i = 0; i < ClusNum; i++)
    00A98 E080      LDI	R24,0
    00A99 A388      STD	Y+32,R24
    00A9A A389      STD	Y+33,R24
    00A9B A38A      STD	Y+34,R24
    00A9C A38B      STD	Y+35,R24
    00A9D C02B      RJMP	0x0AC9
(0806) 	{
(0807)                 ClusIDValue = ReadFAT(ClusID);                        //读取对应文件的FAT表，0xFFFF表示文件结束
    00A9E 0187      MOVW	R16,R14
    00A9F D935      RCALL	_ReadFAT
    00AA0 0158      MOVW	R10,R16
(0808) 		WriteFAT(ClusID, 0xffff);
    00AA1 EF2F      LDI	R18,0xFF
    00AA2 EF3F      LDI	R19,0xFF
    00AA3 0187      MOVW	R16,R14
    00AA4 D9A0      RCALL	_WriteFAT
(0809)                 WriteFAT2(ClusID, 0xffff);
    00AA5 EF2F      LDI	R18,0xFF
    00AA6 EF3F      LDI	R19,0xFF
    00AA7 0187      MOVW	R16,R14
    00AA8 DA2D      RCALL	_WriteFAT2
(0810)                 if(ClusIDValue==0xffff)                               //如过ClusIDValue值不为0xFFFF，其他的表示下一个簇地址
    00AA9 01C5      MOVW	R24,R10
    00AAA 3F8F      CPI	R24,0xFF
    00AAB EFEF      LDI	R30,0xFF
    00AAC 079E      CPC	R25,R30
    00AAD F419      BNE	0x0AB1
(0811)                   ClusNext = GetNextFAT();
    00AAE DBD4      RCALL	_GetNextFAT
    00AAF 0168      MOVW	R12,R16
    00AB0 C001      RJMP	0x0AB2
(0812)                 else
(0813)                   ClusNext = ClusIDValue; 
    00AB1 0165      MOVW	R12,R10
(0814)                 
(0815) 		WriteFAT(ClusID, ClusNext);
    00AB2 0196      MOVW	R18,R12
    00AB3 0187      MOVW	R16,R14
    00AB4 D990      RCALL	_WriteFAT
(0816)                 WriteFAT2(ClusID, ClusNext);
    00AB5 0196      MOVW	R18,R12
    00AB6 0187      MOVW	R16,R14
    00AB7 DA1E      RCALL	_WriteFAT2
(0817) 		ClusID = ClusNext;
    00AB8 0176      MOVW	R14,R12
    00AB9 E041      LDI	R20,1
    00ABA E050      LDI	R21,0
    00ABB E060      LDI	R22,0
    00ABC E070      LDI	R23,0
    00ABD A028      LDD	R2,Y+32
    00ABE A039      LDD	R3,Y+33
    00ABF A04A      LDD	R4,Y+34
    00AC0 A05B      LDD	R5,Y+35
    00AC1 0E24      ADD	R2,R20
    00AC2 1E35      ADC	R3,R21
    00AC3 1E46      ADC	R4,R22
    00AC4 1E57      ADC	R5,R23
    00AC5 A228      STD	Y+32,R2
    00AC6 A239      STD	Y+33,R3
    00AC7 A24A      STD	Y+34,R4
    00AC8 A25B      STD	Y+35,R5
    00AC9 AC2A      LDD	R2,Y+58
    00ACA AC3B      LDD	R3,Y+59
    00ACB 2444      CLR	R4
    00ACC 2455      CLR	R5
    00ACD A068      LDD	R6,Y+32
    00ACE A079      LDD	R7,Y+33
    00ACF A08A      LDD	R8,Y+34
    00AD0 A09B      LDD	R9,Y+35
    00AD1 1462      CP	R6,R2
    00AD2 0473      CPC	R7,R3
    00AD3 0484      CPC	R8,R4
    00AD4 0495      CPC	R9,R5
    00AD5 F408      BCC	0x0AD7
    00AD6 CFC7      RJMP	0x0A9E
(0818) 	}
(0819)         WriteFAT(ClusID, 0xffff);
    00AD7 EF2F      LDI	R18,0xFF
    00AD8 EF3F      LDI	R19,0xFF
    00AD9 0187      MOVW	R16,R14
    00ADA D96A      RCALL	_WriteFAT
(0820)         WriteFAT2(ClusID, 0xffff);
    00ADB EF2F      LDI	R18,0xFF
    00ADC EF3F      LDI	R19,0xFF
    00ADD 0187      MOVW	R16,R14
    00ADE D9F7      RCALL	_WriteFAT2
(0821) 
(0822) 	//计算开始位置所在扇区簇内偏移
(0823) 	i = (Start % BytePerClus) / 512;
    00ADF AC2C      LDD	R2,Y+60
    00AE0 AC3D      LDD	R3,Y+61
    00AE1 2444      CLR	R4
    00AE2 2455      CLR	R5
    00AE3 01DE      MOVW	R26,R28
    00AE4 5BA4      SUBI	R26,0xB4
    00AE5 4FBF      SBCI	R27,0xFF
    00AE6 910D      LD	R16,X+
    00AE7 911D      LD	R17,X+
    00AE8 912D      LD	R18,X+
    00AE9 913C      LD	R19,X
    00AEA 925A      ST	-Y,R5
    00AEB 924A      ST	-Y,R4
    00AEC 923A      ST	-Y,R3
    00AED 922A      ST	-Y,R2
    00AEE 940E 1A25 CALL	mod32u
    00AF0 E089      LDI	R24,0x9
    00AF1 E090      LDI	R25,0
    00AF2 938A      ST	-Y,R24
    00AF3 940E 1B8F CALL	lsr32
    00AF5 A308      STD	Y+32,R16
    00AF6 A319      STD	Y+33,R17
    00AF7 A32A      STD	Y+34,R18
    00AF8 A33B      STD	Y+35,R19
(0824) 
(0825) 	//计算开始位置扇区内偏移
(0826) 	m = (Start % BytePerClus) % 512;
    00AF9 AC2C      LDD	R2,Y+60
    00AFA AC3D      LDD	R3,Y+61
    00AFB 2444      CLR	R4
    00AFC 2455      CLR	R5
    00AFD 01FE      MOVW	R30,R28
    00AFE 5BE4      SUBI	R30,0xB4
    00AFF 4FFF      SBCI	R31,0xFF
    00B00 8100      LD	R16,Z
    00B01 8111      LDD	R17,Z+1
    00B02 8122      LDD	R18,Z+2
    00B03 8133      LDD	R19,Z+3
    00B04 925A      ST	-Y,R5
    00B05 924A      ST	-Y,R4
    00B06 923A      ST	-Y,R3
    00B07 922A      ST	-Y,R2
    00B08 940E 1A25 CALL	mod32u
    00B0A EF4F      LDI	R20,0xFF
    00B0B E051      LDI	R21,1
    00B0C E060      LDI	R22,0
    00B0D E070      LDI	R23,0
    00B0E 0118      MOVW	R2,R16
    00B0F 0129      MOVW	R4,R18
    00B10 2224      AND	R2,R20
    00B11 2235      AND	R3,R21
    00B12 2246      AND	R4,R22
    00B13 2257      AND	R5,R23
    00B14 0151      MOVW	R10,R2
(0827) 
(0828) 	LBA = ClusConvLBA(ClusID) + i;
    00B15 0187      MOVW	R16,R14
    00B16 D894      RCALL	_ClusConvLBA
    00B17 A028      LDD	R2,Y+32
    00B18 A039      LDD	R3,Y+33
    00B19 A04A      LDD	R4,Y+34
    00B1A A05B      LDD	R5,Y+35
    00B1B 0138      MOVW	R6,R16
    00B1C 0149      MOVW	R8,R18
    00B1D 0C62      ADD	R6,R2
    00B1E 1C73      ADC	R7,R3
    00B1F 1C84      ADC	R8,R4
    00B20 1C95      ADC	R9,R5
    00B21 A26C      STD	Y+36,R6
    00B22 A27D      STD	Y+37,R7
    00B23 A28E      STD	Y+38,R8
    00B24 A29F      STD	Y+39,R9
(0829) 
(0830) 
(0831) 		for(i = 0; i < SecPerClus; i++)
    00B25 E080      LDI	R24,0
    00B26 A388      STD	Y+32,R24
    00B27 A389      STD	Y+33,R24
    00B28 A38A      STD	Y+34,R24
    00B29 A38B      STD	Y+35,R24
    00B2A C0D5      RJMP	0x0C00
(0832) 		{
(0833) 			if(Write)
    00B2B 01DE      MOVW	R26,R28
    00B2C 5BA8      SUBI	R26,0xB8
    00B2D 4FBF      SBCI	R27,0xFF
    00B2E 900C      LD	R0,X
    00B2F 2000      TST	R0
    00B30 F039      BEQ	0x0B38
(0834) 				ReadBlock(LBA);
    00B31 A10C      LDD	R16,Y+36
    00B32 A11D      LDD	R17,Y+37
    00B33 A12E      LDD	R18,Y+38
    00B34 A13F      LDD	R19,Y+39
    00B35 940E 01DD CALL	_ReadBlock
    00B37 C01E      RJMP	0x0B56
(0835) 			else
(0836) 				ReadBlock(LBA++);
    00B38 A02C      LDD	R2,Y+36
    00B39 A03D      LDD	R3,Y+37
    00B3A A04E      LDD	R4,Y+38
    00B3B A05F      LDD	R5,Y+39
    00B3C A62C      STD	Y+44,R2
    00B3D A63D      STD	Y+45,R3
    00B3E A64E      STD	Y+46,R4
    00B3F A65F      STD	Y+47,R5
    00B40 E041      LDI	R20,1
    00B41 E050      LDI	R21,0
    00B42 E060      LDI	R22,0
    00B43 E070      LDI	R23,0
    00B44 A42C      LDD	R2,Y+44
    00B45 A43D      LDD	R3,Y+45
    00B46 A44E      LDD	R4,Y+46
    00B47 A45F      LDD	R5,Y+47
    00B48 0E24      ADD	R2,R20
    00B49 1E35      ADC	R3,R21
    00B4A 1E46      ADC	R4,R22
    00B4B 1E57      ADC	R5,R23
    00B4C A22C      STD	Y+36,R2
    00B4D A23D      STD	Y+37,R3
    00B4E A24E      STD	Y+38,R4
    00B4F A25F      STD	Y+39,R5
    00B50 A50C      LDD	R16,Y+44
    00B51 A51D      LDD	R17,Y+45
    00B52 A52E      LDD	R18,Y+46
    00B53 A53F      LDD	R19,Y+47
    00B54 940E 01DD CALL	_ReadBlock
(0837) 
(0838) 			for(m = 0; m < 512; m++)
    00B56 24AA      CLR	R10
    00B57 24BB      CLR	R11
    00B58 C06D      RJMP	0x0BC6
(0839) 			{
(0840) 
(0841) 				if(Write)
    00B59 01FE      MOVW	R30,R28
    00B5A 5BE8      SUBI	R30,0xB8
    00B5B 4FFF      SBCI	R31,0xFF
    00B5C 8000      LD	R0,Z
    00B5D 2000      TST	R0
    00B5E F061      BEQ	0x0B6B
(0842) 					BUFFER[m] = *data++;
    00B5F E887      LDI	R24,0x87
    00B60 E092      LDI	R25,2
    00B61 01F5      MOVW	R30,R10
    00B62 0FE8      ADD	R30,R24
    00B63 1FF9      ADC	R31,R25
    00B64 A9AC      LDD	R26,Y+52
    00B65 A9BD      LDD	R27,Y+53
    00B66 902D      LD	R2,X+
    00B67 ABBD      STD	Y+53,R27
    00B68 ABAC      STD	Y+52,R26
    00B69 8220      ST	Z,R2
    00B6A C00B      RJMP	0x0B76
(0843) 				else
(0844) 					*data++ = BUFFER[m];
    00B6B E887      LDI	R24,0x87
    00B6C E092      LDI	R25,2
    00B6D 01F5      MOVW	R30,R10
    00B6E 0FE8      ADD	R30,R24
    00B6F 1FF9      ADC	R31,R25
    00B70 8020      LD	R2,Z
    00B71 A9EC      LDD	R30,Y+52
    00B72 A9FD      LDD	R31,Y+53
    00B73 9221      ST	Z+,R2
    00B74 ABFD      STD	Y+53,R31
    00B75 ABEC      STD	Y+52,R30
(0845) 
(0846) 				//如果读取完成就退出
(0847) 				if(--Length == 0)
    00B76 E041      LDI	R20,1
    00B77 E050      LDI	R21,0
    00B78 E060      LDI	R22,0
    00B79 E070      LDI	R23,0
    00B7A 01DE      MOVW	R26,R28
    00B7B 5BA0      SUBI	R26,0xB0
    00B7C 4FBF      SBCI	R27,0xFF
    00B7D 902D      LD	R2,X+
    00B7E 903D      LD	R3,X+
    00B7F 904D      LD	R4,X+
    00B80 905C      LD	R5,X
    00B81 1A24      SUB	R2,R20
    00B82 0A35      SBC	R3,R21
    00B83 0A46      SBC	R4,R22
    00B84 0A57      SBC	R5,R23
    00B85 AA28      STD	Y+48,R2
    00B86 AA39      STD	Y+49,R3
    00B87 AA4A      STD	Y+50,R4
    00B88 AA5B      STD	Y+51,R5
    00B89 A828      LDD	R2,Y+48
    00B8A A839      LDD	R3,Y+49
    00B8B A84A      LDD	R4,Y+50
    00B8C A85B      LDD	R5,Y+51
    00B8D 01DE      MOVW	R26,R28
    00B8E 5BA0      SUBI	R26,0xB0
    00B8F 4FBF      SBCI	R27,0xFF
    00B90 922D      ST	X+,R2
    00B91 923D      ST	X+,R3
    00B92 924D      ST	X+,R4
    00B93 925C      ST	X,R5
    00B94 A828      LDD	R2,Y+48
    00B95 A839      LDD	R3,Y+49
    00B96 A84A      LDD	R4,Y+50
    00B97 A85B      LDD	R5,Y+51
    00B98 9488      BCLR	0
    00B99 2022      TST	R2
    00B9A 0432      CPC	R3,R2
    00B9B 0442      CPC	R4,R2
    00B9C 0452      CPC	R5,R2
    00B9D F529      BNE	0x0BC3
(0848) 				{
(0849) 					if(Write)
    00B9E 01DE      MOVW	R26,R28
    00B9F 5BA8      SUBI	R26,0xB8
    00BA0 4FBF      SBCI	R27,0xFF
    00BA1 900C      LD	R0,X
    00BA2 2000      TST	R0
    00BA3 F409      BNE	0x0BA5
    00BA4 C069      RJMP	0x0C0E
(0850)                                         {
(0851)                                                 //回写扇区
(0852) 						WriteBlock(LBA); 
    00BA5 A10C      LDD	R16,Y+36
    00BA6 A11D      LDD	R17,Y+37
    00BA7 A12E      LDD	R18,Y+38
    00BA8 A13F      LDD	R19,Y+39
    00BA9 940E 01F0 CALL	_WriteBlock
(0853)                                                //回写目录
(0854)                                                 FileDir.FilePosit.Size = Start+length;
    00BAB A428      LDD	R2,Y+40
    00BAC A439      LDD	R3,Y+41
    00BAD A44A      LDD	R4,Y+42
    00BAE A45B      LDD	R5,Y+43
    00BAF 01DE      MOVW	R26,R28
    00BB0 5BA4      SUBI	R26,0xB4
    00BB1 4FBF      SBCI	R27,0xFF
    00BB2 906D      LD	R6,X+
    00BB3 907D      LD	R7,X+
    00BB4 908D      LD	R8,X+
    00BB5 909C      LD	R9,X
    00BB6 0C62      ADD	R6,R2
    00BB7 1C73      ADC	R7,R3
    00BB8 1C84      ADC	R8,R4
    00BB9 1C95      ADC	R9,R5
    00BBA 8E6C      STD	Y+28,R6
    00BBB 8E7D      STD	Y+29,R7
    00BBC 8E8E      STD	Y+30,R8
    00BBD 8E9F      STD	Y+31,R9
(0855)                                                 WriteDIR(Index,&FileDir);
    00BBE 019E      MOVW	R18,R28
    00BBF A90E      LDD	R16,Y+54
    00BC0 A91F      LDD	R17,Y+55
    00BC1 DB6C      RCALL	_WriteDIR
(0856)                                         }
(0857) 					return;
    00BC2 C04B      RJMP	0x0C0E
    00BC3 01C5      MOVW	R24,R10
    00BC4 9601      ADIW	R24,1
    00BC5 015C      MOVW	R10,R24
    00BC6 01C5      MOVW	R24,R10
    00BC7 3080      CPI	R24,0
    00BC8 E0A2      LDI	R26,2
    00BC9 079A      CPC	R25,R26
    00BCA F408      BCC	0x0BCC
    00BCB CF8D      RJMP	0x0B59
(0858) 				}
(0859) 			}
(0860) 			if(Write)
    00BCC 01DE      MOVW	R26,R28
    00BCD 5BA8      SUBI	R26,0xB8
    00BCE 4FBF      SBCI	R27,0xFF
    00BCF 900C      LD	R0,X
    00BD0 2000      TST	R0
    00BD1 F0F1      BEQ	0x0BF0
(0861) 				WriteBlock(LBA++); //回写扇区,指针下移
    00BD2 A02C      LDD	R2,Y+36
    00BD3 A03D      LDD	R3,Y+37
    00BD4 A04E      LDD	R4,Y+38
    00BD5 A05F      LDD	R5,Y+39
    00BD6 AA28      STD	Y+48,R2
    00BD7 AA39      STD	Y+49,R3
    00BD8 AA4A      STD	Y+50,R4
    00BD9 AA5B      STD	Y+51,R5
    00BDA E041      LDI	R20,1
    00BDB E050      LDI	R21,0
    00BDC E060      LDI	R22,0
    00BDD E070      LDI	R23,0
    00BDE A828      LDD	R2,Y+48
    00BDF A839      LDD	R3,Y+49
    00BE0 A84A      LDD	R4,Y+50
    00BE1 A85B      LDD	R5,Y+51
    00BE2 0E24      ADD	R2,R20
    00BE3 1E35      ADC	R3,R21
    00BE4 1E46      ADC	R4,R22
    00BE5 1E57      ADC	R5,R23
    00BE6 A22C      STD	Y+36,R2
    00BE7 A23D      STD	Y+37,R3
    00BE8 A24E      STD	Y+38,R4
    00BE9 A25F      STD	Y+39,R5
    00BEA A908      LDD	R16,Y+48
    00BEB A919      LDD	R17,Y+49
    00BEC A92A      LDD	R18,Y+50
    00BED A93B      LDD	R19,Y+51
    00BEE 940E 01F0 CALL	_WriteBlock
    00BF0 E041      LDI	R20,1
    00BF1 E050      LDI	R21,0
    00BF2 E060      LDI	R22,0
    00BF3 E070      LDI	R23,0
    00BF4 A028      LDD	R2,Y+32
    00BF5 A039      LDD	R3,Y+33
    00BF6 A04A      LDD	R4,Y+34
    00BF7 A05B      LDD	R5,Y+35
    00BF8 0E24      ADD	R2,R20
    00BF9 1E35      ADC	R3,R21
    00BFA 1E46      ADC	R4,R22
    00BFB 1E57      ADC	R5,R23
    00BFC A228      STD	Y+32,R2
    00BFD A239      STD	Y+33,R3
    00BFE A24A      STD	Y+34,R4
    00BFF A25B      STD	Y+35,R5
    00C00 AC28      LDD	R2,Y+56
    00C01 AC39      LDD	R3,Y+57
    00C02 2444      CLR	R4
    00C03 2455      CLR	R5
    00C04 A068      LDD	R6,Y+32
    00C05 A079      LDD	R7,Y+33
    00C06 A08A      LDD	R8,Y+34
    00C07 A09B      LDD	R9,Y+35
    00C08 1462      CP	R6,R2
    00C09 0473      CPC	R7,R3
    00C0A 0484      CPC	R8,R4
    00C0B 0495      CPC	R9,R5
    00C0C F408      BCC	0x0C0E
    00C0D CF1D      RJMP	0x0B2B
    00C0E 96EE      ADIW	R28,0x3E
    00C0F 940E 1AE6 CALL	pop_xgsetF0FC
    00C11 9624      ADIW	R28,4
    00C12 9508      RET
_Operate32File:
  BytePerClus          --> R10
  ClusNum              --> R14
  SecPerClus           --> Y,+68
  ClusIDValue          --> Y,+54
  length               --> Y,+50
  Index                --> R12
  ClusNext             --> Y,+46
  LBA                  --> Y,+42
  i                    --> Y,+38
  FileDir              --> Y,+8
  ClusID               --> Y,+4
  data                 --> Y,+66
  m                    --> R10
  Data                 --> R10
  Length               --> Y,+88
  Start                --> Y,+84
  Name                 --> R12
  Write                --> Y,+80
    00C13 940E 19E4 CALL	push_arg4
    00C15 940E 1AF1 CALL	push_xgsetF0FC
    00C17 0169      MOVW	R12,R18
    00C18 97EF      SBIW	R28,0x3F
    00C19 9727      SBIW	R28,7
    00C1A 01FE      MOVW	R30,R28
    00C1B 5AE4      SUBI	R30,0xA4
    00C1C 4FFF      SBCI	R31,0xFF
    00C1D 80A0      LD	R10,Z
    00C1E 80B1      LDD	R11,Z+1
(0862) 		}
(0863) 	}
(0864) 
(0865) /***********************************************************************
(0866) 函数功能：FAT32操作文件的数据，支持读写
(0867) 操作内容：1、Write为1是写操作，为0是读操作，Start为开始字节，Length为操作长度 
(0868)           2、Data为操作数据，先写入缓冲区
(0869)           3、需要同步更新FAT表，记录文件所占大小位置
(0870) ***********************************************************************/
(0871) 
(0872) void Operate32File(uint8 Write ,uint8 Name[11], uint32 Start, uint32 Length, void* Data)
(0873) {
(0874) 	uint8 *data = Data;
    00C1F 01FE      MOVW	R30,R28
    00C20 5BEE      SUBI	R30,0xBE
    00C21 4FFF      SBCI	R31,0xFF
    00C22 82B1      STD	Z+1,R11
    00C23 82A0      ST	Z,R10
(0875) 	uint16 BytePerClus, SecPerClus, ClusNum ,m,Index;
(0876)         uint32 ClusID,ClusIDValue, ClusNext;
(0877) 	uint32 LBA, i,length;
(0878) 	DIR32 FileDir;
(0879) 	SecPerClus = BPB_SecPerClus;
    00C24 9020 0284 LDS	R2,BPB_SecPerClus
    00C26 2433      CLR	R3
    00C27 01FE      MOVW	R30,R28
    00C28 5BEC      SUBI	R30,0xBC
    00C29 4FFF      SBCI	R31,0xFF
    00C2A 8231      STD	Z+1,R3
    00C2B 8220      ST	Z,R2
(0880) 	BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
    00C2C 9120 0285 LDS	R18,BPB_BytesPerSec
    00C2E 9130 0286 LDS	R19,BPB_BytesPerSec+1
    00C30 2D02      MOV	R16,R2
    00C31 2711      CLR	R17
    00C32 940E 1A8D CALL	empy16s
    00C34 0158      MOVW	R10,R16
(0881) 	Index = GetFileID32(Name, &FileDir);                            //文件根目录位置0～511
    00C35 019E      MOVW	R18,R28
    00C36 5F28      SUBI	R18,0xF8
    00C37 4F3F      SBCI	R19,0xFF
    00C38 0186      MOVW	R16,R12
    00C39 D9F0      RCALL	_GetFileID32
    00C3A 2EC0      MOV	R12,R16
    00C3B 24DD      CLR	R13
(0882)         length = Length;
    00C3C 01DE      MOVW	R26,R28
    00C3D 5AA8      SUBI	R26,0xA8
    00C3E 4FBF      SBCI	R27,0xFF
    00C3F 902D      LD	R2,X+
    00C40 903D      LD	R3,X+
    00C41 904D      LD	R4,X+
    00C42 905C      LD	R5,X
    00C43 AA2A      STD	Y+50,R2
    00C44 AA3B      STD	Y+51,R3
    00C45 AA4C      STD	Y+52,R4
    00C46 AA5D      STD	Y+53,R5
(0883) 
(0884) 	//计算开始位置所在簇的簇号
(0885) 	ClusNum = Start / BytePerClus;
    00C47 0115      MOVW	R2,R10
    00C48 2444      CLR	R4
    00C49 2455      CLR	R5
    00C4A 01DE      MOVW	R26,R28
    00C4B 5AAC      SUBI	R26,0xAC
    00C4C 4FBF      SBCI	R27,0xFF
    00C4D 910D      LD	R16,X+
    00C4E 911D      LD	R17,X+
    00C4F 912D      LD	R18,X+
    00C50 913C      LD	R19,X
    00C51 925A      ST	-Y,R5
    00C52 924A      ST	-Y,R4
    00C53 923A      ST	-Y,R3
    00C54 922A      ST	-Y,R2
    00C55 940E 1A23 CALL	div32u
    00C57 0178      MOVW	R14,R16
(0886)         ClusID=((uint32)FileDir.DIR_FstClusHI<<16)+(uint32)FileDir.DIR_FstClusLo;
    00C58 A02A      LDD	R2,Y+34
    00C59 A03B      LDD	R3,Y+35
    00C5A 2444      CLR	R4
    00C5B 2455      CLR	R5
    00C5C 8C6C      LDD	R6,Y+28
    00C5D 8C7D      LDD	R7,Y+29
    00C5E 2488      CLR	R8
    00C5F 2499      CLR	R9
    00C60 0143      MOVW	R8,R6
    00C61 2466      CLR	R6
    00C62 2477      CLR	R7
    00C63 0C62      ADD	R6,R2
    00C64 1C73      ADC	R7,R3
    00C65 1C84      ADC	R8,R4
    00C66 1C95      ADC	R9,R5
    00C67 826C      STD	Y+4,R6
    00C68 827D      STD	Y+5,R7
    00C69 828E      STD	Y+6,R8
    00C6A 829F      STD	Y+7,R9
(0887)   	for(i = 0; i < ClusNum; i++)
    00C6B E080      LDI	R24,0
    00C6C A38E      STD	Y+38,R24
    00C6D A38F      STD	Y+39,R24
    00C6E A788      STD	Y+40,R24
    00C6F A789      STD	Y+41,R24
    00C70 C06F      RJMP	0x0CE0
(0888) 	{
(0889)                 ClusIDValue = Read32FAT(ClusID);                        //读取对应文件的FAT表，0xFFFF表示文件结束
    00C71 810C      LDD	R16,Y+4
    00C72 811D      LDD	R17,Y+5
    00C73 812E      LDD	R18,Y+6
    00C74 813F      LDD	R19,Y+7
    00C75 940E 0400 CALL	_Read32FAT
    00C77 AB0E      STD	Y+54,R16
    00C78 AB1F      STD	Y+55,R17
    00C79 AF28      STD	Y+56,R18
    00C7A AF39      STD	Y+57,R19
(0890) 		Write32FAT(ClusID, 0x0fffffff);
    00C7B EF8F      LDI	R24,0xFF
    00C7C 8388      ST	Y,R24
    00C7D 8389      STD	Y+1,R24
    00C7E 838A      STD	Y+2,R24
    00C7F E08F      LDI	R24,0xF
    00C80 838B      STD	Y+3,R24
    00C81 810C      LDD	R16,Y+4
    00C82 811D      LDD	R17,Y+5
    00C83 812E      LDD	R18,Y+6
    00C84 813F      LDD	R19,Y+7
    00C85 940E 0480 CALL	_Write32FAT
(0891)                 Write32FAT2(ClusID, 0x0fffffff);
    00C87 EF8F      LDI	R24,0xFF
    00C88 8388      ST	Y,R24
    00C89 8389      STD	Y+1,R24
    00C8A 838A      STD	Y+2,R24
    00C8B E08F      LDI	R24,0xF
    00C8C 838B      STD	Y+3,R24
    00C8D 810C      LDD	R16,Y+4
    00C8E 811D      LDD	R17,Y+5
    00C8F 812E      LDD	R18,Y+6
    00C90 813F      LDD	R19,Y+7
    00C91 D876      RCALL	_Write32FAT2
(0892)                 if(ClusIDValue==0x0fffffff)                               //如过ClusIDValue值不为0xFFFF，其他的表示下一个簇地址
    00C92 EF4F      LDI	R20,0xFF
    00C93 EF5F      LDI	R21,0xFF
    00C94 EF6F      LDI	R22,0xFF
    00C95 E07F      LDI	R23,0xF
    00C96 A82E      LDD	R2,Y+54
    00C97 A83F      LDD	R3,Y+55
    00C98 AC48      LDD	R4,Y+56
    00C99 AC59      LDD	R5,Y+57
    00C9A 1624      CP	R2,R20
    00C9B 0635      CPC	R3,R21
    00C9C 0646      CPC	R4,R22
    00C9D 0657      CPC	R5,R23
    00C9E F431      BNE	0x0CA5
(0893)                   ClusNext = GetNext32FAT();
    00C9F DA01      RCALL	_GetNext32FAT
    00CA0 A70E      STD	Y+46,R16
    00CA1 A71F      STD	Y+47,R17
    00CA2 AB28      STD	Y+48,R18
    00CA3 AB39      STD	Y+49,R19
    00CA4 C008      RJMP	0x0CAD
(0894)                 else
(0895)                   ClusNext = ClusIDValue; 
    00CA5 A82E      LDD	R2,Y+54
    00CA6 A83F      LDD	R3,Y+55
    00CA7 AC48      LDD	R4,Y+56
    00CA8 AC59      LDD	R5,Y+57
    00CA9 A62E      STD	Y+46,R2
    00CAA A63F      STD	Y+47,R3
    00CAB AA48      STD	Y+48,R4
    00CAC AA59      STD	Y+49,R5
(0896)                 
(0897) 		Write32FAT(ClusID, ClusNext);
    00CAD A42E      LDD	R2,Y+46
    00CAE A43F      LDD	R3,Y+47
    00CAF A848      LDD	R4,Y+48
    00CB0 A859      LDD	R5,Y+49
    00CB1 8228      ST	Y,R2
    00CB2 8239      STD	Y+1,R3
    00CB3 824A      STD	Y+2,R4
    00CB4 825B      STD	Y+3,R5
    00CB5 810C      LDD	R16,Y+4
    00CB6 811D      LDD	R17,Y+5
    00CB7 812E      LDD	R18,Y+6
    00CB8 813F      LDD	R19,Y+7
    00CB9 940E 0480 CALL	_Write32FAT
(0898)                 Write32FAT2(ClusID, ClusNext);
    00CBB A42E      LDD	R2,Y+46
    00CBC A43F      LDD	R3,Y+47
    00CBD A848      LDD	R4,Y+48
    00CBE A859      LDD	R5,Y+49
    00CBF 8228      ST	Y,R2
    00CC0 8239      STD	Y+1,R3
    00CC1 824A      STD	Y+2,R4
    00CC2 825B      STD	Y+3,R5
    00CC3 810C      LDD	R16,Y+4
    00CC4 811D      LDD	R17,Y+5
    00CC5 812E      LDD	R18,Y+6
    00CC6 813F      LDD	R19,Y+7
    00CC7 D840      RCALL	_Write32FAT2
(0899) 		ClusID = ClusNext;
    00CC8 A42E      LDD	R2,Y+46
    00CC9 A43F      LDD	R3,Y+47
    00CCA A848      LDD	R4,Y+48
    00CCB A859      LDD	R5,Y+49
    00CCC 822C      STD	Y+4,R2
    00CCD 823D      STD	Y+5,R3
    00CCE 824E      STD	Y+6,R4
    00CCF 825F      STD	Y+7,R5
    00CD0 E041      LDI	R20,1
    00CD1 E050      LDI	R21,0
    00CD2 E060      LDI	R22,0
    00CD3 E070      LDI	R23,0
    00CD4 A02E      LDD	R2,Y+38
    00CD5 A03F      LDD	R3,Y+39
    00CD6 A448      LDD	R4,Y+40
    00CD7 A459      LDD	R5,Y+41
    00CD8 0E24      ADD	R2,R20
    00CD9 1E35      ADC	R3,R21
    00CDA 1E46      ADC	R4,R22
    00CDB 1E57      ADC	R5,R23
    00CDC A22E      STD	Y+38,R2
    00CDD A23F      STD	Y+39,R3
    00CDE A648      STD	Y+40,R4
    00CDF A659      STD	Y+41,R5
    00CE0 0117      MOVW	R2,R14
    00CE1 2444      CLR	R4
    00CE2 2455      CLR	R5
    00CE3 A06E      LDD	R6,Y+38
    00CE4 A07F      LDD	R7,Y+39
    00CE5 A488      LDD	R8,Y+40
    00CE6 A499      LDD	R9,Y+41
    00CE7 1462      CP	R6,R2
    00CE8 0473      CPC	R7,R3
    00CE9 0484      CPC	R8,R4
    00CEA 0495      CPC	R9,R5
    00CEB F408      BCC	0x0CED
    00CEC CF84      RJMP	0x0C71
(0900) 	}
(0901)         Write32FAT(ClusID, 0x0fffffff);
    00CED EF8F      LDI	R24,0xFF
    00CEE 8388      ST	Y,R24
    00CEF 8389      STD	Y+1,R24
    00CF0 838A      STD	Y+2,R24
    00CF1 E08F      LDI	R24,0xF
    00CF2 838B      STD	Y+3,R24
    00CF3 810C      LDD	R16,Y+4
    00CF4 811D      LDD	R17,Y+5
    00CF5 812E      LDD	R18,Y+6
    00CF6 813F      LDD	R19,Y+7
    00CF7 940E 0480 CALL	_Write32FAT
(0902)         Write32FAT2(ClusID, 0x0fffffff);
    00CF9 EF8F      LDI	R24,0xFF
    00CFA 8388      ST	Y,R24
    00CFB 8389      STD	Y+1,R24
    00CFC 838A      STD	Y+2,R24
    00CFD E08F      LDI	R24,0xF
    00CFE 838B      STD	Y+3,R24
    00CFF 810C      LDD	R16,Y+4
    00D00 811D      LDD	R17,Y+5
    00D01 812E      LDD	R18,Y+6
    00D02 813F      LDD	R19,Y+7
    00D03 D804      RCALL	_Write32FAT2
(0903) 
(0904) 	//计算开始位置所在扇区簇内偏移
(0905) 	i = (Start % BytePerClus) / 512;
    00D04 0115      MOVW	R2,R10
    00D05 2444      CLR	R4
    00D06 2455      CLR	R5
    00D07 01DE      MOVW	R26,R28
    00D08 5AAC      SUBI	R26,0xAC
    00D09 4FBF      SBCI	R27,0xFF
    00D0A 910D      LD	R16,X+
    00D0B 911D      LD	R17,X+
    00D0C 912D      LD	R18,X+
    00D0D 913C      LD	R19,X
    00D0E 925A      ST	-Y,R5
    00D0F 924A      ST	-Y,R4
    00D10 923A      ST	-Y,R3
    00D11 922A      ST	-Y,R2
    00D12 940E 1A25 CALL	mod32u
    00D14 E089      LDI	R24,0x9
    00D15 E090      LDI	R25,0
    00D16 938A      ST	-Y,R24
    00D17 940E 1B8F CALL	lsr32
    00D19 A30E      STD	Y+38,R16
    00D1A A31F      STD	Y+39,R17
    00D1B A728      STD	Y+40,R18
    00D1C A739      STD	Y+41,R19
(0906) 
(0907) 	//计算开始位置扇区内偏移
(0908) 	m = (Start % BytePerClus) % 512;
    00D1D 0115      MOVW	R2,R10
    00D1E 2444      CLR	R4
    00D1F 2455      CLR	R5
    00D20 01FE      MOVW	R30,R28
    00D21 5AEC      SUBI	R30,0xAC
    00D22 4FFF      SBCI	R31,0xFF
    00D23 8100      LD	R16,Z
    00D24 8111      LDD	R17,Z+1
    00D25 8122      LDD	R18,Z+2
    00D26 8133      LDD	R19,Z+3
    00D27 925A      ST	-Y,R5
    00D28 924A      ST	-Y,R4
    00D29 923A      ST	-Y,R3
    00D2A 922A      ST	-Y,R2
    00D2B 940E 1A25 CALL	mod32u
    00D2D EF4F      LDI	R20,0xFF
    00D2E E051      LDI	R21,1
    00D2F E060      LDI	R22,0
    00D30 E070      LDI	R23,0
    00D31 0118      MOVW	R2,R16
    00D32 0129      MOVW	R4,R18
    00D33 2224      AND	R2,R20
    00D34 2235      AND	R3,R21
    00D35 2246      AND	R4,R22
    00D36 2257      AND	R5,R23
    00D37 0151      MOVW	R10,R2
(0909) 
(0910) 	LBA = ClusConvLBA(ClusID) + i;
    00D38 810C      LDD	R16,Y+4
    00D39 811D      LDD	R17,Y+5
    00D3A 940E 03AB CALL	_ClusConvLBA
    00D3C A02E      LDD	R2,Y+38
    00D3D A03F      LDD	R3,Y+39
    00D3E A448      LDD	R4,Y+40
    00D3F A459      LDD	R5,Y+41
    00D40 0138      MOVW	R6,R16
    00D41 0149      MOVW	R8,R18
    00D42 0C62      ADD	R6,R2
    00D43 1C73      ADC	R7,R3
    00D44 1C84      ADC	R8,R4
    00D45 1C95      ADC	R9,R5
    00D46 A66A      STD	Y+42,R6
    00D47 A67B      STD	Y+43,R7
    00D48 A68C      STD	Y+44,R8
    00D49 A69D      STD	Y+45,R9
(0911) 
(0912) 
(0913) 		for(i = 0; i < SecPerClus; i++)
    00D4A E080      LDI	R24,0
    00D4B A38E      STD	Y+38,R24
    00D4C A38F      STD	Y+39,R24
    00D4D A788      STD	Y+40,R24
    00D4E A789      STD	Y+41,R24
    00D4F C0EA      RJMP	0x0E3A
(0914) 		{
(0915) 			if(Write)
    00D50 01DE      MOVW	R26,R28
    00D51 5BA0      SUBI	R26,0xB0
    00D52 4FBF      SBCI	R27,0xFF
    00D53 900C      LD	R0,X
    00D54 2000      TST	R0
    00D55 F039      BEQ	0x0D5D
(0916) 				ReadBlock(LBA);
    00D56 A50A      LDD	R16,Y+42
    00D57 A51B      LDD	R17,Y+43
    00D58 A52C      LDD	R18,Y+44
    00D59 A53D      LDD	R19,Y+45
    00D5A 940E 01DD CALL	_ReadBlock
    00D5C C01E      RJMP	0x0D7B
(0917) 			else
(0918) 				ReadBlock(LBA++);
    00D5D A42A      LDD	R2,Y+42
    00D5E A43B      LDD	R3,Y+43
    00D5F A44C      LDD	R4,Y+44
    00D60 A45D      LDD	R5,Y+45
    00D61 AE2A      STD	Y+58,R2
    00D62 AE3B      STD	Y+59,R3
    00D63 AE4C      STD	Y+60,R4
    00D64 AE5D      STD	Y+61,R5
    00D65 E041      LDI	R20,1
    00D66 E050      LDI	R21,0
    00D67 E060      LDI	R22,0
    00D68 E070      LDI	R23,0
    00D69 AC2A      LDD	R2,Y+58
    00D6A AC3B      LDD	R3,Y+59
    00D6B AC4C      LDD	R4,Y+60
    00D6C AC5D      LDD	R5,Y+61
    00D6D 0E24      ADD	R2,R20
    00D6E 1E35      ADC	R3,R21
    00D6F 1E46      ADC	R4,R22
    00D70 1E57      ADC	R5,R23
    00D71 A62A      STD	Y+42,R2
    00D72 A63B      STD	Y+43,R3
    00D73 A64C      STD	Y+44,R4
    00D74 A65D      STD	Y+45,R5
    00D75 AD0A      LDD	R16,Y+58
    00D76 AD1B      LDD	R17,Y+59
    00D77 AD2C      LDD	R18,Y+60
    00D78 AD3D      LDD	R19,Y+61
    00D79 940E 01DD CALL	_ReadBlock
(0919) 
(0920) 			for(m = 0; m < 512; m++)
    00D7B 24AA      CLR	R10
    00D7C 24BB      CLR	R11
    00D7D C07C      RJMP	0x0DFA
(0921) 			{
(0922) 
(0923) 				if(Write)
    00D7E 01FE      MOVW	R30,R28
    00D7F 5BE0      SUBI	R30,0xB0
    00D80 4FFF      SBCI	R31,0xFF
    00D81 8000      LD	R0,Z
    00D82 2000      TST	R0
    00D83 F0B1      BEQ	0x0D9A
(0924) 					BUFFER[m] = *data++;
    00D84 E887      LDI	R24,0x87
    00D85 E092      LDI	R25,2
    00D86 01F5      MOVW	R30,R10
    00D87 0FE8      ADD	R30,R24
    00D88 1FF9      ADC	R31,R25
    00D89 93EF      PUSH	R30
    00D8A 93FF      PUSH	R31
    00D8B 01FE      MOVW	R30,R28
    00D8C 5BEE      SUBI	R30,0xBE
    00D8D 4FFF      SBCI	R31,0xFF
    00D8E 81A0      LD	R26,Z
    00D8F 81B1      LDD	R27,Z+1
    00D90 91FF      POP	R31
    00D91 91EF      POP	R30
    00D92 902D      LD	R2,X+
    00D93 01DE      MOVW	R26,R28
    00D94 5BAE      SUBI	R26,0xBE
    00D95 4FBF      SBCI	R27,0xFF
    00D96 93AD      ST	X+,R26
    00D97 93BC      ST	X,R27
    00D98 8220      ST	Z,R2
    00D99 C011      RJMP	0x0DAB
(0925) 				else
(0926) 					*data++ = BUFFER[m];
    00D9A E887      LDI	R24,0x87
    00D9B E092      LDI	R25,2
    00D9C 01F5      MOVW	R30,R10
    00D9D 0FE8      ADD	R30,R24
    00D9E 1FF9      ADC	R31,R25
    00D9F 8020      LD	R2,Z
    00DA0 01DE      MOVW	R26,R28
    00DA1 5BAE      SUBI	R26,0xBE
    00DA2 4FBF      SBCI	R27,0xFF
    00DA3 91ED      LD	R30,X+
    00DA4 91FC      LD	R31,X
    00DA5 9221      ST	Z+,R2
    00DA6 01DE      MOVW	R26,R28
    00DA7 5BAE      SUBI	R26,0xBE
    00DA8 4FBF      SBCI	R27,0xFF
    00DA9 93ED      ST	X+,R30
    00DAA 93FC      ST	X,R31
(0927) 
(0928) 				//如果读取完成就退出
(0929) 				if(--Length == 0)
    00DAB E041      LDI	R20,1
    00DAC E050      LDI	R21,0
    00DAD E060      LDI	R22,0
    00DAE E070      LDI	R23,0
    00DAF 01DE      MOVW	R26,R28
    00DB0 5AA8      SUBI	R26,0xA8
    00DB1 4FBF      SBCI	R27,0xFF
    00DB2 902D      LD	R2,X+
    00DB3 903D      LD	R3,X+
    00DB4 904D      LD	R4,X+
    00DB5 905C      LD	R5,X
    00DB6 1A24      SUB	R2,R20
    00DB7 0A35      SBC	R3,R21
    00DB8 0A46      SBC	R4,R22
    00DB9 0A57      SBC	R5,R23
    00DBA 01DE      MOVW	R26,R28
    00DBB 96DE      ADIW	R26,0x3E
    00DBC 922D      ST	X+,R2
    00DBD 923D      ST	X+,R3
    00DBE 924D      ST	X+,R4
    00DBF 925C      ST	X,R5
    00DC0 01DE      MOVW	R26,R28
    00DC1 96DE      ADIW	R26,0x3E
    00DC2 902D      LD	R2,X+
    00DC3 903D      LD	R3,X+
    00DC4 904D      LD	R4,X+
    00DC5 905C      LD	R5,X
    00DC6 01DE      MOVW	R26,R28
    00DC7 5AA8      SUBI	R26,0xA8
    00DC8 4FBF      SBCI	R27,0xFF
    00DC9 922D      ST	X+,R2
    00DCA 923D      ST	X+,R3
    00DCB 924D      ST	X+,R4
    00DCC 925C      ST	X,R5
    00DCD 01DE      MOVW	R26,R28
    00DCE 96DE      ADIW	R26,0x3E
    00DCF 902D      LD	R2,X+
    00DD0 903D      LD	R3,X+
    00DD1 904D      LD	R4,X+
    00DD2 905C      LD	R5,X
    00DD3 9488      BCLR	0
    00DD4 2022      TST	R2
    00DD5 0432      CPC	R3,R2
    00DD6 0442      CPC	R4,R2
    00DD7 0452      CPC	R5,R2
    00DD8 F4F1      BNE	0x0DF7
(0930) 				{
(0931) 					if(Write)
    00DD9 01DE      MOVW	R26,R28
    00DDA 5BA0      SUBI	R26,0xB0
    00DDB 4FBF      SBCI	R27,0xFF
    00DDC 900C      LD	R0,X
    00DDD 2000      TST	R0
    00DDE F409      BNE	0x0DE0
    00DDF C06B      RJMP	0x0E4B
(0932)                                         {
(0933)                                                 //回写扇区
(0934) 						WriteBlock(LBA); 
    00DE0 A50A      LDD	R16,Y+42
    00DE1 A51B      LDD	R17,Y+43
    00DE2 A52C      LDD	R18,Y+44
    00DE3 A53D      LDD	R19,Y+45
    00DE4 940E 01F0 CALL	_WriteBlock
(0935)                                                //回写目录
(0936)                                                 FileDir.DIR_FileSize = Start+length;
    00DE6 A82A      LDD	R2,Y+50
    00DE7 A83B      LDD	R3,Y+51
    00DE8 01FE      MOVW	R30,R28
    00DE9 5AEC      SUBI	R30,0xAC
    00DEA 4FFF      SBCI	R31,0xFF
    00DEB 8040      LD	R4,Z
    00DEC 8051      LDD	R5,Z+1
    00DED 0C42      ADD	R4,R2
    00DEE 1C53      ADC	R5,R3
    00DEF A25D      STD	Y+37,R5
    00DF0 A24C      STD	Y+36,R4
(0937)                                                 WriteDIR32(Index,&FileDir);
    00DF1 019E      MOVW	R18,R28
    00DF2 5F28      SUBI	R18,0xF8
    00DF3 4F3F      SBCI	R19,0xFF
    00DF4 0186      MOVW	R16,R12
    00DF5 D972      RCALL	_WriteDIR32
(0938)                                         }
(0939) 					return;
    00DF6 C054      RJMP	0x0E4B
    00DF7 01C5      MOVW	R24,R10
    00DF8 9601      ADIW	R24,1
    00DF9 015C      MOVW	R10,R24
    00DFA 01C5      MOVW	R24,R10
    00DFB 3080      CPI	R24,0
    00DFC E0A2      LDI	R26,2
    00DFD 079A      CPC	R25,R26
    00DFE F408      BCC	0x0E00
    00DFF CF7E      RJMP	0x0D7E
(0940) 				}
(0941) 			}
(0942) 			if(Write)
    00E00 01DE      MOVW	R26,R28
    00E01 5BA0      SUBI	R26,0xB0
    00E02 4FBF      SBCI	R27,0xFF
    00E03 900C      LD	R0,X
    00E04 2000      TST	R0
    00E05 F121      BEQ	0x0E2A
(0943) 				WriteBlock(LBA++); //回写扇区,指针下移
    00E06 A42A      LDD	R2,Y+42
    00E07 A43B      LDD	R3,Y+43
    00E08 A44C      LDD	R4,Y+44
    00E09 A45D      LDD	R5,Y+45
    00E0A 01DE      MOVW	R26,R28
    00E0B 96DE      ADIW	R26,0x3E
    00E0C 922D      ST	X+,R2
    00E0D 923D      ST	X+,R3
    00E0E 924D      ST	X+,R4
    00E0F 925C      ST	X,R5
    00E10 E041      LDI	R20,1
    00E11 E050      LDI	R21,0
    00E12 E060      LDI	R22,0
    00E13 E070      LDI	R23,0
    00E14 01DE      MOVW	R26,R28
    00E15 96DE      ADIW	R26,0x3E
    00E16 902D      LD	R2,X+
    00E17 903D      LD	R3,X+
    00E18 904D      LD	R4,X+
    00E19 905C      LD	R5,X
    00E1A 0E24      ADD	R2,R20
    00E1B 1E35      ADC	R3,R21
    00E1C 1E46      ADC	R4,R22
    00E1D 1E57      ADC	R5,R23
    00E1E A62A      STD	Y+42,R2
    00E1F A63B      STD	Y+43,R3
    00E20 A64C      STD	Y+44,R4
    00E21 A65D      STD	Y+45,R5
    00E22 01FE      MOVW	R30,R28
    00E23 96FE      ADIW	R30,0x3E
    00E24 8100      LD	R16,Z
    00E25 8111      LDD	R17,Z+1
    00E26 8122      LDD	R18,Z+2
    00E27 8133      LDD	R19,Z+3
    00E28 940E 01F0 CALL	_WriteBlock
    00E2A E041      LDI	R20,1
    00E2B E050      LDI	R21,0
    00E2C E060      LDI	R22,0
    00E2D E070      LDI	R23,0
    00E2E A02E      LDD	R2,Y+38
    00E2F A03F      LDD	R3,Y+39
    00E30 A448      LDD	R4,Y+40
    00E31 A459      LDD	R5,Y+41
    00E32 0E24      ADD	R2,R20
    00E33 1E35      ADC	R3,R21
    00E34 1E46      ADC	R4,R22
    00E35 1E57      ADC	R5,R23
    00E36 A22E      STD	Y+38,R2
    00E37 A23F      STD	Y+39,R3
    00E38 A648      STD	Y+40,R4
    00E39 A659      STD	Y+41,R5
    00E3A 01DE      MOVW	R26,R28
    00E3B 5BAC      SUBI	R26,0xBC
    00E3C 4FBF      SBCI	R27,0xFF
    00E3D 902D      LD	R2,X+
    00E3E 903C      LD	R3,X
    00E3F 2444      CLR	R4
    00E40 2455      CLR	R5
    00E41 A06E      LDD	R6,Y+38
    00E42 A07F      LDD	R7,Y+39
    00E43 A488      LDD	R8,Y+40
    00E44 A499      LDD	R9,Y+41
    00E45 1462      CP	R6,R2
    00E46 0473      CPC	R7,R3
    00E47 0484      CPC	R8,R4
    00E48 0495      CPC	R9,R5
    00E49 F408      BCC	0x0E4B
    00E4A CF05      RJMP	0x0D50
    00E4B 96EF      ADIW	R28,0x3F
    00E4C 9627      ADIW	R28,7
    00E4D 940E 1AE6 CALL	pop_xgsetF0FC
    00E4F 9624      ADIW	R28,4
    00E50 9508      RET
_FormatCard:
  FatSecNum            --> R12
  FatStart             --> R10
  DirSecNum            --> R10
  DirStart             --> R12
  i                    --> R20
    00E51 940E 1B1E CALL	push_xgset303C
(0944) 		}
(0945) 	}
(0946) 
(0947) /***********************************************************************
(0948) 函数功能：格式化磁盘
(0949) 操作内容：1、不是真正意义上的格式化，只是清除根目录
(0950)           2、实际文件的数据依然存在
(0951) ***********************************************************************/
(0952) 
(0953) void FormatCard(void)
(0954) {
(0955)     uint16 i,DirStart,DirSecNum,FatStart,FatSecNum;
(0956)    
(0957)     //ReadBPB();
(0958) 
(0959)     for(i = 0; i < 512;i++ )BUFFER[i]=0;                  //清除根目录，填入数据0
    00E53 2744      CLR	R20
    00E54 2755      CLR	R21
    00E55 C009      RJMP	0x0E5F
    00E56 E887      LDI	R24,0x87
    00E57 E092      LDI	R25,2
    00E58 01FA      MOVW	R30,R20
    00E59 0FE8      ADD	R30,R24
    00E5A 1FF9      ADC	R31,R25
    00E5B 2422      CLR	R2
    00E5C 8220      ST	Z,R2
    00E5D 5F4F      SUBI	R20,0xFF
    00E5E 4F5F      SBCI	R21,0xFF
    00E5F 3040      CPI	R20,0
    00E60 E0E2      LDI	R30,2
    00E61 075E      CPC	R21,R30
    00E62 F398      BCS	0x0E56
(0960)     DirSecNum = GetDirSecCount();                          //FAT16的根目录项数位512，占32个扇区，FAT32根目录项数不定
    00E63 940E 0394 CALL	_GetDirSecCount
    00E65 0158      MOVW	R10,R16
(0961)     DirStart = DirStartSec();                              //获取根目录开始地址
    00E66 940E 0334 CALL	_DirStartSec
    00E68 0168      MOVW	R12,R16
(0962)     for(i=0;i<DirSecNum;i++)                               //按扇区依次填入0
    00E69 2744      CLR	R20
    00E6A 2755      CLR	R21
    00E6B C009      RJMP	0x0E75
(0963)     {
(0964)       WriteBlock(DirStart+i);
    00E6C 0186      MOVW	R16,R12
    00E6D 0F04      ADD	R16,R20
    00E6E 1F15      ADC	R17,R21
    00E6F 2722      CLR	R18
    00E70 2733      CLR	R19
    00E71 940E 01F0 CALL	_WriteBlock
    00E73 5F4F      SUBI	R20,0xFF
    00E74 4F5F      SBCI	R21,0xFF
    00E75 154A      CP	R20,R10
    00E76 055B      CPC	R21,R11
    00E77 F3A0      BCS	0x0E6C
(0965)     }
(0966)  
(0967) 
(0968)     FatStart = BPB_HiddSec + BPB_RsvdSecCnt;              //清除FAT表
    00E78 9020 0282 LDS	R2,BPB_RsvdSecCnt
    00E7A 9030 0283 LDS	R3,BPB_RsvdSecCnt+1
    00E7C 2444      CLR	R4
    00E7D 2455      CLR	R5
    00E7E 9080 0279 LDS	R8,BPB_HiddSec+2
    00E80 9090 027A LDS	R9,BPB_HiddSec+3
    00E82 9060 0277 LDS	R6,BPB_HiddSec
    00E84 9070 0278 LDS	R7,BPB_HiddSec+1
    00E86 0C62      ADD	R6,R2
    00E87 1C73      ADC	R7,R3
    00E88 1C84      ADC	R8,R4
    00E89 1C95      ADC	R9,R5
    00E8A 0153      MOVW	R10,R6
(0969)     FatSecNum = BPB_FATSz16;                              //FAT表所占扇区数大小
    00E8B 90C0 027B LDS	R12,BPB_FATSz16
    00E8D 90D0 027C LDS	R13,BPB_FATSz16+1
(0970)     for(i=0;i<FatSecNum;i++)
    00E8F 2744      CLR	R20
    00E90 2755      CLR	R21
    00E91 C009      RJMP	0x0E9B
(0971)     {
(0972)       WriteBlock(FatStart+i);
    00E92 0185      MOVW	R16,R10
    00E93 0F04      ADD	R16,R20
    00E94 1F15      ADC	R17,R21
    00E95 2722      CLR	R18
    00E96 2733      CLR	R19
    00E97 940E 01F0 CALL	_WriteBlock
    00E99 5F4F      SUBI	R20,0xFF
    00E9A 4F5F      SBCI	R21,0xFF
    00E9B 154C      CP	R20,R12
    00E9C 055D      CPC	R21,R13
    00E9D F3A0      BCS	0x0E92
(0973)     }
(0974)     WriteFAT(0,0xfff8);                                   //FAT表的第一个字固定为0xfff8
    00E9E EF28      LDI	R18,0xF8
    00E9F EF3F      LDI	R19,0xFF
    00EA0 2700      CLR	R16
    00EA1 2711      CLR	R17
    00EA2 940E 0445 CALL	_WriteFAT
(0975)     WriteFAT(1,0xffff);                                   //FAT表的第二个字固定为0xffff
    00EA4 EF2F      LDI	R18,0xFF
    00EA5 EF3F      LDI	R19,0xFF
    00EA6 E001      LDI	R16,1
    00EA7 E010      LDI	R17,0
    00EA8 940E 0445 CALL	_WriteFAT
(0976) 
(0977)     CopyFAT();                                            //备份FAT表，保持与FAT1一致
    00EAA DB6E      RCALL	_CopyFAT
    00EAB 940C 1B25 JMP	pop_xgset303C
_FileCountSearch:
  DirStart             --> R10
  DirSecCut            --> R22
  i                    --> R20
  m                    --> R12
    00EAD 940E 1B2C CALL	push_xgsetF03C
(0978)     
(0979) 
(0980) }
(0981)        
(0982) /***********************************************************************
(0983) 函数功能：根目录下文件夹和文件数量搜索
(0984) 操作内容：1、搜索根目录项的目录项数以及属性 
(0985)           2、可以判断文件类型，如文件夹、txt文件、BMP文件、MP3文件等
(0986)           3、返回文件数量
(0987) ***********************************************************************/  
(0988) void FileCountSearch(void)
(0989) {/*
(0990) 	uint16 BytePerClus, SecPerClus, ClusNum, ClusNext,ClusID,ClusIDValue ,m,Index;
(0991) 	uint32 LBA, i;
(0992) 	DIR FileDir;
(0993) 	SecPerClus = BPB_SecPerClus;
(0994) 	BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
(0995) 	Index = GetFileID(Name, &FileDir);                            //文件根目录位置0～511
(0996)   
(0997)       */  
(0998)         uint16 DirSecCut, DirStart, i, m;//, Count = 0;
(0999) 	DirSecCut = 32;                                               //根目录扇区总数，这里限制FAT16和FAT32都最多为512个根目录项
    00EAF E260      LDI	R22,0x20
    00EB0 E070      LDI	R23,0
(1000) 	DirStart = DirStartSec();                                     //根目录开始扇区地址,FAT16为512
    00EB1 940E 0334 CALL	_DirStartSec
    00EB3 0158      MOVW	R10,R16
(1001)         DirectoryCount = 0,FileCount = 0;
    00EB4 2422      CLR	R2
    00EB5 2433      CLR	R3
    00EB6 9230 0101 STS	DirectoryCount+1,R3
    00EB8 9220 0100 STS	DirectoryCount,R2
    00EBA 9230 0103 STS	FileCount+1,R3
    00EBC 9220 0102 STS	FileCount,R2
(1002) 	for(i = 0; i < DirSecCut; i++)                                //在整个扇区空间搜索
    00EBE 2744      CLR	R20
    00EBF 2755      CLR	R21
    00EC0 C055      RJMP	0x0F16
(1003) 	{
(1004) 		ReadBlock(DirStart + i);                              //读根目录扇区
    00EC1 0185      MOVW	R16,R10
    00EC2 0F04      ADD	R16,R20
    00EC3 1F15      ADC	R17,R21
    00EC4 2722      CLR	R18
    00EC5 2733      CLR	R19
    00EC6 940E 01DD CALL	_ReadBlock
(1005) 		for(m = 0; m < 16; m++)
    00EC8 24CC      CLR	R12
    00EC9 24DD      CLR	R13
    00ECA C043      RJMP	0x0F0E
(1006) 		{
(1007) 			if((BUFFER[m * 32] != 0) && (BUFFER[m * 32] != 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
    00ECB E200      LDI	R16,0x20
    00ECC E010      LDI	R17,0
    00ECD 0196      MOVW	R18,R12
    00ECE 940E 1A8D CALL	empy16s
    00ED0 E887      LDI	R24,0x87
    00ED1 E092      LDI	R25,2
    00ED2 01F8      MOVW	R30,R16
    00ED3 0FE8      ADD	R30,R24
    00ED4 1FF9      ADC	R31,R25
    00ED5 8020      LD	R2,Z
    00ED6 2433      CLR	R3
    00ED7 2022      TST	R2
    00ED8 F409      BNE	0x0EDA
    00ED9 C031      RJMP	0x0F0B
    00EDA 2D82      MOV	R24,R2
    00EDB 3E85      CPI	R24,0xE5
    00EDC F171      BEQ	0x0F0B
(1008)                         {
(1009)                           if(BUFFER[m * 32+11] == 0x10)               //0x10为文件夹
    00EDD E200      LDI	R16,0x20
    00EDE E010      LDI	R17,0
    00EDF 0196      MOVW	R18,R12
    00EE0 940E 1A8D CALL	empy16s
    00EE2 01F8      MOVW	R30,R16
    00EE3 963B      ADIW	R30,0xB
    00EE4 E887      LDI	R24,0x87
    00EE5 E092      LDI	R25,2
    00EE6 0FE8      ADD	R30,R24
    00EE7 1FF9      ADC	R31,R25
    00EE8 8180      LD	R24,Z
    00EE9 3180      CPI	R24,0x10
    00EEA F449      BNE	0x0EF4
(1010)                             DirectoryCount++;
    00EEB 9180 0100 LDS	R24,DirectoryCount
    00EED 9190 0101 LDS	R25,DirectoryCount+1
    00EEF 9601      ADIW	R24,1
    00EF0 9390 0101 STS	DirectoryCount+1,R25
    00EF2 9380 0100 STS	DirectoryCount,R24
(1011)                           if(BUFFER[m * 32+11] == 0x20)               //0x20为文件
    00EF4 E200      LDI	R16,0x20
    00EF5 E010      LDI	R17,0
    00EF6 0196      MOVW	R18,R12
    00EF7 940E 1A8D CALL	empy16s
    00EF9 01F8      MOVW	R30,R16
    00EFA 963B      ADIW	R30,0xB
    00EFB E887      LDI	R24,0x87
    00EFC E092      LDI	R25,2
    00EFD 0FE8      ADD	R30,R24
    00EFE 1FF9      ADC	R31,R25
    00EFF 8180      LD	R24,Z
    00F00 3280      CPI	R24,0x20
    00F01 F449      BNE	0x0F0B
(1012)                             FileCount++;
    00F02 9180 0102 LDS	R24,FileCount
    00F04 9190 0103 LDS	R25,FileCount+1
    00F06 9601      ADIW	R24,1
    00F07 9390 0103 STS	FileCount+1,R25
    00F09 9380 0102 STS	FileCount,R24
    00F0B 01C6      MOVW	R24,R12
    00F0C 9601      ADIW	R24,1
    00F0D 016C      MOVW	R12,R24
    00F0E 01C6      MOVW	R24,R12
    00F0F 3180      CPI	R24,0x10
    00F10 E0E0      LDI	R30,0
    00F11 079E      CPC	R25,R30
    00F12 F408      BCC	0x0F14
    00F13 CFB7      RJMP	0x0ECB
    00F14 5F4F      SUBI	R20,0xFF
    00F15 4F5F      SBCI	R21,0xFF
    00F16 1746      CP	R20,R22
    00F17 0757      CPC	R21,R23
    00F18 F408      BCC	0x0F1A
    00F19 CFA7      RJMP	0x0EC1
    00F1A 940C 1B35 JMP	pop_xgsetF03C
FILE: D:\PROGRA~1\ICCAVR7.22\include\delay.h
(0001) //********************************************************************
(0002) /*函 数 名：delay_us
(0003) 建立日期：2010年1月28日
(0004) 编译环境：ICCAVR7.16A
(0005) 函数作用：微秒级的延时程序
(0006) 说    明：7.3728M晶振下
(0007) ********************************************************************/
(0008) void delay_1us(void);
(0009) void delay_3us(void);
(0010) void delay_10us(void);
(0011) void delay_50us(void);
(0012) void delay_100us(void);
(0013) void delay_n100us(unsigned char n100us);
(0014) void delay_1ms(void);
(0015) void delay_nms(unsigned int nms);
(0016) void delay_ns(unsigned char ns);
(0017) 
(0018) 
(0019) void delay_1us(void)                 //1us延时函数，不能连续调用， 
(0020) { 
(0021)    asm("nop");                       //1时钟周期
_delay_1us:
    00F1C 0000      NOP
(0022)    asm("nop");
    00F1D 0000      NOP
(0023)    asm("nop");
    00F1E 0000      NOP
(0024)    asm("nop");
    00F1F 0000      NOP
(0025)    asm("nop");                       //1T
    00F20 0000      NOP
(0026)    asm("nop");
    00F21 0000      NOP
    00F22 9508      RET
(0027) 
(0028) }
(0029) void delay_3us(void)                 //3us延时函数,,可重复调用不影响精度
(0030) { 
(0031)    
(0032)    asm("nop");
_delay_3us:
    00F23 0000      NOP
(0033)    asm("nop");
    00F24 0000      NOP
(0034)    asm("nop");                       
    00F25 0000      NOP
(0035)    asm("nop");
    00F26 0000      NOP
(0036)    asm("nop");
    00F27 0000      NOP
(0037)    asm("nop");
    00F28 0000      NOP
(0038)    asm("nop");                       
    00F29 0000      NOP
(0039)    asm("nop");
    00F2A 0000      NOP
(0040)    asm("nop");
    00F2B 0000      NOP
(0041)    asm("nop");
    00F2C 0000      NOP
(0042)    asm("nop");                       
    00F2D 0000      NOP
(0043)    asm("nop");
    00F2E 0000      NOP
(0044)    asm("nop");
    00F2F 0000      NOP
(0045)    asm("nop");
    00F30 0000      NOP
(0046)    asm("nop");                       
    00F31 0000      NOP
(0047)    asm("nop");
    00F32 0000      NOP
(0048)    asm("nop");
    00F33 0000      NOP
(0049)    asm("nop");
    00F34 0000      NOP
(0050)    asm("nop");
    00F35 0000      NOP
(0051)    asm("nop");
    00F36 0000      NOP
(0052)    asm("nop");                       
    00F37 0000      NOP
    00F38 9508      RET
(0053) } 
(0054) 
(0055) void delay_10us(void)                 //10us延时函数,,可重复调用不影响精度
(0056) {
(0057)    delay_3us();
_delay_10us:
    00F39 DFE9      RCALL	_delay_3us
(0058)    delay_3us(); 
    00F3A DFE8      RCALL	_delay_3us
(0059)    delay_3us();  
    00F3B CFE7      RJMP	_delay_3us
(0060) }
(0061)   
(0062) void delay_50us(void)                 //48us延时函数,,可重复调用不影响精度
(0063) { 
(0064)    delay_10us();
_delay_50us:
    00F3C DFFC      RCALL	_delay_10us
(0065)    delay_10us(); 
    00F3D DFFB      RCALL	_delay_10us
(0066)    delay_10us();
    00F3E DFFA      RCALL	_delay_10us
(0067)    delay_10us();
    00F3F CFF9      RJMP	_delay_10us
(0068) }
(0069) void delay_100us(void)     //exactly 98us延时函数,,可重复调用不影响精度
(0070) {
(0071)  delay_50us();
_delay_100us:
    00F40 DFFB      RCALL	_delay_50us
(0072)  delay_50us();
    00F41 CFFA      RJMP	_delay_50us
_delay_n100us:
  n100us               --> R20
    00F42 934A      ST	-Y,R20
    00F43 2F40      MOV	R20,R16
(0073) }
(0074) void delay_n100us(unsigned char n100us)
(0075) {
    00F44 C001      RJMP	0x0F46
(0076)  while(n100us--)                          
(0077)  delay_100us();
    00F45 DFFA      RCALL	_delay_100us
    00F46 2E24      MOV	R2,R20
    00F47 2433      CLR	R3
    00F48 5041      SUBI	R20,1
    00F49 2022      TST	R2
    00F4A F7D1      BNE	0x0F45
    00F4B 9149      LD	R20,Y+
    00F4C 9508      RET
(0078) }
(0079) /*delay_n100us(2)        250us
(0080) delay_n100us(3)          360us
(0081) delay_n100us(4)          470us
(0082) delay_n100us(5)          580us
(0083) delay_n100us(6)          690us
(0084) delay_n100us(7)       800us
(0085) delay_n100us(8)          900us              主要是由于函数声明及while,,,大概6us
(0086) 
(0087) */
(0088) void delay_1ms()
(0089) {
(0090)  delay_100us();
_delay_1ms:
    00F4D DFF2      RCALL	_delay_100us
(0091)  delay_100us();
    00F4E DFF1      RCALL	_delay_100us
(0092)  delay_100us();
    00F4F DFF0      RCALL	_delay_100us
(0093)  delay_100us();
    00F50 DFEF      RCALL	_delay_100us
(0094)  delay_100us();
    00F51 DFEE      RCALL	_delay_100us
(0095)  delay_100us();
    00F52 DFED      RCALL	_delay_100us
(0096)  delay_100us();
    00F53 DFEC      RCALL	_delay_100us
(0097)  delay_100us();
    00F54 DFEB      RCALL	_delay_100us
(0098)  delay_100us();
    00F55 DFEA      RCALL	_delay_100us
(0099)  delay_100us();
    00F56 CFE9      RJMP	_delay_100us
_delay_nms:
  nms                  --> R20
    00F57 934A      ST	-Y,R20
    00F58 935A      ST	-Y,R21
    00F59 01A8      MOVW	R20,R16
(0100) }
(0101) /********************************************************************
(0102) 函 数 名：Delay_ms
(0103) 建立日期：2010年1月28日
(0104) 修改日期：
(0105) 函数作用：毫秒级的精确延时程序
(0106) 说    明：
(0107) ********************************************************************/
(0108) void delay_nms(unsigned int nms)
(0109) {
    00F5A C001      RJMP	0x0F5C
(0110)  while(nms--) 
(0111)  delay_1ms();
    00F5B DFF1      RCALL	_delay_1ms
    00F5C 011A      MOVW	R2,R20
    00F5D 5041      SUBI	R20,1
    00F5E 4050      SBCI	R21,0
    00F5F 2022      TST	R2
    00F60 F7D1      BNE	0x0F5B
    00F61 2033      TST	R3
    00F62 F7C1      BNE	0x0F5B
    00F63 9159      LD	R21,Y+
    00F64 9149      LD	R20,Y+
    00F65 9508      RET
_delay_ns:
  ns                   --> R20
    00F66 934A      ST	-Y,R20
    00F67 2F40      MOV	R20,R16
(0112) }
(0113) void delay_ns(unsigned char ns)
(0114) {
    00F68 C003      RJMP	0x0F6C
(0115)  while(ns--) 
(0116)  delay_nms(1000);
    00F69 EE08      LDI	R16,0xE8
    00F6A E013      LDI	R17,3
    00F6B DFEB      RCALL	_delay_nms
    00F6C 2E24      MOV	R2,R20
    00F6D 2433      CLR	R3
    00F6E 5041      SUBI	R20,1
    00F6F 2022      TST	R2
    00F70 F7C1      BNE	0x0F69
    00F71 9149      LD	R20,Y+
    00F72 9508      RET
FILE: E:\DMAVR-~3\FAT-NE~1\main.c
(0001) //******************************************************************************
(0002) //基于DMAVR-128系统的MMC/SD卡的FAT16文件系统，支持建立TXT文件，写入数据,不支持FAT32
(0003) //采用SPI控制方式，MMC/SD卡作为存储器，进行读写，研究文件系统前需要掌握
(0004) //由于存在长整型数据，因此，要设定ICCAVR环境支持long型数据，设置project->options->Target，选中long
(0005) //SD卡仅仅支持2GB以下的卡，所以一定要注意，包括2GB，格式化时簇大小为16K
(0006) //读写完成后，蜂鸣器会响三声
(0007) //版本号：Ver2.0
(0008) //编译环境：ICCAVR 7.22A
(0009) //作者：www.avrgcc.com
(0010) //时间：2012.06.01
(0011) //版权：欣世纪电子版权所有，转载请注明出处
(0012) //******************************************************************************
(0013) 
(0014) #include <string.h>
(0015) #include <stdio.h>
(0016) #include <iom128v.h>
(0017) #define	 F_CPU	7372800		/* 单片机主频为7.3728MHz,用于延时子程序 */
(0018) #include <SD.h>
(0019) #include "libtypes.h"		// include our global settings
(0020) #include <delay.h>
(0021) #include <fat16.h>
(0022) 
(0023) #define SoundON             PORTD &= ~(1 << PD6)    		//蜂鸣器所在IO口PD6
(0024) #define SoundOFF            PORTD |= (1 << PD6)
(0025) 
(0026) 
(0027) 
(0028) uint16 BlockLength=512; //MMC/SD卡块大小，CSD寄存器记录了卡本身允许的大小，一般为512
(0029) uint32 cardSize = 0;    //初始化MMC/SD卡容量为0
(0030) uint8 status = 1;       //状态变量
(0031) uint16 timeout = 0;        
(0032) uint8 buffer1[512];     //写入数据缓冲区，由于空间足够，因此分别开辟写入和读出缓冲区
(0033) uint8 buffer2[512];     //读出数据缓冲区，由于空间足够，因此分别开辟写入和读出缓冲区
(0034) uint8 BUFFER[512];
(0035) uint32 numSector=200;	//向SD卡中写入数据的地址，为扇区数，对于一个扇区为512字节的SD卡实际地址为numSector*512字节
(0036) void uartInit();
(0037) int putchar(char c);
(0038) int getchar(void);
(0039) uint32 MMC_ReadCardSize(void);
(0040) 
(0041) void SoundSuccess(void)
(0042) {
(0043)    SoundON;
_SoundSuccess:
    00F73 9896      CBI	0x12,6
(0044)    delay_nms(500);
    00F74 EF04      LDI	R16,0xF4
    00F75 E011      LDI	R17,1
    00F76 DFE0      RCALL	_delay_nms
(0045)    SoundOFF;
    00F77 9A96      SBI	0x12,6
(0046)    SoundON;
    00F78 9896      CBI	0x12,6
(0047)    delay_nms(500);
    00F79 EF04      LDI	R16,0xF4
    00F7A E011      LDI	R17,1
    00F7B DFDB      RCALL	_delay_nms
(0048)    SoundOFF;
    00F7C 9A96      SBI	0x12,6
(0049)    SoundON;
    00F7D 9896      CBI	0x12,6
(0050)    delay_nms(500);
    00F7E EF04      LDI	R16,0xF4
    00F7F E011      LDI	R17,1
    00F80 DFD6      RCALL	_delay_nms
(0051)    SoundOFF;
    00F81 9A96      SBI	0x12,6
    00F82 9508      RET
_main:
  getchar              --> Y,+10
  success              --> R20
  i                    --> R20
    00F83 972B      SBIW	R28,0xB
(0052) }
(0053) 
(0054) /*************************************************
(0055) 函数功能：主函数
(0056) 操作内容：1、初始化系统时钟,内部或者外部时钟皆可
(0057)           2、调用函数,启动MMC/SD控制和FAT文件系统
(0058) *************************************************/
(0059) int main( void )
(0060) {
(0061)   uint16 i;
(0062)   uint8 getchar,success=0;
    00F84 2744      CLR	R20
(0063) 
(0064)   uartInit();                 //串口初始化
    00F85 940E 15BE CALL	_uartInit
(0065)   printf("DMAVR-128读写MMC/SD卡数据实验\r\n");
    00F87 E40C      LDI	R16,0x4C
    00F88 E012      LDI	R17,2
    00F89 940E 2279 CALL	_printf
(0066)   printf("DMAVR-M128 初始化成功!\r\n");
    00F8B E303      LDI	R16,0x33
    00F8C E012      LDI	R17,2
    00F8D 940E 2279 CALL	_printf
(0067)   printf("等待初始化MMC/SD卡……\r\n");
    00F8F E10A      LDI	R16,0x1A
    00F90 E012      LDI	R17,2
    00F91 940E 2279 CALL	_printf
(0068) 
(0069)   PORTD=0xff;                                       //PD设置为输出
    00F93 EF8F      LDI	R24,0xFF
    00F94 BB82      OUT	0x12,R24
(0070)   DDRD=0xff;
    00F95 BB81      OUT	0x11,R24
    00F96 C01A      RJMP	0x0FB1
(0071) 
(0072)   while (status != 0)         // 如果返回非零值，则表示出错，SD卡继续重新初始化                                           
(0073)   {
(0074)     status = initMMC();
    00F97 940E 1127 CALL	_initMMC
    00F99 9300 0120 STS	status,R16
(0075)     timeout++;
    00F9B 9180 0121 LDS	R24,timeout
    00F9D 9190 0122 LDS	R25,timeout+1
    00F9F 9601      ADIW	R24,1
    00FA0 9390 0122 STS	timeout+1,R25
    00FA2 9380 0121 STS	timeout,R24
(0076)     if (timeout == 50)       //初始化50次MMC/SD卡，如果依然返回错误代码，则初始化失败，可能是没有SD卡或损坏
    00FA4 3382      CPI	R24,0x32
    00FA5 E0E0      LDI	R30,0
    00FA6 079E      CPC	R25,R30
    00FA7 F449      BNE	0x0FB1
(0077)     {
(0078)       printf("MMC/SD卡初始化失败!\r\n");   //初始化失败显示
    00FA8 E004      LDI	R16,4
    00FA9 E012      LDI	R17,2
    00FAA 940E 2279 CALL	_printf
(0079) 	  printf("请检查SD卡是否存在或者复位系统!\r\n");
    00FAC EE02      LDI	R16,0xE2
    00FAD E011      LDI	R17,1
    00FAE 940E 2279 CALL	_printf
(0080) 	  while(1);   		
    00FB0 CFFF      RJMP	0x0FB0
    00FB1 9020 0120 LDS	R2,status
    00FB3 2022      TST	R2
    00FB4 F711      BNE	0x0F97
(0081)       break;                                          //50次满则退出
(0082)     }
(0083)   }
(0084)  
(0085)   printf("初始化MMC/SD卡成功!\r\n");                  //初始化成功显示提示信息
    00FB5 EC0C      LDI	R16,0xCC
    00FB6 E011      LDI	R17,1
    00FB7 940E 2279 CALL	_printf
(0086)  
(0087)   cardSize =  MMC_ReadCardSize();                     //从CSD寄存器读取MMC/SD卡容量大小，返回长整型
    00FB9 940E 1444 CALL	_MMC_ReadCardSize
    00FBB 9310 011D STS	cardSize+1,R17
    00FBD 9300 011C STS	cardSize,R16
    00FBF 9330 011F STS	cardSize+3,R19
    00FC1 9320 011E STS	cardSize+2,R18
(0088)   printf("卡容量=%ld\r\n",cardSize);				  //输出SD卡容量，单位:字节
    00FC3 8328      ST	Y,R18
    00FC4 8339      STD	Y+1,R19
    00FC5 0198      MOVW	R18,R16
    00FC6 EB0F      LDI	R16,0xBF
    00FC7 E011      LDI	R17,1
    00FC8 940E 2279 CALL	_printf
(0089)   ReadBPB();
    00FCA 940E 0289 CALL	_ReadBPB
(0090)   FormatCard();                //格式化MMC/SD卡，需要时使用，建议在此处打开，可以每次上电时格式化一次，格式化时间会比较长
    00FCC 940E 0E51 CALL	_FormatCard
(0091)   CreateFile("TEST0009TXT");                          //创建文件TEST0009.TXT，文件名长度8位，后缀名3位，必须大写
    00FCE EB03      LDI	R16,0xB3
    00FCF E011      LDI	R17,1
    00FD0 940E 08AB CALL	_CreateFile
(0092)   for (i = 0; i <= 512; i++) buffer1[i] = 'A';        //以下函数为向建立的文件中写入数据，可以根据需要更改
    00FD2 2744      CLR	R20
    00FD3 2755      CLR	R21
    00FD4 C009      RJMP	0x0FDE
    00FD5 E887      LDI	R24,0x87
    00FD6 E096      LDI	R25,6
    00FD7 01FA      MOVW	R30,R20
    00FD8 0FE8      ADD	R30,R24
    00FD9 1FF9      ADC	R31,R25
    00FDA E481      LDI	R24,0x41
    00FDB 8380      ST	Z,R24
    00FDC 5F4F      SUBI	R20,0xFF
    00FDD 4F5F      SBCI	R21,0xFF
    00FDE E080      LDI	R24,0
    00FDF E092      LDI	R25,2
    00FE0 1784      CP	R24,R20
    00FE1 0795      CPC	R25,R21
    00FE2 F790      BCC	0x0FD5
(0093)   OperateFile(1,"TEST0009TXT",0,512,buffer1);
    00FE3 E887      LDI	R24,0x87
    00FE4 E096      LDI	R25,6
    00FE5 8799      STD	Y+9,R25
    00FE6 8788      STD	Y+8,R24
    00FE7 E080      LDI	R24,0
    00FE8 838C      STD	Y+4,R24
    00FE9 838E      STD	Y+6,R24
    00FEA 838F      STD	Y+7,R24
    00FEB E082      LDI	R24,2
    00FEC 838D      STD	Y+5,R24
    00FED E080      LDI	R24,0
    00FEE 8388      ST	Y,R24
    00FEF 8389      STD	Y+1,R24
    00FF0 838A      STD	Y+2,R24
    00FF1 838B      STD	Y+3,R24
    00FF2 EB23      LDI	R18,0xB3
    00FF3 E031      LDI	R19,1
    00FF4 E001      LDI	R16,1
    00FF5 940E 0A55 CALL	_OperateFile
(0094)   for (i = 0; i <= 512; i++) buffer1[i] = 'B';  
    00FF7 2744      CLR	R20
    00FF8 2755      CLR	R21
    00FF9 C009      RJMP	0x1003
    00FFA E887      LDI	R24,0x87
    00FFB E096      LDI	R25,6
    00FFC 01FA      MOVW	R30,R20
    00FFD 0FE8      ADD	R30,R24
    00FFE 1FF9      ADC	R31,R25
    00FFF E482      LDI	R24,0x42
    01000 8380      ST	Z,R24
    01001 5F4F      SUBI	R20,0xFF
    01002 4F5F      SBCI	R21,0xFF
    01003 E080      LDI	R24,0
    01004 E092      LDI	R25,2
    01005 1784      CP	R24,R20
    01006 0795      CPC	R25,R21
    01007 F790      BCC	0x0FFA
(0095)   OperateFile(1,"TEST0009TXT",512,512,buffer1);
    01008 E887      LDI	R24,0x87
    01009 E096      LDI	R25,6
    0100A 8799      STD	Y+9,R25
    0100B 8788      STD	Y+8,R24
    0100C E080      LDI	R24,0
    0100D 838C      STD	Y+4,R24
    0100E 838E      STD	Y+6,R24
    0100F 838F      STD	Y+7,R24
    01010 E082      LDI	R24,2
    01011 838D      STD	Y+5,R24
    01012 E080      LDI	R24,0
    01013 8388      ST	Y,R24
    01014 838A      STD	Y+2,R24
    01015 838B      STD	Y+3,R24
    01016 E082      LDI	R24,2
    01017 8389      STD	Y+1,R24
    01018 EB23      LDI	R18,0xB3
    01019 E031      LDI	R19,1
    0101A E001      LDI	R16,1
    0101B 940E 0A55 CALL	_OperateFile
(0096)   for (i = 0; i <= 512; i++) buffer1[i] = 'C';  
    0101D 2744      CLR	R20
    0101E 2755      CLR	R21
    0101F C009      RJMP	0x1029
    01020 E887      LDI	R24,0x87
    01021 E096      LDI	R25,6
    01022 01FA      MOVW	R30,R20
    01023 0FE8      ADD	R30,R24
    01024 1FF9      ADC	R31,R25
    01025 E483      LDI	R24,0x43
    01026 8380      ST	Z,R24
    01027 5F4F      SUBI	R20,0xFF
    01028 4F5F      SBCI	R21,0xFF
    01029 E080      LDI	R24,0
    0102A E092      LDI	R25,2
    0102B 1784      CP	R24,R20
    0102C 0795      CPC	R25,R21
    0102D F790      BCC	0x1020
(0097)   OperateFile(1,"TEST0009TXT",1024,512,buffer1);
    0102E E887      LDI	R24,0x87
    0102F E096      LDI	R25,6
    01030 8799      STD	Y+9,R25
    01031 8788      STD	Y+8,R24
    01032 E080      LDI	R24,0
    01033 838C      STD	Y+4,R24
    01034 838E      STD	Y+6,R24
    01035 838F      STD	Y+7,R24
    01036 E082      LDI	R24,2
    01037 838D      STD	Y+5,R24
    01038 E080      LDI	R24,0
    01039 8388      ST	Y,R24
    0103A 838A      STD	Y+2,R24
    0103B 838B      STD	Y+3,R24
    0103C E084      LDI	R24,4
    0103D 8389      STD	Y+1,R24
    0103E EB23      LDI	R18,0xB3
    0103F E031      LDI	R19,1
    01040 E001      LDI	R16,1
    01041 940E 0A55 CALL	_OperateFile
(0098)   for (i = 0; i <= 512; i++) buffer1[i] = 'D';  
    01043 2744      CLR	R20
    01044 2755      CLR	R21
    01045 C009      RJMP	0x104F
    01046 E887      LDI	R24,0x87
    01047 E096      LDI	R25,6
    01048 01FA      MOVW	R30,R20
    01049 0FE8      ADD	R30,R24
    0104A 1FF9      ADC	R31,R25
    0104B E484      LDI	R24,0x44
    0104C 8380      ST	Z,R24
    0104D 5F4F      SUBI	R20,0xFF
    0104E 4F5F      SBCI	R21,0xFF
    0104F E080      LDI	R24,0
    01050 E092      LDI	R25,2
    01051 1784      CP	R24,R20
    01052 0795      CPC	R25,R21
    01053 F790      BCC	0x1046
(0099)   OperateFile(1,"TEST0009TXT",1536,512,buffer1); 
    01054 E887      LDI	R24,0x87
    01055 E096      LDI	R25,6
    01056 8799      STD	Y+9,R25
    01057 8788      STD	Y+8,R24
    01058 E080      LDI	R24,0
    01059 838C      STD	Y+4,R24
    0105A 838E      STD	Y+6,R24
    0105B 838F      STD	Y+7,R24
    0105C E082      LDI	R24,2
    0105D 838D      STD	Y+5,R24
    0105E E080      LDI	R24,0
    0105F 8388      ST	Y,R24
    01060 838A      STD	Y+2,R24
    01061 838B      STD	Y+3,R24
    01062 E086      LDI	R24,6
    01063 8389      STD	Y+1,R24
    01064 EB23      LDI	R18,0xB3
    01065 E031      LDI	R19,1
    01066 E001      LDI	R16,1
    01067 940E 0A55 CALL	_OperateFile
(0100)   for (i = 0; i <= 512; i++) buffer1[i] = 'E';  
    01069 2744      CLR	R20
    0106A 2755      CLR	R21
    0106B C009      RJMP	0x1075
    0106C E887      LDI	R24,0x87
    0106D E096      LDI	R25,6
    0106E 01FA      MOVW	R30,R20
    0106F 0FE8      ADD	R30,R24
    01070 1FF9      ADC	R31,R25
    01071 E485      LDI	R24,0x45
    01072 8380      ST	Z,R24
    01073 5F4F      SUBI	R20,0xFF
    01074 4F5F      SBCI	R21,0xFF
    01075 E080      LDI	R24,0
    01076 E092      LDI	R25,2
    01077 1784      CP	R24,R20
    01078 0795      CPC	R25,R21
    01079 F790      BCC	0x106C
(0101)   OperateFile(1,"TEST0009TXT",2048,512,buffer1); 
    0107A E887      LDI	R24,0x87
    0107B E096      LDI	R25,6
    0107C 8799      STD	Y+9,R25
    0107D 8788      STD	Y+8,R24
    0107E E080      LDI	R24,0
    0107F 838C      STD	Y+4,R24
    01080 838E      STD	Y+6,R24
    01081 838F      STD	Y+7,R24
    01082 E082      LDI	R24,2
    01083 838D      STD	Y+5,R24
    01084 E080      LDI	R24,0
    01085 8388      ST	Y,R24
    01086 838A      STD	Y+2,R24
    01087 838B      STD	Y+3,R24
    01088 E088      LDI	R24,0x8
    01089 8389      STD	Y+1,R24
    0108A EB23      LDI	R18,0xB3
    0108B E031      LDI	R19,1
    0108C E001      LDI	R16,1
    0108D 940E 0A55 CALL	_OperateFile
(0102)   
(0103)   SoundSuccess();                  //完成提示音，响三声
    0108F DEE3      RCALL	_SoundSuccess
(0104)   
(0105) /*以下部分不执行，实际功能是向SD卡中读写数据测试功能，SD卡数据读写实验就是这样的，如有疑问，请看SD卡视频教程*/
(0106) /*去掉while(1);语句可以启用，要借助串口，在电脑上可以看到数据，通过串口调试助手显示*/
(0107) while(1);
    01090 CFFF      RJMP	0x1090
(0108) while(1)
(0109)  {
(0110)   printf("请输入要写入MMC/SD卡的字符数据!\n");
    01091 E902      LDI	R16,0x92
    01092 E011      LDI	R17,1
    01093 940E 2279 CALL	_printf
(0111)  
(0112)   scanf("%c",&getchar);                               //将从串口输入的数据写入SD卡，数据为单个字符，如a
    01095 019E      MOVW	R18,R28
    01096 5F26      SUBI	R18,0xF6
    01097 4F3F      SBCI	R19,0xFF
    01098 E80F      LDI	R16,0x8F
    01099 E011      LDI	R17,1
    0109A 940E 22A2 CALL	_scanf
(0113)  
(0114)   printf("要写入的字符是： %c\n",getchar) ;
    0109C 852A      LDD	R18,Y+10
    0109D 2733      CLR	R19
    0109E E70A      LDI	R16,0x7A
    0109F E011      LDI	R17,1
    010A0 940E 2279 CALL	_printf
(0115) 
(0116)   buffer1[0]=getchar;                                 //将串口输入的数据赋予buffer1，准备写入SD卡
    010A2 842A      LDD	R2,Y+10
    010A3 9220 0687 STS	buffer1,R2
(0117) 
(0118)   printf("DMAVR-M128开始读写MMC/SD卡，请查看结果!\n");
    010A5 E501      LDI	R16,0x51
    010A6 E011      LDI	R17,1
    010A7 940E 2279 CALL	_printf
(0119) 
(0120)   for(i=1;i<512;i++)
    010A9 E041      LDI	R20,1
    010AA E050      LDI	R21,0
    010AB C00A      RJMP	0x10B6
(0121)    {
(0122)     	buffer1[i]=buffer1[0];   	                  //将输入的数据填充在整个数据缓冲区buffer1
    010AC E887      LDI	R24,0x87
    010AD E096      LDI	R25,6
    010AE 01FA      MOVW	R30,R20
    010AF 0FE8      ADD	R30,R24
    010B0 1FF9      ADC	R31,R25
    010B1 9020 0687 LDS	R2,buffer1
    010B3 8220      ST	Z,R2
    010B4 5F4F      SUBI	R20,0xFF
    010B5 4F5F      SBCI	R21,0xFF
    010B6 3040      CPI	R20,0
    010B7 E0E2      LDI	R30,2
    010B8 075E      CPC	R21,R30
    010B9 F390      BCS	0x10AC
(0123)     }
(0124) 
(0125)   mmcWriteBlock (numSector, BlockLength, buffer1);    //向指定扇区地址(numSector*512)写入数据    			  
    010BA E887      LDI	R24,0x87
    010BB E096      LDI	R25,6
    010BC 839B      STD	Y+3,R25
    010BD 838A      STD	Y+2,R24
    010BE 9020 011A LDS	R2,BlockLength
    010C0 9030 011B LDS	R3,BlockLength+1
    010C2 8239      STD	Y+1,R3
    010C3 8228      ST	Y,R2
    010C4 9120 0125 LDS	R18,numSector+2
    010C6 9130 0126 LDS	R19,numSector+3
    010C8 9100 0123 LDS	R16,numSector
    010CA 9110 0124 LDS	R17,numSector+1
    010CC 940E 1308 CALL	_mmcWriteBlock
(0126) 
(0127)   mmcReadBlock(numSector, BlockLength, buffer2);	  //读取刚才写入空间的数据，判断是否写入成功
    010CE E887      LDI	R24,0x87
    010CF E094      LDI	R25,4
    010D0 839B      STD	Y+3,R25
    010D1 838A      STD	Y+2,R24
    010D2 9020 011A LDS	R2,BlockLength
    010D4 9030 011B LDS	R3,BlockLength+1
    010D6 8239      STD	Y+1,R3
    010D7 8228      ST	Y,R2
    010D8 9120 0125 LDS	R18,numSector+2
    010DA 9130 0126 LDS	R19,numSector+3
    010DC 9100 0123 LDS	R16,numSector
    010DE 9110 0124 LDS	R17,numSector+1
    010E0 940E 1284 CALL	_mmcReadBlock
(0128) 
(0129)  for(i=0;i<BlockLength;i++)
    010E2 2744      CLR	R20
    010E3 2755      CLR	R21
    010E4 C00D      RJMP	0x10F2
(0130)    {
(0131)     	printf ("Data=%c \r",buffer2[i]);			  //输出从MMC/SD卡读出的数据
    010E5 E887      LDI	R24,0x87
    010E6 E094      LDI	R25,4
    010E7 01FA      MOVW	R30,R20
    010E8 0FE8      ADD	R30,R24
    010E9 1FF9      ADC	R31,R25
    010EA 8120      LD	R18,Z
    010EB 2733      CLR	R19
    010EC E407      LDI	R16,0x47
    010ED E011      LDI	R17,1
    010EE 940E 2279 CALL	_printf
    010F0 5F4F      SUBI	R20,0xFF
    010F1 4F5F      SBCI	R21,0xFF
    010F2 9020 011A LDS	R2,BlockLength
    010F4 9030 011B LDS	R3,BlockLength+1
    010F6 1542      CP	R20,R2
    010F7 0553      CPC	R21,R3
    010F8 F360      BCS	0x10E5
(0132)    }
(0133)   printf ("\n");
    010F9 E405      LDI	R16,0x45
    010FA E011      LDI	R17,1
    010FB 940E 2279 CALL	_printf
(0134) 
(0135)  for(i=0;i<BlockLength;i++)                                   //判断读写是否成功，读出和写入数据是否一致
    010FD 2744      CLR	R20
    010FE 2755      CLR	R21
    010FF C017      RJMP	0x1117
(0136)  	{
(0137) 
(0138)  		if(buffer1[i]!=buffer2[i])                    //数据读写失败
    01100 E887      LDI	R24,0x87
    01101 E094      LDI	R25,4
    01102 01FA      MOVW	R30,R20
    01103 0FE8      ADD	R30,R24
    01104 1FF9      ADC	R31,R25
    01105 8020      LD	R2,Z
    01106 E887      LDI	R24,0x87
    01107 E096      LDI	R25,6
    01108 01FA      MOVW	R30,R20
    01109 0FE8      ADD	R30,R24
    0110A 1FF9      ADC	R31,R25
    0110B 8030      LD	R3,Z
    0110C 1432      CP	R3,R2
    0110D F031      BEQ	0x1114
(0139)  			{
(0140) 				printf("读写数据失败!\n");
    0110E E306      LDI	R16,0x36
    0110F E011      LDI	R17,1
    01110 940E 2279 CALL	_printf
(0141) 				success=0;
    01112 2744      CLR	R20
(0142) 				break;
    01113 C00A      RJMP	0x111E
(0143)  			 }
(0144)  		else success=1;
    01114 E041      LDI	R20,1
    01115 5F4F      SUBI	R20,0xFF
    01116 4F5F      SBCI	R21,0xFF
    01117 9020 011A LDS	R2,BlockLength
    01119 9030 011B LDS	R3,BlockLength+1
    0111B 1542      CP	R20,R2
    0111C 0553      CPC	R21,R3
    0111D F310      BCS	0x1100
(0145)  	}
(0146)  if(success==1)  printf("读写数据成功!\n");           //数据读写成功
    0111E 3041      CPI	R20,1
    0111F F421      BNE	0x1124
    01120 E207      LDI	R16,0x27
    01121 E011      LDI	R17,1
    01122 940E 2279 CALL	_printf
    01124 CF6C      RJMP	0x1091
    01125 962B      ADIW	R28,0xB
    01126 9508      RET
_initMMC:
  i                    --> R20
    01127 934A      ST	-Y,R20
    01128 935A      ST	-Y,R21
FILE: E:\DMAVR-~3\FAT-NE~1\SD.c
(0001) //******************************************************************************
(0002) //MMC/SD卡驱动，SPI模式下MMC/SD卡驱动，可识别MMC/SD卡类型
(0003) //版本号：Ver1.0
(0004) //编译环境：ICCAVR 7.22A
(0005) //作者：www.avrgcc.com
(0006) //时间：2010.08.01
(0007) //******************************************************************************  
(0008) 
(0009) #include <SD.h>           //配置头文件，配置CS片选信号等，根据硬件调整相关IO口
(0010) #include <math.h>
(0011) 
(0012) /***********************************************************************
(0013) 函数功能：MMC/SD卡初始化
(0014) 操作内容：1、拉高CS片选和MOSI至少74个时钟周期
(0015)           2、SPI发送10个FF
(0016) ***********************************************************************/
(0017) uint8 initMMC (void)
(0018) {
(0019)   int i;
(0020)   spiInit();                          //初始化SPI接口，准备与MMC/SD卡通信
    01129 940E 156F CALL	_spiInit
(0021)  
(0022)   MMC_CS_DDR |= (1<<MMC_CS_PIN);      //MMC/SD卡片选IO设置输出模式
    0112B 9180 0064 LDS	R24,0x64
    0112D 6088      ORI	R24,0x8
    0112E 9380 0064 STS	0x64,R24
(0023)   CS_HIGH();                          //MMC/SD卡片选IO设置为1，拉高   
    01130 9180 0065 LDS	R24,0x65
    01132 6088      ORI	R24,0x8
    01133 9380 0065 STS	0x65,R24
(0024)  for(i=0;i<=9;i++)
    01135 2744      CLR	R20
    01136 2755      CLR	R21
(0025)   spiSendByte(0xff);                  //上电后进行一个延时，至少74个时钟周期
    01137 EF0F      LDI	R16,0xFF
    01138 940E 1583 CALL	_spiSendByte
    0113A 5F4F      SUBI	R20,0xFF
    0113B 4F5F      SBCI	R21,0xFF
    0113C E089      LDI	R24,0x9
    0113D E090      LDI	R25,0
    0113E 1784      CP	R24,R20
    0113F 0795      CPC	R25,R21
    01140 F7B4      BGE	0x1137
(0026)   return (mmcGoIdle());
    01141 D003      RCALL	_mmcGoIdle
    01142 9159      LD	R21,Y+
    01143 9149      LD	R20,Y+
    01144 9508      RET
_mmcGoIdle:
  sdcard               --> R20
  response             --> R22
  i                    --> R10
    01145 940E 1B2C CALL	push_xgsetF03C
    01147 9723      SBIW	R28,3
(0027) }
(0028) 
(0029) /***********************************************************************
(0030) 函数功能：MMC/SD卡空闲模式及初始化
(0031) 操作内容：1、初始化MMC/SD卡工作在SPI模式，无论MMC还是SD卡都发送CMD0进行复位
(0032)           2、判断MMC卡还是SD卡
(0033)           3、SD卡循环10次发送CMD55+ACMD41，MMC卡发送CMD1
(0034) ***********************************************************************/
(0035) uint8 mmcGoIdle()
(0036) {
(0037)   uint8 response=0x01;
    01148 E061      LDI	R22,1
(0038)   uint8 i;
(0039)   uint8 sdcard=0x00;                               //SD卡标志位，为0表示SD卡，为1表示为MMC卡
    01149 2744      CLR	R20
(0040)   CS_LOW();                                        //选中MMC/SD卡，拉低片选，进入SPI模式，默认为MMC/SD模式
    0114A 9180 0065 LDS	R24,0x65
    0114C 7F87      ANDI	R24,0xF7
    0114D 9380 0065 STS	0x65,R24
(0041)   mmcSendCmd(MMC_GO_IDLE_STATE,0,0x95);            //发送CMD0，复位MMC/SD卡，0x95为CRC值
    0114F E985      LDI	R24,0x95
    01150 838A      STD	Y+2,R24
    01151 E080      LDI	R24,0
    01152 E090      LDI	R25,0
    01153 E0A0      LDI	R26,0
    01154 E0B0      LDI	R27,0
    01155 83A8      ST	Y,R26
    01156 83B9      STD	Y+1,R27
    01157 019C      MOVW	R18,R24
    01158 E400      LDI	R16,0x40
    01159 D22F      RCALL	_mmcSendCmd
(0042) 
(0043)   if(mmcGetResponse()!=0x01)                       //CMD0命令的返回值为0x01则继续下一个命令
    0115A D05F      RCALL	_mmcGetResponse
    0115B 3001      CPI	R16,1
    0115C F409      BNE	0x115E
    0115D C04D      RJMP	0x11AB
(0044)     return MMC_INIT_ERROR;
    0115E E004      LDI	R16,4
    0115F C057      RJMP	0x11B7
(0045) 
(0046)   while(response==0x01)
(0047)   {
(0048)     CS_HIGH();
    01160 9180 0065 LDS	R24,0x65
    01162 6088      ORI	R24,0x8
    01163 9380 0065 STS	0x65,R24
(0049)     spiSendByte(0xff);
    01165 EF0F      LDI	R16,0xFF
    01166 940E 1583 CALL	_spiSendByte
(0050)     CS_LOW();
    01168 9180 0065 LDS	R24,0x65
    0116A 7F87      ANDI	R24,0xF7
    0116B 9380 0065 STS	0x65,R24
(0051)   if(sdcard==0x00)                                //先识别是否为SD卡，发送SD卡命令CMD55+ACMD41
    0116D 2344      TST	R20
    0116E F571      BNE	0x119D
(0052)   {
(0053)    for(i=0;i<10;i++)                              //循环10次，如果为SD卡，一般2次即可正确返回0x00
    0116F 24AA      CLR	R10
    01170 C028      RJMP	0x1199
(0054)    {
(0055)     mmcSendCmd(SD_APP_COND,0x00,0xff);            //发送SD卡CMD55命令，接下来应用激活初始化命令ACMD41
    01171 EF8F      LDI	R24,0xFF
    01172 838A      STD	Y+2,R24
    01173 E080      LDI	R24,0
    01174 E090      LDI	R25,0
    01175 E0A0      LDI	R26,0
    01176 E0B0      LDI	R27,0
    01177 83A8      ST	Y,R26
    01178 83B9      STD	Y+1,R27
    01179 019C      MOVW	R18,R24
    0117A E707      LDI	R16,0x77
    0117B D20D      RCALL	_mmcSendCmd
(0056)     while(mmcGetResponse()!=0x01);                //返回值为0x01，则表示处于空闲状态，再发ACMD41命令
    0117C D03D      RCALL	_mmcGetResponse
    0117D 3001      CPI	R16,1
    0117E F7E9      BNE	0x117C
(0057)     
(0058)     mmcSendCmd(SD_APP_OP_COND,0x00,0xff);         //发送ACMD41命令，激活初始化
    0117F EF8F      LDI	R24,0xFF
    01180 838A      STD	Y+2,R24
    01181 E080      LDI	R24,0
    01182 E090      LDI	R25,0
    01183 E0A0      LDI	R26,0
    01184 E0B0      LDI	R27,0
    01185 83A8      ST	Y,R26
    01186 83B9      STD	Y+1,R27
    01187 019C      MOVW	R18,R24
    01188 E609      LDI	R16,0x69
    01189 D1FF      RCALL	_mmcSendCmd
(0059)     if(mmcGetResponse()==0x00)                    //返回值为0x00，则初始化成功，否则使用MMC命令CMD1继续初始化
    0118A D02F      RCALL	_mmcGetResponse
    0118B 2EC0      MOV	R12,R16
    0118C 2300      TST	R16
    0118D F451      BNE	0x1198
(0060)      {
(0061)       CS_HIGH();
    0118E 9180 0065 LDS	R24,0x65
    01190 6088      ORI	R24,0x8
    01191 9380 0065 STS	0x65,R24
(0062)       spiSendByte(0xff);
    01193 EF0F      LDI	R16,0xFF
    01194 940E 1583 CALL	_spiSendByte
(0063)       return (MMC_SUCCESS);                       //返回初始化成功代码
    01196 2700      CLR	R16
    01197 C01F      RJMP	0x11B7
    01198 94A3      INC	R10
    01199 2D8A      MOV	R24,R10
    0119A 308A      CPI	R24,0xA
    0119B F2A8      BCS	0x1171
(0064)      }
(0065)    }
(0066)    sdcard=0x01;                                   //为1表示SD卡命令无效，卡为MMC卡，准备下面发送CMD1命令
    0119C E041      LDI	R20,1
(0067)   }
(0068)     response=0x01;                                //准备发送MMC卡命令CMD1
(0069)     mmcSendCmd(MMC_SEND_OP_COND,0x00,0xff);       //发送MMC卡CMD1命令，成功则返回0x00
    0119D EF8F      LDI	R24,0xFF
    0119E 838A      STD	Y+2,R24
    0119F E080      LDI	R24,0
    011A0 E090      LDI	R25,0
    011A1 E0A0      LDI	R26,0
    011A2 E0B0      LDI	R27,0
    011A3 83A8      ST	Y,R26
    011A4 83B9      STD	Y+1,R27
    011A5 019C      MOVW	R18,R24
    011A6 E401      LDI	R16,0x41
    011A7 D1E1      RCALL	_mmcSendCmd
(0070)     response=mmcGetResponse();                    //返回值为0x00，则表示MMC卡初始化成功
    011A8 D011      RCALL	_mmcGetResponse
    011A9 2EA0      MOV	R10,R16
    011AA 2D6A      MOV	R22,R10
    011AB 3061      CPI	R22,1
    011AC F409      BNE	0x11AE
    011AD CFB2      RJMP	0x1160
(0071)   }
(0072)   
(0073)   CS_HIGH();                                      //MMC/SD卡片选无效
    011AE 9180 0065 LDS	R24,0x65
    011B0 6088      ORI	R24,0x8
    011B1 9380 0065 STS	0x65,R24
(0074)   spiSendByte(0xff);
    011B3 EF0F      LDI	R16,0xFF
    011B4 940E 1583 CALL	_spiSendByte
(0075)   return (MMC_SUCCESS);                           //返回初始化成功代码
    011B6 2700      CLR	R16
    011B7 9623      ADIW	R28,3
    011B8 940C 1B35 JMP	pop_xgsetF03C
_mmcGetResponse:
  i                    --> R22
  response             --> R20
    011BA 940E 1B06 CALL	push_xgsetF000
(0076) }
(0077) 
(0078) /***********************************************************************
(0079) 函数功能：MMC/SD卡发送命令后返回的响应值
(0080) 操作内容：1、SPI模式下响应值长度1~8bytes，参考SD卡手册关于响应值的描述
(0081)           2、响应值最高位总是为0，紧跟着为错误代码
(0082)           3、如果响应值为FF，则表示命令无效或超时
(0083) ***********************************************************************/
(0084) uint8 mmcGetResponse(void)
(0085) {
(0086)   int i=0;
    011BC 2766      CLR	R22
    011BD 2777      CLR	R23
    011BE C00C      RJMP	0x11CB
(0087)   uint8 response;
(0088) 
(0089)   while(i<=64)
(0090)   {
(0091)     response=spiSendByte(0xff);
    011BF EF0F      LDI	R16,0xFF
    011C0 940E 1583 CALL	_spiSendByte
    011C2 2F40      MOV	R20,R16
(0092)     if(response==0x00)break;
    011C3 2300      TST	R16
    011C4 F409      BNE	0x11C6
    011C5 C00A      RJMP	0x11D0
(0093)     if(response==0x01)break;
    011C6 3041      CPI	R20,1
    011C7 F409      BNE	0x11C9
    011C8 C007      RJMP	0x11D0
(0094)     i++;
    011C9 5F6F      SUBI	R22,0xFF
    011CA 4F7F      SBCI	R23,0xFF
    011CB E480      LDI	R24,0x40
    011CC E090      LDI	R25,0
    011CD 1786      CP	R24,R22
    011CE 0797      CPC	R25,R23
    011CF F77C      BGE	0x11BF
(0095)   }
(0096)   return response;
    011D0 2F04      MOV	R16,R20
    011D1 940C 1B0B JMP	pop_xgsetF000
_mmcGetXXResponse:
  response             --> R10
  i                    --> R20
  resp                 --> R12
    011D3 940E 1B1E CALL	push_xgset303C
    011D5 2EC0      MOV	R12,R16
(0097) }
(0098) 
(0099) /***********************************************************************
(0100) 函数功能：MMC/SD卡发送读写数据命令后返回的响应值
(0101) 操作内容：1、SPI模式下响应值长度1~8bytes，参考SD卡手册关于响应值的描述
(0102)           2、响应值最高位总是为0，紧跟着为错误代码
(0103)           3、响应之前，数据一直为0xff
(0104) ***********************************************************************/
(0105) 
(0106) uint8 mmcGetXXResponse(uint8 resp)
(0107) {
(0108)   int i=0;
    011D6 2744      CLR	R20
    011D7 2755      CLR	R21
    011D8 C009      RJMP	0x11E2
(0109)   uint8 response;
(0110) 
(0111)   while(i<=1000)
(0112)   {
(0113)     response=spiSendByte(0xff);
    011D9 EF0F      LDI	R16,0xFF
    011DA 940E 1583 CALL	_spiSendByte
    011DC 2EA0      MOV	R10,R16
(0114)     if(response==resp)break;
    011DD 150C      CP	R16,R12
    011DE F409      BNE	0x11E0
    011DF C007      RJMP	0x11E7
(0115)     i++;
    011E0 5F4F      SUBI	R20,0xFF
    011E1 4F5F      SBCI	R21,0xFF
    011E2 EE88      LDI	R24,0xE8
    011E3 E093      LDI	R25,3
    011E4 1784      CP	R24,R20
    011E5 0795      CPC	R25,R21
    011E6 F794      BGE	0x11D9
(0116)   }
(0117)   return response;
    011E7 2D0A      MOV	R16,R10
    011E8 940C 1B25 JMP	pop_xgset303C
_mmcCheckBusy:
  rvalue               --> R10
  i                    --> R22
  response             --> R20
    011EA 940E 1B10 CALL	push_xgsetF00C
(0118) }
(0119) 
(0120) /***********************************************************************
(0121) 函数功能：MMC/SD卡判忙程序
(0122) 操作内容：1、SPI模式下响应值长度1~8bytes，参考SD卡手册关于响应值的描述
(0123)           2、响应值最高位总是为0，紧跟着为错误代码
(0124)           3、如果响应值为FF，则表示命令无效或超时
(0125)           4、进行数据块写入的时候，写入数据后都会有响应值，定义了错误代码
(0126) ***********************************************************************/
(0127) 
(0128) uint8 mmcCheckBusy(void)
(0129) {
(0130) 
(0131)   int i=0;
    011EC 2766      CLR	R22
    011ED 2777      CLR	R23
    011EE C027      RJMP	0x1216
(0132) 
(0133)   uint8 response;
(0134)   uint8 rvalue;
(0135)   while(i<=64)
(0136)   {
(0137)     response=spiSendByte(0xff);
    011EF EF0F      LDI	R16,0xFF
    011F0 940E 1583 CALL	_spiSendByte
    011F2 2F40      MOV	R20,R16
(0138)     response &= 0x1f;
    011F3 714F      ANDI	R20,0x1F
(0139)     switch(response)
    011F4 2EA4      MOV	R10,R20
    011F5 24BB      CLR	R11
    011F6 01C5      MOVW	R24,R10
    011F7 3E85      CPI	R24,0xE5
    011F8 E0E0      LDI	R30,0
    011F9 079E      CPC	R25,R30
    011FA F071      BEQ	0x1209
    011FB 3E85      CPI	R24,0xE5
    011FC E0E0      LDI	R30,0
    011FD 079E      CPC	R25,R30
    011FE F084      BLT	0x120F
    011FF 01C5      MOVW	R24,R10
    01200 3E8B      CPI	R24,0xEB
    01201 E0E0      LDI	R30,0
    01202 079E      CPC	R25,R30
    01203 F039      BEQ	0x120B
    01204 3E8D      CPI	R24,0xED
    01205 E0E0      LDI	R30,0
    01206 079E      CPC	R25,R30
    01207 F029      BEQ	0x120D
    01208 C006      RJMP	0x120F
(0140)     {
(0141)       case 0xe5: rvalue=MMC_SUCCESS;break;      //表示MMC/SD卡正确成功接收数据
    01209 24AA      CLR	R10
    0120A C006      RJMP	0x1211
(0142)       case 0xeb: return(MMC_CRC_ERROR);         //表示CRC校验错误，数据被拒绝
    0120B E100      LDI	R16,0x10
    0120C C019      RJMP	0x1226
(0143)       case 0xed: return(MMC_WRITE_ERROR);       //表示MMC/SD卡写错误，数据被拒绝
    0120D E101      LDI	R16,0x11
    0120E C017      RJMP	0x1226
(0144)       default:
(0145)         rvalue = MMC_OTHER_ERROR;               //其他错误
    0120F E182      LDI	R24,0x12
    01210 2EA8      MOV	R10,R24
(0146)         break;
(0147)     }
(0148)     if(rvalue==MMC_SUCCESS)break;
    01211 20AA      TST	R10
    01212 F409      BNE	0x1214
    01213 C007      RJMP	0x121B
(0149)     i++;
    01214 5F6F      SUBI	R22,0xFF
    01215 4F7F      SBCI	R23,0xFF
    01216 E480      LDI	R24,0x40
    01217 E090      LDI	R25,0
    01218 1786      CP	R24,R22
    01219 0797      CPC	R25,R23
    0121A F6A4      BGE	0x11EF
(0150)   }
(0151)   i=0;
    0121B 2766      CLR	R22
    0121C 2777      CLR	R23
(0152)   do
(0153)   {
(0154)     response=spiSendByte(0xff);
    0121D EF0F      LDI	R16,0xFF
    0121E 940E 1583 CALL	_spiSendByte
    01220 2F40      MOV	R20,R16
(0155)     i++;
    01221 5F6F      SUBI	R22,0xFF
    01222 4F7F      SBCI	R23,0xFF
(0156)   }while(response==0);
    01223 2344      TST	R20
    01224 F3C1      BEQ	0x121D
(0157)   return response;
    01225 2F04      MOV	R16,R20
    01226 940C 1B17 JMP	pop_xgsetF00C
_mmcEreaseBlock:
  response             --> R10
  Sector               --> Y,+9
    01228 940E 19E4 CALL	push_arg4
    0122A 940E 1B10 CALL	push_xgsetF00C
    0122C 9723      SBIW	R28,3
(0158) }
(0159) 
(0160) /***********************************************************************
(0161) 函数功能：MMC/SD卡数据擦除函数
(0162) 操作内容：1、包括读取的地址、长度以及存入的缓冲区
(0163) 		  2、数据擦除需要设定块区间，没有直接全盘擦除命令
(0164)           3、数据后面是16位CRC值
(0165) 		  4、块大小要大于512个字节，擦除后数据可能是0x00或0xff
(0166) ***********************************************************************/
(0167) uint8 mmcEreaseBlock(uint32 Sector)
(0168) {
(0169) 	uint8 response=0x01;
    0122D 24AA      CLR	R10
    0122E 94A3      INC	R10
(0170) 
(0171)     CS_LOW ();
    0122F 9180 0065 LDS	R24,0x65
    01231 7F87      ANDI	R24,0xF7
    01232 9380 0065 STS	0x65,R24
(0172) 	
(0173) 	mmcSendCmd(MMC_TAG_SECTOR_START,Sector*512,0xff);         //需要擦除的起始地址
    01234 EF8F      LDI	R24,0xFF
    01235 838A      STD	Y+2,R24
    01236 8429      LDD	R2,Y+9
    01237 843A      LDD	R3,Y+10
    01238 844B      LDD	R4,Y+11
    01239 845C      LDD	R5,Y+12
    0123A E040      LDI	R20,0
    0123B E052      LDI	R21,2
    0123C E060      LDI	R22,0
    0123D E070      LDI	R23,0
    0123E 925A      ST	-Y,R5
    0123F 924A      ST	-Y,R4
    01240 923A      ST	-Y,R3
    01241 922A      ST	-Y,R2
    01242 018A      MOVW	R16,R20
    01243 019B      MOVW	R18,R22
    01244 940E 1A9D CALL	empy32u|empy32s
    01246 8328      ST	Y,R18
    01247 8339      STD	Y+1,R19
    01248 0198      MOVW	R18,R16
    01249 E600      LDI	R16,0x60
    0124A D13E      RCALL	_mmcSendCmd
(0174) 
(0175) 	mmcSendCmd(MMC_TAG_SECTOR_END,(Sector+1)*512,0xff);       //需要擦除的结束地址
    0124B EF8F      LDI	R24,0xFF
    0124C 838A      STD	Y+2,R24
    0124D E041      LDI	R20,1
    0124E E050      LDI	R21,0
    0124F E060      LDI	R22,0
    01250 E070      LDI	R23,0
    01251 8429      LDD	R2,Y+9
    01252 843A      LDD	R3,Y+10
    01253 844B      LDD	R4,Y+11
    01254 845C      LDD	R5,Y+12
    01255 0E24      ADD	R2,R20
    01256 1E35      ADC	R3,R21
    01257 1E46      ADC	R4,R22
    01258 1E57      ADC	R5,R23
    01259 E040      LDI	R20,0
    0125A E052      LDI	R21,2
    0125B E060      LDI	R22,0
    0125C E070      LDI	R23,0
    0125D 925A      ST	-Y,R5
    0125E 924A      ST	-Y,R4
    0125F 923A      ST	-Y,R3
    01260 922A      ST	-Y,R2
    01261 018A      MOVW	R16,R20
    01262 019B      MOVW	R18,R22
    01263 940E 1A9D CALL	empy32u|empy32s
    01265 8328      ST	Y,R18
    01266 8339      STD	Y+1,R19
    01267 0198      MOVW	R18,R16
    01268 E601      LDI	R16,0x61
    01269 D11F      RCALL	_mmcSendCmd
(0176) 
(0177) 	mmcSendCmd(MMC_EREASE,0x00,0xff);                         //发送块擦除命令，使用CMD38命令    
    0126A EF8F      LDI	R24,0xFF
    0126B 838A      STD	Y+2,R24
    0126C E040      LDI	R20,0
    0126D E050      LDI	R21,0
    0126E E060      LDI	R22,0
    0126F E070      LDI	R23,0
    01270 8368      ST	Y,R22
    01271 8379      STD	Y+1,R23
    01272 019A      MOVW	R18,R20
    01273 E606      LDI	R16,0x66
    01274 D114      RCALL	_mmcSendCmd
(0178)  
(0179)   while(mmcGetResponse()!=0);
    01275 DF44      RCALL	_mmcGetResponse
    01276 2300      TST	R16
    01277 F7E9      BNE	0x1275
(0180) 
(0181)     response=0;
    01278 24AA      CLR	R10
(0182)   
(0183) 	CS_HIGH();
    01279 9180 0065 LDS	R24,0x65
    0127B 6088      ORI	R24,0x8
    0127C 9380 0065 STS	0x65,R24
(0184) 	
(0185) 	return response;
    0127E 2D0A      MOV	R16,R10
    0127F 9623      ADIW	R28,3
    01280 940E 1B17 CALL	pop_xgsetF00C
    01282 9624      ADIW	R28,4
    01283 9508      RET
_mmcReadBlock:
  rvalue               --> R10
  i                    --> Y,+3
  pBuffer              --> R14
  count                --> Y,+21
  address              --> Y,+17
    01284 940E 19E4 CALL	push_arg4
    01286 940E 1AF1 CALL	push_xgsetF0FC
    01288 9727      SBIW	R28,7
    01289 88EF      LDD	R14,Y+23
    0128A 8CF8      LDD	R15,Y+24
(0186) }
(0187) 
(0188) 
(0189) /***********************************************************************
(0190) 函数功能：MMC/SD卡单块数据读取
(0191) 操作内容：1、包括读取的地址、长度以及存入的缓冲区
(0192) 		  2、块大小可以设置，若为512，可以认为是一个标准扇区大小
(0193)           3、数据后面是16位CRC值
(0194) ***********************************************************************/
(0195) 
(0196) uint8 mmcReadBlock(uint32 address, uint16 count, uint8 *pBuffer)
(0197) {
(0198)   unsigned long i = 0;
    0128B E080      LDI	R24,0
    0128C 838B      STD	Y+3,R24
    0128D 838C      STD	Y+4,R24
    0128E 838D      STD	Y+5,R24
    0128F 838E      STD	Y+6,R24
(0199)   uint8 rvalue = MMC_RESPONSE_ERROR;
    01290 E082      LDI	R24,2
    01291 2EA8      MOV	R10,R24
(0200) 
(0201)   if (mmcSetBlockLength (count) == MMC_SUCCESS)  //设置MMC/SD卡块长度,全局变量BlockLength
    01292 890D      LDD	R16,Y+21
    01293 891E      LDD	R17,Y+22
    01294 D132      RCALL	_mmcSetBlockLength
    01295 2300      TST	R16
    01296 F009      BEQ	0x1298
    01297 C060      RJMP	0x12F8
(0202)   {
(0203) 
(0204)     CS_LOW ();
    01298 9180 0065 LDS	R24,0x65
    0129A 7F87      ANDI	R24,0xF7
    0129B 9380 0065 STS	0x65,R24
(0205) 
(0206)     mmcSendCmd (MMC_READ_SINGLE_BLOCK,address*512, 0xFF); //发送读单块操作命令CMD17，实际地址是扇区号numSector*512
    0129D EF8F      LDI	R24,0xFF
    0129E 838A      STD	Y+2,R24
    0129F 8829      LDD	R2,Y+17
    012A0 883A      LDD	R3,Y+18
    012A1 884B      LDD	R4,Y+19
    012A2 885C      LDD	R5,Y+20
    012A3 E040      LDI	R20,0
    012A4 E052      LDI	R21,2
    012A5 E060      LDI	R22,0
    012A6 E070      LDI	R23,0
    012A7 925A      ST	-Y,R5
    012A8 924A      ST	-Y,R4
    012A9 923A      ST	-Y,R3
    012AA 922A      ST	-Y,R2
    012AB 018A      MOVW	R16,R20
    012AC 019B      MOVW	R18,R22
    012AD 940E 1A9D CALL	empy32u|empy32s
    012AF 8328      ST	Y,R18
    012B0 8339      STD	Y+1,R19
    012B1 0198      MOVW	R18,R16
    012B2 E501      LDI	R16,0x51
    012B3 D0D5      RCALL	_mmcSendCmd
(0207)     if (mmcGetResponse() == 0x00)                         //返回值为00，表示发送命令被成功接收
    012B4 DF05      RCALL	_mmcGetResponse
    012B5 2300      TST	R16
    012B6 F009      BEQ	0x12B8
    012B7 C03D      RJMP	0x12F5
(0208)     {
(0209)       if (mmcGetXXResponse(MMC_START_DATA_BLOCK_TOKEN) == MMC_START_DATA_BLOCK_TOKEN) //接收数据包开始标志，为0xfe
    012B8 EF0E      LDI	R16,0xFE
    012B9 DF19      RCALL	_mmcGetXXResponse
    012BA 2EC0      MOV	R12,R16
    012BB 2D8C      MOV	R24,R12
    012BC 3F0E      CPI	R16,0xFE
    012BD F5A1      BNE	0x12F2
(0210)       {
(0211)         for (i = 0; i < count; i++)
    012BE E080      LDI	R24,0
    012BF 838B      STD	Y+3,R24
    012C0 838C      STD	Y+4,R24
    012C1 838D      STD	Y+5,R24
    012C2 838E      STD	Y+6,R24
    012C3 C019      RJMP	0x12DD
(0212)           pBuffer[i] = spiSendByte(0xff);   // 接收读出的数据
    012C4 EF0F      LDI	R16,0xFF
    012C5 940E 1583 CALL	_spiSendByte
    012C7 2EC0      MOV	R12,R16
    012C8 81EB      LDD	R30,Y+3
    012C9 81FC      LDD	R31,Y+4
    012CA 0DEE      ADD	R30,R14
    012CB 1DFF      ADC	R31,R15
    012CC 82C0      ST	Z,R12
    012CD E041      LDI	R20,1
    012CE E050      LDI	R21,0
    012CF E060      LDI	R22,0
    012D0 E070      LDI	R23,0
    012D1 802B      LDD	R2,Y+3
    012D2 803C      LDD	R3,Y+4
    012D3 804D      LDD	R4,Y+5
    012D4 805E      LDD	R5,Y+6
    012D5 0E24      ADD	R2,R20
    012D6 1E35      ADC	R3,R21
    012D7 1E46      ADC	R4,R22
    012D8 1E57      ADC	R5,R23
    012D9 822B      STD	Y+3,R2
    012DA 823C      STD	Y+4,R3
    012DB 824D      STD	Y+5,R4
    012DC 825E      STD	Y+6,R5
    012DD 882D      LDD	R2,Y+21
    012DE 883E      LDD	R3,Y+22
    012DF 2444      CLR	R4
    012E0 2455      CLR	R5
    012E1 806B      LDD	R6,Y+3
    012E2 807C      LDD	R7,Y+4
    012E3 808D      LDD	R8,Y+5
    012E4 809E      LDD	R9,Y+6
    012E5 1462      CP	R6,R2
    012E6 0473      CPC	R7,R3
    012E7 0484      CPC	R8,R4
    012E8 0495      CPC	R9,R5
    012E9 F2D0      BCS	0x12C4
(0213) 
(0214)         spiSendByte(0xff);                  //16位CRC值
    012EA EF0F      LDI	R16,0xFF
    012EB 940E 1583 CALL	_spiSendByte
(0215)         spiSendByte(0xff);                  //16位CRC值，不是真正的CRC值，这里忽略，但是实际数据后面跟16位CRC值
    012ED EF0F      LDI	R16,0xFF
    012EE 940E 1583 CALL	_spiSendByte
(0216)         rvalue = MMC_SUCCESS;               //接收成功，返回成功代码
    012F0 24AA      CLR	R10
(0217)       }
    012F1 C008      RJMP	0x12FA
(0218)       else
(0219)       {
(0220)         rvalue = MMC_DATA_TOKEN_ERROR;      // 如果没有收到数据包的开始标志，则返回错误代码
    012F2 E083      LDI	R24,3
    012F3 2EA8      MOV	R10,R24
(0221)       }
(0222)     }
    012F4 C005      RJMP	0x12FA
(0223)     else
(0224)     {
(0225)       rvalue = MMC_RESPONSE_ERROR;          //返回命令未成功接收错误代码
    012F5 E082      LDI	R24,2
    012F6 2EA8      MOV	R10,R24
(0226)     }
(0227)   }
    012F7 C002      RJMP	0x12FA
(0228)   else
(0229)   {
(0230)     rvalue = MMC_BLOCK_SET_ERROR;           //返回卡块长度设置失败错误代码
    012F8 24AA      CLR	R10
    012F9 94A3      INC	R10
(0231)   }
(0232)   CS_HIGH ();
    012FA 9180 0065 LDS	R24,0x65
    012FC 6088      ORI	R24,0x8
    012FD 9380 0065 STS	0x65,R24
(0233)   spiSendByte(0xff);
    012FF EF0F      LDI	R16,0xFF
    01300 940E 1583 CALL	_spiSendByte
(0234)   return rvalue;                            //返回读取函数代码
    01302 2D0A      MOV	R16,R10
    01303 9627      ADIW	R28,7
    01304 940E 1AE6 CALL	pop_xgsetF0FC
    01306 9624      ADIW	R28,4
    01307 9508      RET
_mmcWriteBlock:
  rvalue               --> R10
  i                    --> Y,+3
  pBuffer              --> R14
  count                --> R12
  address              --> Y,+17
    01308 940E 19E4 CALL	push_arg4
    0130A 940E 1AF1 CALL	push_xgsetF0FC
    0130C 9727      SBIW	R28,7
    0130D 88CD      LDD	R12,Y+21
    0130E 88DE      LDD	R13,Y+22
    0130F 88EF      LDD	R14,Y+23
    01310 8CF8      LDD	R15,Y+24
(0235) }
(0236) 
(0237) 
(0238) 
(0239) /***********************************************************************
(0240) 函数功能：MMC/SD卡单块数据写入
(0241) 操作内容：1、包括读取的地址、长度以及存入的缓冲区
(0242) 		  2、块大小可以设置，若为512，可以认为是一个标准扇区大小
(0243)           3、数据后面是16位CRC值
(0244) ***********************************************************************/
(0245) 
(0246) uint8 mmcWriteBlock(uint32 address, uint16 count, uint8 *pBuffer)
(0247) {
(0248)   unsigned long i = 0;
    01311 E080      LDI	R24,0
    01312 838B      STD	Y+3,R24
    01313 838C      STD	Y+4,R24
    01314 838D      STD	Y+5,R24
    01315 838E      STD	Y+6,R24
(0249)   uint8 rvalue = MMC_RESPONSE_ERROR;         
    01316 E082      LDI	R24,2
    01317 2EA8      MOV	R10,R24
(0250) 
(0251)   if (mmcSetBlockLength (count) == MMC_SUCCESS)    //设置MMC/SD块的长度，全局变量BlockLength
    01318 0186      MOVW	R16,R12
    01319 D0AD      RCALL	_mmcSetBlockLength
    0131A 2300      TST	R16
    0131B F009      BEQ	0x131D
    0131C C05C      RJMP	0x1379
(0252)   {
(0253)     CS_LOW ();									   //拉低片选信号，多个卡，选择需要操作的片选拉低
    0131D 9180 0065 LDS	R24,0x65
    0131F 7F87      ANDI	R24,0xF7
    01320 9380 0065 STS	0x65,R24
(0254)     mmcSendCmd (MMC_WRITE_BLOCK,address*512, 0xFF);//发送单块写数据命令CMD24，地址为扇区numSector*512
    01322 EF8F      LDI	R24,0xFF
    01323 838A      STD	Y+2,R24
    01324 8829      LDD	R2,Y+17
    01325 883A      LDD	R3,Y+18
    01326 884B      LDD	R4,Y+19
    01327 885C      LDD	R5,Y+20
    01328 E040      LDI	R20,0
    01329 E052      LDI	R21,2
    0132A E060      LDI	R22,0
    0132B E070      LDI	R23,0
    0132C 925A      ST	-Y,R5
    0132D 924A      ST	-Y,R4
    0132E 923A      ST	-Y,R3
    0132F 922A      ST	-Y,R2
    01330 018A      MOVW	R16,R20
    01331 019B      MOVW	R18,R22
    01332 940E 1A9D CALL	empy32u|empy32s
    01334 8328      ST	Y,R18
    01335 8339      STD	Y+1,R19
    01336 0198      MOVW	R18,R16
    01337 E508      LDI	R16,0x58
    01338 D050      RCALL	_mmcSendCmd
(0255) 
(0256)     if (mmcGetXXResponse(MMC_R1_RESPONSE) == MMC_R1_RESPONSE) //收到返回值，检查MMC/SD卡是否正确接收命令
    01339 2700      CLR	R16
    0133A DE98      RCALL	_mmcGetXXResponse
    0133B 2300      TST	R16
    0133C F009      BEQ	0x133E
    0133D C038      RJMP	0x1376
(0257)     {
(0258)       spiSendByte(0xff);
    0133E EF0F      LDI	R16,0xFF
    0133F 940E 1583 CALL	_spiSendByte
(0259)       spiSendByte(0xfe);                           //发送数据起始标志0xfe，表示接下来是数据包，一个块长度的数据
    01341 EF0E      LDI	R16,0xFE
    01342 940E 1583 CALL	_spiSendByte
(0260) 
(0261)       for (i = 0; i < count; i++)                  //写一个块长度的数据到MMC/SD卡
    01344 E080      LDI	R24,0
    01345 838B      STD	Y+3,R24
    01346 838C      STD	Y+4,R24
    01347 838D      STD	Y+5,R24
    01348 838E      STD	Y+6,R24
    01349 C017      RJMP	0x1361
(0262)         spiSendByte(pBuffer[i]);            
    0134A 81EB      LDD	R30,Y+3
    0134B 81FC      LDD	R31,Y+4
    0134C 0DEE      ADD	R30,R14
    0134D 1DFF      ADC	R31,R15
    0134E 8100      LD	R16,Z
    0134F 940E 1583 CALL	_spiSendByte
    01351 E041      LDI	R20,1
    01352 E050      LDI	R21,0
    01353 E060      LDI	R22,0
    01354 E070      LDI	R23,0
    01355 802B      LDD	R2,Y+3
    01356 803C      LDD	R3,Y+4
    01357 804D      LDD	R4,Y+5
    01358 805E      LDD	R5,Y+6
    01359 0E24      ADD	R2,R20
    0135A 1E35      ADC	R3,R21
    0135B 1E46      ADC	R4,R22
    0135C 1E57      ADC	R5,R23
    0135D 822B      STD	Y+3,R2
    0135E 823C      STD	Y+4,R3
    0135F 824D      STD	Y+5,R4
    01360 825E      STD	Y+6,R5
    01361 0116      MOVW	R2,R12
    01362 2444      CLR	R4
    01363 2455      CLR	R5
    01364 806B      LDD	R6,Y+3
    01365 807C      LDD	R7,Y+4
    01366 808D      LDD	R8,Y+5
    01367 809E      LDD	R9,Y+6
    01368 1462      CP	R6,R2
    01369 0473      CPC	R7,R3
    0136A 0484      CPC	R8,R4
    0136B 0495      CPC	R9,R5
    0136C F2E8      BCS	0x134A
(0263) 
(0264)       spiSendByte(0xff);                           //传送16位CRC值，不是必须的，可以不用些真实CRC值
    0136D EF0F      LDI	R16,0xFF
    0136E 940E 1583 CALL	_spiSendByte
(0265)       spiSendByte(0xff);
    01370 EF0F      LDI	R16,0xFF
    01371 940E 1583 CALL	_spiSendByte
(0266)       mmcCheckBusy();                              //MMC/SD卡判忙，返回参数参考对应函数，这里不存取
    01373 DE76      RCALL	_mmcCheckBusy
(0267)       rvalue = MMC_SUCCESS;                        //操作成功
    01374 24AA      CLR	R10
(0268)     }
    01375 C005      RJMP	0x137B
(0269)     else
(0270)     {
(0271)       rvalue = MMC_RESPONSE_ERROR;   			   //接收命令失败，返回错误代码
    01376 E082      LDI	R24,2
    01377 2EA8      MOV	R10,R24
(0272)     }
(0273)   }
    01378 C002      RJMP	0x137B
(0274)   else
(0275)   {
(0276)     rvalue = MMC_BLOCK_SET_ERROR;                  //设置块长度失败，返回错误代码
    01379 24AA      CLR	R10
    0137A 94A3      INC	R10
(0277)   }
(0278) 
(0279)   CS_HIGH ();                                      //拉高片选，释放SD卡
    0137B 9180 0065 LDS	R24,0x65
    0137D 6088      ORI	R24,0x8
    0137E 9380 0065 STS	0x65,R24
(0280)   spiSendByte(0xff);                               //小延时
    01380 EF0F      LDI	R16,0xFF
    01381 940E 1583 CALL	_spiSendByte
(0281)   return rvalue;                                   //函数状态返回值
    01383 2D0A      MOV	R16,R10
    01384 9627      ADIW	R28,7
    01385 940E 1AE6 CALL	pop_xgsetF0FC
    01387 9624      ADIW	R28,4
    01388 9508      RET
_mmcSendCmd:
  temp                 --> R12
  frame                --> Y,+0
  i                    --> R20
  crc                  --> R10
  data                 --> Y,+12
  cmd                  --> R20
    01389 933A      ST	-Y,R19
    0138A 932A      ST	-Y,R18
    0138B 940E 1B1E CALL	push_xgset303C
    0138D 2F40      MOV	R20,R16
    0138E 9726      SBIW	R28,6
    0138F 88A8      LDD	R10,Y+16
(0282) } 
(0283) 
(0284) /***********************************************************************
(0285) 函数功能：MMC/SD卡命令发送函数
(0286) 操作内容：1、发送整个长度为48位的MMC/SD卡命令
(0287) 		  2、实际命令长度是6位，48位中还包括命令的参数，不同命令参数不同
(0288) ***********************************************************************/
(0289) 
(0290) void mmcSendCmd (uint8 cmd, uint32 data, uint8 crc)
(0291) {
(0292)   uint8 frame[6];                                  //MMC/SD卡命令长度为48位,6个字节
(0293)   uint8 temp;
(0294)   int i;
(0295)   frame[0]=(cmd|0x40);                             //命令格式中最高的两位为01，对于单字节来说，"或"上0x40
    01390 2F84      MOV	R24,R20
    01391 6480      ORI	R24,0x40
    01392 8388      ST	Y,R24
(0296)   for(i=3;i>=0;i--)                                //4个字节长度的参数，或没有，或为地址，不同命令下参数不同
    01393 E043      LDI	R20,3
    01394 E050      LDI	R21,0
(0297)   	{
(0298)     	temp=(uint8)(data>>(8*i));
    01395 011A      MOVW	R2,R20
    01396 0C22      LSL	R2
    01397 1C33      ROL	R3
    01398 0C22      LSL	R2
    01399 1C33      ROL	R3
    0139A 0C22      LSL	R2
    0139B 1C33      ROL	R3
    0139C 850C      LDD	R16,Y+12
    0139D 851D      LDD	R17,Y+13
    0139E 852E      LDD	R18,Y+14
    0139F 853F      LDD	R19,Y+15
    013A0 922A      ST	-Y,R2
    013A1 940E 1B8F CALL	lsr32
    013A3 2EC0      MOV	R12,R16
(0299)     	frame[4-i]=(temp);
    013A4 E0E4      LDI	R30,4
    013A5 E0F0      LDI	R31,0
    013A6 1BE4      SUB	R30,R20
    013A7 0BF5      SBC	R31,R21
    013A8 01CE      MOVW	R24,R28
    013A9 0FE8      ADD	R30,R24
    013AA 1FF9      ADC	R31,R25
    013AB 82C0      ST	Z,R12
    013AC 5041      SUBI	R20,1
    013AD 4050      SBCI	R21,0
    013AE 3040      CPI	R20,0
    013AF E0E0      LDI	R30,0
    013B0 075E      CPC	R21,R30
    013B1 F71C      BGE	0x1395
(0300)   	}
(0301)   frame[5]=(crc);                                  //1个字节的CRC值
    013B2 82AD      STD	Y+5,R10
(0302)   for(i=0;i<6;i++)
    013B3 2744      CLR	R20
    013B4 2755      CLR	R21
(0303)     	spiSendByte(frame[i]);                     //传送命令
    013B5 01CE      MOVW	R24,R28
    013B6 01FA      MOVW	R30,R20
    013B7 0FE8      ADD	R30,R24
    013B8 1FF9      ADC	R31,R25
    013B9 8100      LD	R16,Z
    013BA 940E 1583 CALL	_spiSendByte
    013BC 5F4F      SUBI	R20,0xFF
    013BD 4F5F      SBCI	R21,0xFF
    013BE 3046      CPI	R20,6
    013BF E0E0      LDI	R30,0
    013C0 075E      CPC	R21,R30
    013C1 F39C      BLT	0x13B5
    013C2 9626      ADIW	R28,6
    013C3 940E 1B25 CALL	pop_xgset303C
    013C5 9622      ADIW	R28,2
    013C6 9508      RET
_mmcSetBlockLength:
  blocklength          --> R10
    013C7 92AA      ST	-Y,R10
    013C8 92BA      ST	-Y,R11
    013C9 0158      MOVW	R10,R16
    013CA 9723      SBIW	R28,3
(0304) }
(0305) 
(0306) /**********************************************************************
(0307) 函数功能：MMC/SD卡块长度设置
(0308) 操作内容：1、设置块长度，必须为2^n大小，一般为512
(0309) 		  2、对于RAM小的单片机，可以定义小的块长度，这样节省数据空间
(0310) ***********************************************************************/
(0311) 
(0312) uint8 mmcSetBlockLength (uint16 blocklength)
(0313) {
(0314) 
(0315)   CS_LOW ();                                       //选中SD卡片选信号
    013CB 9180 0065 LDS	R24,0x65
    013CD 7F87      ANDI	R24,0xF7
    013CE 9380 0065 STS	0x65,R24
(0316)   mmcSendCmd(MMC_SET_BLOCKLEN, blocklength, 0xFF); //传送设置块长度命令CMD16
    013D0 EF8F      LDI	R24,0xFF
    013D1 838A      STD	Y+2,R24
    013D2 0115      MOVW	R2,R10
    013D3 2444      CLR	R4
    013D4 2455      CLR	R5
    013D5 8248      ST	Y,R4
    013D6 8259      STD	Y+1,R5
    013D7 0191      MOVW	R18,R2
    013D8 E500      LDI	R16,0x50
    013D9 DFAF      RCALL	_mmcSendCmd
(0317)   if(mmcGetResponse()!=0x00)                       //命令传送不成功，则重新复位MMC/SD卡，然后重新设置
    013DA DDDF      RCALL	_mmcGetResponse
    013DB 2300      TST	R16
    013DC F061      BEQ	0x13E9
(0318)   	{ 
(0319)   		initMMC();
    013DD DD49      RCALL	_initMMC
(0320)     	mmcSendCmd(MMC_SET_BLOCKLEN, blocklength, 0xFF);
    013DE EF8F      LDI	R24,0xFF
    013DF 838A      STD	Y+2,R24
    013E0 0115      MOVW	R2,R10
    013E1 2444      CLR	R4
    013E2 2455      CLR	R5
    013E3 8248      ST	Y,R4
    013E4 8259      STD	Y+1,R5
    013E5 0191      MOVW	R18,R2
    013E6 E500      LDI	R16,0x50
    013E7 DFA1      RCALL	_mmcSendCmd
(0321)     	mmcGetResponse();
    013E8 DDD1      RCALL	_mmcGetResponse
(0322)   	}
(0323) 
(0324)   CS_HIGH ();                                      //释放MMC/SD卡
    013E9 9180 0065 LDS	R24,0x65
    013EB 6088      ORI	R24,0x8
    013EC 9380 0065 STS	0x65,R24
(0325)  
(0326)   spiSendByte(0xff);                               //8个时钟的延时
    013EE EF0F      LDI	R16,0xFF
    013EF 940E 1583 CALL	_spiSendByte
(0327) 
(0328)   return MMC_SUCCESS;                              //返回操作成功命令
    013F1 2700      CLR	R16
    013F2 9623      ADIW	R28,3
    013F3 90B9      LD	R11,Y+
    013F4 90A9      LD	R10,Y+
    013F5 9508      RET
_mmcReadRegister:
  rvalue               --> R20
  i                    --> R10
  pBuffer              --> R14
  length               --> R12
  cmd_register         --> R22
    013F6 940E 1AF1 CALL	push_xgsetF0FC
    013F8 2EC2      MOV	R12,R18
    013F9 2F60      MOV	R22,R16
    013FA 9723      SBIW	R28,3
    013FB 84ED      LDD	R14,Y+13
    013FC 84FE      LDD	R15,Y+14
(0329) } 
(0330) 
(0331) /**********************************************************************
(0332) 函数功能：读CSD或者CID寄存器值
(0333) 操作内容：1、CSD和CID寄存器记录了卡的相关信息
(0334) 		  2、可以通过CSD卡获取卡的容量
(0335) ***********************************************************************/
(0336) 
(0337) uint8 mmcReadRegister (uint8 cmd_register, uint8 length, uint8 *pBuffer)
(0338) {
(0339)   uint8 i = 0;
    013FD 24AA      CLR	R10
(0340)   uint8 rvalue = MMC_TIMEOUT_ERROR;
    013FE EF4F      LDI	R20,0xFF
(0341) 
(0342)   if (mmcSetBlockLength (length) == MMC_SUCCESS)   //设置块长度
    013FF 2D0C      MOV	R16,R12
    01400 2711      CLR	R17
    01401 DFC5      RCALL	_mmcSetBlockLength
    01402 2300      TST	R16
    01403 F009      BEQ	0x1405
    01404 C036      RJMP	0x143B
(0343)   {
(0344)     CS_LOW ();
    01405 9180 0065 LDS	R24,0x65
    01407 7F87      ANDI	R24,0xF7
    01408 9380 0065 STS	0x65,R24
(0345) 
(0346)     mmcSendCmd(cmd_register, 0x00, 0xff);          //发送对寄存器操作命令
    0140A EF8F      LDI	R24,0xFF
    0140B 838A      STD	Y+2,R24
    0140C E080      LDI	R24,0
    0140D E090      LDI	R25,0
    0140E E0A0      LDI	R26,0
    0140F E0B0      LDI	R27,0
    01410 83A8      ST	Y,R26
    01411 83B9      STD	Y+1,R27
    01412 019C      MOVW	R18,R24
    01413 2F06      MOV	R16,R22
    01414 DF74      RCALL	_mmcSendCmd
(0347) 
(0348)     if (mmcGetResponse() == 0x00)                  //返回成功代码
    01415 DDA4      RCALL	_mmcGetResponse
    01416 2300      TST	R16
    01417 F4D1      BNE	0x1432
(0349)     {
(0350)       if (mmcGetXXResponse(MMC_START_DATA_BLOCK_TOKEN)==MMC_START_DATA_BLOCK_TOKEN) //数据起始标志位，0xfe
    01418 EF0E      LDI	R16,0xFE
    01419 DDB9      RCALL	_mmcGetXXResponse
    0141A 2F60      MOV	R22,R16
    0141B 3F0E      CPI	R16,0xFE
    0141C F469      BNE	0x142A
(0351)         for (i = 0; i < length; i++)
    0141D C00A      RJMP	0x1428
(0352)           pBuffer[i] = spiSendByte(0xff);          //读取数据，即寄存器的值
    0141E EF0F      LDI	R16,0xFF
    0141F 940E 1583 CALL	_spiSendByte
    01421 2F60      MOV	R22,R16
    01422 2DEA      MOV	R30,R10
    01423 27FF      CLR	R31
    01424 0DEE      ADD	R30,R14
    01425 1DFF      ADC	R31,R15
    01426 8360      ST	Z,R22
    01427 94A3      INC	R10
    01428 14AC      CP	R10,R12
    01429 F3A0      BCS	0x141E
(0353)       spiSendByte(0xff);                           //16位CRC值，不是必须的
    0142A EF0F      LDI	R16,0xFF
    0142B 940E 1583 CALL	_spiSendByte
(0354)       spiSendByte(0xff);
    0142D EF0F      LDI	R16,0xFF
    0142E 940E 1583 CALL	_spiSendByte
(0355)       rvalue = MMC_SUCCESS;                        //返回成功代码
    01430 2744      CLR	R20
(0356)     }
    01431 C001      RJMP	0x1433
(0357)     else
(0358)       rvalue = MMC_RESPONSE_ERROR;                 //操作命令不成功，返回错误代码
    01432 E042      LDI	R20,2
(0359) 
(0360)     CS_HIGH ();                                    //释放MMC/SD卡
    01433 9180 0065 LDS	R24,0x65
    01435 6088      ORI	R24,0x8
    01436 9380 0065 STS	0x65,R24
(0361) 
(0362)     spiSendByte(0xff);							   //延时8个时钟周期
    01438 EF0F      LDI	R16,0xFF
    01439 940E 1583 CALL	_spiSendByte
(0363)   }
(0364)   CS_HIGH ();                                      //释放MMC/SD卡
    0143B 9180 0065 LDS	R24,0x65
    0143D 6088      ORI	R24,0x8
    0143E 9380 0065 STS	0x65,R24
(0365)   return rvalue;                                   //返回状态值
    01440 2F04      MOV	R16,R20
    01441 9623      ADIW	R28,3
    01442 940C 1AE6 JMP	pop_xgsetF0FC
_MMC_ReadCardSize:
  response             --> R12
  mmc_READ_BL_LEN      --> Y,+10
  mmc_C_SIZE_MULT      --> Y,+9
  mmc_C_SIZE           --> Y,+7
  MMC_CardSize         --> Y,+3
  i                    --> R10
  b                    --> R10
  j                    --> R12
    01444 940E 1AF1 CALL	push_xgsetF0FC
    01446 972B      SBIW	R28,0xB
(0366) } 
(0367) 
(0368) /**********************************************************************
(0369) 函数功能：MMC/SD卡容量读取
(0370) 操作内容：1、先获取CSD寄存器数据
(0371) 		  2、根据容量计算公式获取容量大小
(0372) 		  3、容量大小为用户使用空间大小，不包括保护区
(0373) ***********************************************************************/
(0374) 
(0375) uint32 MMC_ReadCardSize(void)
(0376) {
(0377) 
(0378)   uint32 MMC_CardSize;
(0379)   uint16 i, j,b,response,mmc_C_SIZE=0;     
    01447 2400      CLR	R0
    01448 2411      CLR	R1
    01449 8618      STD	Y+8,R1
    0144A 820F      STD	Y+7,R0
(0380) 
(0381)   uint8 mmc_READ_BL_LEN=0;         				  //块大小
    0144B 860A      STD	Y+10,R0
(0382)   uint8 mmc_C_SIZE_MULT=0;         				  //乘数大小
    0144C 8609      STD	Y+9,R0
(0383) 
(0384)   CS_LOW ();
    0144D 9180 0065 LDS	R24,0x65
    0144F 7F87      ANDI	R24,0xF7
    01450 9380 0065 STS	0x65,R24
(0385)   
(0386)   mmcSendCmd(MMC_READ_CSD, 0x00, 0xff);			  //发送读取CSD寄存器命令CMD9
    01452 EF8F      LDI	R24,0xFF
    01453 838A      STD	Y+2,R24
    01454 E040      LDI	R20,0
    01455 E050      LDI	R21,0
    01456 E060      LDI	R22,0
    01457 E070      LDI	R23,0
    01458 8368      ST	Y,R22
    01459 8379      STD	Y+1,R23
    0145A 019A      MOVW	R18,R20
    0145B E409      LDI	R16,0x49
    0145C DF2C      RCALL	_mmcSendCmd
(0387) 
(0388)   response = mmcGetResponse();
    0145D DD5C      RCALL	_mmcGetResponse
    0145E 2EC0      MOV	R12,R16
    0145F 24DD      CLR	R13
(0389) 
(0390)   b = spiSendByte(0xFF);                          //读取返回值，数据开始标志总是0xfe
    01460 EF0F      LDI	R16,0xFF
    01461 940E 1583 CALL	_spiSendByte
    01463 2EA0      MOV	R10,R16
    01464 24BB      CLR	R11
(0391) 
(0392)   if( !response )
    01465 20CC      TST	R12
    01466 F009      BEQ	0x1468
    01467 C096      RJMP	0x14FE
    01468 20DD      TST	R13
    01469 F009      BEQ	0x146B
    0146A C093      RJMP	0x14FE
(0393)   {
    0146B C006      RJMP	0x1472
(0394)     while (b != 0xfe) b = spiSendByte(0xff);      //等待接收到数据起始标志位
    0146C EF0F      LDI	R16,0xFF
    0146D 940E 1583 CALL	_spiSendByte
    0146F 2EC0      MOV	R12,R16
    01470 2CAC      MOV	R10,R12
    01471 24BB      CLR	R11
    01472 01C5      MOVW	R24,R10
    01473 3F8E      CPI	R24,0xFE
    01474 E0E0      LDI	R30,0
    01475 079E      CPC	R25,R30
    01476 F7A9      BNE	0x146C
(0395) 
(0396)     for(j=5; j>0; j--)                            //前5个字节的数据不用，Bit[127:88]
    01477 E085      LDI	R24,5
    01478 E090      LDI	R25,0
    01479 016C      MOVW	R12,R24
    0147A C009      RJMP	0x1484
(0397)       b = spiSendByte(0xff);
    0147B EF0F      LDI	R16,0xFF
    0147C 940E 1583 CALL	_spiSendByte
    0147E 2EE0      MOV	R14,R16
    0147F 2CAE      MOV	R10,R14
    01480 24BB      CLR	R11
    01481 01C6      MOVW	R24,R12
    01482 9701      SBIW	R24,1
    01483 016C      MOVW	R12,R24
    01484 20CC      TST	R12
    01485 F7A9      BNE	0x147B
    01486 20DD      TST	R13
    01487 F799      BNE	0x147B
(0398) 
(0399)     b =spiSendByte(0xff);                         
    01488 EF0F      LDI	R16,0xFF
    01489 940E 1583 CALL	_spiSendByte
    0148B 2EE0      MOV	R14,R16
    0148C 2CAE      MOV	R10,R14
    0148D 24BB      CLR	R11
(0400)     mmc_READ_BL_LEN = b & 0x0F;                   //Bit[83:80]记录了块大小，参考CSD寄存器相关说明
    0148E 01C5      MOVW	R24,R10
    0148F 708F      ANDI	R24,0xF
    01490 7090      ANDI	R25,0
    01491 878A      STD	Y+10,R24
(0401) 
(0402)     b = spiSendByte(0xff);
    01492 EF0F      LDI	R16,0xFF
    01493 940E 1583 CALL	_spiSendByte
    01495 2EE0      MOV	R14,R16
    01496 2CAE      MOV	R10,R14
    01497 24BB      CLR	R11
(0403) 
(0404)     mmc_C_SIZE = (b & 0x03) << 10;               //Bit[73:62]记录了C_SIZE的大小，参考CSD寄存器说明
    01498 E02A      LDI	R18,0xA
    01499 E030      LDI	R19,0
    0149A 0185      MOVW	R16,R10
    0149B 7003      ANDI	R16,3
    0149C 7010      ANDI	R17,0
    0149D 940E 1B75 CALL	lsl16
    0149F 8718      STD	Y+8,R17
    014A0 830F      STD	Y+7,R16
(0405)     b = spiSendByte(0xff);
    014A1 EF0F      LDI	R16,0xFF
    014A2 940E 1583 CALL	_spiSendByte
    014A4 2EE0      MOV	R14,R16
    014A5 2CAE      MOV	R10,R14
    014A6 24BB      CLR	R11
(0406)     mmc_C_SIZE += b << 2;
    014A7 0115      MOVW	R2,R10
    014A8 0C22      LSL	R2
    014A9 1C33      ROL	R3
    014AA 0C22      LSL	R2
    014AB 1C33      ROL	R3
    014AC 800F      LDD	R0,Y+7
    014AD 8418      LDD	R1,Y+8
    014AE 0C02      ADD	R0,R2
    014AF 1C13      ADC	R1,R3
    014B0 8618      STD	Y+8,R1
    014B1 820F      STD	Y+7,R0
(0407)     b = spiSendByte(0xff);
    014B2 EF0F      LDI	R16,0xFF
    014B3 940E 1583 CALL	_spiSendByte
    014B5 2EE0      MOV	R14,R16
    014B6 2CAE      MOV	R10,R14
    014B7 24BB      CLR	R11
(0408)     mmc_C_SIZE += b >> 6;
    014B8 E026      LDI	R18,6
    014B9 E030      LDI	R19,0
    014BA 0185      MOVW	R16,R10
    014BB 940E 1B88 CALL	lsr16
    014BD 800F      LDD	R0,Y+7
    014BE 8418      LDD	R1,Y+8
    014BF 0E00      ADD	R0,R16
    014C0 1E11      ADC	R1,R17
    014C1 8618      STD	Y+8,R1
    014C2 820F      STD	Y+7,R0
(0409) 
(0410)     b = spiSendByte(0xff);
    014C3 EF0F      LDI	R16,0xFF
    014C4 940E 1583 CALL	_spiSendByte
    014C6 2EE0      MOV	R14,R16
    014C7 2CAE      MOV	R10,R14
    014C8 24BB      CLR	R11
(0411) 
(0412) 
(0413)     mmc_C_SIZE_MULT = (b & 0x03) << 1;           //Bit[49:47]记录了乘数的大小
    014C9 01C5      MOVW	R24,R10
    014CA 7083      ANDI	R24,3
    014CB 7090      ANDI	R25,0
    014CC 011C      MOVW	R2,R24
    014CD 0C22      LSL	R2
    014CE 1C33      ROL	R3
    014CF 8629      STD	Y+9,R2
(0414)     b = spiSendByte(0xff);
    014D0 EF0F      LDI	R16,0xFF
    014D1 940E 1583 CALL	_spiSendByte
    014D3 2EE0      MOV	R14,R16
    014D4 2CAE      MOV	R10,R14
    014D5 24BB      CLR	R11
(0415)     mmc_C_SIZE_MULT += b >> 7;
    014D6 E027      LDI	R18,7
    014D7 E030      LDI	R19,0
    014D8 0185      MOVW	R16,R10
    014D9 940E 1B88 CALL	lsr16
    014DB 8429      LDD	R2,Y+9
    014DC 2433      CLR	R3
    014DD 0E20      ADD	R2,R16
    014DE 1E31      ADC	R3,R17
    014DF 8629      STD	Y+9,R2
(0416) 
(0417) 
(0418)     b = spiSendByte(0xff);                       //之后的数据与容量无关
    014E0 EF0F      LDI	R16,0xFF
    014E1 940E 1583 CALL	_spiSendByte
    014E3 2EE0      MOV	R14,R16
    014E4 2CAE      MOV	R10,R14
    014E5 24BB      CLR	R11
(0419) 
(0420)     b = spiSendByte(0xff);
    014E6 EF0F      LDI	R16,0xFF
    014E7 940E 1583 CALL	_spiSendByte
    014E9 2EE0      MOV	R14,R16
    014EA 2CAE      MOV	R10,R14
    014EB 24BB      CLR	R11
(0421) 
(0422)     b = spiSendByte(0xff);
    014EC EF0F      LDI	R16,0xFF
    014ED 940E 1583 CALL	_spiSendByte
    014EF 2EE0      MOV	R14,R16
    014F0 2CAE      MOV	R10,R14
    014F1 24BB      CLR	R11
(0423) 
(0424)     b = spiSendByte(0xff);
    014F2 EF0F      LDI	R16,0xFF
    014F3 940E 1583 CALL	_spiSendByte
    014F5 2EE0      MOV	R14,R16
    014F6 2CAE      MOV	R10,R14
    014F7 24BB      CLR	R11
(0425) 
(0426)     b = spiSendByte(0xff);
    014F8 EF0F      LDI	R16,0xFF
    014F9 940E 1583 CALL	_spiSendByte
    014FB 2EE0      MOV	R14,R16
    014FC 2CAE      MOV	R10,R14
    014FD 24BB      CLR	R11
(0427) 
(0428)   }
(0429) 
(0430)   for(j=4; j>0; j--)          					// 主机至少保持32个时钟周期的SCK
    014FE E084      LDI	R24,4
    014FF E090      LDI	R25,0
    01500 016C      MOVW	R12,R24
    01501 C009      RJMP	0x150B
(0431)     b = spiSendByte(0xff);  					 
    01502 EF0F      LDI	R16,0xFF
    01503 940E 1583 CALL	_spiSendByte
    01505 2EE0      MOV	R14,R16
    01506 2CAE      MOV	R10,R14
    01507 24BB      CLR	R11
    01508 01C6      MOVW	R24,R12
    01509 9701      SBIW	R24,1
    0150A 016C      MOVW	R12,R24
    0150B 20CC      TST	R12
    0150C F7A9      BNE	0x1502
    0150D 20DD      TST	R13
    0150E F799      BNE	0x1502
(0432)                                					
(0433)   b = spiSendByte(0xff);
    0150F EF0F      LDI	R16,0xFF
    01510 940E 1583 CALL	_spiSendByte
    01512 2EE0      MOV	R14,R16
    01513 2CAE      MOV	R10,R14
    01514 24BB      CLR	R11
(0434)   CS_LOW ();
    01515 9180 0065 LDS	R24,0x65
    01517 7F87      ANDI	R24,0xF7
    01518 9380 0065 STS	0x65,R24
(0435) 
(0436)   MMC_CardSize = (mmc_C_SIZE + 1);              //卡容量计算，参考容量计算公式
    0151A 818F      LDD	R24,Y+7
    0151B 8598      LDD	R25,Y+8
    0151C 9601      ADIW	R24,1
    0151D 011C      MOVW	R2,R24
    0151E 2444      CLR	R4
    0151F 2455      CLR	R5
    01520 822B      STD	Y+3,R2
    01521 823C      STD	Y+4,R3
    01522 824D      STD	Y+5,R4
    01523 825E      STD	Y+6,R5
(0437) 
(0438)   for(i = 2,j=mmc_C_SIZE_MULT+2; j>1; j--)      //容量大小：块长度×块数量，不含保护区，一般保护区为总大小的1%
    01524 E082      LDI	R24,2
    01525 E090      LDI	R25,0
    01526 015C      MOVW	R10,R24
    01527 8589      LDD	R24,Y+9
    01528 2799      CLR	R25
    01529 9602      ADIW	R24,2
    0152A 016C      MOVW	R12,R24
    0152B C005      RJMP	0x1531
(0439)     i <<= 1;
    0152C 0CAA      LSL	R10
    0152D 1CBB      ROL	R11
    0152E 01C6      MOVW	R24,R12
    0152F 9701      SBIW	R24,1
    01530 016C      MOVW	R12,R24
    01531 E081      LDI	R24,1
    01532 E090      LDI	R25,0
    01533 158C      CP	R24,R12
    01534 059D      CPC	R25,R13
    01535 F3B0      BCS	0x152C
(0440)   MMC_CardSize *= i;
    01536 0115      MOVW	R2,R10
    01537 2444      CLR	R4
    01538 2455      CLR	R5
    01539 810B      LDD	R16,Y+3
    0153A 811C      LDD	R17,Y+4
    0153B 812D      LDD	R18,Y+5
    0153C 813E      LDD	R19,Y+6
    0153D 925A      ST	-Y,R5
    0153E 924A      ST	-Y,R4
    0153F 923A      ST	-Y,R3
    01540 922A      ST	-Y,R2
    01541 940E 1A9D CALL	empy32u|empy32s
    01543 830B      STD	Y+3,R16
    01544 831C      STD	Y+4,R17
    01545 832D      STD	Y+5,R18
    01546 833E      STD	Y+6,R19
(0441) 
(0442)   for(i = 2,j=mmc_READ_BL_LEN; j>1; j--)
    01547 E082      LDI	R24,2
    01548 E090      LDI	R25,0
    01549 015C      MOVW	R10,R24
    0154A 84CA      LDD	R12,Y+10
    0154B 24DD      CLR	R13
    0154C C005      RJMP	0x1552
(0443)     i <<= 1;
    0154D 0CAA      LSL	R10
    0154E 1CBB      ROL	R11
    0154F 01C6      MOVW	R24,R12
    01550 9701      SBIW	R24,1
    01551 016C      MOVW	R12,R24
    01552 E081      LDI	R24,1
    01553 E090      LDI	R25,0
    01554 158C      CP	R24,R12
    01555 059D      CPC	R25,R13
    01556 F3B0      BCS	0x154D
(0444)   MMC_CardSize *= i;
    01557 0115      MOVW	R2,R10
    01558 2444      CLR	R4
    01559 2455      CLR	R5
    0155A 810B      LDD	R16,Y+3
    0155B 811C      LDD	R17,Y+4
    0155C 812D      LDD	R18,Y+5
    0155D 813E      LDD	R19,Y+6
    0155E 925A      ST	-Y,R5
    0155F 924A      ST	-Y,R4
    01560 923A      ST	-Y,R3
    01561 922A      ST	-Y,R2
    01562 940E 1A9D CALL	empy32u|empy32s
    01564 830B      STD	Y+3,R16
    01565 831C      STD	Y+4,R17
    01566 832D      STD	Y+5,R18
    01567 833E      STD	Y+6,R19
(0445) 
(0446)   return MMC_CardSize;                        //返回容量值大小，单位为字节
    01568 810B      LDD	R16,Y+3
    01569 811C      LDD	R17,Y+4
    0156A 812D      LDD	R18,Y+5
    0156B 813E      LDD	R19,Y+6
    0156C 962B      ADIW	R28,0xB
    0156D 940C 1AE6 JMP	pop_xgsetF0FC
FILE: E:\DMAVR-~3\FAT-NE~1\SPI.c
(0001) //**********************************************************************
(0002) //SD卡读写中SPI接口相关函数V1.0
(0003) //编译环境：AVR Studio 4.17 + WinAVR 20100110
(0004) //作者：http://www.avrgcc.com
(0005) //时间：2010.08.01
(0006) //版权：版权所有，转载请注明
(0007) //**********************************************************************
(0008) 
(0009) //**********************************************************************
(0010) //              相关头文件
(0011) //**********************************************************************
(0012) 
(0013) #include <iom128v.h>
(0014) //#include <user/spi.h">
(0015) 
(0016) typedef unsigned char uint8;
(0017) typedef unsigned int uint16;
(0018) typedef unsigned long uint32;
(0019) 
(0020) volatile uint8 spiTransferComplete;  //传输完成标志
(0021) 
(0022) //**********************************************************************
(0023) //              函数声明
(0024) //**********************************************************************
(0025) 
(0026) void   spiInit(void);
(0027) uint8  spiSendByte(uint8 data);
(0028) uint16 spiTransferWord(uint16 data);
(0029) 
(0030) /***********************************************************************
(0031) 函数功能：SPI采用中断的中断函数
(0032) 操作内容：传输完成标志置1
(0033) ***********************************************************************/
(0034) 
(0035) #ifdef SPI_USEINT
(0036) SIGNAL(SIG_SPI)
(0037) {
(0038) 	spiTransferComplete = 1;
(0039) }
(0040) #endif
(0041) 
(0042) /***********************************************************************
(0043) 函数功能：SPI初始化
(0044) 操作内容：1、设置端口输入输出属性
(0045) 		  2、设置SPI接口相关寄存器
(0046)           3、支持常用AVR单片机接口，兼容性增强，可扩展
(0047) ***********************************************************************/
(0048) 
(0049) void spiInit()
(0050) {
(0051)    
(0052) 
(0053) 	PORTB |= (1 << PB1);  //设置SCK为1
_spiInit:
    0156F 9AC1      SBI	0x18,1
(0054)     DDRB |= (1<<DDB1);    //设置SCK为输出
    01570 9AB9      SBI	0x17,1
(0055) 	DDRB &= ~(1<<DDB3);   //设置MISO为输入
    01571 98BB      CBI	0x17,3
(0056) 	DDRB |= (1<<DDB2);    //设置MOSI为输出
    01572 9ABA      SBI	0x17,2
(0057) 	DDRB |= (1<<DDB0);    //主机模式下，设置SS为输出，可以控制SPI外设的片选信号
    01573 9AB8      SBI	0x17,0
(0058)     PORTB |= (1 << PB0);  //拉高SS信号
    01574 9AC0      SBI	0x18,0
(0059) 
(0060)     SPCR = (1<<MSTR)| (1<<SPR1) | (1<<SPE);  //SPI允许，主机模式，数据MSB在前，16分频
    01575 E582      LDI	R24,0x52
    01576 B98D      OUT	0x0D,R24
(0061) 	
(0062) 	spiTransferComplete = 1;
    01577 E081      LDI	R24,1
    01578 9380 0887 STS	spiTransferComplete,R24
    0157A 9508      RET
(0063) 
(0064) 
(0065) }
(0066) 
(0067) /***********************************************************************
(0068) 函数功能：SPI低速模式
(0069) 操作内容：1、晶振64分频
(0070) 		  2、非倍速模式
(0071) ***********************************************************************/
(0072) 
(0073) void spiLow(void)
(0074) {
(0075) 	 SPCR = (1<<MSTR)| (1<<SPR1) | (1<<SPE);  //SPI允许，主机模式，数据MSB在前，16分频
_spiLow:
    0157B E582      LDI	R24,0x52
    0157C B98D      OUT	0x0D,R24
(0076) 	 SPSR &= ~(1<<SPI2X);                     //SPI2X为0，非倍速模式
    0157D 9870      CBI	0x0E,0
    0157E 9508      RET
(0077) }
(0078) 
(0079) /***********************************************************************
(0080) 函数功能：SPI倍速模式
(0081) 操作内容：1、晶振8分频
(0082) 		  2、倍速模式
(0083) ***********************************************************************/
(0084) 
(0085) void spiHigh(void)
(0086) {
(0087) 	SPCR = (1<<MSTR)| (1<<SPR0) | (1<<SPE);  //SPI允许，主机模式，数据MSB在前，8分频
_spiHigh:
    0157F E581      LDI	R24,0x51
    01580 B98D      OUT	0x0D,R24
(0088) 	SPSR |= (1<<SPI2X);                      //SPI2X为1，倍速模式
    01581 9A70      SBI	0x0E,0
    01582 9508      RET
(0089) }
(0090) 
(0091) /***********************************************************************
(0092) 函数功能：SPI字节传输函数
(0093) 操作内容：数据从SPDR读出或者读入
(0094) ***********************************************************************/
(0095) 
(0096) uint8 spiSendByte(uint8 data)
(0097) {
(0098) #ifdef SPI_USEINT                    //如果启用中断模式
(0099) 	while(!spiTransferComplete);
(0100) 	SPDR=data;                      //数据输出到SPDR
(0101) 	spiTransferComplete = 0;
(0102) #else
(0103)     SPDR=data;                      //数据输出到SPDR
_spiSendByte:
  data                 --> R16
    01583 B90F      OUT	0x0F,R16
(0104) 	while(!(SPSR & (1<<SPIF)));     //等待上次传输完成
    01584 9B77      SBIS	0x0E,7
    01585 CFFE      RJMP	0x1584
(0105) #endif
(0106)     return SPDR;                     //返回SPDR值
    01586 B10F      IN	R16,0x0F
    01587 9508      RET
_spiTransferWord:
  rxData               --> R10
  data                 --> R20
    01588 940E 1AFC CALL	push_xgset300C
    0158A 01A8      MOVW	R20,R16
(0107) 	
(0108) }
(0109) 
(0110) /***********************************************************************
(0111) 函数功能：SPI双字节传输函数
(0112) 操作内容：先传输高字节，再传输低字节
(0113) ***********************************************************************/
(0114) 
(0115) uint16 spiTransferWord(uint16 data)
(0116) {
(0117) 	uint16 rxData = 0;
(0118) 
(0119) 	rxData = (spiSendByte((data>>8) & 0x00FF))<<8;   //先传输高字节
    0158B 018A      MOVW	R16,R20
    0158C 2F01      MOV	R16,R17
    0158D 2711      CLR	R17
    0158E 7010      ANDI	R17,0
    0158F DFF3      RCALL	_spiSendByte
    01590 2EA0      MOV	R10,R16
    01591 24BB      CLR	R11
    01592 2CBA      MOV	R11,R10
    01593 24AA      CLR	R10
(0120) 	rxData |= (spiSendByte(data & 0x00FF));          //再传输低字节
    01594 018A      MOVW	R16,R20
    01595 7010      ANDI	R17,0
    01596 DFEC      RCALL	_spiSendByte
    01597 2E20      MOV	R2,R16
    01598 2433      CLR	R3
    01599 28A2      OR	R10,R2
    0159A 28B3      OR	R11,R3
(0121) 	return rxData;
    0159B 0185      MOVW	R16,R10
    0159C 940C 1B01 JMP	pop_xgset300C
_putchar$device_specific$|_putchar:
  c                    --> R20
    0159E 934A      ST	-Y,R20
    0159F 2F40      MOV	R20,R16
FILE: E:\DMAVR-~3\FAT-NE~1\uart.c
(0001) //DMAVR-128的串口通信实验，通过getchar与printf输入和输出字符
(0002) //编译环境 ICCAVR 7.22A
(0003) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0004) //作者：www.avrgcc.com
(0005) //日期：2010.08.01
(0006) //***********************************************************************
(0007) //			包含文件
(0008) //***********************************************************************
(0009) #include <stdio.h>
(0010) #include <string.h>
(0011) #include <iom128v.h>
(0012) 
(0013) #define uchar           unsigned char
(0014) #define uint            unsigned int
(0015) #define ulong           unsigned long
(0016) #define	F_CPU		   7372800		 						    // 单片机主频为7.3728MHz
(0017) #define baud           9600                                     //设置波特率的大小
(0018) #define baud_setting   (uint)((ulong)F_CPU/(16*(ulong)baud)-1)  //波特率计算公式
(0019) #define baud_h         (uchar)(baud_setting>>8)                 //提取高位
(0020) #define baud_l         (uchar)(baud_setting)                    //低位
(0021) 
(0022) //***********************************************************************
(0023) // 用于输出的标准格式函数，用printf输出到UART1
(0024) //***********************************************************************
(0025) 
(0026) extern int _textmode;
(0027) 
(0028) int putchar(char c)
(0029)     {
(0030)     if (_textmode && c == '\n')
    015A0 9020 08A4 LDS	R2,_textmode
    015A2 9030 08A5 LDS	R3,_textmode+1
    015A4 2022      TST	R2
    015A5 F411      BNE	0x15A8
    015A6 2033      TST	R3
    015A7 F021      BEQ	0x15AC
    015A8 304A      CPI	R20,0xA
    015A9 F411      BNE	0x15AC
(0031)         putchar('\r');
    015AA E00D      LDI	R16,0xD
    015AB DFF2      RCALL	_putchar$device_specific$|_putchar
(0032)     while ( !(UCSR1A & (1<<UDRE1)) )   // UDRE, data register empty
    015AC 9020 009B LDS	R2,0x9B
    015AE FE25      SBRS	R2,5
    015AF CFFC      RJMP	0x15AC
(0033)         ;
(0034)     UDR1 = c;
    015B0 9340 009C STS	0x9C,R20
(0035)     return c;
    015B2 2F04      MOV	R16,R20
    015B3 2711      CLR	R17
    015B4 9149      LD	R20,Y+
    015B5 9508      RET
(0036)     }
(0037) //***********************************************************************
(0038) // 用于输入的标准格式函数，用getchar通过UART1输入到单片机，代替C中的scanf
(0039) //***********************************************************************
(0040) 
(0041) int getchar(void)
(0042)     {
(0043)     while ((UCSR1A & 0x80) == 0)
_getchar$device_specific$|_getchar:
    015B6 9020 009B LDS	R2,0x9B
    015B8 FE27      SBRS	R2,7
    015B9 CFFC      RJMP	_getchar$device_specific$|_getchar
(0044)         ;
(0045)     return UDR1;
    015BA 9100 009C LDS	R16,0x9C
    015BC 2711      CLR	R17
    015BD 9508      RET
(0046)     } 
(0047) //***********************************************************************
(0048) // 串口1初始化接口函数
(0049) // 初始化uart,查询方式读写
(0050) //***********************************************************************
(0051) void uartInit(void)
(0052) {
(0053)  
(0054)   UCSR1B =(1<<RXEN1)|(1<<TXEN1);             		//发送接收使能
_uartInit:
    015BE E188      LDI	R24,0x18
    015BF 9380 009A STS	0x9A,R24
(0055)   UBRR1H=baud_h;                                	//写波特率的值
    015C1 2422      CLR	R2
    015C2 9220 0098 STS	0x98,R2
(0056)   UBRR1L=baud_l; 
FILE: <library>
    015C4 E28F      LDI	R24,0x2F
    015C5 9380 0099 STS	0x99,R24
    015C7 9508      RET
__print:
    015C8 940E 19E4 CALL	push_arg4
    015CA 940E 1AF1 CALL	push_xgsetF0FC
    015CC 9762      SBIW	R28,0x12
    015CD 2400      CLR	R0
    015CE 2411      CLR	R1
    015CF 861D      STD	Y+13,R1
    015D0 860C      STD	Y+12,R0
    015D1 C3F9      RJMP	0x19CB
    015D2 8DEE      LDD	R30,Y+30
    015D3 8DFF      LDD	R31,Y+31
    015D4 8180      LD	R24,Z
    015D5 3285      CPI	R24,0x25
    015D6 F059      BEQ	0x15E2
    015D7 8100      LD	R16,Z
    015D8 8DEC      LDD	R30,Y+28
    015D9 8DFD      LDD	R31,Y+29
    015DA 940E 1B3E CALL	xicallx
    015DC 858C      LDD	R24,Y+12
    015DD 859D      LDD	R25,Y+13
    015DE 9601      ADIW	R24,1
    015DF 879D      STD	Y+13,R25
    015E0 878C      STD	Y+12,R24
    015E1 C3E4      RJMP	0x19C6
    015E2 2400      CLR	R0
    015E3 2411      CLR	R1
    015E4 861B      STD	Y+11,R1
    015E5 860A      STD	Y+10,R0
    015E6 EF8F      LDI	R24,0xFF
    015E7 EF9F      LDI	R25,0xFF
    015E8 879F      STD	Y+15,R25
    015E9 878E      STD	Y+14,R24
    015EA 2766      CLR	R22
    015EB 2777      CLR	R23
    015EC E848      LDI	R20,0x88
    015ED E058      LDI	R21,0x8
    015EE E280      LDI	R24,0x20
    015EF 2EC8      MOV	R12,R24
    015F0 8D8E      LDD	R24,Y+30
    015F1 8D9F      LDD	R25,Y+31
    015F2 9601      ADIW	R24,1
    015F3 8F9F      STD	Y+31,R25
    015F4 8F8E      STD	Y+30,R24
    015F5 24AA      CLR	R10
    015F6 24BB      CLR	R11
    015F7 8DEE      LDD	R30,Y+30
    015F8 8DFF      LDD	R31,Y+31
    015F9 80E0      LD	R14,Z
    015FA 24FF      CLR	R15
    015FB 01C7      MOVW	R24,R14
    015FC 3280      CPI	R24,0x20
    015FD E0E0      LDI	R30,0
    015FE 079E      CPC	R25,R30
    015FF F0F1      BEQ	0x161E
    01600 3283      CPI	R24,0x23
    01601 E0E0      LDI	R30,0
    01602 079E      CPC	R25,R30
    01603 F091      BEQ	0x1616
    01604 3280      CPI	R24,0x20
    01605 E0E0      LDI	R30,0
    01606 079E      CPC	R25,R30
    01607 F0E4      BLT	0x1624
    01608 01C7      MOVW	R24,R14
    01609 328B      CPI	R24,0x2B
    0160A E0E0      LDI	R30,0
    0160B 079E      CPC	R25,R30
    0160C F069      BEQ	0x161A
    0160D 328D      CPI	R24,0x2D
    0160E E0E0      LDI	R30,0
    0160F 079E      CPC	R25,R30
    01610 F039      BEQ	0x1618
    01611 3380      CPI	R24,0x30
    01612 E0E0      LDI	R30,0
    01613 079E      CPC	R25,R30
    01614 F069      BEQ	0x1622
    01615 C00E      RJMP	0x1624
    01616 6061      ORI	R22,1
    01617 C00F      RJMP	0x1627
    01618 6064      ORI	R22,4
    01619 C00D      RJMP	0x1627
    0161A 6068      ORI	R22,0x8
    0161B E28B      LDI	R24,0x2B
    0161C 2EC8      MOV	R12,R24
    0161D C009      RJMP	0x1627
    0161E 6068      ORI	R22,0x8
    0161F E280      LDI	R24,0x20
    01620 2EC8      MOV	R12,R24
    01621 C005      RJMP	0x1627
    01622 6160      ORI	R22,0x10
    01623 C003      RJMP	0x1627
    01624 E081      LDI	R24,1
    01625 E090      LDI	R25,0
    01626 015C      MOVW	R10,R24
    01627 20AA      TST	R10
    01628 F411      BNE	0x162B
    01629 20BB      TST	R11
    0162A F009      BEQ	0x162C
    0162B C006      RJMP	0x1632
    0162C 8D8E      LDD	R24,Y+30
    0162D 8D9F      LDD	R25,Y+31
    0162E 9601      ADIW	R24,1
    0162F 8F9F      STD	Y+31,R25
    01630 8F8E      STD	Y+30,R24
    01631 CFC5      RJMP	0x15F7
    01632 8DEE      LDD	R30,Y+30
    01633 8DFF      LDD	R31,Y+31
    01634 8100      LD	R16,Z
    01635 2711      CLR	R17
    01636 940E 206E CALL	_isdigit
    01638 3000      CPI	R16,0
    01639 0701      CPC	R16,R17
    0163A F0B9      BEQ	0x1652
    0163B 8D0E      LDD	R16,Y+30
    0163C 8D1F      LDD	R17,Y+31
    0163D 940E 1BC0 CALL	_atoi
    0163F 871B      STD	Y+11,R17
    01640 870A      STD	Y+10,R16
    01641 C005      RJMP	0x1647
    01642 8D8E      LDD	R24,Y+30
    01643 8D9F      LDD	R25,Y+31
    01644 9601      ADIW	R24,1
    01645 8F9F      STD	Y+31,R25
    01646 8F8E      STD	Y+30,R24
    01647 8DEE      LDD	R30,Y+30
    01648 8DFF      LDD	R31,Y+31
    01649 8100      LD	R16,Z
    0164A 2711      CLR	R17
    0164B 940E 206E CALL	_isdigit
    0164D 0158      MOVW	R10,R16
    0164E 3000      CPI	R16,0
    0164F 0701      CPC	R16,R17
    01650 F789      BNE	0x1642
    01651 C015      RJMP	0x1667
    01652 8DEE      LDD	R30,Y+30
    01653 8DFF      LDD	R31,Y+31
    01654 8180      LD	R24,Z
    01655 328A      CPI	R24,0x2A
    01656 F481      BNE	0x1667
    01657 A188      LDD	R24,Y+32
    01658 A199      LDD	R25,Y+33
    01659 9602      ADIW	R24,2
    0165A A399      STD	Y+33,R25
    0165B A388      STD	Y+32,R24
    0165C 01FC      MOVW	R30,R24
    0165D 9732      SBIW	R30,2
    0165E 8020      LD	R2,Z
    0165F 8031      LDD	R3,Z+1
    01660 863B      STD	Y+11,R3
    01661 862A      STD	Y+10,R2
    01662 8D8E      LDD	R24,Y+30
    01663 8D9F      LDD	R25,Y+31
    01664 9601      ADIW	R24,1
    01665 8F9F      STD	Y+31,R25
    01666 8F8E      STD	Y+30,R24
    01667 8DEE      LDD	R30,Y+30
    01668 8DFF      LDD	R31,Y+31
    01669 8180      LD	R24,Z
    0166A 328E      CPI	R24,0x2E
    0166B F009      BEQ	0x166D
    0166C C03A      RJMP	0x16A7
    0166D 01CF      MOVW	R24,R30
    0166E 9601      ADIW	R24,1
    0166F 8F9F      STD	Y+31,R25
    01670 8F8E      STD	Y+30,R24
    01671 01FC      MOVW	R30,R24
    01672 8100      LD	R16,Z
    01673 2711      CLR	R17
    01674 940E 206E CALL	_isdigit
    01676 0158      MOVW	R10,R16
    01677 3000      CPI	R16,0
    01678 0701      CPC	R16,R17
    01679 F0C1      BEQ	0x1692
    0167A 8D0E      LDD	R16,Y+30
    0167B 8D1F      LDD	R17,Y+31
    0167C 940E 1BC0 CALL	_atoi
    0167E 0158      MOVW	R10,R16
    0167F 86BF      STD	Y+15,R11
    01680 86AE      STD	Y+14,R10
    01681 C005      RJMP	0x1687
    01682 8D8E      LDD	R24,Y+30
    01683 8D9F      LDD	R25,Y+31
    01684 9601      ADIW	R24,1
    01685 8F9F      STD	Y+31,R25
    01686 8F8E      STD	Y+30,R24
    01687 8DEE      LDD	R30,Y+30
    01688 8DFF      LDD	R31,Y+31
    01689 8100      LD	R16,Z
    0168A 2711      CLR	R17
    0168B 940E 206E CALL	_isdigit
    0168D 0158      MOVW	R10,R16
    0168E 3000      CPI	R16,0
    0168F 0701      CPC	R16,R17
    01690 F789      BNE	0x1682
    01691 C015      RJMP	0x16A7
    01692 8DEE      LDD	R30,Y+30
    01693 8DFF      LDD	R31,Y+31
    01694 8180      LD	R24,Z
    01695 328A      CPI	R24,0x2A
    01696 F481      BNE	0x16A7
    01697 A188      LDD	R24,Y+32
    01698 A199      LDD	R25,Y+33
    01699 9602      ADIW	R24,2
    0169A A399      STD	Y+33,R25
    0169B A388      STD	Y+32,R24
    0169C 01FC      MOVW	R30,R24
    0169D 9732      SBIW	R30,2
    0169E 8020      LD	R2,Z
    0169F 8031      LDD	R3,Z+1
    016A0 863F      STD	Y+15,R3
    016A1 862E      STD	Y+14,R2
    016A2 8D8E      LDD	R24,Y+30
    016A3 8D9F      LDD	R25,Y+31
    016A4 9601      ADIW	R24,1
    016A5 8F9F      STD	Y+31,R25
    016A6 8F8E      STD	Y+30,R24
    016A7 8DEE      LDD	R30,Y+30
    016A8 8DFF      LDD	R31,Y+31
    016A9 8180      LD	R24,Z
    016AA 368C      CPI	R24,0x6C
    016AB F429      BNE	0x16B1
    016AC 01CF      MOVW	R24,R30
    016AD 9601      ADIW	R24,1
    016AE 8F9F      STD	Y+31,R25
    016AF 8F8E      STD	Y+30,R24
    016B0 6062      ORI	R22,2
    016B1 8DEE      LDD	R30,Y+30
    016B2 8DFF      LDD	R31,Y+31
    016B3 80A0      LD	R10,Z
    016B4 24BB      CLR	R11
    016B5 01C5      MOVW	R24,R10
    016B6 3588      CPI	R24,0x58
    016B7 E0E0      LDI	R30,0
    016B8 079E      CPC	R25,R30
    016B9 F409      BNE	0x16BB
    016BA C090      RJMP	0x174B
    016BB E588      LDI	R24,0x58
    016BC 158A      CP	R24,R10
    016BD 059B      CPC	R25,R11
    016BE F094      BLT	0x16D1
    016BF 01C5      MOVW	R24,R10
    016C0 3485      CPI	R24,0x45
    016C1 E0E0      LDI	R30,0
    016C2 079E      CPC	R25,R30
    016C3 F409      BNE	0x16C5
    016C4 C2FD      RJMP	0x19C2
    016C5 3485      CPI	R24,0x45
    016C6 E0E0      LDI	R30,0
    016C7 079E      CPC	R25,R30
    016C8 F40C      BGE	0x16CA
    016C9 C040      RJMP	0x170A
    016CA 01C5      MOVW	R24,R10
    016CB 3583      CPI	R24,0x53
    016CC E0E0      LDI	R30,0
    016CD 079E      CPC	R25,R30
    016CE F409      BNE	0x16D0
    016CF C16E      RJMP	0x183E
    016D0 C039      RJMP	0x170A
    016D1 01C5      MOVW	R24,R10
    016D2 3683      CPI	R24,0x63
    016D3 E0E0      LDI	R30,0
    016D4 079E      CPC	R25,R30
    016D5 F409      BNE	0x16D7
    016D6 C143      RJMP	0x181A
    016D7 3684      CPI	R24,0x64
    016D8 E0E0      LDI	R30,0
    016D9 079E      CPC	R25,R30
    016DA F409      BNE	0x16DC
    016DB C03B      RJMP	0x1717
    016DC 3685      CPI	R24,0x65
    016DD E0E0      LDI	R30,0
    016DE 079E      CPC	R25,R30
    016DF F409      BNE	0x16E1
    016E0 C2E1      RJMP	0x19C2
    016E1 3686      CPI	R24,0x66
    016E2 E0E0      LDI	R30,0
    016E3 079E      CPC	R25,R30
    016E4 F409      BNE	0x16E6
    016E5 C2DC      RJMP	0x19C2
    016E6 3689      CPI	R24,0x69
    016E7 E0E0      LDI	R30,0
    016E8 079E      CPC	R25,R30
    016E9 F409      BNE	0x16EB
    016EA C02C      RJMP	0x1717
    016EB 368F      CPI	R24,0x6F
    016EC E0E0      LDI	R30,0
    016ED 079E      CPC	R25,R30
    016EE F409      BNE	0x16F0
    016EF C05B      RJMP	0x174B
    016F0 3780      CPI	R24,0x70
    016F1 E0E0      LDI	R30,0
    016F2 079E      CPC	R25,R30
    016F3 F409      BNE	0x16F5
    016F4 C056      RJMP	0x174B
    016F5 3683      CPI	R24,0x63
    016F6 E0E0      LDI	R30,0
    016F7 079E      CPC	R25,R30
    016F8 F08C      BLT	0x170A
    016F9 01C5      MOVW	R24,R10
    016FA 3783      CPI	R24,0x73
    016FB E0E0      LDI	R30,0
    016FC 079E      CPC	R25,R30
    016FD F409      BNE	0x16FF
    016FE C1FE      RJMP	0x18FD
    016FF 3785      CPI	R24,0x75
    01700 E0E0      LDI	R30,0
    01701 079E      CPC	R25,R30
    01702 F409      BNE	0x1704
    01703 C047      RJMP	0x174B
    01704 3788      CPI	R24,0x78
    01705 E0E0      LDI	R30,0
    01706 079E      CPC	R25,R30
    01707 F409      BNE	0x1709
    01708 C042      RJMP	0x174B
    01709 C000      RJMP	0x170A
    0170A 8DEE      LDD	R30,Y+30
    0170B 8DFF      LDD	R31,Y+31
    0170C 8100      LD	R16,Z
    0170D 8DEC      LDD	R30,Y+28
    0170E 8DFD      LDD	R31,Y+29
    0170F 940E 1B3E CALL	xicallx
    01711 858C      LDD	R24,Y+12
    01712 859D      LDD	R25,Y+13
    01713 9601      ADIW	R24,1
    01714 879D      STD	Y+13,R25
    01715 878C      STD	Y+12,R24
    01716 C2AF      RJMP	0x19C6
    01717 FF61      SBRS	R22,1
    01718 C01E      RJMP	0x1737
    01719 A188      LDD	R24,Y+32
    0171A A199      LDD	R25,Y+33
    0171B 9604      ADIW	R24,4
    0171C A399      STD	Y+33,R25
    0171D A388      STD	Y+32,R24
    0171E 01FC      MOVW	R30,R24
    0171F 9734      SBIW	R30,4
    01720 8020      LD	R2,Z
    01721 8031      LDD	R3,Z+1
    01722 8042      LDD	R4,Z+2
    01723 8053      LDD	R5,Z+3
    01724 822E      STD	Y+6,R2
    01725 823F      STD	Y+7,R3
    01726 8648      STD	Y+8,R4
    01727 8659      STD	Y+9,R5
    01728 E08A      LDI	R24,0xA
    01729 E090      LDI	R25,0
    0172A 839B      STD	Y+3,R25
    0172B 838A      STD	Y+2,R24
    0172C 802E      LDD	R2,Y+6
    0172D 803F      LDD	R3,Y+7
    0172E 8448      LDD	R4,Y+8
    0172F 8459      LDD	R5,Y+9
    01730 8248      ST	Y,R4
    01731 8259      STD	Y+1,R5
    01732 0191      MOVW	R18,R2
    01733 018A      MOVW	R16,R20
    01734 940E 1C71 CALL	_ltoa
    01736 C0BF      RJMP	0x17F6
    01737 A188      LDD	R24,Y+32
    01738 A199      LDD	R25,Y+33
    01739 9602      ADIW	R24,2
    0173A A399      STD	Y+33,R25
    0173B A388      STD	Y+32,R24
    0173C 01FC      MOVW	R30,R24
    0173D 9732      SBIW	R30,2
    0173E 8020      LD	R2,Z
    0173F 8031      LDD	R3,Z+1
    01740 8A39      STD	Y+17,R3
    01741 8A28      STD	Y+16,R2
    01742 E08A      LDI	R24,0xA
    01743 E090      LDI	R25,0
    01744 8399      STD	Y+1,R25
    01745 8388      ST	Y,R24
    01746 0191      MOVW	R18,R2
    01747 018A      MOVW	R16,R20
    01748 940E 1C06 CALL	_itoa
    0174A C0AB      RJMP	0x17F6
    0174B FF61      SBRS	R22,1
    0174C C010      RJMP	0x175D
    0174D A188      LDD	R24,Y+32
    0174E A199      LDD	R25,Y+33
    0174F 9604      ADIW	R24,4
    01750 A399      STD	Y+33,R25
    01751 A388      STD	Y+32,R24
    01752 01FC      MOVW	R30,R24
    01753 9734      SBIW	R30,4
    01754 8020      LD	R2,Z
    01755 8031      LDD	R3,Z+1
    01756 8042      LDD	R4,Z+2
    01757 8053      LDD	R5,Z+3
    01758 822E      STD	Y+6,R2
    01759 823F      STD	Y+7,R3
    0175A 8648      STD	Y+8,R4
    0175B 8659      STD	Y+9,R5
    0175C C00B      RJMP	0x1768
    0175D A188      LDD	R24,Y+32
    0175E A199      LDD	R25,Y+33
    0175F 9602      ADIW	R24,2
    01760 A399      STD	Y+33,R25
    01761 A388      STD	Y+32,R24
    01762 01FC      MOVW	R30,R24
    01763 9732      SBIW	R30,2
    01764 8020      LD	R2,Z
    01765 8031      LDD	R3,Z+1
    01766 8A39      STD	Y+17,R3
    01767 8A28      STD	Y+16,R2
    01768 8DEE      LDD	R30,Y+30
    01769 8DFF      LDD	R31,Y+31
    0176A 8180      LD	R24,Z
    0176B 3785      CPI	R24,0x75
    0176C F4D9      BNE	0x1788
    0176D FF61      SBRS	R22,1
    0176E C00F      RJMP	0x177E
    0176F E08A      LDI	R24,0xA
    01770 E090      LDI	R25,0
    01771 839B      STD	Y+3,R25
    01772 838A      STD	Y+2,R24
    01773 802E      LDD	R2,Y+6
    01774 803F      LDD	R3,Y+7
    01775 8448      LDD	R4,Y+8
    01776 8459      LDD	R5,Y+9
    01777 8248      ST	Y,R4
    01778 8259      STD	Y+1,R5
    01779 0191      MOVW	R18,R2
    0177A 018A      MOVW	R16,R20
    0177B 940E 1FC7 CALL	_ultoa
    0177D C078      RJMP	0x17F6
    0177E E08A      LDI	R24,0xA
    0177F E090      LDI	R25,0
    01780 8399      STD	Y+1,R25
    01781 8388      ST	Y,R24
    01782 8928      LDD	R18,Y+16
    01783 8939      LDD	R19,Y+17
    01784 018A      MOVW	R16,R20
    01785 940E 202E CALL	_utoa
    01787 C06E      RJMP	0x17F6
    01788 8DEE      LDD	R30,Y+30
    01789 8DFF      LDD	R31,Y+31
    0178A 8180      LD	R24,Z
    0178B 368F      CPI	R24,0x6F
    0178C F509      BNE	0x17AE
    0178D FF60      SBRS	R22,0
    0178E C004      RJMP	0x1793
    0178F E380      LDI	R24,0x30
    01790 01FA      MOVW	R30,R20
    01791 9381      ST	Z+,R24
    01792 01AF      MOVW	R20,R30
    01793 FF61      SBRS	R22,1
    01794 C00F      RJMP	0x17A4
    01795 E088      LDI	R24,0x8
    01796 E090      LDI	R25,0
    01797 839B      STD	Y+3,R25
    01798 838A      STD	Y+2,R24
    01799 802E      LDD	R2,Y+6
    0179A 803F      LDD	R3,Y+7
    0179B 8448      LDD	R4,Y+8
    0179C 8459      LDD	R5,Y+9
    0179D 8248      ST	Y,R4
    0179E 8259      STD	Y+1,R5
    0179F 0191      MOVW	R18,R2
    017A0 018A      MOVW	R16,R20
    017A1 940E 1FC7 CALL	_ultoa
    017A3 C052      RJMP	0x17F6
    017A4 E088      LDI	R24,0x8
    017A5 E090      LDI	R25,0
    017A6 8399      STD	Y+1,R25
    017A7 8388      ST	Y,R24
    017A8 8928      LDD	R18,Y+16
    017A9 8939      LDD	R19,Y+17
    017AA 018A      MOVW	R16,R20
    017AB 940E 202E CALL	_utoa
    017AD C048      RJMP	0x17F6
    017AE 8DEE      LDD	R30,Y+30
    017AF 8DFF      LDD	R31,Y+31
    017B0 8180      LD	R24,Z
    017B1 3780      CPI	R24,0x70
    017B2 F439      BNE	0x17BA
    017B3 E380      LDI	R24,0x30
    017B4 01FA      MOVW	R30,R20
    017B5 9381      ST	Z+,R24
    017B6 E788      LDI	R24,0x78
    017B7 9381      ST	Z+,R24
    017B8 01AF      MOVW	R20,R30
    017B9 C00C      RJMP	0x17C6
    017BA FF60      SBRS	R22,0
    017BB C00A      RJMP	0x17C6
    017BC E380      LDI	R24,0x30
    017BD 01FA      MOVW	R30,R20
    017BE 9381      ST	Z+,R24
    017BF 01AF      MOVW	R20,R30
    017C0 8DEE      LDD	R30,Y+30
    017C1 8DFF      LDD	R31,Y+31
    017C2 8020      LD	R2,Z
    017C3 01FA      MOVW	R30,R20
    017C4 9221      ST	Z+,R2
    017C5 01AF      MOVW	R20,R30
    017C6 FF61      SBRS	R22,1
    017C7 C00F      RJMP	0x17D7
    017C8 E180      LDI	R24,0x10
    017C9 E090      LDI	R25,0
    017CA 839B      STD	Y+3,R25
    017CB 838A      STD	Y+2,R24
    017CC 802E      LDD	R2,Y+6
    017CD 803F      LDD	R3,Y+7
    017CE 8448      LDD	R4,Y+8
    017CF 8459      LDD	R5,Y+9
    017D0 8248      ST	Y,R4
    017D1 8259      STD	Y+1,R5
    017D2 0191      MOVW	R18,R2
    017D3 018A      MOVW	R16,R20
    017D4 940E 1FC7 CALL	_ultoa
    017D6 C009      RJMP	0x17E0
    017D7 E180      LDI	R24,0x10
    017D8 E090      LDI	R25,0
    017D9 8399      STD	Y+1,R25
    017DA 8388      ST	Y,R24
    017DB 8928      LDD	R18,Y+16
    017DC 8939      LDD	R19,Y+17
    017DD 018A      MOVW	R16,R20
    017DE 940E 202E CALL	_utoa
    017E0 8DEE      LDD	R30,Y+30
    017E1 8DFF      LDD	R31,Y+31
    017E2 8180      LD	R24,Z
    017E3 3588      CPI	R24,0x58
    017E4 F489      BNE	0x17F6
    017E5 E848      LDI	R20,0x88
    017E6 E058      LDI	R21,0x8
    017E7 C00A      RJMP	0x17F2
    017E8 01FA      MOVW	R30,R20
    017E9 8100      LD	R16,Z
    017EA 2711      CLR	R17
    017EB 940E 20A0 CALL	_toupper
    017ED 0158      MOVW	R10,R16
    017EE 01FA      MOVW	R30,R20
    017EF 82A0      ST	Z,R10
    017F0 5F4F      SUBI	R20,0xFF
    017F1 4F5F      SBCI	R21,0xFF
    017F2 01FA      MOVW	R30,R20
    017F3 8020      LD	R2,Z
    017F4 2022      TST	R2
    017F5 F791      BNE	0x17E8
    017F6 E848      LDI	R20,0x88
    017F7 E058      LDI	R21,0x8
    017F8 858E      LDD	R24,Y+14
    017F9 859F      LDD	R25,Y+15
    017FA 3F8F      CPI	R24,0xFF
    017FB EFEF      LDI	R30,0xFF
    017FC 079E      CPC	R25,R30
    017FD F421      BNE	0x1802
    017FE 2400      CLR	R0
    017FF 2411      CLR	R1
    01800 861F      STD	Y+15,R1
    01801 860E      STD	Y+14,R0
    01802 840E      LDD	R0,Y+14
    01803 841F      LDD	R1,Y+15
    01804 2000      TST	R0
    01805 F419      BNE	0x1809
    01806 2011      TST	R1
    01807 F409      BNE	0x1809
    01808 C104      RJMP	0x190D
    01809 E808      LDI	R16,0x88
    0180A E018      LDI	R17,0x8
    0180B 940E 19D8 CALL	_strlen
    0180D 0158      MOVW	R10,R16
    0180E 8AB9      STD	Y+17,R11
    0180F 8AA8      STD	Y+16,R10
    01810 840E      LDD	R0,Y+14
    01811 841F      LDD	R1,Y+15
    01812 140A      CP	R0,R10
    01813 041B      CPC	R1,R11
    01814 F00C      BLT	0x1816
    01815 C0F7      RJMP	0x190D
    01816 0105      MOVW	R0,R10
    01817 861F      STD	Y+15,R1
    01818 860E      STD	Y+14,R0
    01819 C0F3      RJMP	0x190D
    0181A A188      LDD	R24,Y+32
    0181B A199      LDD	R25,Y+33
    0181C 9602      ADIW	R24,2
    0181D A399      STD	Y+33,R25
    0181E A388      STD	Y+32,R24
    0181F 01FC      MOVW	R30,R24
    01820 9732      SBIW	R30,2
    01821 8020      LD	R2,Z
    01822 8031      LDD	R3,Z+1
    01823 822C      STD	Y+4,R2
    01824 E081      LDI	R24,1
    01825 E090      LDI	R25,0
    01826 840A      LDD	R0,Y+10
    01827 841B      LDD	R1,Y+11
    01828 1580      CP	R24,R0
    01829 0591      CPC	R25,R1
    0182A F444      BGE	0x1833
    0182B 861F      STD	Y+15,R1
    0182C 860E      STD	Y+14,R0
    0182D 2422      CLR	R2
    0182E 822D      STD	Y+5,R2
    0182F 01AE      MOVW	R20,R28
    01830 5F4C      SUBI	R20,0xFC
    01831 4F5F      SBCI	R21,0xFF
    01832 C0DA      RJMP	0x190D
    01833 810C      LDD	R16,Y+4
    01834 8DEC      LDD	R30,Y+28
    01835 8DFD      LDD	R31,Y+29
    01836 940E 1B3E CALL	xicallx
    01838 858C      LDD	R24,Y+12
    01839 859D      LDD	R25,Y+13
    0183A 9601      ADIW	R24,1
    0183B 879D      STD	Y+13,R25
    0183C 878C      STD	Y+12,R24
    0183D C188      RJMP	0x19C6
    0183E A188      LDD	R24,Y+32
    0183F A199      LDD	R25,Y+33
    01840 9602      ADIW	R24,2
    01841 A399      STD	Y+33,R25
    01842 A388      STD	Y+32,R24
    01843 01FC      MOVW	R30,R24
    01844 9732      SBIW	R30,2
    01845 80E0      LD	R14,Z
    01846 80F1      LDD	R15,Z+1
    01847 858E      LDD	R24,Y+14
    01848 859F      LDD	R25,Y+15
    01849 3F8F      CPI	R24,0xFF
    0184A EFEF      LDI	R30,0xFF
    0184B 079E      CPC	R25,R30
    0184C F421      BNE	0x1851
    0184D 2400      CLR	R0
    0184E 2411      CLR	R1
    0184F 861F      STD	Y+15,R1
    01850 860E      STD	Y+14,R0
    01851 840A      LDD	R0,Y+10
    01852 841B      LDD	R1,Y+11
    01853 2000      TST	R0
    01854 F411      BNE	0x1857
    01855 2011      TST	R1
    01856 F051      BEQ	0x1861
    01857 0187      MOVW	R16,R14
    01858 940E 1BB3 CALL	_cstrlen
    0185A 0158      MOVW	R10,R16
    0185B 842A      LDD	R2,Y+10
    0185C 843B      LDD	R3,Y+11
    0185D 1A20      SUB	R2,R16
    0185E 0A31      SBC	R3,R17
    0185F 863B      STD	Y+11,R3
    01860 862A      STD	Y+10,R2
    01861 840E      LDD	R0,Y+14
    01862 841F      LDD	R1,Y+15
    01863 2000      TST	R0
    01864 F441      BNE	0x186D
    01865 2011      TST	R1
    01866 F431      BNE	0x186D
    01867 0187      MOVW	R16,R14
    01868 940E 1BB3 CALL	_cstrlen
    0186A 0158      MOVW	R10,R16
    0186B 86BF      STD	Y+15,R11
    0186C 86AE      STD	Y+14,R10
    0186D 840A      LDD	R0,Y+10
    0186E 841B      LDD	R1,Y+11
    0186F 2000      TST	R0
    01870 F411      BNE	0x1873
    01871 2011      TST	R1
    01872 F031      BEQ	0x1879
    01873 FF63      SBRS	R22,3
    01874 C004      RJMP	0x1879
    01875 01C0      MOVW	R24,R0
    01876 9701      SBIW	R24,1
    01877 879B      STD	Y+11,R25
    01878 878A      STD	Y+10,R24
    01879 FF64      SBRS	R22,4
    0187A C026      RJMP	0x18A1
    0187B FF63      SBRS	R22,3
    0187C C00A      RJMP	0x1887
    0187D 2D0C      MOV	R16,R12
    0187E 8DEC      LDD	R30,Y+28
    0187F 8DFD      LDD	R31,Y+29
    01880 940E 1B3E CALL	xicallx
    01882 858C      LDD	R24,Y+12
    01883 859D      LDD	R25,Y+13
    01884 9601      ADIW	R24,1
    01885 879D      STD	Y+13,R25
    01886 878C      STD	Y+12,R24
    01887 FD62      SBRC	R22,2
    01888 C04C      RJMP	0x18D5
    01889 C00F      RJMP	0x1899
    0188A E300      LDI	R16,0x30
    0188B 8DEC      LDD	R30,Y+28
    0188C 8DFD      LDD	R31,Y+29
    0188D 940E 1B3E CALL	xicallx
    0188F 858C      LDD	R24,Y+12
    01890 859D      LDD	R25,Y+13
    01891 9601      ADIW	R24,1
    01892 879D      STD	Y+13,R25
    01893 878C      STD	Y+12,R24
    01894 858A      LDD	R24,Y+10
    01895 859B      LDD	R25,Y+11
    01896 9701      SBIW	R24,1
    01897 879B      STD	Y+11,R25
    01898 878A      STD	Y+10,R24
    01899 2422      CLR	R2
    0189A 2433      CLR	R3
    0189B 840A      LDD	R0,Y+10
    0189C 841B      LDD	R1,Y+11
    0189D 1420      CP	R2,R0
    0189E 0431      CPC	R3,R1
    0189F F354      BLT	0x188A
    018A0 C034      RJMP	0x18D5
    018A1 FD62      SBRC	R22,2
    018A2 C017      RJMP	0x18BA
    018A3 C00F      RJMP	0x18B3
    018A4 E200      LDI	R16,0x20
    018A5 8DEC      LDD	R30,Y+28
    018A6 8DFD      LDD	R31,Y+29
    018A7 940E 1B3E CALL	xicallx
    018A9 858C      LDD	R24,Y+12
    018AA 859D      LDD	R25,Y+13
    018AB 9601      ADIW	R24,1
    018AC 879D      STD	Y+13,R25
    018AD 878C      STD	Y+12,R24
    018AE 858A      LDD	R24,Y+10
    018AF 859B      LDD	R25,Y+11
    018B0 9701      SBIW	R24,1
    018B1 879B      STD	Y+11,R25
    018B2 878A      STD	Y+10,R24
    018B3 2422      CLR	R2
    018B4 2433      CLR	R3
    018B5 840A      LDD	R0,Y+10
    018B6 841B      LDD	R1,Y+11
    018B7 1420      CP	R2,R0
    018B8 0431      CPC	R3,R1
    018B9 F354      BLT	0x18A4
    018BA FF63      SBRS	R22,3
    018BB C019      RJMP	0x18D5
    018BC 2D0C      MOV	R16,R12
    018BD 8DEC      LDD	R30,Y+28
    018BE 8DFD      LDD	R31,Y+29
    018BF 940E 1B3E CALL	xicallx
    018C1 858C      LDD	R24,Y+12
    018C2 859D      LDD	R25,Y+13
    018C3 9601      ADIW	R24,1
    018C4 879D      STD	Y+13,R25
    018C5 878C      STD	Y+12,R24
    018C6 C00E      RJMP	0x18D5
    018C7 01F7      MOVW	R30,R14
    018C8 9106      ELPM	R16,Z
    018C9 8DEC      LDD	R30,Y+28
    018CA 8DFD      LDD	R31,Y+29
    018CB 940E 1B3E CALL	xicallx
    018CD 858C      LDD	R24,Y+12
    018CE 859D      LDD	R25,Y+13
    018CF 9601      ADIW	R24,1
    018D0 879D      STD	Y+13,R25
    018D1 878C      STD	Y+12,R24
    018D2 01C7      MOVW	R24,R14
    018D3 9601      ADIW	R24,1
    018D4 017C      MOVW	R14,R24
    018D5 01F7      MOVW	R30,R14
    018D6 9026      ELPM	R2,Z
    018D7 2022      TST	R2
    018D8 F051      BEQ	0x18E3
    018D9 84AE      LDD	R10,Y+14
    018DA 84BF      LDD	R11,Y+15
    018DB 01C5      MOVW	R24,R10
    018DC 9701      SBIW	R24,1
    018DD 879F      STD	Y+15,R25
    018DE 878E      STD	Y+14,R24
    018DF 20AA      TST	R10
    018E0 F731      BNE	0x18C7
    018E1 20BB      TST	R11
    018E2 F721      BNE	0x18C7
    018E3 FF62      SBRS	R22,2
    018E4 C0E1      RJMP	0x19C6
    018E5 C00F      RJMP	0x18F5
    018E6 E200      LDI	R16,0x20
    018E7 8DEC      LDD	R30,Y+28
    018E8 8DFD      LDD	R31,Y+29
    018E9 940E 1B3E CALL	xicallx
    018EB 858C      LDD	R24,Y+12
    018EC 859D      LDD	R25,Y+13
    018ED 9601      ADIW	R24,1
    018EE 879D      STD	Y+13,R25
    018EF 878C      STD	Y+12,R24
    018F0 858A      LDD	R24,Y+10
    018F1 859B      LDD	R25,Y+11
    018F2 9701      SBIW	R24,1
    018F3 879B      STD	Y+11,R25
    018F4 878A      STD	Y+10,R24
    018F5 2422      CLR	R2
    018F6 2433      CLR	R3
    018F7 840A      LDD	R0,Y+10
    018F8 841B      LDD	R1,Y+11
    018F9 1420      CP	R2,R0
    018FA 0431      CPC	R3,R1
    018FB F354      BLT	0x18E6
    018FC C0C9      RJMP	0x19C6
    018FD A188      LDD	R24,Y+32
    018FE A199      LDD	R25,Y+33
    018FF 9602      ADIW	R24,2
    01900 A399      STD	Y+33,R25
    01901 A388      STD	Y+32,R24
    01902 01FC      MOVW	R30,R24
    01903 9732      SBIW	R30,2
    01904 8140      LD	R20,Z
    01905 8151      LDD	R21,Z+1
    01906 3040      CPI	R20,0
    01907 0745      CPC	R20,R21
    01908 F421      BNE	0x190D
    01909 E982      LDI	R24,0x92
    0190A E090      LDI	R25,0
    0190B 017C      MOVW	R14,R24
    0190C CF3A      RJMP	0x1847
    0190D 858E      LDD	R24,Y+14
    0190E 859F      LDD	R25,Y+15
    0190F 3F8F      CPI	R24,0xFF
    01910 EFEF      LDI	R30,0xFF
    01911 079E      CPC	R25,R30
    01912 F421      BNE	0x1917
    01913 2400      CLR	R0
    01914 2411      CLR	R1
    01915 861F      STD	Y+15,R1
    01916 860E      STD	Y+14,R0
    01917 840A      LDD	R0,Y+10
    01918 841B      LDD	R1,Y+11
    01919 2000      TST	R0
    0191A F411      BNE	0x191D
    0191B 2011      TST	R1
    0191C F051      BEQ	0x1927
    0191D 018A      MOVW	R16,R20
    0191E 940E 19D8 CALL	_strlen
    01920 0158      MOVW	R10,R16
    01921 842A      LDD	R2,Y+10
    01922 843B      LDD	R3,Y+11
    01923 1A20      SUB	R2,R16
    01924 0A31      SBC	R3,R17
    01925 863B      STD	Y+11,R3
    01926 862A      STD	Y+10,R2
    01927 840E      LDD	R0,Y+14
    01928 841F      LDD	R1,Y+15
    01929 2000      TST	R0
    0192A F441      BNE	0x1933
    0192B 2011      TST	R1
    0192C F431      BNE	0x1933
    0192D 018A      MOVW	R16,R20
    0192E 940E 19D8 CALL	_strlen
    01930 0158      MOVW	R10,R16
    01931 86BF      STD	Y+15,R11
    01932 86AE      STD	Y+14,R10
    01933 840A      LDD	R0,Y+10
    01934 841B      LDD	R1,Y+11
    01935 2000      TST	R0
    01936 F411      BNE	0x1939
    01937 2011      TST	R1
    01938 F031      BEQ	0x193F
    01939 FF63      SBRS	R22,3
    0193A C004      RJMP	0x193F
    0193B 01C0      MOVW	R24,R0
    0193C 9701      SBIW	R24,1
    0193D 879B      STD	Y+11,R25
    0193E 878A      STD	Y+10,R24
    0193F FF64      SBRS	R22,4
    01940 C026      RJMP	0x1967
    01941 FF63      SBRS	R22,3
    01942 C00A      RJMP	0x194D
    01943 2D0C      MOV	R16,R12
    01944 8DEC      LDD	R30,Y+28
    01945 8DFD      LDD	R31,Y+29
    01946 940E 1B3E CALL	xicallx
    01948 858C      LDD	R24,Y+12
    01949 859D      LDD	R25,Y+13
    0194A 9601      ADIW	R24,1
    0194B 879D      STD	Y+13,R25
    0194C 878C      STD	Y+12,R24
    0194D FD62      SBRC	R22,2
    0194E C04B      RJMP	0x199A
    0194F C00F      RJMP	0x195F
    01950 E300      LDI	R16,0x30
    01951 8DEC      LDD	R30,Y+28
    01952 8DFD      LDD	R31,Y+29
    01953 940E 1B3E CALL	xicallx
    01955 858C      LDD	R24,Y+12
    01956 859D      LDD	R25,Y+13
    01957 9601      ADIW	R24,1
    01958 879D      STD	Y+13,R25
    01959 878C      STD	Y+12,R24
    0195A 858A      LDD	R24,Y+10
    0195B 859B      LDD	R25,Y+11
    0195C 9701      SBIW	R24,1
    0195D 879B      STD	Y+11,R25
    0195E 878A      STD	Y+10,R24
    0195F 2422      CLR	R2
    01960 2433      CLR	R3
    01961 840A      LDD	R0,Y+10
    01962 841B      LDD	R1,Y+11
    01963 1420      CP	R2,R0
    01964 0431      CPC	R3,R1
    01965 F354      BLT	0x1950
    01966 C033      RJMP	0x199A
    01967 FD62      SBRC	R22,2
    01968 C017      RJMP	0x1980
    01969 C00F      RJMP	0x1979
    0196A E200      LDI	R16,0x20
    0196B 8DEC      LDD	R30,Y+28
    0196C 8DFD      LDD	R31,Y+29
    0196D 940E 1B3E CALL	xicallx
    0196F 858C      LDD	R24,Y+12
    01970 859D      LDD	R25,Y+13
    01971 9601      ADIW	R24,1
    01972 879D      STD	Y+13,R25
    01973 878C      STD	Y+12,R24
    01974 858A      LDD	R24,Y+10
    01975 859B      LDD	R25,Y+11
    01976 9701      SBIW	R24,1
    01977 879B      STD	Y+11,R25
    01978 878A      STD	Y+10,R24
    01979 2422      CLR	R2
    0197A 2433      CLR	R3
    0197B 840A      LDD	R0,Y+10
    0197C 841B      LDD	R1,Y+11
    0197D 1420      CP	R2,R0
    0197E 0431      CPC	R3,R1
    0197F F354      BLT	0x196A
    01980 FF63      SBRS	R22,3
    01981 C018      RJMP	0x199A
    01982 2D0C      MOV	R16,R12
    01983 8DEC      LDD	R30,Y+28
    01984 8DFD      LDD	R31,Y+29
    01985 940E 1B3E CALL	xicallx
    01987 858C      LDD	R24,Y+12
    01988 859D      LDD	R25,Y+13
    01989 9601      ADIW	R24,1
    0198A 879D      STD	Y+13,R25
    0198B 878C      STD	Y+12,R24
    0198C C00D      RJMP	0x199A
    0198D 01FA      MOVW	R30,R20
    0198E 8100      LD	R16,Z
    0198F 8DEC      LDD	R30,Y+28
    01990 8DFD      LDD	R31,Y+29
    01991 940E 1B3E CALL	xicallx
    01993 858C      LDD	R24,Y+12
    01994 859D      LDD	R25,Y+13
    01995 9601      ADIW	R24,1
    01996 879D      STD	Y+13,R25
    01997 878C      STD	Y+12,R24
    01998 5F4F      SUBI	R20,0xFF
    01999 4F5F      SBCI	R21,0xFF
    0199A 01FA      MOVW	R30,R20
    0199B 8020      LD	R2,Z
    0199C 2022      TST	R2
    0199D F051      BEQ	0x19A8
    0199E 84AE      LDD	R10,Y+14
    0199F 84BF      LDD	R11,Y+15
    019A0 01C5      MOVW	R24,R10
    019A1 9701      SBIW	R24,1
    019A2 879F      STD	Y+15,R25
    019A3 878E      STD	Y+14,R24
    019A4 20AA      TST	R10
    019A5 F739      BNE	0x198D
    019A6 20BB      TST	R11
    019A7 F729      BNE	0x198D
    019A8 FF62      SBRS	R22,2
    019A9 C01C      RJMP	0x19C6
    019AA C00F      RJMP	0x19BA
    019AB E200      LDI	R16,0x20
    019AC 8DEC      LDD	R30,Y+28
    019AD 8DFD      LDD	R31,Y+29
    019AE 940E 1B3E CALL	xicallx
    019B0 858C      LDD	R24,Y+12
    019B1 859D      LDD	R25,Y+13
    019B2 9601      ADIW	R24,1
    019B3 879D      STD	Y+13,R25
    019B4 878C      STD	Y+12,R24
    019B5 858A      LDD	R24,Y+10
    019B6 859B      LDD	R25,Y+11
    019B7 9701      SBIW	R24,1
    019B8 879B      STD	Y+11,R25
    019B9 878A      STD	Y+10,R24
    019BA 2422      CLR	R2
    019BB 2433      CLR	R3
    019BC 840A      LDD	R0,Y+10
    019BD 841B      LDD	R1,Y+11
    019BE 1420      CP	R2,R0
    019BF 0431      CPC	R3,R1
    019C0 F354      BLT	0x19AB
    019C1 C004      RJMP	0x19C6
    019C2 EA84      LDI	R24,0xA4
    019C3 E090      LDI	R25,0
    019C4 017C      MOVW	R14,R24
    019C5 CE81      RJMP	0x1847
    019C6 8D8E      LDD	R24,Y+30
    019C7 8D9F      LDD	R25,Y+31
    019C8 9601      ADIW	R24,1
    019C9 8F9F      STD	Y+31,R25
    019CA 8F8E      STD	Y+30,R24
    019CB 8DEE      LDD	R30,Y+30
    019CC 8DFF      LDD	R31,Y+31
    019CD 8020      LD	R2,Z
    019CE 2022      TST	R2
    019CF F009      BEQ	0x19D1
    019D0 CC01      RJMP	0x15D2
    019D1 850C      LDD	R16,Y+12
    019D2 851D      LDD	R17,Y+13
    019D3 9662      ADIW	R28,0x12
    019D4 940E 1AE6 CALL	pop_xgsetF0FC
    019D6 9624      ADIW	R28,4
    019D7 9508      RET
_strlen:
    019D8 2FE0      MOV	R30,R16
    019D9 2FF1      MOV	R31,R17
    019DA 27AA      CLR	R26
    019DB 27BB      CLR	R27
    019DC 9001      LD	R0,Z+
    019DD 2000      TST	R0
    019DE F011      BEQ	0x19E1
    019DF 9611      ADIW	R26,1
    019E0 CFFB      RJMP	0x19DC
    019E1 2F0A      MOV	R16,R26
    019E2 2F1B      MOV	R17,R27
    019E3 9508      RET
push_arg4:
    019E4 933A      ST	-Y,R19
    019E5 932A      ST	-Y,R18
push_arg2:
    019E6 931A      ST	-Y,R17
    019E7 930A      ST	-Y,R16
    019E8 9508      RET
mod16s:
    019E9 9468      BSET	6
    019EA 92DA      ST	-Y,R13
    019EB 2ED1      MOV	R13,R17
    019EC C004      RJMP	0x19F1
div16s:
    019ED 94E8      BCLR	6
    019EE 92DA      ST	-Y,R13
    019EF 2ED1      MOV	R13,R17
    019F0 26D3      EOR	R13,R19
    019F1 FF17      SBRS	R17,7
    019F2 C004      RJMP	0x19F7
    019F3 9510      COM	R17
    019F4 9500      COM	R16
    019F5 5F0F      SUBI	R16,0xFF
    019F6 4F1F      SBCI	R17,0xFF
    019F7 FF37      SBRS	R19,7
    019F8 C004      RJMP	0x19FD
    019F9 9530      COM	R19
    019FA 9520      COM	R18
    019FB 5F2F      SUBI	R18,0xFF
    019FC 4F3F      SBCI	R19,0xFF
    019FD 940E 1A0A CALL	xdiv16u
    019FF FED7      SBRS	R13,7
    01A00 C004      RJMP	0x1A05
    01A01 9510      COM	R17
    01A02 9500      COM	R16
    01A03 5F0F      SUBI	R16,0xFF
    01A04 4F1F      SBCI	R17,0xFF
    01A05 90D9      LD	R13,Y+
    01A06 9508      RET
mod16u:
    01A07 9468      BSET	6
    01A08 C001      RJMP	xdiv16u
div16u:
    01A09 94E8      BCLR	6
xdiv16u:
    01A0A 92EA      ST	-Y,R14
    01A0B 92FA      ST	-Y,R15
    01A0C 938A      ST	-Y,R24
    01A0D 24EE      CLR	R14
    01A0E 24FF      CLR	R15
    01A0F E180      LDI	R24,0x10
    01A10 0F00      LSL	R16
    01A11 1F11      ROL	R17
    01A12 1CEE      ROL	R14
    01A13 1CFF      ROL	R15
    01A14 16E2      CP	R14,R18
    01A15 06F3      CPC	R15,R19
    01A16 F018      BCS	0x1A1A
    01A17 1AE2      SUB	R14,R18
    01A18 0AF3      SBC	R15,R19
    01A19 9503      INC	R16
    01A1A 958A      DEC	R24
    01A1B F7A1      BNE	0x1A10
    01A1C F416      BRTC	0x1A1F
    01A1D 2D0E      MOV	R16,R14
    01A1E 2D1F      MOV	R17,R15
    01A1F 9189      LD	R24,Y+
    01A20 90F9      LD	R15,Y+
    01A21 90E9      LD	R14,Y+
    01A22 9508      RET
div32u:
    01A23 94E8      BCLR	6
    01A24 C001      RJMP	0x1A26
mod32u:
    01A25 9468      BSET	6
    01A26 D030      RCALL	long_div_prolog
    01A27 24CC      CLR	R12
    01A28 C009      RJMP	0x1A32
div32s:
    01A29 94E8      BCLR	6
    01A2A C001      RJMP	0x1A2C
mod32s:
    01A2B 9468      BSET	6
    01A2C D02A      RCALL	long_div_prolog
    01A2D FD37      SBRC	R19,7
    01A2E 940E 1B47 CALL	neg32
    01A30 FDB7      SBRC	R27,7
    01A31 D052      RCALL	neg_R24_R27
    01A32 2477      CLR	R7
    01A33 2488      CLR	R8
    01A34 2499      CLR	R9
    01A35 24AA      CLR	R10
    01A36 24BB      CLR	R11
    01A37 D042      RCALL	tst_R16_R19
    01A38 F0C1      BEQ	0x1A51
    01A39 D045      RCALL	tst_R24_R27
    01A3A F0B1      BEQ	0x1A51
    01A3B E2E8      LDI	R30,0x28
    01A3C 0F00      LSL	R16
    01A3D 1F11      ROL	R17
    01A3E 1F22      ROL	R18
    01A3F 1F33      ROL	R19
    01A40 1C77      ROL	R7
    01A41 1C88      ROL	R8
    01A42 1C99      ROL	R9
    01A43 1CAA      ROL	R10
    01A44 1CBB      ROL	R11
    01A45 1688      CP	R8,R24
    01A46 0699      CPC	R9,R25
    01A47 06AA      CPC	R10,R26
    01A48 06BB      CPC	R11,R27
    01A49 F028      BCS	0x1A4F
    01A4A 1A88      SUB	R8,R24
    01A4B 0A99      SBC	R9,R25
    01A4C 0AAA      SBC	R10,R26
    01A4D 0ABB      SBC	R11,R27
    01A4E 9503      INC	R16
    01A4F 95EA      DEC	R30
    01A50 F759      BNE	0x1A3C
    01A51 F426      BRTC	0x1A56
    01A52 2D08      MOV	R16,R8
    01A53 2D19      MOV	R17,R9
    01A54 2D2A      MOV	R18,R10
    01A55 2D3B      MOV	R19,R11
    01A56 C013      RJMP	long_div_epilog
long_div_prolog:
    01A57 927A      ST	-Y,R7
    01A58 928A      ST	-Y,R8
    01A59 929A      ST	-Y,R9
    01A5A 92AA      ST	-Y,R10
    01A5B 92BA      ST	-Y,R11
    01A5C 92CA      ST	-Y,R12
    01A5D 93EA      ST	-Y,R30
    01A5E 938A      ST	-Y,R24
    01A5F 939A      ST	-Y,R25
    01A60 93AA      ST	-Y,R26
    01A61 93BA      ST	-Y,R27
    01A62 858B      LDD	R24,Y+11
    01A63 859C      LDD	R25,Y+12
    01A64 85AD      LDD	R26,Y+13
    01A65 85BE      LDD	R27,Y+14
    01A66 2EC3      MOV	R12,R19
    01A67 F00E      BRTS	0x1A69
    01A68 26CB      EOR	R12,R27
    01A69 9508      RET
long_div_epilog:
    01A6A FCC7      SBRC	R12,7
    01A6B 940E 1B47 CALL	neg32
    01A6D 91B9      LD	R27,Y+
    01A6E 91A9      LD	R26,Y+
    01A6F 9199      LD	R25,Y+
    01A70 9189      LD	R24,Y+
    01A71 91E9      LD	R30,Y+
    01A72 90C9      LD	R12,Y+
    01A73 90B9      LD	R11,Y+
    01A74 90A9      LD	R10,Y+
    01A75 9099      LD	R9,Y+
    01A76 9089      LD	R8,Y+
    01A77 9079      LD	R7,Y+
    01A78 9624      ADIW	R28,4
    01A79 9508      RET
tst_R16_R19:
    01A7A 2FE0      MOV	R30,R16
    01A7B 2BE1      OR	R30,R17
    01A7C 2BE2      OR	R30,R18
    01A7D 2BE3      OR	R30,R19
    01A7E 9508      RET
tst_R24_R27:
    01A7F 2FE8      MOV	R30,R24
    01A80 2BE9      OR	R30,R25
    01A81 2BEA      OR	R30,R26
    01A82 2BEB      OR	R30,R27
    01A83 9508      RET
neg_R24_R27:
    01A84 9580      COM	R24
    01A85 9590      COM	R25
    01A86 95A0      COM	R26
    01A87 95B0      COM	R27
    01A88 5F8F      SUBI	R24,0xFF
    01A89 4F9F      SBCI	R25,0xFF
    01A8A 4FAF      SBCI	R26,0xFF
    01A8B 4FBF      SBCI	R27,0xFF
    01A8C 9508      RET
empy16s:
    01A8D 920A      ST	-Y,R0
    01A8E 921A      ST	-Y,R1
    01A8F 938A      ST	-Y,R24
    01A90 939A      ST	-Y,R25
    01A91 9F02      MUL	R16,R18
    01A92 01C0      MOVW	R24,R0
    01A93 9F12      MUL	R17,R18
    01A94 0D90      ADD	R25,R0
    01A95 9F03      MUL	R16,R19
    01A96 0D90      ADD	R25,R0
    01A97 018C      MOVW	R16,R24
    01A98 9199      LD	R25,Y+
    01A99 9189      LD	R24,Y+
    01A9A 9019      LD	R1,Y+
    01A9B 9009      LD	R0,Y+
    01A9C 9508      RET
empy32u|empy32s:
    01A9D 940E 1B50 CALL	long_prolog
    01A9F 927A      ST	-Y,R7
    01AA0 940E 1B69 CALL	tstzero1
    01AA2 F159      BEQ	0x1ACE
    01AA3 2477      CLR	R7
    01AA4 940E 1B6F CALL	tstzero2
    01AA6 F419      BNE	0x1AAA
    01AA7 018C      MOVW	R16,R24
    01AA8 019D      MOVW	R18,R26
    01AA9 C024      RJMP	0x1ACE
    01AAA 920A      ST	-Y,R0
    01AAB 921A      ST	-Y,R1
    01AAC 9F08      MUL	R16,R24
    01AAD 2CB0      MOV	R11,R0
    01AAE 2CA1      MOV	R10,R1
    01AAF 9F28      MUL	R18,R24
    01AB0 2C90      MOV	R9,R0
    01AB1 2C81      MOV	R8,R1
    01AB2 9F18      MUL	R17,R24
    01AB3 0CA0      ADD	R10,R0
    01AB4 1C91      ADC	R9,R1
    01AB5 1C87      ADC	R8,R7
    01AB6 9F09      MUL	R16,R25
    01AB7 0CA0      ADD	R10,R0
    01AB8 1C91      ADC	R9,R1
    01AB9 1C87      ADC	R8,R7
    01ABA 9F19      MUL	R17,R25
    01ABB 0C90      ADD	R9,R0
    01ABC 1C81      ADC	R8,R1
    01ABD 9F0A      MUL	R16,R26
    01ABE 0C90      ADD	R9,R0
    01ABF 1C81      ADC	R8,R1
    01AC0 9F38      MUL	R19,R24
    01AC1 0C80      ADD	R8,R0
    01AC2 9F29      MUL	R18,R25
    01AC3 0C80      ADD	R8,R0
    01AC4 9F1A      MUL	R17,R26
    01AC5 0C80      ADD	R8,R0
    01AC6 9F0B      MUL	R16,R27
    01AC7 0C80      ADD	R8,R0
    01AC8 9019      LD	R1,Y+
    01AC9 9009      LD	R0,Y+
    01ACA 2D0B      MOV	R16,R11
    01ACB 2D1A      MOV	R17,R10
    01ACC 2D29      MOV	R18,R9
    01ACD 2D38      MOV	R19,R8
    01ACE 9079      LD	R7,Y+
    01ACF 940C 1B5E JMP	long_epilog
pop_xgset003C:
    01AD1 90A9      LD	R10,Y+
    01AD2 90B9      LD	R11,Y+
    01AD3 90C9      LD	R12,Y+
    01AD4 90D9      LD	R13,Y+
    01AD5 9508      RET
pop_xgset00FC:
    01AD6 90A9      LD	R10,Y+
    01AD7 90B9      LD	R11,Y+
    01AD8 90C9      LD	R12,Y+
    01AD9 90D9      LD	R13,Y+
    01ADA 90E9      LD	R14,Y+
    01ADB 90F9      LD	R15,Y+
    01ADC 9508      RET
pop_xgset30FC:
    01ADD 90A9      LD	R10,Y+
    01ADE 90B9      LD	R11,Y+
    01ADF 90C9      LD	R12,Y+
    01AE0 90D9      LD	R13,Y+
    01AE1 90E9      LD	R14,Y+
    01AE2 90F9      LD	R15,Y+
    01AE3 9149      LD	R20,Y+
    01AE4 9159      LD	R21,Y+
    01AE5 9508      RET
pop_xgsetF0FC:
    01AE6 90A9      LD	R10,Y+
    01AE7 90B9      LD	R11,Y+
    01AE8 90C9      LD	R12,Y+
    01AE9 90D9      LD	R13,Y+
    01AEA 90E9      LD	R14,Y+
    01AEB 90F9      LD	R15,Y+
    01AEC 9149      LD	R20,Y+
    01AED 9159      LD	R21,Y+
    01AEE 9169      LD	R22,Y+
    01AEF 9179      LD	R23,Y+
    01AF0 9508      RET
push_xgsetF0FC:
    01AF1 937A      ST	-Y,R23
    01AF2 936A      ST	-Y,R22
push_xgset30FC:
    01AF3 935A      ST	-Y,R21
    01AF4 934A      ST	-Y,R20
push_xgset00FC:
    01AF5 92FA      ST	-Y,R15
    01AF6 92EA      ST	-Y,R14
push_xgset003C:
    01AF7 92DA      ST	-Y,R13
    01AF8 92CA      ST	-Y,R12
    01AF9 92BA      ST	-Y,R11
    01AFA 92AA      ST	-Y,R10
    01AFB 9508      RET
push_xgset300C:
    01AFC 935A      ST	-Y,R21
    01AFD 934A      ST	-Y,R20
    01AFE 92BA      ST	-Y,R11
    01AFF 92AA      ST	-Y,R10
    01B00 9508      RET
pop_xgset300C:
    01B01 90A9      LD	R10,Y+
    01B02 90B9      LD	R11,Y+
    01B03 9149      LD	R20,Y+
    01B04 9159      LD	R21,Y+
    01B05 9508      RET
push_xgsetF000:
    01B06 937A      ST	-Y,R23
    01B07 936A      ST	-Y,R22
    01B08 935A      ST	-Y,R21
    01B09 934A      ST	-Y,R20
    01B0A 9508      RET
pop_xgsetF000:
    01B0B 9149      LD	R20,Y+
    01B0C 9159      LD	R21,Y+
    01B0D 9169      LD	R22,Y+
    01B0E 9179      LD	R23,Y+
    01B0F 9508      RET
push_xgsetF00C:
    01B10 937A      ST	-Y,R23
    01B11 936A      ST	-Y,R22
    01B12 935A      ST	-Y,R21
    01B13 934A      ST	-Y,R20
    01B14 92BA      ST	-Y,R11
    01B15 92AA      ST	-Y,R10
    01B16 9508      RET
pop_xgsetF00C:
    01B17 90A9      LD	R10,Y+
    01B18 90B9      LD	R11,Y+
    01B19 9149      LD	R20,Y+
    01B1A 9159      LD	R21,Y+
    01B1B 9169      LD	R22,Y+
    01B1C 9179      LD	R23,Y+
    01B1D 9508      RET
push_xgset303C:
    01B1E 935A      ST	-Y,R21
    01B1F 934A      ST	-Y,R20
    01B20 92DA      ST	-Y,R13
    01B21 92CA      ST	-Y,R12
    01B22 92BA      ST	-Y,R11
    01B23 92AA      ST	-Y,R10
    01B24 9508      RET
pop_xgset303C:
    01B25 90A9      LD	R10,Y+
    01B26 90B9      LD	R11,Y+
    01B27 90C9      LD	R12,Y+
    01B28 90D9      LD	R13,Y+
    01B29 9149      LD	R20,Y+
    01B2A 9159      LD	R21,Y+
    01B2B 9508      RET
push_xgsetF03C:
    01B2C 937A      ST	-Y,R23
    01B2D 936A      ST	-Y,R22
    01B2E 935A      ST	-Y,R21
    01B2F 934A      ST	-Y,R20
    01B30 92DA      ST	-Y,R13
    01B31 92CA      ST	-Y,R12
    01B32 92BA      ST	-Y,R11
    01B33 92AA      ST	-Y,R10
    01B34 9508      RET
pop_xgsetF03C:
    01B35 90A9      LD	R10,Y+
    01B36 90B9      LD	R11,Y+
    01B37 90C9      LD	R12,Y+
    01B38 90D9      LD	R13,Y+
    01B39 9149      LD	R20,Y+
    01B3A 9159      LD	R21,Y+
    01B3B 9169      LD	R22,Y+
    01B3C 9179      LD	R23,Y+
    01B3D 9508      RET
xicallx:
    01B3E 920A      ST	-Y,R0
    01B3F 95D8      ELPM
    01B40 920A      ST	-Y,R0
    01B41 9631      ADIW	R30,1
    01B42 95D8      ELPM
    01B43 2DF0      MOV	R31,R0
    01B44 91E9      LD	R30,Y+
    01B45 9009      LD	R0,Y+
    01B46 9409      IJMP
neg32:
    01B47 9500      COM	R16
    01B48 9510      COM	R17
    01B49 9520      COM	R18
    01B4A 9530      COM	R19
    01B4B 5F0F      SUBI	R16,0xFF
    01B4C 4F1F      SBCI	R17,0xFF
    01B4D 4F2F      SBCI	R18,0xFF
    01B4E 4F3F      SBCI	R19,0xFF
    01B4F 9508      RET
long_prolog:
    01B50 928A      ST	-Y,R8
    01B51 929A      ST	-Y,R9
    01B52 92AA      ST	-Y,R10
    01B53 92BA      ST	-Y,R11
    01B54 93EA      ST	-Y,R30
    01B55 938A      ST	-Y,R24
    01B56 939A      ST	-Y,R25
    01B57 93AA      ST	-Y,R26
    01B58 93BA      ST	-Y,R27
    01B59 8589      LDD	R24,Y+9
    01B5A 859A      LDD	R25,Y+10
    01B5B 85AB      LDD	R26,Y+11
    01B5C 85BC      LDD	R27,Y+12
    01B5D 9508      RET
long_epilog:
    01B5E 91B9      LD	R27,Y+
    01B5F 91A9      LD	R26,Y+
    01B60 9199      LD	R25,Y+
    01B61 9189      LD	R24,Y+
    01B62 91E9      LD	R30,Y+
    01B63 90B9      LD	R11,Y+
    01B64 90A9      LD	R10,Y+
    01B65 9099      LD	R9,Y+
    01B66 9089      LD	R8,Y+
    01B67 9624      ADIW	R28,4
    01B68 9508      RET
tstzero1:
    01B69 27EE      CLR	R30
    01B6A 2BE0      OR	R30,R16
    01B6B 2BE1      OR	R30,R17
    01B6C 2BE2      OR	R30,R18
    01B6D 2BE3      OR	R30,R19
    01B6E 9508      RET
tstzero2:
    01B6F 27EE      CLR	R30
    01B70 2BE8      OR	R30,R24
    01B71 2BE9      OR	R30,R25
    01B72 2BEA      OR	R30,R26
    01B73 2BEB      OR	R30,R27
    01B74 9508      RET
lsl16:
    01B75 2322      TST	R18
    01B76 F021      BEQ	0x1B7B
    01B77 0F00      LSL	R16
    01B78 1F11      ROL	R17
    01B79 952A      DEC	R18
    01B7A CFFA      RJMP	lsl16
    01B7B 9508      RET
lsl32:
    01B7C 920F      PUSH	R0
    01B7D 9009      LD	R0,Y+
    01B7E 2000      TST	R0
    01B7F F031      BEQ	0x1B86
    01B80 0F00      LSL	R16
    01B81 1F11      ROL	R17
    01B82 1F22      ROL	R18
    01B83 1F33      ROL	R19
    01B84 940A      DEC	R0
    01B85 CFF8      RJMP	0x1B7E
    01B86 900F      POP	R0
    01B87 9508      RET
lsr16:
    01B88 2322      TST	R18
    01B89 F021      BEQ	0x1B8E
    01B8A 9516      LSR	R17
    01B8B 9507      ROR	R16
    01B8C 952A      DEC	R18
    01B8D CFFA      RJMP	lsr16
    01B8E 9508      RET
lsr32:
    01B8F 920F      PUSH	R0
    01B90 9009      LD	R0,Y+
    01B91 2000      TST	R0
    01B92 F031      BEQ	0x1B99
    01B93 9536      LSR	R19
    01B94 9527      ROR	R18
    01B95 9517      ROR	R17
    01B96 9507      ROR	R16
    01B97 940A      DEC	R0
    01B98 CFF8      RJMP	0x1B91
    01B99 900F      POP	R0
    01B9A 9508      RET
asgnblk:
    01B9B 93AA      ST	-Y,R26
    01B9C 93BA      ST	-Y,R27
    01B9D 93EA      ST	-Y,R30
    01B9E 93FA      ST	-Y,R31
    01B9F 920A      ST	-Y,R0
    01BA0 81AF      LDD	R26,Y+7
    01BA1 85B8      LDD	R27,Y+8
    01BA2 81ED      LDD	R30,Y+5
    01BA3 81FE      LDD	R31,Y+6
    01BA4 3000      CPI	R16,0
    01BA5 0701      CPC	R16,R17
    01BA6 F029      BEQ	0x1BAC
    01BA7 9001      LD	R0,Z+
    01BA8 920D      ST	X+,R0
    01BA9 5001      SUBI	R16,1
    01BAA 4010      SBCI	R17,0
    01BAB CFF8      RJMP	0x1BA4
    01BAC 9009      LD	R0,Y+
    01BAD 91F9      LD	R31,Y+
    01BAE 91E9      LD	R30,Y+
    01BAF 91B9      LD	R27,Y+
    01BB0 91A9      LD	R26,Y+
    01BB1 9624      ADIW	R28,4
    01BB2 9508      RET
_cstrlen:
    01BB3 2FE0      MOV	R30,R16
    01BB4 2FF1      MOV	R31,R17
    01BB5 27AA      CLR	R26
    01BB6 27BB      CLR	R27
    01BB7 95C8      LPM
    01BB8 2000      TST	R0
    01BB9 F019      BEQ	0x1BBD
    01BBA 9631      ADIW	R30,1
    01BBB 9611      ADIW	R26,1
    01BBC CFFA      RJMP	0x1BB7
    01BBD 2F0A      MOV	R16,R26
    01BBE 2F1B      MOV	R17,R27
    01BBF 9508      RET
_atoi:
    01BC0 940E 1B10 CALL	push_xgsetF00C
    01BC2 0158      MOVW	R10,R16
    01BC3 C003      RJMP	0x1BC7
    01BC4 01C5      MOVW	R24,R10
    01BC5 9601      ADIW	R24,1
    01BC6 015C      MOVW	R10,R24
    01BC7 01F5      MOVW	R30,R10
    01BC8 8100      LD	R16,Z
    01BC9 2711      CLR	R17
    01BCA 940E 2082 CALL	_isspace
    01BCC 3000      CPI	R16,0
    01BCD 0701      CPC	R16,R17
    01BCE F7A9      BNE	0x1BC4
    01BCF 2766      CLR	R22
    01BD0 2777      CLR	R23
    01BD1 01F5      MOVW	R30,R10
    01BD2 8180      LD	R24,Z
    01BD3 328D      CPI	R24,0x2D
    01BD4 F429      BNE	0x1BDA
    01BD5 E061      LDI	R22,1
    01BD6 01CF      MOVW	R24,R30
    01BD7 9601      ADIW	R24,1
    01BD8 015C      MOVW	R10,R24
    01BD9 C007      RJMP	0x1BE1
    01BDA 01F5      MOVW	R30,R10
    01BDB 8180      LD	R24,Z
    01BDC 328B      CPI	R24,0x2B
    01BDD F419      BNE	0x1BE1
    01BDE 01CF      MOVW	R24,R30
    01BDF 9601      ADIW	R24,1
    01BE0 015C      MOVW	R10,R24
    01BE1 2744      CLR	R20
    01BE2 2755      CLR	R21
    01BE3 C00E      RJMP	0x1BF2
    01BE4 E00A      LDI	R16,0xA
    01BE5 E010      LDI	R17,0
    01BE6 019A      MOVW	R18,R20
    01BE7 940E 1A8D CALL	empy16s
    01BE9 01A8      MOVW	R20,R16
    01BEA 01F5      MOVW	R30,R10
    01BEB 9021      LD	R2,Z+
    01BEC 015F      MOVW	R10,R30
    01BED 2433      CLR	R3
    01BEE 0D42      ADD	R20,R2
    01BEF 1D53      ADC	R21,R3
    01BF0 5340      SUBI	R20,0x30
    01BF1 4050      SBCI	R21,0
    01BF2 01F5      MOVW	R30,R10
    01BF3 8100      LD	R16,Z
    01BF4 2711      CLR	R17
    01BF5 940E 206E CALL	_isdigit
    01BF7 3000      CPI	R16,0
    01BF8 0701      CPC	R16,R17
    01BF9 F751      BNE	0x1BE4
    01BFA 3060      CPI	R22,0
    01BFB 0767      CPC	R22,R23
    01BFC F031      BEQ	0x1C03
    01BFD 018A      MOVW	R16,R20
    01BFE 9500      COM	R16
    01BFF 9510      COM	R17
    01C00 5F0F      SUBI	R16,0xFF
    01C01 4F1F      SBCI	R17,0xFF
    01C02 C001      RJMP	0x1C04
    01C03 018A      MOVW	R16,R20
    01C04 940C 1B17 JMP	pop_xgsetF00C
_itoa:
    01C06 940E 19E4 CALL	push_arg4
    01C08 940E 1AF1 CALL	push_xgsetF0FC
    01C0A 01A9      MOVW	R20,R18
    01C0B 84EE      LDD	R14,Y+14
    01C0C 84FF      LDD	R15,Y+15
    01C0D 015A      MOVW	R10,R20
    01C0E 20AA      TST	R10
    01C0F F451      BNE	0x1C1A
    01C10 20BB      TST	R11
    01C11 F441      BNE	0x1C1A
    01C12 E380      LDI	R24,0x30
    01C13 85EA      LDD	R30,Y+10
    01C14 85FB      LDD	R31,Y+11
    01C15 8380      ST	Z,R24
    01C16 2422      CLR	R2
    01C17 8221      STD	Z+1,R2
    01C18 018F      MOVW	R16,R30
    01C19 C053      RJMP	0x1C6D
    01C1A 3040      CPI	R20,0
    01C1B E0E0      LDI	R30,0
    01C1C 075E      CPC	R21,R30
    01C1D F46C      BGE	0x1C2B
    01C1E 01C7      MOVW	R24,R14
    01C1F 308A      CPI	R24,0xA
    01C20 E0E0      LDI	R30,0
    01C21 079E      CPC	R25,R30
    01C22 F441      BNE	0x1C2B
    01C23 24CC      CLR	R12
    01C24 94C3      INC	R12
    01C25 01C5      MOVW	R24,R10
    01C26 9580      COM	R24
    01C27 9590      COM	R25
    01C28 9601      ADIW	R24,1
    01C29 015C      MOVW	R10,R24
    01C2A C001      RJMP	0x1C2C
    01C2B 24CC      CLR	R12
    01C2C 856A      LDD	R22,Y+10
    01C2D 857B      LDD	R23,Y+11
    01C2E 0197      MOVW	R18,R14
    01C2F 0185      MOVW	R16,R10
    01C30 940E 1A07 CALL	mod16u
    01C32 01A8      MOVW	R20,R16
    01C33 E089      LDI	R24,0x9
    01C34 E090      LDI	R25,0
    01C35 1780      CP	R24,R16
    01C36 0791      CPC	R25,R17
    01C37 F034      BLT	0x1C3E
    01C38 01CA      MOVW	R24,R20
    01C39 96C0      ADIW	R24,0x30
    01C3A 01FB      MOVW	R30,R22
    01C3B 9381      ST	Z+,R24
    01C3C 01BF      MOVW	R22,R30
    01C3D C006      RJMP	0x1C44
    01C3E 01CA      MOVW	R24,R20
    01C3F 5A89      SUBI	R24,0xA9
    01C40 4F9F      SBCI	R25,0xFF
    01C41 01FB      MOVW	R30,R22
    01C42 9381      ST	Z+,R24
    01C43 01BF      MOVW	R22,R30
    01C44 0197      MOVW	R18,R14
    01C45 0185      MOVW	R16,R10
    01C46 940E 1A09 CALL	div16u
    01C48 0158      MOVW	R10,R16
    01C49 20AA      TST	R10
    01C4A F719      BNE	0x1C2E
    01C4B 20BB      TST	R11
    01C4C F709      BNE	0x1C2E
    01C4D 20CC      TST	R12
    01C4E F021      BEQ	0x1C53
    01C4F E28D      LDI	R24,0x2D
    01C50 01FB      MOVW	R30,R22
    01C51 9381      ST	Z+,R24
    01C52 01BF      MOVW	R22,R30
    01C53 012B      MOVW	R4,R22
    01C54 5061      SUBI	R22,1
    01C55 4070      SBCI	R23,0
    01C56 2422      CLR	R2
    01C57 01F2      MOVW	R30,R4
    01C58 8220      ST	Z,R2
    01C59 84AA      LDD	R10,Y+10
    01C5A 84BB      LDD	R11,Y+11
    01C5B C00C      RJMP	0x1C68
    01C5C 01F5      MOVW	R30,R10
    01C5D 80C0      LD	R12,Z
    01C5E 01FB      MOVW	R30,R22
    01C5F 8020      LD	R2,Z
    01C60 01F5      MOVW	R30,R10
    01C61 9221      ST	Z+,R2
    01C62 015F      MOVW	R10,R30
    01C63 011B      MOVW	R2,R22
    01C64 5061      SUBI	R22,1
    01C65 4070      SBCI	R23,0
    01C66 01F1      MOVW	R30,R2
    01C67 82C0      ST	Z,R12
    01C68 16A6      CP	R10,R22
    01C69 06B7      CPC	R11,R23
    01C6A F388      BCS	0x1C5C
    01C6B 850A      LDD	R16,Y+10
    01C6C 851B      LDD	R17,Y+11
    01C6D 940E 1AE6 CALL	pop_xgsetF0FC
    01C6F 9624      ADIW	R28,4
    01C70 9508      RET
_ltoa:
    01C71 940E 19E4 CALL	push_arg4
    01C73 940E 1AF1 CALL	push_xgsetF0FC
    01C75 9724      SBIW	R28,4
    01C76 8828      LDD	R2,Y+16
    01C77 8839      LDD	R3,Y+17
    01C78 884A      LDD	R4,Y+18
    01C79 885B      LDD	R5,Y+19
    01C7A 8228      ST	Y,R2
    01C7B 8239      STD	Y+1,R3
    01C7C 824A      STD	Y+2,R4
    01C7D 825B      STD	Y+3,R5
    01C7E 8828      LDD	R2,Y+16
    01C7F 8839      LDD	R3,Y+17
    01C80 884A      LDD	R4,Y+18
    01C81 885B      LDD	R5,Y+19
    01C82 9488      BCLR	0
    01C83 2022      TST	R2
    01C84 0432      CPC	R3,R2
    01C85 0442      CPC	R4,R2
    01C86 0452      CPC	R5,R2
    01C87 F441      BNE	0x1C90
    01C88 E380      LDI	R24,0x30
    01C89 85EE      LDD	R30,Y+14
    01C8A 85FF      LDD	R31,Y+15
    01C8B 8380      ST	Z,R24
    01C8C 2422      CLR	R2
    01C8D 8221      STD	Z+1,R2
    01C8E 018F      MOVW	R16,R30
    01C8F C094      RJMP	0x1D24
    01C90 E040      LDI	R20,0
    01C91 E050      LDI	R21,0
    01C92 E060      LDI	R22,0
    01C93 E070      LDI	R23,0
    01C94 8828      LDD	R2,Y+16
    01C95 8839      LDD	R3,Y+17
    01C96 884A      LDD	R4,Y+18
    01C97 885B      LDD	R5,Y+19
    01C98 1624      CP	R2,R20
    01C99 0635      CPC	R3,R21
    01C9A 0646      CPC	R4,R22
    01C9B 0657      CPC	R5,R23
    01C9C F4EC      BGE	0x1CBA
    01C9D 898C      LDD	R24,Y+20
    01C9E 899D      LDD	R25,Y+21
    01C9F 308A      CPI	R24,0xA
    01CA0 E0A0      LDI	R26,0
    01CA1 079A      CPC	R25,R26
    01CA2 F4B9      BNE	0x1CBA
    01CA3 24AA      CLR	R10
    01CA4 94A3      INC	R10
    01CA5 E041      LDI	R20,1
    01CA6 E050      LDI	R21,0
    01CA7 E060      LDI	R22,0
    01CA8 E070      LDI	R23,0
    01CA9 8028      LD	R2,Y
    01CAA 8039      LDD	R3,Y+1
    01CAB 804A      LDD	R4,Y+2
    01CAC 805B      LDD	R5,Y+3
    01CAD 9420      COM	R2
    01CAE 9430      COM	R3
    01CAF 9440      COM	R4
    01CB0 9450      COM	R5
    01CB1 0E24      ADD	R2,R20
    01CB2 1E35      ADC	R3,R21
    01CB3 1E46      ADC	R4,R22
    01CB4 1E57      ADC	R5,R23
    01CB5 8228      ST	Y,R2
    01CB6 8239      STD	Y+1,R3
    01CB7 824A      STD	Y+2,R4
    01CB8 825B      STD	Y+3,R5
    01CB9 C001      RJMP	0x1CBB
    01CBA 24AA      CLR	R10
    01CBB 84CE      LDD	R12,Y+14
    01CBC 84DF      LDD	R13,Y+15
    01CBD 882C      LDD	R2,Y+20
    01CBE 883D      LDD	R3,Y+21
    01CBF 2444      CLR	R4
    01CC0 FC37      SBRC	R3,7
    01CC1 9440      COM	R4
    01CC2 2455      CLR	R5
    01CC3 FC47      SBRC	R4,7
    01CC4 9450      COM	R5
    01CC5 8108      LD	R16,Y
    01CC6 8119      LDD	R17,Y+1
    01CC7 812A      LDD	R18,Y+2
    01CC8 813B      LDD	R19,Y+3
    01CC9 925A      ST	-Y,R5
    01CCA 924A      ST	-Y,R4
    01CCB 923A      ST	-Y,R3
    01CCC 922A      ST	-Y,R2
    01CCD 940E 1A25 CALL	mod32u
    01CCF 0178      MOVW	R14,R16
    01CD0 E089      LDI	R24,0x9
    01CD1 E090      LDI	R25,0
    01CD2 1780      CP	R24,R16
    01CD3 0791      CPC	R25,R17
    01CD4 F034      BLT	0x1CDB
    01CD5 01C7      MOVW	R24,R14
    01CD6 96C0      ADIW	R24,0x30
    01CD7 01F6      MOVW	R30,R12
    01CD8 9381      ST	Z+,R24
    01CD9 016F      MOVW	R12,R30
    01CDA C006      RJMP	0x1CE1
    01CDB 01C7      MOVW	R24,R14
    01CDC 5A89      SUBI	R24,0xA9
    01CDD 4F9F      SBCI	R25,0xFF
    01CDE 01F6      MOVW	R30,R12
    01CDF 9381      ST	Z+,R24
    01CE0 016F      MOVW	R12,R30
    01CE1 882C      LDD	R2,Y+20
    01CE2 883D      LDD	R3,Y+21
    01CE3 2444      CLR	R4
    01CE4 FC37      SBRC	R3,7
    01CE5 9440      COM	R4
    01CE6 2455      CLR	R5
    01CE7 FC47      SBRC	R4,7
    01CE8 9450      COM	R5
    01CE9 8108      LD	R16,Y
    01CEA 8119      LDD	R17,Y+1
    01CEB 812A      LDD	R18,Y+2
    01CEC 813B      LDD	R19,Y+3
    01CED 925A      ST	-Y,R5
    01CEE 924A      ST	-Y,R4
    01CEF 923A      ST	-Y,R3
    01CF0 922A      ST	-Y,R2
    01CF1 940E 1A23 CALL	div32u
    01CF3 8308      ST	Y,R16
    01CF4 8319      STD	Y+1,R17
    01CF5 832A      STD	Y+2,R18
    01CF6 833B      STD	Y+3,R19
    01CF7 8028      LD	R2,Y
    01CF8 8039      LDD	R3,Y+1
    01CF9 804A      LDD	R4,Y+2
    01CFA 805B      LDD	R5,Y+3
    01CFB 9488      BCLR	0
    01CFC 2022      TST	R2
    01CFD 0432      CPC	R3,R2
    01CFE 0442      CPC	R4,R2
    01CFF 0452      CPC	R5,R2
    01D00 F009      BEQ	0x1D02
    01D01 CFBB      RJMP	0x1CBD
    01D02 20AA      TST	R10
    01D03 F021      BEQ	0x1D08
    01D04 E28D      LDI	R24,0x2D
    01D05 01F6      MOVW	R30,R12
    01D06 9381      ST	Z+,R24
    01D07 016F      MOVW	R12,R30
    01D08 0126      MOVW	R4,R12
    01D09 01C2      MOVW	R24,R4
    01D0A 9701      SBIW	R24,1
    01D0B 016C      MOVW	R12,R24
    01D0C 2422      CLR	R2
    01D0D 01F2      MOVW	R30,R4
    01D0E 8220      ST	Z,R2
    01D0F 84EE      LDD	R14,Y+14
    01D10 84FF      LDD	R15,Y+15
    01D11 C00D      RJMP	0x1D1F
    01D12 01F7      MOVW	R30,R14
    01D13 80A0      LD	R10,Z
    01D14 01F6      MOVW	R30,R12
    01D15 8020      LD	R2,Z
    01D16 01F7      MOVW	R30,R14
    01D17 9221      ST	Z+,R2
    01D18 017F      MOVW	R14,R30
    01D19 0116      MOVW	R2,R12
    01D1A 01C1      MOVW	R24,R2
    01D1B 9701      SBIW	R24,1
    01D1C 016C      MOVW	R12,R24
    01D1D 01F1      MOVW	R30,R2
    01D1E 82A0      ST	Z,R10
    01D1F 14EC      CP	R14,R12
    01D20 04FD      CPC	R15,R13
    01D21 F380      BCS	0x1D12
    01D22 850E      LDD	R16,Y+14
    01D23 851F      LDD	R17,Y+15
    01D24 9624      ADIW	R28,4
    01D25 940E 1AE6 CALL	pop_xgsetF0FC
    01D27 9624      ADIW	R28,4
    01D28 9508      RET
_strtol:
    01D29 940E 19E4 CALL	push_arg4
    01D2B 940E 1AF5 CALL	push_xgset00FC
    01D2D 9760      SBIW	R28,0x10
    01D2E E080      LDI	R24,0
    01D2F 8388      ST	Y,R24
    01D30 8389      STD	Y+1,R24
    01D31 838A      STD	Y+2,R24
    01D32 838B      STD	Y+3,R24
    01D33 C005      RJMP	0x1D39
    01D34 898E      LDD	R24,Y+22
    01D35 899F      LDD	R25,Y+23
    01D36 9601      ADIW	R24,1
    01D37 8B9F      STD	Y+23,R25
    01D38 8B8E      STD	Y+22,R24
    01D39 89EE      LDD	R30,Y+22
    01D3A 89FF      LDD	R31,Y+23
    01D3B 8100      LD	R16,Z
    01D3C 2711      CLR	R17
    01D3D 940E 2082 CALL	_isspace
    01D3F 3000      CPI	R16,0
    01D40 0701      CPC	R16,R17
    01D41 F791      BNE	0x1D34
    01D42 89EE      LDD	R30,Y+22
    01D43 89FF      LDD	R31,Y+23
    01D44 8020      LD	R2,Z
    01D45 2022      TST	R2
    01D46 F079      BEQ	0x1D56
    01D47 8C0A      LDD	R0,Y+26
    01D48 8C1B      LDD	R1,Y+27
    01D49 2000      TST	R0
    01D4A F411      BNE	0x1D4D
    01D4B 2011      TST	R1
    01D4C F0C9      BEQ	0x1D66
    01D4D E081      LDI	R24,1
    01D4E E090      LDI	R25,0
    01D4F 1580      CP	R24,R0
    01D50 0591      CPC	R25,R1
    01D51 F424      BGE	0x1D56
    01D52 E284      LDI	R24,0x24
    01D53 1580      CP	R24,R0
    01D54 0591      CPC	R25,R1
    01D55 F484      BGE	0x1D66
    01D56 8C08      LDD	R0,Y+24
    01D57 8C19      LDD	R1,Y+25
    01D58 2000      TST	R0
    01D59 F411      BNE	0x1D5C
    01D5A 2011      TST	R1
    01D5B F029      BEQ	0x1D61
    01D5C 01F0      MOVW	R30,R0
    01D5D 880E      LDD	R0,Y+22
    01D5E 881F      LDD	R1,Y+23
    01D5F 8211      STD	Z+1,R1
    01D60 8200      ST	Z,R0
    01D61 E000      LDI	R16,0
    01D62 E010      LDI	R17,0
    01D63 E020      LDI	R18,0
    01D64 E030      LDI	R19,0
    01D65 C12C      RJMP	0x1E92
    01D66 2400      CLR	R0
    01D67 2411      CLR	R1
    01D68 861D      STD	Y+13,R1
    01D69 860C      STD	Y+12,R0
    01D6A 89EE      LDD	R30,Y+22
    01D6B 89FF      LDD	R31,Y+23
    01D6C 8180      LD	R24,Z
    01D6D 328D      CPI	R24,0x2D
    01D6E F449      BNE	0x1D78
    01D6F 01CF      MOVW	R24,R30
    01D70 9601      ADIW	R24,1
    01D71 8B9F      STD	Y+23,R25
    01D72 8B8E      STD	Y+22,R24
    01D73 E081      LDI	R24,1
    01D74 E090      LDI	R25,0
    01D75 879D      STD	Y+13,R25
    01D76 878C      STD	Y+12,R24
    01D77 C009      RJMP	0x1D81
    01D78 89EE      LDD	R30,Y+22
    01D79 89FF      LDD	R31,Y+23
    01D7A 8180      LD	R24,Z
    01D7B 328B      CPI	R24,0x2B
    01D7C F421      BNE	0x1D81
    01D7D 01CF      MOVW	R24,R30
    01D7E 9601      ADIW	R24,1
    01D7F 8B9F      STD	Y+23,R25
    01D80 8B8E      STD	Y+22,R24
    01D81 89EE      LDD	R30,Y+22
    01D82 89FF      LDD	R31,Y+23
    01D83 8180      LD	R24,Z
    01D84 3380      CPI	R24,0x30
    01D85 F4D1      BNE	0x1DA0
    01D86 8021      LDD	R2,Z+1
    01D87 2433      CLR	R3
    01D88 2D82      MOV	R24,R2
    01D89 3588      CPI	R24,0x58
    01D8A F011      BEQ	0x1D8D
    01D8B 3788      CPI	R24,0x78
    01D8C F499      BNE	0x1DA0
    01D8D 8D8A      LDD	R24,Y+26
    01D8E 8D9B      LDD	R25,Y+27
    01D8F 3180      CPI	R24,0x10
    01D90 E0E0      LDI	R30,0
    01D91 079E      CPC	R25,R30
    01D92 F021      BEQ	0x1D97
    01D93 010C      MOVW	R0,R24
    01D94 3080      CPI	R24,0
    01D95 0789      CPC	R24,R25
    01D96 F449      BNE	0x1DA0
    01D97 E180      LDI	R24,0x10
    01D98 E090      LDI	R25,0
    01D99 8F9B      STD	Y+27,R25
    01D9A 8F8A      STD	Y+26,R24
    01D9B 898E      LDD	R24,Y+22
    01D9C 899F      LDD	R25,Y+23
    01D9D 9602      ADIW	R24,2
    01D9E 8B9F      STD	Y+23,R25
    01D9F 8B8E      STD	Y+22,R24
    01DA0 8C0A      LDD	R0,Y+26
    01DA1 8C1B      LDD	R1,Y+27
    01DA2 2000      TST	R0
    01DA3 F481      BNE	0x1DB4
    01DA4 2011      TST	R1
    01DA5 F471      BNE	0x1DB4
    01DA6 89EE      LDD	R30,Y+22
    01DA7 89FF      LDD	R31,Y+23
    01DA8 8180      LD	R24,Z
    01DA9 3380      CPI	R24,0x30
    01DAA F421      BNE	0x1DAF
    01DAB E088      LDI	R24,0x8
    01DAC E090      LDI	R25,0
    01DAD 015C      MOVW	R10,R24
    01DAE C003      RJMP	0x1DB2
    01DAF E08A      LDI	R24,0xA
    01DB0 E090      LDI	R25,0
    01DB1 015C      MOVW	R10,R24
    01DB2 8EBB      STD	Y+27,R11
    01DB3 8EAA      STD	Y+26,R10
    01DB4 8D8A      LDD	R24,Y+26
    01DB5 8D9B      LDD	R25,Y+27
    01DB6 308A      CPI	R24,0xA
    01DB7 E0E0      LDI	R30,0
    01DB8 079E      CPC	R25,R30
    01DB9 F024      BLT	0x1DBE
    01DBA E389      LDI	R24,0x39
    01DBB E090      LDI	R25,0
    01DBC 015C      MOVW	R10,R24
    01DBD C005      RJMP	0x1DC3
    01DBE 8D8A      LDD	R24,Y+26
    01DBF 8D9B      LDD	R25,Y+27
    01DC0 9701      SBIW	R24,1
    01DC1 96C0      ADIW	R24,0x30
    01DC2 015C      MOVW	R10,R24
    01DC3 0165      MOVW	R12,R10
    01DC4 E08A      LDI	R24,0xA
    01DC5 E090      LDI	R25,0
    01DC6 8C0A      LDD	R0,Y+26
    01DC7 8C1B      LDD	R1,Y+27
    01DC8 1580      CP	R24,R0
    01DC9 0591      CPC	R25,R1
    01DCA F00C      BLT	0x1DCC
    01DCB C098      RJMP	0x1E64
    01DCC 01C0      MOVW	R24,R0
    01DCD 970B      SBIW	R24,0xB
    01DCE 598F      SUBI	R24,0x9F
    01DCF 4F9F      SBCI	R25,0xFF
    01DD0 879F      STD	Y+15,R25
    01DD1 878E      STD	Y+14,R24
    01DD2 C091      RJMP	0x1E64
    01DD3 89EE      LDD	R30,Y+22
    01DD4 89FF      LDD	R31,Y+23
    01DD5 8100      LD	R16,Z
    01DD6 2711      CLR	R17
    01DD7 940E 206E CALL	_isdigit
    01DD9 0158      MOVW	R10,R16
    01DDA 3000      CPI	R16,0
    01DDB 0701      CPC	R16,R17
    01DDC F061      BEQ	0x1DE9
    01DDD 89EE      LDD	R30,Y+22
    01DDE 89FF      LDD	R31,Y+23
    01DDF 8020      LD	R2,Z
    01DE0 2433      CLR	R3
    01DE1 14C2      CP	R12,R2
    01DE2 04D3      CPC	R13,R3
    01DE3 F02C      BLT	0x1DE9
    01DE4 8180      LD	R24,Z
    01DE5 2799      CLR	R25
    01DE6 97C0      SBIW	R24,0x30
    01DE7 017C      MOVW	R14,R24
    01DE8 C020      RJMP	0x1E09
    01DE9 E08A      LDI	R24,0xA
    01DEA E090      LDI	R25,0
    01DEB 8C0A      LDD	R0,Y+26
    01DEC 8C1B      LDD	R1,Y+27
    01DED 1580      CP	R24,R0
    01DEE 0591      CPC	R25,R1
    01DEF F00C      BLT	0x1DF1
    01DF0 C079      RJMP	0x1E6A
    01DF1 89EE      LDD	R30,Y+22
    01DF2 89FF      LDD	R31,Y+23
    01DF3 8100      LD	R16,Z
    01DF4 2711      CLR	R17
    01DF5 940E 20B3 CALL	_tolower
    01DF7 0158      MOVW	R10,R16
    01DF8 0175      MOVW	R14,R10
    01DF9 01C5      MOVW	R24,R10
    01DFA 3601      CPI	R16,0x61
    01DFB E0E0      LDI	R30,0
    01DFC 071E      CPC	R17,R30
    01DFD F40C      BGE	0x1DFF
    01DFE C06B      RJMP	0x1E6A
    01DFF 840E      LDD	R0,Y+14
    01E00 841F      LDD	R1,Y+15
    01E01 1600      CP	R0,R16
    01E02 0611      CPC	R1,R17
    01E03 F40C      BGE	0x1E05
    01E04 C065      RJMP	0x1E6A
    01E05 5681      SUBI	R24,0x61
    01E06 4090      SBCI	R25,0
    01E07 960A      ADIW	R24,0xA
    01E08 017C      MOVW	R14,R24
    01E09 8028      LD	R2,Y
    01E0A 8039      LDD	R3,Y+1
    01E0B 804A      LDD	R4,Y+2
    01E0C 805B      LDD	R5,Y+3
    01E0D 822C      STD	Y+4,R2
    01E0E 823D      STD	Y+5,R3
    01E0F 824E      STD	Y+6,R4
    01E10 825F      STD	Y+7,R5
    01E11 8C2A      LDD	R2,Y+26
    01E12 8C3B      LDD	R3,Y+27
    01E13 2444      CLR	R4
    01E14 FC37      SBRC	R3,7
    01E15 9440      COM	R4
    01E16 2455      CLR	R5
    01E17 FC47      SBRC	R4,7
    01E18 9450      COM	R5
    01E19 8108      LD	R16,Y
    01E1A 8119      LDD	R17,Y+1
    01E1B 812A      LDD	R18,Y+2
    01E1C 813B      LDD	R19,Y+3
    01E1D 925A      ST	-Y,R5
    01E1E 924A      ST	-Y,R4
    01E1F 923A      ST	-Y,R3
    01E20 922A      ST	-Y,R2
    01E21 940E 1A9D CALL	empy32u|empy32s
    01E23 0118      MOVW	R2,R16
    01E24 0129      MOVW	R4,R18
    01E25 0137      MOVW	R6,R14
    01E26 2488      CLR	R8
    01E27 FC77      SBRC	R7,7
    01E28 9480      COM	R8
    01E29 2499      CLR	R9
    01E2A FC87      SBRC	R8,7
    01E2B 9490      COM	R9
    01E2C 0C26      ADD	R2,R6
    01E2D 1C37      ADC	R3,R7
    01E2E 1C48      ADC	R4,R8
    01E2F 1C59      ADC	R5,R9
    01E30 8228      ST	Y,R2
    01E31 8239      STD	Y+1,R3
    01E32 824A      STD	Y+2,R4
    01E33 825B      STD	Y+3,R5
    01E34 802C      LDD	R2,Y+4
    01E35 803D      LDD	R3,Y+5
    01E36 804E      LDD	R4,Y+6
    01E37 805F      LDD	R5,Y+7
    01E38 8068      LD	R6,Y
    01E39 8079      LDD	R7,Y+1
    01E3A 808A      LDD	R8,Y+2
    01E3B 809B      LDD	R9,Y+3
    01E3C 1462      CP	R6,R2
    01E3D 0473      CPC	R7,R3
    01E3E 0484      CPC	R8,R4
    01E3F 0495      CPC	R9,R5
    01E40 F4F4      BGE	0x1E5F
    01E41 E082      LDI	R24,2
    01E42 E090      LDI	R25,0
    01E43 9390 08A7 STS	errno+1,R25
    01E45 9380 08A6 STS	errno,R24
    01E47 840C      LDD	R0,Y+12
    01E48 841D      LDD	R1,Y+13
    01E49 2000      TST	R0
    01E4A F411      BNE	0x1E4D
    01E4B 2011      TST	R1
    01E4C F039      BEQ	0x1E54
    01E4D E080      LDI	R24,0
    01E4E 8788      STD	Y+8,R24
    01E4F 8789      STD	Y+9,R24
    01E50 878A      STD	Y+10,R24
    01E51 E880      LDI	R24,0x80
    01E52 878B      STD	Y+11,R24
    01E53 C006      RJMP	0x1E5A
    01E54 EF8F      LDI	R24,0xFF
    01E55 8788      STD	Y+8,R24
    01E56 8789      STD	Y+9,R24
    01E57 878A      STD	Y+10,R24
    01E58 E78F      LDI	R24,0x7F
    01E59 878B      STD	Y+11,R24
    01E5A 8508      LDD	R16,Y+8
    01E5B 8519      LDD	R17,Y+9
    01E5C 852A      LDD	R18,Y+10
    01E5D 853B      LDD	R19,Y+11
    01E5E C033      RJMP	0x1E92
    01E5F 898E      LDD	R24,Y+22
    01E60 899F      LDD	R25,Y+23
    01E61 9601      ADIW	R24,1
    01E62 8B9F      STD	Y+23,R25
    01E63 8B8E      STD	Y+22,R24
    01E64 89EE      LDD	R30,Y+22
    01E65 89FF      LDD	R31,Y+23
    01E66 8020      LD	R2,Z
    01E67 2022      TST	R2
    01E68 F009      BEQ	0x1E6A
    01E69 CF69      RJMP	0x1DD3
    01E6A 8C08      LDD	R0,Y+24
    01E6B 8C19      LDD	R1,Y+25
    01E6C 2000      TST	R0
    01E6D F411      BNE	0x1E70
    01E6E 2011      TST	R1
    01E6F F029      BEQ	0x1E75
    01E70 01F0      MOVW	R30,R0
    01E71 880E      LDD	R0,Y+22
    01E72 881F      LDD	R1,Y+23
    01E73 8211      STD	Z+1,R1
    01E74 8200      ST	Z,R0
    01E75 840C      LDD	R0,Y+12
    01E76 841D      LDD	R1,Y+13
    01E77 2000      TST	R0
    01E78 F411      BNE	0x1E7B
    01E79 2011      TST	R1
    01E7A F059      BEQ	0x1E86
    01E7B 8108      LD	R16,Y
    01E7C 8119      LDD	R17,Y+1
    01E7D 812A      LDD	R18,Y+2
    01E7E 813B      LDD	R19,Y+3
    01E7F 940E 1B47 CALL	neg32
    01E81 8708      STD	Y+8,R16
    01E82 8719      STD	Y+9,R17
    01E83 872A      STD	Y+10,R18
    01E84 873B      STD	Y+11,R19
    01E85 C008      RJMP	0x1E8E
    01E86 8028      LD	R2,Y
    01E87 8039      LDD	R3,Y+1
    01E88 804A      LDD	R4,Y+2
    01E89 805B      LDD	R5,Y+3
    01E8A 8628      STD	Y+8,R2
    01E8B 8639      STD	Y+9,R3
    01E8C 864A      STD	Y+10,R4
    01E8D 865B      STD	Y+11,R5
    01E8E 8508      LDD	R16,Y+8
    01E8F 8519      LDD	R17,Y+9
    01E90 852A      LDD	R18,Y+10
    01E91 853B      LDD	R19,Y+11
    01E92 9660      ADIW	R28,0x10
    01E93 940E 1AD6 CALL	pop_xgset00FC
    01E95 9624      ADIW	R28,4
    01E96 9508      RET
_strtoul:
    01E97 940E 19E4 CALL	push_arg4
    01E99 940E 1AF5 CALL	push_xgset00FC
    01E9B 972A      SBIW	R28,0xA
    01E9C E080      LDI	R24,0
    01E9D 8388      ST	Y,R24
    01E9E 8389      STD	Y+1,R24
    01E9F 838A      STD	Y+2,R24
    01EA0 838B      STD	Y+3,R24
    01EA1 C005      RJMP	0x1EA7
    01EA2 8988      LDD	R24,Y+16
    01EA3 8999      LDD	R25,Y+17
    01EA4 9601      ADIW	R24,1
    01EA5 8B99      STD	Y+17,R25
    01EA6 8B88      STD	Y+16,R24
    01EA7 89E8      LDD	R30,Y+16
    01EA8 89F9      LDD	R31,Y+17
    01EA9 8100      LD	R16,Z
    01EAA 2711      CLR	R17
    01EAB 940E 2082 CALL	_isspace
    01EAD 3000      CPI	R16,0
    01EAE 0701      CPC	R16,R17
    01EAF F791      BNE	0x1EA2
    01EB0 89E8      LDD	R30,Y+16
    01EB1 89F9      LDD	R31,Y+17
    01EB2 8020      LD	R2,Z
    01EB3 2022      TST	R2
    01EB4 F079      BEQ	0x1EC4
    01EB5 880C      LDD	R0,Y+20
    01EB6 881D      LDD	R1,Y+21
    01EB7 2000      TST	R0
    01EB8 F411      BNE	0x1EBB
    01EB9 2011      TST	R1
    01EBA F0C9      BEQ	0x1ED4
    01EBB E081      LDI	R24,1
    01EBC E090      LDI	R25,0
    01EBD 1580      CP	R24,R0
    01EBE 0591      CPC	R25,R1
    01EBF F424      BGE	0x1EC4
    01EC0 E284      LDI	R24,0x24
    01EC1 1580      CP	R24,R0
    01EC2 0591      CPC	R25,R1
    01EC3 F484      BGE	0x1ED4
    01EC4 880A      LDD	R0,Y+18
    01EC5 881B      LDD	R1,Y+19
    01EC6 2000      TST	R0
    01EC7 F411      BNE	0x1ECA
    01EC8 2011      TST	R1
    01EC9 F029      BEQ	0x1ECF
    01ECA 01F0      MOVW	R30,R0
    01ECB 8808      LDD	R0,Y+16
    01ECC 8819      LDD	R1,Y+17
    01ECD 8211      STD	Z+1,R1
    01ECE 8200      ST	Z,R0
    01ECF E000      LDI	R16,0
    01ED0 E010      LDI	R17,0
    01ED1 E020      LDI	R18,0
    01ED2 E030      LDI	R19,0
    01ED3 C0EE      RJMP	0x1FC2
    01ED4 89E8      LDD	R30,Y+16
    01ED5 89F9      LDD	R31,Y+17
    01ED6 8180      LD	R24,Z
    01ED7 328B      CPI	R24,0x2B
    01ED8 F421      BNE	0x1EDD
    01ED9 01CF      MOVW	R24,R30
    01EDA 9601      ADIW	R24,1
    01EDB 8B99      STD	Y+17,R25
    01EDC 8B88      STD	Y+16,R24
    01EDD 89E8      LDD	R30,Y+16
    01EDE 89F9      LDD	R31,Y+17
    01EDF 8180      LD	R24,Z
    01EE0 3380      CPI	R24,0x30
    01EE1 F4D1      BNE	0x1EFC
    01EE2 8021      LDD	R2,Z+1
    01EE3 2433      CLR	R3
    01EE4 2D82      MOV	R24,R2
    01EE5 3588      CPI	R24,0x58
    01EE6 F011      BEQ	0x1EE9
    01EE7 3788      CPI	R24,0x78
    01EE8 F499      BNE	0x1EFC
    01EE9 898C      LDD	R24,Y+20
    01EEA 899D      LDD	R25,Y+21
    01EEB 3180      CPI	R24,0x10
    01EEC E0E0      LDI	R30,0
    01EED 079E      CPC	R25,R30
    01EEE F021      BEQ	0x1EF3
    01EEF 010C      MOVW	R0,R24
    01EF0 3080      CPI	R24,0
    01EF1 0789      CPC	R24,R25
    01EF2 F449      BNE	0x1EFC
    01EF3 E180      LDI	R24,0x10
    01EF4 E090      LDI	R25,0
    01EF5 8B9D      STD	Y+21,R25
    01EF6 8B8C      STD	Y+20,R24
    01EF7 8988      LDD	R24,Y+16
    01EF8 8999      LDD	R25,Y+17
    01EF9 9602      ADIW	R24,2
    01EFA 8B99      STD	Y+17,R25
    01EFB 8B88      STD	Y+16,R24
    01EFC 880C      LDD	R0,Y+20
    01EFD 881D      LDD	R1,Y+21
    01EFE 2000      TST	R0
    01EFF F481      BNE	0x1F10
    01F00 2011      TST	R1
    01F01 F471      BNE	0x1F10
    01F02 89E8      LDD	R30,Y+16
    01F03 89F9      LDD	R31,Y+17
    01F04 8180      LD	R24,Z
    01F05 3380      CPI	R24,0x30
    01F06 F421      BNE	0x1F0B
    01F07 E088      LDI	R24,0x8
    01F08 E090      LDI	R25,0
    01F09 015C      MOVW	R10,R24
    01F0A C003      RJMP	0x1F0E
    01F0B E08A      LDI	R24,0xA
    01F0C E090      LDI	R25,0
    01F0D 015C      MOVW	R10,R24
    01F0E 8ABD      STD	Y+21,R11
    01F0F 8AAC      STD	Y+20,R10
    01F10 898C      LDD	R24,Y+20
    01F11 899D      LDD	R25,Y+21
    01F12 308A      CPI	R24,0xA
    01F13 E0E0      LDI	R30,0
    01F14 079E      CPC	R25,R30
    01F15 F024      BLT	0x1F1A
    01F16 E389      LDI	R24,0x39
    01F17 E090      LDI	R25,0
    01F18 015C      MOVW	R10,R24
    01F19 C005      RJMP	0x1F1F
    01F1A 898C      LDD	R24,Y+20
    01F1B 899D      LDD	R25,Y+21
    01F1C 9701      SBIW	R24,1
    01F1D 96C0      ADIW	R24,0x30
    01F1E 015C      MOVW	R10,R24
    01F1F 0165      MOVW	R12,R10
    01F20 E08A      LDI	R24,0xA
    01F21 E090      LDI	R25,0
    01F22 880C      LDD	R0,Y+20
    01F23 881D      LDD	R1,Y+21
    01F24 1580      CP	R24,R0
    01F25 0591      CPC	R25,R1
    01F26 F00C      BLT	0x1F28
    01F27 C085      RJMP	0x1FAD
    01F28 01C0      MOVW	R24,R0
    01F29 970B      SBIW	R24,0xB
    01F2A 598F      SUBI	R24,0x9F
    01F2B 4F9F      SBCI	R25,0xFF
    01F2C 8799      STD	Y+9,R25
    01F2D 8788      STD	Y+8,R24
    01F2E C07E      RJMP	0x1FAD
    01F2F 89E8      LDD	R30,Y+16
    01F30 89F9      LDD	R31,Y+17
    01F31 8100      LD	R16,Z
    01F32 2711      CLR	R17
    01F33 940E 206E CALL	_isdigit
    01F35 0158      MOVW	R10,R16
    01F36 3000      CPI	R16,0
    01F37 0701      CPC	R16,R17
    01F38 F061      BEQ	0x1F45
    01F39 89E8      LDD	R30,Y+16
    01F3A 89F9      LDD	R31,Y+17
    01F3B 8020      LD	R2,Z
    01F3C 2433      CLR	R3
    01F3D 14C2      CP	R12,R2
    01F3E 04D3      CPC	R13,R3
    01F3F F02C      BLT	0x1F45
    01F40 8180      LD	R24,Z
    01F41 2799      CLR	R25
    01F42 97C0      SBIW	R24,0x30
    01F43 017C      MOVW	R14,R24
    01F44 C020      RJMP	0x1F65
    01F45 E08A      LDI	R24,0xA
    01F46 E090      LDI	R25,0
    01F47 880C      LDD	R0,Y+20
    01F48 881D      LDD	R1,Y+21
    01F49 1580      CP	R24,R0
    01F4A 0591      CPC	R25,R1
    01F4B F00C      BLT	0x1F4D
    01F4C C066      RJMP	0x1FB3
    01F4D 89E8      LDD	R30,Y+16
    01F4E 89F9      LDD	R31,Y+17
    01F4F 8100      LD	R16,Z
    01F50 2711      CLR	R17
    01F51 940E 20B3 CALL	_tolower
    01F53 0158      MOVW	R10,R16
    01F54 0175      MOVW	R14,R10
    01F55 01C5      MOVW	R24,R10
    01F56 3601      CPI	R16,0x61
    01F57 E0E0      LDI	R30,0
    01F58 071E      CPC	R17,R30
    01F59 F40C      BGE	0x1F5B
    01F5A C058      RJMP	0x1FB3
    01F5B 8408      LDD	R0,Y+8
    01F5C 8419      LDD	R1,Y+9
    01F5D 1600      CP	R0,R16
    01F5E 0611      CPC	R1,R17
    01F5F F40C      BGE	0x1F61
    01F60 C052      RJMP	0x1FB3
    01F61 5681      SUBI	R24,0x61
    01F62 4090      SBCI	R25,0
    01F63 960A      ADIW	R24,0xA
    01F64 017C      MOVW	R14,R24
    01F65 8028      LD	R2,Y
    01F66 8039      LDD	R3,Y+1
    01F67 804A      LDD	R4,Y+2
    01F68 805B      LDD	R5,Y+3
    01F69 822C      STD	Y+4,R2
    01F6A 823D      STD	Y+5,R3
    01F6B 824E      STD	Y+6,R4
    01F6C 825F      STD	Y+7,R5
    01F6D 882C      LDD	R2,Y+20
    01F6E 883D      LDD	R3,Y+21
    01F6F 2444      CLR	R4
    01F70 FC37      SBRC	R3,7
    01F71 9440      COM	R4
    01F72 2455      CLR	R5
    01F73 FC47      SBRC	R4,7
    01F74 9450      COM	R5
    01F75 8108      LD	R16,Y
    01F76 8119      LDD	R17,Y+1
    01F77 812A      LDD	R18,Y+2
    01F78 813B      LDD	R19,Y+3
    01F79 925A      ST	-Y,R5
    01F7A 924A      ST	-Y,R4
    01F7B 923A      ST	-Y,R3
    01F7C 922A      ST	-Y,R2
    01F7D 940E 1A9D CALL	empy32u|empy32s
    01F7F 0118      MOVW	R2,R16
    01F80 0129      MOVW	R4,R18
    01F81 0137      MOVW	R6,R14
    01F82 2488      CLR	R8
    01F83 FC77      SBRC	R7,7
    01F84 9480      COM	R8
    01F85 2499      CLR	R9
    01F86 FC87      SBRC	R8,7
    01F87 9490      COM	R9
    01F88 0C26      ADD	R2,R6
    01F89 1C37      ADC	R3,R7
    01F8A 1C48      ADC	R4,R8
    01F8B 1C59      ADC	R5,R9
    01F8C 8228      ST	Y,R2
    01F8D 8239      STD	Y+1,R3
    01F8E 824A      STD	Y+2,R4
    01F8F 825B      STD	Y+3,R5
    01F90 802C      LDD	R2,Y+4
    01F91 803D      LDD	R3,Y+5
    01F92 804E      LDD	R4,Y+6
    01F93 805F      LDD	R5,Y+7
    01F94 8068      LD	R6,Y
    01F95 8079      LDD	R7,Y+1
    01F96 808A      LDD	R8,Y+2
    01F97 809B      LDD	R9,Y+3
    01F98 1462      CP	R6,R2
    01F99 0473      CPC	R7,R3
    01F9A 0484      CPC	R8,R4
    01F9B 0495      CPC	R9,R5
    01F9C F458      BCC	0x1FA8
    01F9D E082      LDI	R24,2
    01F9E E090      LDI	R25,0
    01F9F 9390 08A7 STS	errno+1,R25
    01FA1 9380 08A6 STS	errno,R24
    01FA3 EF0F      LDI	R16,0xFF
    01FA4 EF1F      LDI	R17,0xFF
    01FA5 EF2F      LDI	R18,0xFF
    01FA6 EF3F      LDI	R19,0xFF
    01FA7 C01A      RJMP	0x1FC2
    01FA8 8988      LDD	R24,Y+16
    01FA9 8999      LDD	R25,Y+17
    01FAA 9601      ADIW	R24,1
    01FAB 8B99      STD	Y+17,R25
    01FAC 8B88      STD	Y+16,R24
    01FAD 89E8      LDD	R30,Y+16
    01FAE 89F9      LDD	R31,Y+17
    01FAF 8020      LD	R2,Z
    01FB0 2022      TST	R2
    01FB1 F009      BEQ	0x1FB3
    01FB2 CF7C      RJMP	0x1F2F
    01FB3 880A      LDD	R0,Y+18
    01FB4 881B      LDD	R1,Y+19
    01FB5 2000      TST	R0
    01FB6 F411      BNE	0x1FB9
    01FB7 2011      TST	R1
    01FB8 F029      BEQ	0x1FBE
    01FB9 01F0      MOVW	R30,R0
    01FBA 8808      LDD	R0,Y+16
    01FBB 8819      LDD	R1,Y+17
    01FBC 8211      STD	Z+1,R1
    01FBD 8200      ST	Z,R0
    01FBE 8108      LD	R16,Y
    01FBF 8119      LDD	R17,Y+1
    01FC0 812A      LDD	R18,Y+2
    01FC1 813B      LDD	R19,Y+3
    01FC2 962A      ADIW	R28,0xA
    01FC3 940E 1AD6 CALL	pop_xgset00FC
    01FC5 9624      ADIW	R28,4
    01FC6 9508      RET
_ultoa:
    01FC7 933A      ST	-Y,R19
    01FC8 932A      ST	-Y,R18
    01FC9 940E 1AF1 CALL	push_xgsetF0FC
    01FCB 0158      MOVW	R10,R16
    01FCC 84CE      LDD	R12,Y+14
    01FCD 84DF      LDD	R13,Y+15
    01FCE 01A5      MOVW	R20,R10
    01FCF 0116      MOVW	R2,R12
    01FD0 2444      CLR	R4
    01FD1 FC37      SBRC	R3,7
    01FD2 9440      COM	R4
    01FD3 2455      CLR	R5
    01FD4 FC47      SBRC	R4,7
    01FD5 9450      COM	R5
    01FD6 850A      LDD	R16,Y+10
    01FD7 851B      LDD	R17,Y+11
    01FD8 852C      LDD	R18,Y+12
    01FD9 853D      LDD	R19,Y+13
    01FDA 925A      ST	-Y,R5
    01FDB 924A      ST	-Y,R4
    01FDC 923A      ST	-Y,R3
    01FDD 922A      ST	-Y,R2
    01FDE 940E 1A25 CALL	mod32u
    01FE0 01B8      MOVW	R22,R16
    01FE1 E089      LDI	R24,0x9
    01FE2 E090      LDI	R25,0
    01FE3 1780      CP	R24,R16
    01FE4 0791      CPC	R25,R17
    01FE5 F034      BLT	0x1FEC
    01FE6 01CB      MOVW	R24,R22
    01FE7 96C0      ADIW	R24,0x30
    01FE8 01FA      MOVW	R30,R20
    01FE9 9381      ST	Z+,R24
    01FEA 01AF      MOVW	R20,R30
    01FEB C006      RJMP	0x1FF2
    01FEC 01CB      MOVW	R24,R22
    01FED 5A89      SUBI	R24,0xA9
    01FEE 4F9F      SBCI	R25,0xFF
    01FEF 01FA      MOVW	R30,R20
    01FF0 9381      ST	Z+,R24
    01FF1 01AF      MOVW	R20,R30
    01FF2 0116      MOVW	R2,R12
    01FF3 2444      CLR	R4
    01FF4 FC37      SBRC	R3,7
    01FF5 9440      COM	R4
    01FF6 2455      CLR	R5
    01FF7 FC47      SBRC	R4,7
    01FF8 9450      COM	R5
    01FF9 850A      LDD	R16,Y+10
    01FFA 851B      LDD	R17,Y+11
    01FFB 852C      LDD	R18,Y+12
    01FFC 853D      LDD	R19,Y+13
    01FFD 925A      ST	-Y,R5
    01FFE 924A      ST	-Y,R4
    01FFF 923A      ST	-Y,R3
    02000 922A      ST	-Y,R2
    02001 940E 1A23 CALL	div32u
    02003 870A      STD	Y+10,R16
    02004 871B      STD	Y+11,R17
    02005 872C      STD	Y+12,R18
    02006 873D      STD	Y+13,R19
    02007 842A      LDD	R2,Y+10
    02008 843B      LDD	R3,Y+11
    02009 844C      LDD	R4,Y+12
    0200A 845D      LDD	R5,Y+13
    0200B 9488      BCLR	0
    0200C 2022      TST	R2
    0200D 0432      CPC	R3,R2
    0200E 0442      CPC	R4,R2
    0200F 0452      CPC	R5,R2
    02010 F009      BEQ	0x2012
    02011 CFBD      RJMP	0x1FCF
    02012 012A      MOVW	R4,R20
    02013 5041      SUBI	R20,1
    02014 4050      SBCI	R21,0
    02015 2422      CLR	R2
    02016 01F2      MOVW	R30,R4
    02017 8220      ST	Z,R2
    02018 0165      MOVW	R12,R10
    02019 C00C      RJMP	0x2026
    0201A 01F6      MOVW	R30,R12
    0201B 80E0      LD	R14,Z
    0201C 01FA      MOVW	R30,R20
    0201D 8020      LD	R2,Z
    0201E 01F6      MOVW	R30,R12
    0201F 9221      ST	Z+,R2
    02020 016F      MOVW	R12,R30
    02021 011A      MOVW	R2,R20
    02022 5041      SUBI	R20,1
    02023 4050      SBCI	R21,0
    02024 01F1      MOVW	R30,R2
    02025 82E0      ST	Z,R14
    02026 16C4      CP	R12,R20
    02027 06D5      CPC	R13,R21
    02028 F388      BCS	0x201A
    02029 0185      MOVW	R16,R10
    0202A 940E 1AE6 CALL	pop_xgsetF0FC
    0202C 9622      ADIW	R28,2
    0202D 9508      RET
_utoa:
    0202E 940E 1AF1 CALL	push_xgsetF0FC
    02030 0169      MOVW	R12,R18
    02031 0158      MOVW	R10,R16
    02032 84EA      LDD	R14,Y+10
    02033 84FB      LDD	R15,Y+11
    02034 01A5      MOVW	R20,R10
    02035 0197      MOVW	R18,R14
    02036 0186      MOVW	R16,R12
    02037 940E 1A07 CALL	mod16u
    02039 01B8      MOVW	R22,R16
    0203A E089      LDI	R24,0x9
    0203B E090      LDI	R25,0
    0203C 1780      CP	R24,R16
    0203D 0791      CPC	R25,R17
    0203E F034      BLT	0x2045
    0203F 01CB      MOVW	R24,R22
    02040 96C0      ADIW	R24,0x30
    02041 01FA      MOVW	R30,R20
    02042 9381      ST	Z+,R24
    02043 01AF      MOVW	R20,R30
    02044 C006      RJMP	0x204B
    02045 01CB      MOVW	R24,R22
    02046 5A89      SUBI	R24,0xA9
    02047 4F9F      SBCI	R25,0xFF
    02048 01FA      MOVW	R30,R20
    02049 9381      ST	Z+,R24
    0204A 01AF      MOVW	R20,R30
    0204B 0197      MOVW	R18,R14
    0204C 0186      MOVW	R16,R12
    0204D 940E 1A09 CALL	div16u
    0204F 0168      MOVW	R12,R16
    02050 20CC      TST	R12
    02051 F719      BNE	0x2035
    02052 20DD      TST	R13
    02053 F709      BNE	0x2035
    02054 012A      MOVW	R4,R20
    02055 5041      SUBI	R20,1
    02056 4050      SBCI	R21,0
    02057 2422      CLR	R2
    02058 01F2      MOVW	R30,R4
    02059 8220      ST	Z,R2
    0205A 0165      MOVW	R12,R10
    0205B C00C      RJMP	0x2068
    0205C 01F6      MOVW	R30,R12
    0205D 80E0      LD	R14,Z
    0205E 01FA      MOVW	R30,R20
    0205F 8020      LD	R2,Z
    02060 01F6      MOVW	R30,R12
    02061 9221      ST	Z+,R2
    02062 016F      MOVW	R12,R30
    02063 011A      MOVW	R2,R20
    02064 5041      SUBI	R20,1
    02065 4050      SBCI	R21,0
    02066 01F1      MOVW	R30,R2
    02067 82E0      ST	Z,R14
    02068 16C4      CP	R12,R20
    02069 06D5      CPC	R13,R21
    0206A F388      BCS	0x205C
    0206B 0185      MOVW	R16,R10
    0206C 940C 1AE6 JMP	pop_xgsetF0FC
_isdigit:
    0206E E087      LDI	R24,7
    0206F E091      LDI	R25,1
    02070 01F8      MOVW	R30,R16
    02071 0FE8      ADD	R30,R24
    02072 1FF9      ADC	R31,R25
    02073 9106      ELPM	R16,Z
    02074 2711      CLR	R17
    02075 7004      ANDI	R16,4
    02076 7010      ANDI	R17,0
    02077 9508      RET
_islower:
    02078 E087      LDI	R24,7
    02079 E091      LDI	R25,1
    0207A 01F8      MOVW	R30,R16
    0207B 0FE8      ADD	R30,R24
    0207C 1FF9      ADC	R31,R25
    0207D 9106      ELPM	R16,Z
    0207E 2711      CLR	R17
    0207F 7002      ANDI	R16,2
    02080 7010      ANDI	R17,0
    02081 9508      RET
_isspace:
    02082 E087      LDI	R24,7
    02083 E091      LDI	R25,1
    02084 01F8      MOVW	R30,R16
    02085 0FE8      ADD	R30,R24
    02086 1FF9      ADC	R31,R25
    02087 9106      ELPM	R16,Z
    02088 2711      CLR	R17
    02089 7100      ANDI	R16,0x10
    0208A 7010      ANDI	R17,0
    0208B 9508      RET
_isupper:
    0208C E087      LDI	R24,7
    0208D E091      LDI	R25,1
    0208E 01F8      MOVW	R30,R16
    0208F 0FE8      ADD	R30,R24
    02090 1FF9      ADC	R31,R25
    02091 9106      ELPM	R16,Z
    02092 2711      CLR	R17
    02093 7001      ANDI	R16,1
    02094 7010      ANDI	R17,0
    02095 9508      RET
_isxdigit:
    02096 E087      LDI	R24,7
    02097 E091      LDI	R25,1
    02098 01F8      MOVW	R30,R16
    02099 0FE8      ADD	R30,R24
    0209A 1FF9      ADC	R31,R25
    0209B 9106      ELPM	R16,Z
    0209C 2711      CLR	R17
    0209D 7008      ANDI	R16,0x8
    0209E 7010      ANDI	R17,0
    0209F 9508      RET
_toupper:
    020A0 934A      ST	-Y,R20
    020A1 935A      ST	-Y,R21
    020A2 01A8      MOVW	R20,R16
    020A3 018A      MOVW	R16,R20
    020A4 940E 2078 CALL	_islower
    020A6 3000      CPI	R16,0
    020A7 0701      CPC	R16,R17
    020A8 F031      BEQ	0x20AF
    020A9 018A      MOVW	R16,R20
    020AA 5601      SUBI	R16,0x61
    020AB 4010      SBCI	R17,0
    020AC 5B0F      SUBI	R16,0xBF
    020AD 4F1F      SBCI	R17,0xFF
    020AE C001      RJMP	0x20B0
    020AF 018A      MOVW	R16,R20
    020B0 9159      LD	R21,Y+
    020B1 9149      LD	R20,Y+
    020B2 9508      RET
_tolower:
    020B3 934A      ST	-Y,R20
    020B4 935A      ST	-Y,R21
    020B5 01A8      MOVW	R20,R16
    020B6 018A      MOVW	R16,R20
    020B7 940E 208C CALL	_isupper
    020B9 3000      CPI	R16,0
    020BA 0701      CPC	R16,R17
    020BB F031      BEQ	0x20C2
    020BC 018A      MOVW	R16,R20
    020BD 5401      SUBI	R16,0x41
    020BE 4010      SBCI	R17,0
    020BF 590F      SUBI	R16,0x9F
    020C0 4F1F      SBCI	R17,0xFF
    020C1 C001      RJMP	0x20C3
    020C2 018A      MOVW	R16,R20
    020C3 9159      LD	R21,Y+
    020C4 9149      LD	R20,Y+
    020C5 9508      RET
    020C6 940E 19E4 CALL	push_arg4
    020C8 940E 1AF1 CALL	push_xgsetF0FC
    020CA 0159      MOVW	R10,R18
    020CB 856E      LDD	R22,Y+14
    020CC 857F      LDD	R23,Y+15
    020CD 2744      CLR	R20
    020CE 2755      CLR	R21
    020CF C012      RJMP	0x20E2
    020D0 0186      MOVW	R16,R12
    020D1 940E 2082 CALL	_isspace
    020D3 3000      CPI	R16,0
    020D4 0701      CPC	R16,R17
    020D5 F029      BEQ	0x20DB
    020D6 2D0C      MOV	R16,R12
    020D7 01FB      MOVW	R30,R22
    020D8 940E 1B3E CALL	xicallx
    020DA C00F      RJMP	0x20EA
    020DB 85EA      LDD	R30,Y+10
    020DC 85FB      LDD	R31,Y+11
    020DD 92C1      ST	Z+,R12
    020DE 87FB      STD	Y+11,R31
    020DF 87EA      STD	Y+10,R30
    020E0 E041      LDI	R20,1
    020E1 E050      LDI	R21,0
    020E2 01F5      MOVW	R30,R10
    020E3 940E 1B3E CALL	xicallx
    020E5 2EE0      MOV	R14,R16
    020E6 24FF      CLR	R15
    020E7 0167      MOVW	R12,R14
    020E8 2300      TST	R16
    020E9 F731      BNE	0x20D0
    020EA 2422      CLR	R2
    020EB 85EA      LDD	R30,Y+10
    020EC 85FB      LDD	R31,Y+11
    020ED 8220      ST	Z,R2
    020EE 9020 08A1 LDS	R2,spiTransferComplete+26
    020F0 9030 08A2 LDS	R3,spiTransferComplete+27
    020F2 0E24      ADD	R2,R20
    020F3 1E35      ADC	R3,R21
    020F4 9230 08A2 STS	spiTransferComplete+27,R3
    020F6 9220 08A1 STS	spiTransferComplete+26,R2
    020F8 940E 1AE6 CALL	pop_xgsetF0FC
    020FA 9624      ADIW	R28,4
    020FB 9508      RET
    020FC 940E 19E4 CALL	push_arg4
    020FE 940E 1AF1 CALL	push_xgsetF0FC
    02100 0169      MOVW	R12,R18
    02101 88A8      LDD	R10,Y+16
    02102 88B9      LDD	R11,Y+17
    02103 2744      CLR	R20
    02104 2755      CLR	R21
    02105 C03F      RJMP	0x2145
    02106 01C5      MOVW	R24,R10
    02107 3180      CPI	R24,0x10
    02108 E0E0      LDI	R30,0
    02109 079E      CPC	R25,R30
    0210A F469      BNE	0x2118
    0210B 018B      MOVW	R16,R22
    0210C 940E 2096 CALL	_isxdigit
    0210E 3000      CPI	R16,0
    0210F 0701      CPC	R16,R17
    02110 F009      BEQ	0x2112
    02111 C02C      RJMP	0x213E
    02112 2F06      MOV	R16,R22
    02113 85EE      LDD	R30,Y+14
    02114 85FF      LDD	R31,Y+15
    02115 940E 1B3E CALL	xicallx
    02117 C036      RJMP	0x214E
    02118 01C5      MOVW	R24,R10
    02119 3088      CPI	R24,0x8
    0211A E0E0      LDI	R30,0
    0211B 079E      CPC	R25,R30
    0211C F481      BNE	0x212D
    0211D 018B      MOVW	R16,R22
    0211E 940E 206E CALL	_isdigit
    02120 3000      CPI	R16,0
    02121 0701      CPC	R16,R17
    02122 F021      BEQ	0x2127
    02123 3368      CPI	R22,0x38
    02124 E0E0      LDI	R30,0
    02125 077E      CPC	R23,R30
    02126 F0BC      BLT	0x213E
    02127 2F06      MOV	R16,R22
    02128 85EE      LDD	R30,Y+14
    02129 85FF      LDD	R31,Y+15
    0212A 940E 1B3E CALL	xicallx
    0212C C021      RJMP	0x214E
    0212D 018B      MOVW	R16,R22
    0212E 940E 206E CALL	_isdigit
    02130 0178      MOVW	R14,R16
    02131 3000      CPI	R16,0
    02132 0701      CPC	R16,R17
    02133 F451      BNE	0x213E
    02134 326D      CPI	R22,0x2D
    02135 E0E0      LDI	R30,0
    02136 077E      CPC	R23,R30
    02137 F031      BEQ	0x213E
    02138 2F06      MOV	R16,R22
    02139 85EE      LDD	R30,Y+14
    0213A 85FF      LDD	R31,Y+15
    0213B 940E 1B3E CALL	xicallx
    0213D C010      RJMP	0x214E
    0213E 85EA      LDD	R30,Y+10
    0213F 85FB      LDD	R31,Y+11
    02140 9361      ST	Z+,R22
    02141 87FB      STD	Y+11,R31
    02142 87EA      STD	Y+10,R30
    02143 E041      LDI	R20,1
    02144 E050      LDI	R21,0
    02145 01F6      MOVW	R30,R12
    02146 940E 1B3E CALL	xicallx
    02148 2EE0      MOV	R14,R16
    02149 24FF      CLR	R15
    0214A 01B7      MOVW	R22,R14
    0214B 2300      TST	R16
    0214C F009      BEQ	0x214E
    0214D CFB8      RJMP	0x2106
    0214E 2422      CLR	R2
    0214F 85EA      LDD	R30,Y+10
    02150 85FB      LDD	R31,Y+11
    02151 8220      ST	Z,R2
    02152 9020 08A1 LDS	R2,spiTransferComplete+26
    02154 9030 08A2 LDS	R3,spiTransferComplete+27
    02156 0E24      ADD	R2,R20
    02157 1E35      ADC	R3,R21
    02158 9230 08A2 STS	spiTransferComplete+27,R3
    0215A 9220 08A1 STS	spiTransferComplete+26,R2
    0215C 940E 1AE6 CALL	pop_xgsetF0FC
    0215E 9624      ADIW	R28,4
    0215F 9508      RET
__scanf:
    02160 940E 19E4 CALL	push_arg4
    02162 940E 1AF1 CALL	push_xgsetF0FC
    02164 972F      SBIW	R28,0xF
    02165 8CEF      LDD	R14,Y+31
    02166 A0F8      LDD	R15,Y+32
    02167 2422      CLR	R2
    02168 2433      CLR	R3
    02169 9230 08A2 STS	spiTransferComplete+27,R3
    0216B 9220 08A1 STS	spiTransferComplete+26,R2
    0216D C0F7      RJMP	0x2265
    0216E 3265      CPI	R22,0x25
    0216F E0E0      LDI	R30,0
    02170 077E      CPC	R23,R30
    02171 F009      BEQ	0x2173
    02172 C0CB      RJMP	0x223E
    02173 8DED      LDD	R30,Y+29
    02174 8DFE      LDD	R31,Y+30
    02175 8180      LD	R24,Z
    02176 368C      CPI	R24,0x6C
    02177 F441      BNE	0x2180
    02178 E081      LDI	R24,1
    02179 E090      LDI	R25,0
    0217A 016C      MOVW	R12,R24
    0217B 01CF      MOVW	R24,R30
    0217C 9601      ADIW	R24,1
    0217D 8F9E      STD	Y+30,R25
    0217E 8F8D      STD	Y+29,R24
    0217F C002      RJMP	0x2182
    02180 24CC      CLR	R12
    02181 24DD      CLR	R13
    02182 01C7      MOVW	R24,R14
    02183 9602      ADIW	R24,2
    02184 017C      MOVW	R14,R24
    02185 01FC      MOVW	R30,R24
    02186 9732      SBIW	R30,2
    02187 80A0      LD	R10,Z
    02188 80B1      LDD	R11,Z+1
    02189 8DED      LDD	R30,Y+29
    0218A 8DFE      LDD	R31,Y+30
    0218B 8140      LD	R20,Z
    0218C 2755      CLR	R21
    0218D 3643      CPI	R20,0x63
    0218E E0E0      LDI	R30,0
    0218F 075E      CPC	R21,R30
    02190 F129      BEQ	0x21B6
    02191 3644      CPI	R20,0x64
    02192 E0E0      LDI	R30,0
    02193 075E      CPC	R21,R30
    02194 F409      BNE	0x2196
    02195 C064      RJMP	0x21FA
    02196 E684      LDI	R24,0x64
    02197 E090      LDI	R25,0
    02198 1784      CP	R24,R20
    02199 0795      CPC	R25,R21
    0219A F02C      BLT	0x21A0
    0219B 3548      CPI	R20,0x58
    0219C E0E0      LDI	R30,0
    0219D 075E      CPC	R21,R30
    0219E F169      BEQ	0x21CC
    0219F C095      RJMP	0x2235
    021A0 364F      CPI	R20,0x6F
    021A1 E0E0      LDI	R30,0
    021A2 075E      CPC	R21,R30
    021A3 F111      BEQ	0x21C6
    021A4 3740      CPI	R20,0x70
    021A5 E0E0      LDI	R30,0
    021A6 075E      CPC	R21,R30
    021A7 F121      BEQ	0x21CC
    021A8 3743      CPI	R20,0x73
    021A9 E0E0      LDI	R30,0
    021AA 075E      CPC	R21,R30
    021AB F409      BNE	0x21AD
    021AC C07F      RJMP	0x222C
    021AD 3745      CPI	R20,0x75
    021AE E0E0      LDI	R30,0
    021AF 075E      CPC	R21,R30
    021B0 F0C1      BEQ	0x21C9
    021B1 3748      CPI	R20,0x78
    021B2 E0E0      LDI	R30,0
    021B3 075E      CPC	R21,R30
    021B4 F0B9      BEQ	0x21CC
    021B5 C07F      RJMP	0x2235
    021B6 8DE9      LDD	R30,Y+25
    021B7 8DFA      LDD	R31,Y+26
    021B8 940E 1B3E CALL	xicallx
    021BA 01F5      MOVW	R30,R10
    021BB 8300      ST	Z,R16
    021BC 9180 08A1 LDS	R24,spiTransferComplete+26
    021BE 9190 08A2 LDS	R25,spiTransferComplete+27
    021C0 9601      ADIW	R24,1
    021C1 9390 08A2 STS	spiTransferComplete+27,R25
    021C3 9380 08A1 STS	spiTransferComplete+26,R24
    021C5 C072      RJMP	0x2238
    021C6 E048      LDI	R20,0x8
    021C7 E050      LDI	R21,0
    021C8 C005      RJMP	0x21CE
    021C9 E04A      LDI	R20,0xA
    021CA E050      LDI	R21,0
    021CB C002      RJMP	0x21CE
    021CC E140      LDI	R20,0x10
    021CD E050      LDI	R21,0
    021CE 835B      STD	Y+3,R21
    021CF 834A      STD	Y+2,R20
    021D0 8C0B      LDD	R0,Y+27
    021D1 8C1C      LDD	R1,Y+28
    021D2 8219      STD	Y+1,R1
    021D3 8208      ST	Y,R0
    021D4 8D29      LDD	R18,Y+25
    021D5 8D3A      LDD	R19,Y+26
    021D6 018E      MOVW	R16,R28
    021D7 5F0C      SUBI	R16,0xFC
    021D8 4F1F      SBCI	R17,0xFF
    021D9 DF22      RCALL	0x20FC
    021DA 20CC      TST	R12
    021DB F411      BNE	0x21DE
    021DC 20DD      TST	R13
    021DD F079      BEQ	0x21ED
    021DE 8359      STD	Y+1,R21
    021DF 8348      ST	Y,R20
    021E0 2722      CLR	R18
    021E1 2733      CLR	R19
    021E2 018E      MOVW	R16,R28
    021E3 5F0C      SUBI	R16,0xFC
    021E4 4F1F      SBCI	R17,0xFF
    021E5 940E 1E97 CALL	_strtoul
    021E7 01F5      MOVW	R30,R10
    021E8 8300      ST	Z,R16
    021E9 8311      STD	Z+1,R17
    021EA 8322      STD	Z+2,R18
    021EB 8333      STD	Z+3,R19
    021EC C04B      RJMP	0x2238
    021ED 8359      STD	Y+1,R21
    021EE 8348      ST	Y,R20
    021EF 2722      CLR	R18
    021F0 2733      CLR	R19
    021F1 018E      MOVW	R16,R28
    021F2 5F0C      SUBI	R16,0xFC
    021F3 4F1F      SBCI	R17,0xFF
    021F4 940E 1E97 CALL	_strtoul
    021F6 01F5      MOVW	R30,R10
    021F7 8311      STD	Z+1,R17
    021F8 8300      ST	Z,R16
    021F9 C03E      RJMP	0x2238
    021FA E08A      LDI	R24,0xA
    021FB E090      LDI	R25,0
    021FC 839B      STD	Y+3,R25
    021FD 838A      STD	Y+2,R24
    021FE 8C0B      LDD	R0,Y+27
    021FF 8C1C      LDD	R1,Y+28
    02200 8219      STD	Y+1,R1
    02201 8208      ST	Y,R0
    02202 8D29      LDD	R18,Y+25
    02203 8D3A      LDD	R19,Y+26
    02204 018E      MOVW	R16,R28
    02205 5F0C      SUBI	R16,0xFC
    02206 4F1F      SBCI	R17,0xFF
    02207 DEF4      RCALL	0x20FC
    02208 20CC      TST	R12
    02209 F411      BNE	0x220C
    0220A 20DD      TST	R13
    0220B F089      BEQ	0x221D
    0220C E08A      LDI	R24,0xA
    0220D E090      LDI	R25,0
    0220E 8399      STD	Y+1,R25
    0220F 8388      ST	Y,R24
    02210 2722      CLR	R18
    02211 2733      CLR	R19
    02212 018E      MOVW	R16,R28
    02213 5F0C      SUBI	R16,0xFC
    02214 4F1F      SBCI	R17,0xFF
    02215 940E 1D29 CALL	_strtol
    02217 01F5      MOVW	R30,R10
    02218 8300      ST	Z,R16
    02219 8311      STD	Z+1,R17
    0221A 8322      STD	Z+2,R18
    0221B 8333      STD	Z+3,R19
    0221C C01B      RJMP	0x2238
    0221D E08A      LDI	R24,0xA
    0221E E090      LDI	R25,0
    0221F 8399      STD	Y+1,R25
    02220 8388      ST	Y,R24
    02221 2722      CLR	R18
    02222 2733      CLR	R19
    02223 018E      MOVW	R16,R28
    02224 5F0C      SUBI	R16,0xFC
    02225 4F1F      SBCI	R17,0xFF
    02226 940E 1D29 CALL	_strtol
    02228 01F5      MOVW	R30,R10
    02229 8311      STD	Z+1,R17
    0222A 8300      ST	Z,R16
    0222B C00C      RJMP	0x2238
    0222C 8C0B      LDD	R0,Y+27
    0222D 8C1C      LDD	R1,Y+28
    0222E 8219      STD	Y+1,R1
    0222F 8208      ST	Y,R0
    02230 8D29      LDD	R18,Y+25
    02231 8D3A      LDD	R19,Y+26
    02232 0185      MOVW	R16,R10
    02233 DE92      RCALL	0x20C6
    02234 C003      RJMP	0x2238
    02235 2700      CLR	R16
    02236 2711      CLR	R17
    02237 C03C      RJMP	0x2274
    02238 8D8D      LDD	R24,Y+29
    02239 8D9E      LDD	R25,Y+30
    0223A 9601      ADIW	R24,1
    0223B 8F9E      STD	Y+30,R25
    0223C 8F8D      STD	Y+29,R24
    0223D C027      RJMP	0x2265
    0223E 018B      MOVW	R16,R22
    0223F 940E 2082 CALL	_isspace
    02241 3000      CPI	R16,0
    02242 0701      CPC	R16,R17
    02243 F0B1      BEQ	0x225A
    02244 8DE9      LDD	R30,Y+25
    02245 8DFA      LDD	R31,Y+26
    02246 940E 1B3E CALL	xicallx
    02248 2EA0      MOV	R10,R16
    02249 24BB      CLR	R11
    0224A 01B5      MOVW	R22,R10
    0224B 2300      TST	R16
    0224C F039      BEQ	0x2254
    0224D 018B      MOVW	R16,R22
    0224E 940E 2082 CALL	_isspace
    02250 0158      MOVW	R10,R16
    02251 3000      CPI	R16,0
    02252 0701      CPC	R16,R17
    02253 F781      BNE	0x2244
    02254 2F06      MOV	R16,R22
    02255 8DEB      LDD	R30,Y+27
    02256 8DFC      LDD	R31,Y+28
    02257 940E 1B3E CALL	xicallx
    02259 C00B      RJMP	0x2265
    0225A 8DE9      LDD	R30,Y+25
    0225B 8DFA      LDD	R31,Y+26
    0225C 940E 1B3E CALL	xicallx
    0225E 2EA0      MOV	R10,R16
    0225F 2C2A      MOV	R2,R10
    02260 2433      CLR	R3
    02261 1626      CP	R2,R22
    02262 0637      CPC	R3,R23
    02263 F009      BEQ	0x2265
    02264 C00B      RJMP	0x2270
    02265 8DED      LDD	R30,Y+29
    02266 8DFE      LDD	R31,Y+30
    02267 90A1      LD	R10,Z+
    02268 8FFE      STD	Y+30,R31
    02269 8FED      STD	Y+29,R30
    0226A 24BB      CLR	R11
    0226B 01B5      MOVW	R22,R10
    0226C 3060      CPI	R22,0
    0226D 0767      CPC	R22,R23
    0226E F009      BEQ	0x2270
    0226F CEFE      RJMP	0x216E
    02270 9100 08A1 LDS	R16,spiTransferComplete+26
    02272 9110 08A2 LDS	R17,spiTransferComplete+27
    02274 962F      ADIW	R28,0xF
    02275 940E 1AE6 CALL	pop_xgsetF0FC
    02277 9624      ADIW	R28,4
    02278 9508      RET
_printf:
    02279 940E 19E4 CALL	push_arg4
    0227B 92AA      ST	-Y,R10
    0227C 92BA      ST	-Y,R11
    0227D 9722      SBIW	R28,2
    0227E 01CE      MOVW	R24,R28
    0227F 9606      ADIW	R24,6
    02280 015C      MOVW	R10,R24
    02281 82B9      STD	Y+1,R11
    02282 82A8      ST	Y,R10
    02283 812C      LDD	R18,Y+4
    02284 813D      LDD	R19,Y+5
    02285 E80C      LDI	R16,0x8C
    02286 E010      LDI	R17,0
    02287 940E 15C8 CALL	__print
    02289 0158      MOVW	R10,R16
    0228A 9622      ADIW	R28,2
    0228B 90B9      LD	R11,Y+
    0228C 90A9      LD	R10,Y+
    0228D 9624      ADIW	R28,4
    0228E 9508      RET
    0228F 92AA      ST	-Y,R10
    02290 9020 08A3 LDS	R2,spiTransferComplete+28
    02292 2022      TST	R2
    02293 F029      BEQ	0x2299
    02294 2CA2      MOV	R10,R2
    02295 2422      CLR	R2
    02296 9220 08A3 STS	spiTransferComplete+28,R2
    02298 C003      RJMP	0x229C
    02299 940E 15B6 CALL	_getchar$device_specific$|_getchar
    0229B 2EA0      MOV	R10,R16
    0229C 2D0A      MOV	R16,R10
    0229D 90A9      LD	R10,Y+
    0229E 9508      RET
    0229F 9300 08A3 STS	spiTransferComplete+28,R16
    022A1 9508      RET
_scanf:
    022A2 940E 19E4 CALL	push_arg4
    022A4 92AA      ST	-Y,R10
    022A5 92BA      ST	-Y,R11
    022A6 9724      SBIW	R28,4
    022A7 2422      CLR	R2
    022A8 9220 08A3 STS	spiTransferComplete+28,R2
    022AA 01CE      MOVW	R24,R28
    022AB 9608      ADIW	R24,0x8
    022AC 015C      MOVW	R10,R24
    022AD 82BB      STD	Y+3,R11
    022AE 82AA      STD	Y+2,R10
    022AF 802E      LDD	R2,Y+6
    022B0 803F      LDD	R3,Y+7
    022B1 8239      STD	Y+1,R3
    022B2 8228      ST	Y,R2
    022B3 E920      LDI	R18,0x90
    022B4 E030      LDI	R19,0
    022B5 E80E      LDI	R16,0x8E
    022B6 E010      LDI	R17,0
    022B7 940E 2160 CALL	__scanf
    022B9 0158      MOVW	R10,R16
    022BA 9624      ADIW	R28,4
    022BB 90B9      LD	R11,Y+
    022BC 90A9      LD	R10,Y+
    022BD 9624      ADIW	R28,4
    022BE 9508      RET
