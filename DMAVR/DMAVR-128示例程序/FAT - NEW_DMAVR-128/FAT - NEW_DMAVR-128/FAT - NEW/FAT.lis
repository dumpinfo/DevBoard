                        .module FAT.C
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\DMAVR-~3\FAT-NE~1\FAT.C
                        .area data(ram, con, rel)
 0000                   .dbfile ..\..\DMAVR-~3\FAT-NE~1\FAT.C
 0000           _DirectoryCount::
 0000                   .blkb 2
                        .area idata
 0000 0000              .word 0
                        .area data(ram, con, rel)
 0002                   .dbfile ..\..\DMAVR-~3\FAT-NE~1\FAT.C
 0002                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0002                   .dbsym e DirectoryCount _DirectoryCount i
 0002           _FileCount::
 0002                   .blkb 2
                        .area idata
 0002 0000              .word 0
                        .area data(ram, con, rel)
 0004                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0004                   .dbsym e FileCount _FileCount i
                        .area text(rom, con, rel)
 0000                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0000                   .dbfunc e ReadBlock _ReadBlock fV
 0000           ;            LBA -> y+4
                        .even
 0000           _ReadBlock::
 0000 0E940000          xcall push_arg4
 0004 2497              sbiw R28,4
 0006                   .dbline -1
 0006                   .dbline 40
 0006           ; //******************************************************************************
 0006           ; //FAT文件系统相关操作函数
 0006           ; //支持FAT16文件系统
 0006           ; //编译环境：ICCAVR 7.22A
 0006           ; //作者：www.avrgcc.com
 0006           ; //时间：2010.08.01
 0006           ; //******************************************************************************
 0006           ;  
 0006           ; #include "stdio.h"
 0006           ; #include <stdlib.h>
 0006           ; #include "string.h"
 0006           ; #include "SD.h"
 0006           ; #include "FAT16.h"
 0006           ; 
 0006           ; extern uint8 BUFFER[512];
 0006           ; 
 0006           ; uint16 BPB_BytesPerSec;
 0006           ; uint8 BPB_SecPerClus;
 0006           ; uint16 BPB_RsvdSecCnt;
 0006           ; uint8 BPB_NumFATs;
 0006           ; uint16 BPB_RootEntCnt;
 0006           ; uint16 BPB_TotSec16;
 0006           ; uint16 BPB_FATSz16;
 0006           ; uint32 BPB_HiddSec;
 0006           ; 
 0006           ; uint32 BPB_FATSz32;
 0006           ; uint32 BPB_RootClus;
 0006           ; uint16 BPB_FSInfo;
 0006           ; uint8  FAT32_EN;                               //为0则表示FAT16，为1则表示FAT32
 0006           ; 
 0006           ; uint16 DirectoryCount = 0,FileCount = 0;       //根目录下文件夹和文件的数量
 0006           ; 
 0006           ; /***********************************************************************
 0006           ; 函数功能：读一个扇区函数
 0006           ; 操作内容：1、调用MMC/SD卡块读取函数
 0006           ;           2、函数宏定义参考头文件
 0006           ; ***********************************************************************/
 0006           ; 
 0006           ; void ReadBlock(uint32 LBA)
 0006           ; {
 0006                   .dbline 41
 0006           ;       mmcReadSector(LBA,BUFFER);
 0006 80E0              ldi R24,<_BUFFER
 0008 90E0              ldi R25,>_BUFFER
 000A 9B83              std y+3,R25
 000C 8A83              std y+2,R24
 000E 80E0              ldi R24,512
 0010 92E0              ldi R25,2
 0012 9983              std y+1,R25
 0014 8883              std y+0,R24
 0016 0C81              ldd R16,y+4
 0018 1D81              ldd R17,y+5
 001A 2E81              ldd R18,y+6
 001C 3F81              ldd R19,y+7
 001E 0E940000          xcall _mmcReadBlock
 0022                   .dbline 42
 0022           ;         return;
 0022                   .dbline -2
 0022           L9:
 0022                   .dbline 0 ; func end
 0022 2896              adiw R28,8
 0024 0895              ret
 0026                   .dbsym l LBA 4 l
 0026                   .dbend
 0026                   .dbfunc e WriteBlock _WriteBlock fV
 0026           ;            LBA -> y+4
                        .even
 0026           _WriteBlock::
 0026 0E940000          xcall push_arg4
 002A 2497              sbiw R28,4
 002C                   .dbline -1
 002C                   .dbline 52
 002C           ; }
 002C           ; 
 002C           ; /***********************************************************************
 002C           ; 函数功能：写一个扇区函数
 002C           ; 操作内容：1、调用MMC/SD卡块写入函数
 002C           ;           2、函数宏定义参考头文件
 002C           ; ***********************************************************************/
 002C           ; 
 002C           ; void WriteBlock(uint32 LBA)
 002C           ; {
 002C                   .dbline 53
 002C           ;       mmcWriteSector(LBA,BUFFER);
 002C 80E0              ldi R24,<_BUFFER
 002E 90E0              ldi R25,>_BUFFER
 0030 9B83              std y+3,R25
 0032 8A83              std y+2,R24
 0034 80E0              ldi R24,512
 0036 92E0              ldi R25,2
 0038 9983              std y+1,R25
 003A 8883              std y+0,R24
 003C 0C81              ldd R16,y+4
 003E 1D81              ldd R17,y+5
 0040 2E81              ldd R18,y+6
 0042 3F81              ldd R19,y+7
 0044 0E940000          xcall _mmcWriteBlock
 0048                   .dbline 54
 0048           ;         return;
 0048                   .dbline -2
 0048           L10:
 0048                   .dbline 0 ; func end
 0048 2896              adiw R28,8
 004A 0895              ret
 004C                   .dbsym l LBA 4 l
 004C                   .dbend
 004C                   .dbfunc e CopyBytes _CopyBytes fV
 004C           ;              d -> R12,R13
 004C           ;              s -> R10,R11
 004C           ;              i -> R20,R21
 004C           ;           size -> R14,R15
 004C           ;              D -> R18,R19
 004C           ;              S -> R16,R17
                        .even
 004C           _CopyBytes::
 004C 0E940000          xcall push_xgset30FC
 0050 E884              ldd R14,y+8
 0052 F984              ldd R15,y+9
 0054                   .dbline -1
 0054                   .dbline 63
 0054           ; }
 0054           ; 
 0054           ; /***********************************************************************
 0054           ; 函数功能：字节数据复制
 0054           ; 操作内容：数据复制，按字节方式，size定义大小
 0054           ; ***********************************************************************/
 0054           ; 
 0054           ; void CopyBytes(void* S, void* D, uint16 size)
 0054           ; {
 0054                   .dbline 64
 0054           ;       uint8 *s = S, *d = D;
 0054 5801              movw R10,R16
 0056                   .dbline 64
 0056 6901              movw R12,R18
 0058                   .dbline 66
 0058           ;       uint16 i;
 0058           ;       for(i = 0; i < size; i++)
 0058 4427              clr R20
 005A 5527              clr R21
 005C 08C0              xjmp L15
 005E           L12:
 005E                   .dbline 67
 005E           ;               *d++ = *s++;
 005E F501              movw R30,R10
 0060 D601              movw R26,R12
 0062 0190              ld R0,Z+
 0064 5F01              movw R10,R30
 0066 0D92              st X+,R0
 0068 6D01              movw R12,R26
 006A           L13:
 006A                   .dbline 66
 006A 4F5F              subi R20,255  ; offset = 1
 006C 5F4F              sbci R21,255
 006E           L15:
 006E                   .dbline 66
 006E 4E15              cp R20,R14
 0070 5F05              cpc R21,R15
 0072 A8F3              brlo L12
 0074           X0:
 0074                   .dbline -2
 0074           L11:
 0074                   .dbline 0 ; func end
 0074 0C940000          xjmp pop_xgset30FC
 0078                   .dbsym r d 12 pc
 0078                   .dbsym r s 10 pc
 0078                   .dbsym r i 20 i
 0078                   .dbsym r size 14 i
 0078                   .dbsym r D 18 pV
 0078                   .dbsym r S 16 pV
 0078                   .dbend
 0078                   .dbfunc e CopyWord _CopyWord fV
 0078           ;              d -> R12,R13
 0078           ;              s -> R10,R11
 0078           ;              i -> R20,R21
 0078           ;           size -> R14,R15
 0078           ;              D -> R18,R19
 0078           ;              S -> R16,R17
                        .even
 0078           _CopyWord::
 0078 0E940000          xcall push_xgset30FC
 007C E884              ldd R14,y+8
 007E F984              ldd R15,y+9
 0080                   .dbline -1
 0080                   .dbline 76
 0080           ; }
 0080           ; 
 0080           ; /***********************************************************************
 0080           ; 函数功能：字数据复制
 0080           ; 操作内容：数据复制，按字方式，size定义大小
 0080           ; ***********************************************************************/
 0080           ; 
 0080           ; void CopyWord(void* S, void* D, uint16 size)
 0080           ; {
 0080                   .dbline 77
 0080           ;       uint16 *s = S, *d = D;
 0080 5801              movw R10,R16
 0082                   .dbline 77
 0082 6901              movw R12,R18
 0084                   .dbline 79
 0084           ;       uint16 i;
 0084           ;       for(i = 0; i < size; i++)
 0084 4427              clr R20
 0086 5527              clr R21
 0088 0AC0              xjmp L20
 008A           L17:
 008A                   .dbline 80
 008A           ;               *d++ = *s++;
 008A F501              movw R30,R10
 008C D601              movw R26,R12
 008E 0190              ld R0,Z+
 0090 1190              ld R1,Z+
 0092 5F01              movw R10,R30
 0094 0D92              st X+,R0
 0096 1D92              st X+,R1
 0098 6D01              movw R12,R26
 009A           L18:
 009A                   .dbline 79
 009A 4F5F              subi R20,255  ; offset = 1
 009C 5F4F              sbci R21,255
 009E           L20:
 009E                   .dbline 79
 009E 4E15              cp R20,R14
 00A0 5F05              cpc R21,R15
 00A2 98F3              brlo L17
 00A4           X1:
 00A4                   .dbline -2
 00A4           L16:
 00A4                   .dbline 0 ; func end
 00A4 0C940000          xjmp pop_xgset30FC
 00A8                   .dbsym r d 12 pi
 00A8                   .dbsym r s 10 pi
 00A8                   .dbsym r i 20 i
 00A8                   .dbsym r size 14 i
 00A8                   .dbsym r D 18 pV
 00A8                   .dbsym r S 16 pV
 00A8                   .dbend
 00A8                   .dbfunc e IsEqual _IsEqual fc
 00A8           ;              b -> R14,R15
 00A8           ;              a -> R12,R13
 00A8           ;              i -> R10
 00A8           ;           Size -> R20
 00A8           ;              B -> R18,R19
 00A8           ;              A -> R16,R17
                        .even
 00A8           _IsEqual::
 00A8 0E940000          xcall push_xgset30FC
 00AC 4885              ldd R20,y+8
 00AE                   .dbline -1
 00AE                   .dbline 90
 00AE           ; }
 00AE           ; 
 00AE           ; /***********************************************************************
 00AE           ; 函数功能：数据比较函数
 00AE           ; 操作内容：1、比较数据是否相等，相等返回1，不相等返回0
 00AE           ;           2、参数为起始地址和数据大小
 00AE           ; ***********************************************************************/
 00AE           ; 
 00AE           ; uint8 IsEqual(void* A, void* B, uint8 Size)
 00AE           ; {
 00AE                   .dbline 91
 00AE           ;       uint8 i, *a = A, *b = B;
 00AE 6801              movw R12,R16
 00B0                   .dbline 91
 00B0 7901              movw R14,R18
 00B2                   .dbline 92
 00B2           ;       for(i = 0; i < Size; i++)
 00B2 AA24              clr R10
 00B4 0FC0              xjmp L25
 00B6           L22:
 00B6                   .dbline 93
 00B6           ;               if(a[i] != b[i])
 00B6 EA2D              mov R30,R10
 00B8 FF27              clr R31
 00BA EE0D              add R30,R14
 00BC FF1D              adc R31,R15
 00BE 2080              ldd R2,z+0
 00C0 EA2D              mov R30,R10
 00C2 FF27              clr R31
 00C4 EC0D              add R30,R12
 00C6 FD1D              adc R31,R13
 00C8 3080              ldd R3,z+0
 00CA 3214              cp R3,R2
 00CC 11F0              breq L26
 00CE           X2:
 00CE                   .dbline 94
 00CE           ;                       return 0;              //不相等返回0
 00CE 0027              clr R16
 00D0 04C0              xjmp L21
 00D2           L26:
 00D2           L23:
 00D2                   .dbline 92
 00D2 A394              inc R10
 00D4           L25:
 00D4                   .dbline 92
 00D4 A416              cp R10,R20
 00D6 78F3              brlo L22
 00D8           X3:
 00D8                   .dbline 95
 00D8           ;       return 1;                              //相等返回1
 00D8 01E0              ldi R16,1
 00DA                   .dbline -2
 00DA           L21:
 00DA                   .dbline 0 ; func end
 00DA 0C940000          xjmp pop_xgset30FC
 00DE                   .dbsym r b 14 pc
 00DE                   .dbsym r a 12 pc
 00DE                   .dbsym r i 10 c
 00DE                   .dbsym r Size 20 c
 00DE                   .dbsym r B 18 pV
 00DE                   .dbsym r A 16 pV
 00DE                   .dbend
 00DE                   .dbfunc e EmptyBytes _EmptyBytes fV
 00DE           ;           data -> R10,R11
 00DE           ;              i -> R20,R21
 00DE           ;           size -> R18,R19
 00DE           ;              D -> R16,R17
                        .even
 00DE           _EmptyBytes::
 00DE 0E940000          xcall push_xgset300C
 00E2                   .dbline -1
 00E2                   .dbline 104
 00E2           ; }
 00E2           ; 
 00E2           ; /***********************************************************************
 00E2           ; 函数功能：空数据字节填充
 00E2           ; 操作内容：数据全为0，size定义填充0的大小
 00E2           ; ***********************************************************************/
 00E2           ; 
 00E2           ; void EmptyBytes(void* D, uint16 size)
 00E2           ; {
 00E2                   .dbline 106
 00E2           ;       uint16 i;
 00E2           ;       uint8* data = (uint8*)D;
 00E2 5801              movw R10,R16
 00E4                   .dbline 107
 00E4           ;       for(i = 0; i < size; i++)
 00E4 4427              clr R20
 00E6 5527              clr R21
 00E8 06C0              xjmp L32
 00EA           L29:
 00EA                   .dbline 108
 00EA           ;       {
 00EA                   .dbline 109
 00EA           ;               *data++ = 0;
 00EA 2224              clr R2
 00EC F501              movw R30,R10
 00EE 2192              st Z+,R2
 00F0 5F01              movw R10,R30
 00F2                   .dbline 110
 00F2           ;       }
 00F2           L30:
 00F2                   .dbline 107
 00F2 4F5F              subi R20,255  ; offset = 1
 00F4 5F4F              sbci R21,255
 00F6           L32:
 00F6                   .dbline 107
 00F6 4217              cp R20,R18
 00F8 5307              cpc R21,R19
 00FA B8F3              brlo L29
 00FC           X4:
 00FC                   .dbline -2
 00FC           L28:
 00FC                   .dbline 0 ; func end
 00FC 0C940000          xjmp pop_xgset300C
 0100                   .dbsym r data 10 pc
 0100                   .dbsym r i 20 i
 0100                   .dbsym r size 18 i
 0100                   .dbsym r D 16 pV
 0100                   .dbend
 0100                   .dbfunc e FATInit _FATInit fV
 0100                   .dbstruct 0 512 .1
 0100                   .dbfield 0 BS_jmpBoot A[3:3]c
 0100                   .dbfield 3 BS_OEMName A[8:8]c
 0100                   .dbfield 11 BPB_BytesPerSec i
 0100                   .dbfield 13 BPB_SecPerClus c
 0100                   .dbfield 14 BPB_RsvdSecCnt i
 0100                   .dbfield 16 BPB_NumFATs c
 0100                   .dbfield 17 BPB_RootEntCnt i
 0100                   .dbfield 19 BPB_TotSec16 i
 0100                   .dbfield 21 BPB_Media c
 0100                   .dbfield 22 BPB_FATSz16 i
 0100                   .dbfield 24 BPB_SecPerTrk i
 0100                   .dbfield 26 BPB_NumHeads i
 0100                   .dbfield 28 BPB_HiddSec l
 0100                   .dbfield 32 BPB_TotSec32 l
 0100                   .dbfield 36 BS_DrvNum c
 0100                   .dbfield 37 BS_Reservedl c
 0100                   .dbfield 38 BS_BootSig c
 0100                   .dbfield 39 BS_VolID l
 0100                   .dbfield 43 BS_VolLab A[11:11]c
 0100                   .dbfield 54 BS_FilSysType A[8:8]c
 0100                   .dbfield 62 ExecutableCode A[448:448]c
 0100                   .dbfield 510 ExecutableMarker A[2:2]c
 0100                   .dbend
 0100           ;            BPB -> R20,R21
                        .even
 0100           _FATInit::
 0100 4A93              st -y,R20
 0102 5A93              st -y,R21
 0104                   .dbline -1
 0104                   .dbline 118
 0104           ; }
 0104           ; /***********************************************************************
 0104           ; 函数功能：写入MMC/SD卡FAT文件系统BPB(BIOS Parameter Block)数据结构
 0104           ; 操作内容：1、BPB数据结构体参考头文件定义
 0104           ;           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
 0104           ; ***********************************************************************/
 0104           ; void FATInit(void)
 0104           ; {
 0104                   .dbline 119
 0104           ;       FAT_BPB* BPB = (FAT_BPB*)BUFFER;
 0104 40E0              ldi R20,<_BUFFER
 0106 50E0              ldi R21,>_BUFFER
 0108                   .dbline 121
 0108           ;               
 0108           ;       BPB->BPB_BytesPerSec = 0x0200;          //每个扇区512字节
 0108 80E0              ldi R24,512
 010A 92E0              ldi R25,2
 010C FA01              movw R30,R20
 010E 9487              std z+12,R25
 0110 8387              std z+11,R24
 0112                   .dbline 122
 0112           ;       BPB->BPB_SecPerClus  = 0x20;            //每个簇8个扇区
 0112 80E2              ldi R24,32
 0114 8587              std z+13,R24
 0116                   .dbline 123
 0116           ;       BPB->BPB_RsvdSecCnt  = 0x06;          //一个保留扇区
 0116 86E0              ldi R24,6
 0118 90E0              ldi R25,0
 011A 9787              std z+15,R25
 011C 8687              std z+14,R24
 011E                   .dbline 124
 011E           ;       BPB->BPB_NumFATs     = 0x02;            //2个FAT表
 011E 82E0              ldi R24,2
 0120 808B              std z+16,R24
 0122                   .dbline 125
 0122           ;       BPB->BPB_RootEntCnt  = 0x200;          //512目录项个数
 0122 80E0              ldi R24,512
 0124 92E0              ldi R25,2
 0126 928B              std z+18,R25
 0128 818B              std z+17,R24
 012A                   .dbline 126
 012A           ;       BPB->BPB_TotSec16    = 0x00;          //总扇区数
 012A 2224              clr R2
 012C 3324              clr R3
 012E 348A              std z+20,R3
 0130 238A              std z+19,R2
 0132                   .dbline 127
 0132           ;       BPB->BPB_FATSz16     = 0xF1;            //一个FAT表所占的扇区数
 0132 81EF              ldi R24,241
 0134 90E0              ldi R25,0
 0136 978B              std z+23,R25
 0138 868B              std z+22,R24
 013A                   .dbline 128
 013A           ;       BPB->BPB_HiddSec     = 0xFD;      //本FAT表前隐藏的扇区数
 013A 7C96              adiw R30,28
 013C 8DEF              ldi R24,253
 013E 8083              std z+0,R24
 0140 80E0              ldi R24,0
 0142 8183              std z+1,R24
 0144 8283              std z+2,R24
 0146 8383              std z+3,R24
 0148                   .dbline 130
 0148           ;       
 0148           ;       WriteBlock(253);                          //写引导区
 0148 0DEF              ldi R16,253
 014A 10E0              ldi R17,0
 014C 20E0              ldi R18,0
 014E 30E0              ldi R19,0
 0150 6ADF              xcall _WriteBlock
 0152                   .dbline -2
 0152           L33:
 0152                   .dbline 0 ; func end
 0152 5991              ld R21,y+
 0154 4991              ld R20,y+
 0156 0895              ret
 0158                   .dbsym r BPB 20 pS[.1]
 0158                   .dbend
 0158                   .dbfunc e ReadBPB _ReadBPB fV
 0158           ;            BPB -> R20,R21
                        .even
 0158           _ReadBPB::
 0158 4A93              st -y,R20
 015A 5A93              st -y,R21
 015C                   .dbline -1
 015C                   .dbline 141
 015C           ; }
 015C           ; 
 015C           ; 
 015C           ; /***********************************************************************
 015C           ; 函数功能：读取FAT16文件系统BPB(BIOS Parameter Block)数据结构
 015C           ; 操作内容：1、BPB数据结构体参考头文件定义
 015C           ;           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
 015C           ; ***********************************************************************/
 015C           ; 
 015C           ; void ReadBPB(void)
 015C           ; {
 015C                   .dbline 142
 015C           ;       FAT_BPB* BPB = (FAT_BPB*)BUFFER;
 015C 40E0              ldi R20,<_BUFFER
 015E 50E0              ldi R21,>_BUFFER
 0160                   .dbline 144
 0160           ;       //ReadBlock(0);
 0160           ;       ReadBlock(253);                 //获取参数，将BPB区数据读入缓冲区
 0160 0DEF              ldi R16,253
 0162 10E0              ldi R17,0
 0164 20E0              ldi R18,0
 0166 30E0              ldi R19,0
 0168 4BDF              xcall _ReadBlock
 016A                   .dbline 146
 016A           ;         
 016A           ;       BPB_BytesPerSec = BPB->BPB_BytesPerSec;   //这些记录了数据结构  
 016A FA01              movw R30,R20
 016C 2384              ldd R2,z+11
 016E 3484              ldd R3,z+12
 0170 30921A00          sts _BPB_BytesPerSec+1,R3
 0174 20921900          sts _BPB_BytesPerSec,R2
 0178                   .dbline 147
 0178           ;       BPB_SecPerClus = BPB->BPB_SecPerClus;     //每簇扇区数，格式化时可以选每个簇的大小，如2K，32K
 0178 2584              ldd R2,z+13
 017A 20921800          sts _BPB_SecPerClus,R2
 017E                   .dbline 148
 017E           ;       BPB_RsvdSecCnt = BPB->BPB_RsvdSecCnt;     //MMC/SD卡格式化后，保留为6个扇区
 017E 2684              ldd R2,z+14
 0180 3784              ldd R3,z+15
 0182 30921700          sts _BPB_RsvdSecCnt+1,R3
 0186 20921600          sts _BPB_RsvdSecCnt,R2
 018A                   .dbline 149
 018A           ;       BPB_NumFATs = BPB->BPB_NumFATs;           //2个FAT表，如果一个FAT表损坏，可以用另外一个
 018A 2088              ldd R2,z+16
 018C 20921500          sts _BPB_NumFATs,R2
 0190                   .dbline 150
 0190           ;       BPB_RootEntCnt = BPB->BPB_RootEntCnt;
 0190 2188              ldd R2,z+17
 0192 3288              ldd R3,z+18
 0194 30921400          sts _BPB_RootEntCnt+1,R3
 0198 20921300          sts _BPB_RootEntCnt,R2
 019C                   .dbline 151
 019C           ;       BPB_TotSec16 = BPB->BPB_TotSec16;         //如果为0，BPB_FATSz16记录扇区总数
 019C 2388              ldd R2,z+19
 019E 3488              ldd R3,z+20
 01A0 30921200          sts _BPB_TotSec16+1,R3
 01A4 20921100          sts _BPB_TotSec16,R2
 01A8                   .dbline 152
 01A8           ;       BPB_FATSz16 = BPB->BPB_FATSz16;           //FAT占用扇区总数，FAT32为0，FAT16不为0
 01A8 2688              ldd R2,z+22
 01AA 3788              ldd R3,z+23
 01AC 30921000          sts _BPB_FATSz16+1,R3
 01B0 20920F00          sts _BPB_FATSz16,R2
 01B4                   .dbline 153
 01B4           ;       BPB_HiddSec = BPB->BPB_HiddSec;           //隐藏扇区，默认为0
 01B4 248C              ldd R2,z+28
 01B6 358C              ldd R3,z+29
 01B8 468C              ldd R4,z+30
 01BA 578C              ldd R5,z+31
 01BC 30920C00          sts _BPB_HiddSec+1,R3
 01C0 20920B00          sts _BPB_HiddSec,R2
 01C4 50920E00          sts _BPB_HiddSec+2+1,R5
 01C8 40920D00          sts _BPB_HiddSec+2,R4
 01CC                   .dbline -2
 01CC           L34:
 01CC                   .dbline 0 ; func end
 01CC 5991              ld R21,y+
 01CE 4991              ld R20,y+
 01D0 0895              ret
 01D2                   .dbsym r BPB 20 pS[.1]
 01D2                   .dbend
 01D2                   .dbfunc e ReadBPB32 _ReadBPB32 fV
 01D2                   .dbstruct 0 512 .2
 01D2                   .dbfield 0 BS_jmpBoot A[3:3]c
 01D2                   .dbfield 3 BS_OEMName A[8:8]c
 01D2                   .dbfield 11 BPB_BytesPerSec i
 01D2                   .dbfield 13 BPB_SecPerClus c
 01D2                   .dbfield 14 BPB_RsvdSecCnt i
 01D2                   .dbfield 16 BPB_NumFATs c
 01D2                   .dbfield 17 BPB_RootEntCnt i
 01D2                   .dbfield 19 BPB_TotSec16 i
 01D2                   .dbfield 21 BPB_Media c
 01D2                   .dbfield 22 BPB_FATSz16 i
 01D2                   .dbfield 24 BPB_SecPerTrk i
 01D2                   .dbfield 26 BPB_NumHeads i
 01D2                   .dbfield 28 BPB_HiddSec l
 01D2                   .dbfield 32 BPB_TotSec32 l
 01D2                   .dbfield 36 BPB_FATSz32 l
 01D2                   .dbfield 40 BPB_ExtFlags i
 01D2                   .dbfield 42 BPB_FSVer i
 01D2                   .dbfield 44 BPB_RootClus l
 01D2                   .dbfield 48 BPB_FSInfo i
 01D2                   .dbfield 50 BPB_BkBootSec i
 01D2                   .dbfield 52 BPB_Reserved A[12:12]c
 01D2                   .dbfield 64 BS_DrvNum c
 01D2                   .dbfield 65 BS_Reservedl c
 01D2                   .dbfield 66 BS_BootSig c
 01D2                   .dbfield 67 BS_VolID l
 01D2                   .dbfield 71 BS_VolLab A[11:11]c
 01D2                   .dbfield 82 BS_FilSysType A[8:8]c
 01D2                   .dbfield 90 ExecutableCode A[420:420]c
 01D2                   .dbfield 510 ExecutableMarker A[2:2]c
 01D2                   .dbend
 01D2           ;            BPB -> R20,R21
                        .even
 01D2           _ReadBPB32::
 01D2 4A93              st -y,R20
 01D4 5A93              st -y,R21
 01D6                   .dbline -1
 01D6                   .dbline 164
 01D6           ; 
 01D6           ; }
 01D6           ; 
 01D6           ; /***********************************************************************
 01D6           ; 函数功能：读取FAT32文件系统BPB(BIOS Parameter Block)数据结构
 01D6           ; 操作内容：1、BPB数据结构体参考头文件定义
 01D6           ;           2、BPB数据包含磁盘的逻辑结构组成，如扇区大小、簇大小等信息
 01D6           ; ***********************************************************************/
 01D6           ; 
 01D6           ; void ReadBPB32(void)
 01D6           ; {
 01D6                   .dbline 165
 01D6           ;       FAT32_BPB* BPB = (FAT32_BPB*)BUFFER;
 01D6 40E0              ldi R20,<_BUFFER
 01D8 50E0              ldi R21,>_BUFFER
 01DA                   .dbline 166
 01DA           ;       ReadBlock(253);                             //获取参数，将BPB区数据读入缓冲区
 01DA 0DEF              ldi R16,253
 01DC 10E0              ldi R17,0
 01DE 20E0              ldi R18,0
 01E0 30E0              ldi R19,0
 01E2 0EDF              xcall _ReadBlock
 01E4                   .dbline 168
 01E4           ;         
 01E4           ;       BPB_BytesPerSec = BPB->BPB_BytesPerSec;   //这些记录了数据结构  
 01E4 FA01              movw R30,R20
 01E6 2384              ldd R2,z+11
 01E8 3484              ldd R3,z+12
 01EA 30921A00          sts _BPB_BytesPerSec+1,R3
 01EE 20921900          sts _BPB_BytesPerSec,R2
 01F2                   .dbline 169
 01F2           ;       BPB_SecPerClus = BPB->BPB_SecPerClus;     //每簇扇区数，格式化时可以选每个簇的大小，如2K，32K
 01F2 2584              ldd R2,z+13
 01F4 20921800          sts _BPB_SecPerClus,R2
 01F8                   .dbline 170
 01F8           ;       BPB_RsvdSecCnt = BPB->BPB_RsvdSecCnt;     //MMC/SD卡格式化后，保留为6个扇区
 01F8 2684              ldd R2,z+14
 01FA 3784              ldd R3,z+15
 01FC 30921700          sts _BPB_RsvdSecCnt+1,R3
 0200 20921600          sts _BPB_RsvdSecCnt,R2
 0204                   .dbline 171
 0204           ;       BPB_NumFATs = BPB->BPB_NumFATs;           //2个FAT表，如果一个FAT表损坏，可以用另外一个
 0204 2088              ldd R2,z+16
 0206 20921500          sts _BPB_NumFATs,R2
 020A                   .dbline 172
 020A           ;       BPB_RootEntCnt = BPB->BPB_RootEntCnt;
 020A 2188              ldd R2,z+17
 020C 3288              ldd R3,z+18
 020E 30921400          sts _BPB_RootEntCnt+1,R3
 0212 20921300          sts _BPB_RootEntCnt,R2
 0216                   .dbline 173
 0216           ;       BPB_TotSec16 = BPB->BPB_TotSec16;         //如果为0，BPB_FATSz16记录扇区总数
 0216 2388              ldd R2,z+19
 0218 3488              ldd R3,z+20
 021A 30921200          sts _BPB_TotSec16+1,R3
 021E 20921100          sts _BPB_TotSec16,R2
 0222                   .dbline 174
 0222           ;       BPB_FATSz16 = BPB->BPB_FATSz16;           //FAT占用扇区总数，FAT32为0，FAT16不为0
 0222 2688              ldd R2,z+22
 0224 3788              ldd R3,z+23
 0226 30921000          sts _BPB_FATSz16+1,R3
 022A 20920F00          sts _BPB_FATSz16,R2
 022E                   .dbline 175
 022E           ;       BPB_HiddSec = BPB->BPB_HiddSec;           //隐藏扇区，默认为0
 022E 248C              ldd R2,z+28
 0230 358C              ldd R3,z+29
 0232 468C              ldd R4,z+30
 0234 578C              ldd R5,z+31
 0236 30920C00          sts _BPB_HiddSec+1,R3
 023A 20920B00          sts _BPB_HiddSec,R2
 023E 50920E00          sts _BPB_HiddSec+2+1,R5
 0242 40920D00          sts _BPB_HiddSec+2,R4
 0246                   .dbline 177
 0246           ;         
 0246           ;         BPB_FATSz32 = BPB->BPB_FATSz32;
 0246 24A0              ldd R2,z+36
 0248 35A0              ldd R3,z+37
 024A 46A0              ldd R4,z+38
 024C 57A0              ldd R5,z+39
 024E 30920800          sts _BPB_FATSz32+1,R3
 0252 20920700          sts _BPB_FATSz32,R2
 0256 50920A00          sts _BPB_FATSz32+2+1,R5
 025A 40920900          sts _BPB_FATSz32+2,R4
 025E                   .dbline 178
 025E           ;         BPB_RootClus =BPB->BPB_RootClus;
 025E 24A4              ldd R2,z+44
 0260 35A4              ldd R3,z+45
 0262 46A4              ldd R4,z+46
 0264 57A4              ldd R5,z+47
 0266 30920400          sts _BPB_RootClus+1,R3
 026A 20920300          sts _BPB_RootClus,R2
 026E 50920600          sts _BPB_RootClus+2+1,R5
 0272 40920500          sts _BPB_RootClus+2,R4
 0276                   .dbline 179
 0276           ;         BPB_FSInfo = BPB->BPB_FSInfo;
 0276 20A8              ldd R2,z+48
 0278 31A8              ldd R3,z+49
 027A 30920200          sts _BPB_FSInfo+1,R3
 027E 20920100          sts _BPB_FSInfo,R2
 0282                   .dbline -2
 0282           L35:
 0282                   .dbline 0 ; func end
 0282 5991              ld R21,y+
 0284 4991              ld R20,y+
 0286 0895              ret
 0288                   .dbsym r BPB 20 pS[.2]
 0288                   .dbend
 0288                   .dbfunc e FATStartSec _FATStartSec fl
                        .even
 0288           _FATStartSec::
 0288                   .dbline -1
 0288                   .dbline 191
 0288           ; }
 0288           ; 
 0288           ; 
 0288           ; 
 0288           ; /***********************************************************************
 0288           ; 函数功能：获取FAT表扇区号，支持FAT16/32
 0288           ; 操作内容：1、FAT表扇区号为隐藏扇区+保留扇区
 0288           ;           2、隐藏扇区默认为0
 0288           ; ***********************************************************************/
 0288           ; 
 0288           ; uint32 FATStartSec(void)
 0288           ; {
 0288                   .dbline 192
 0288           ;     return BPB_RsvdSecCnt + BPB_HiddSec; //????????????????????????????
 0288 40900D00          lds R4,_BPB_HiddSec+2
 028C 50900E00          lds R5,_BPB_HiddSec+2+1
 0290 20900B00          lds R2,_BPB_HiddSec
 0294 30900C00          lds R3,_BPB_HiddSec+1
 0298 00911600          lds R16,_BPB_RsvdSecCnt
 029C 10911700          lds R17,_BPB_RsvdSecCnt+1
 02A0 2227              clr R18
 02A2 3327              clr R19
 02A4 020D              add R16,R2
 02A6 131D              adc R17,R3
 02A8 241D              adc R18,R4
 02AA 351D              adc R19,R5
 02AC                   .dbline -2
 02AC           L36:
 02AC                   .dbline 0 ; func end
 02AC 0895              ret
 02AE                   .dbend
 02AE                   .dbfunc e DirStartSec _DirStartSec fl
 02AE           ;          FATSz -> y+0
                        .even
 02AE           _DirStartSec::
 02AE 2497              sbiw R28,4
 02B0                   .dbline -1
 02B0                   .dbline 202
 02B0           ; }
 02B0           ; 
 02B0           ; /***********************************************************************
 02B0           ; 函数功能：获取根目录开始扇区号，支持FAT32
 02B0           ; 操作内容：1、根目录扇区数是固定的
 02B0           ;           2、根目录扇区紧接着FAT表之后
 02B0           ; ***********************************************************************/
 02B0           ; 
 02B0           ; uint32 DirStartSec(void)
 02B0           ; {
 02B0                   .dbline 204
 02B0           ;   uint32 FATSz;
 02B0           ;   if(FAT32_EN==0)
 02B0 20900000          lds R2,_FAT32_EN
 02B4 2220              tst R2
 02B6 59F4              brne L38
 02B8           X5:
 02B8                   .dbline 205
 02B8           ;     FATSz=BPB_FATSz16;
 02B8 20900F00          lds R2,_BPB_FATSz16
 02BC 30901000          lds R3,_BPB_FATSz16+1
 02C0 4424              clr R4
 02C2 5524              clr R5
 02C4 2882              std y+0,R2
 02C6 3982              std y+1,R3
 02C8 4A82              std y+2,R4
 02CA 5B82              std y+3,R5
 02CC 0CC0              xjmp L39
 02CE           L38:
 02CE                   .dbline 207
 02CE           ;   else
 02CE           ;     FATSz=BPB_FATSz32;
 02CE 40900900          lds R4,_BPB_FATSz32+2
 02D2 50900A00          lds R5,_BPB_FATSz32+2+1
 02D6 20900700          lds R2,_BPB_FATSz32
 02DA 30900800          lds R3,_BPB_FATSz32+1
 02DE 2882              std y+0,R2
 02E0 3982              std y+1,R3
 02E2 4A82              std y+2,R4
 02E4 5B82              std y+3,R5
 02E6           L39:
 02E6                   .dbline 208
 02E6           ;     return BPB_HiddSec+BPB_RsvdSecCnt + BPB_NumFATs * FATSz;             //保留扇区+FAT表数×FAT占用扇区数   ??????????????????????
 02E6 2880              ldd R2,y+0
 02E8 3980              ldd R3,y+1
 02EA 4A80              ldd R4,y+2
 02EC 5B80              ldd R5,y+3
 02EE 00911500          lds R16,_BPB_NumFATs
 02F2 1127              clr R17
 02F4 2227              clr R18
 02F6 3327              clr R19
 02F8 5A92              st -y,R5
 02FA 4A92              st -y,R4
 02FC 3A92              st -y,R3
 02FE 2A92              st -y,R2
 0300 0E940000          xcall empy32u
 0304 1801              movw R2,R16
 0306 2901              movw R4,R18
 0308 60901600          lds R6,_BPB_RsvdSecCnt
 030C 70901700          lds R7,_BPB_RsvdSecCnt+1
 0310 8824              clr R8
 0312 9924              clr R9
 0314 20910D00          lds R18,_BPB_HiddSec+2
 0318 30910E00          lds R19,_BPB_HiddSec+2+1
 031C 00910B00          lds R16,_BPB_HiddSec
 0320 10910C00          lds R17,_BPB_HiddSec+1
 0324 060D              add R16,R6
 0326 171D              adc R17,R7
 0328 281D              adc R18,R8
 032A 391D              adc R19,R9
 032C 020D              add R16,R2
 032E 131D              adc R17,R3
 0330 241D              adc R18,R4
 0332 351D              adc R19,R5
 0334                   .dbline -2
 0334           L37:
 0334                   .dbline 0 ; func end
 0334 2496              adiw R28,4
 0336 0895              ret
 0338                   .dbsym l FATSz 0 l
 0338                   .dbend
 0338                   .dbfunc e DataStartSec _DataStartSec fl
                        .even
 0338           _DataStartSec::
 0338                   .dbline -1
 0338                   .dbline 218
 0338           ; }
 0338           ; 
 0338           ; /***********************************************************************
 0338           ; 函数功能：获取数据区开始扇区号，支持FAT32
 0338           ; 操作内容：1、计算数据开始扇区号
 0338           ;           2、FAT32系统下BPB_RootEntCnt=0
 0338           ; ***********************************************************************/
 0338           ; 
 0338           ; uint32 DataStartSec(void)
 0338           ; {
 0338                   .dbline 219
 0338           ;       return (uint32)(DirStartSec() + (BPB_RootEntCnt * 32) / BPB_BytesPerSec); //乘以32是因为根目录是32位长度文件
 0338 BADF              xcall _DirStartSec
 033A 1801              movw R2,R16
 033C 2901              movw R4,R18
 033E 20911300          lds R18,_BPB_RootEntCnt
 0342 30911400          lds R19,_BPB_RootEntCnt+1
 0346 00E2              ldi R16,32
 0348 10E0              ldi R17,0
 034A 0E940000          xcall empy16s
 034E 20911900          lds R18,_BPB_BytesPerSec
 0352 30911A00          lds R19,_BPB_BytesPerSec+1
 0356 0E940000          xcall div16u
 035A 3801              movw R6,R16
 035C 8824              clr R8
 035E 9924              clr R9
 0360 8101              movw R16,R2
 0362 9201              movw R18,R4
 0364 060D              add R16,R6
 0366 171D              adc R17,R7
 0368 281D              adc R18,R8
 036A 391D              adc R19,R9
 036C                   .dbline -2
 036C           L40:
 036C                   .dbline 0 ; func end
 036C 0895              ret
 036E                   .dbend
 036E                   .dbfunc e GetDirSecCount _GetDirSecCount fi
                        .even
 036E           _GetDirSecCount::
 036E                   .dbline -1
 036E                   .dbline 230
 036E           ; }
 036E           ; 
 036E           ; /***********************************************************************
 036E           ; 函数功能：根目录占用扇区数，FAT16有效
 036E           ; 操作内容：1、计算根目录占用扇区数
 036E           ;           2、根目录为长度为32位的“文件”
 036E           ;           3、不是真正文件，类似文件
 036E           ; ***********************************************************************/
 036E           ; 
 036E           ; uint16 GetDirSecCount(void)
 036E           ; {
 036E                   .dbline 231
 036E           ;       return BPB_RootEntCnt * 32 / BPB_BytesPerSec;
 036E 20911300          lds R18,_BPB_RootEntCnt
 0372 30911400          lds R19,_BPB_RootEntCnt+1
 0376 00E2              ldi R16,32
 0378 10E0              ldi R17,0
 037A 0E940000          xcall empy16s
 037E 20911900          lds R18,_BPB_BytesPerSec
 0382 30911A00          lds R19,_BPB_BytesPerSec+1
 0386                   .dbline -2
 0386           L41:
 0386                   .dbline 0 ; func end
 0386 0C940000          xjmp div16u
 038A                   .dbend
 038A                   .dbfunc e GetDirStartClus _GetDirStartClus fl
                        .even
 038A           _GetDirStartClus::
 038A                   .dbline -1
 038A                   .dbline 240
 038A           ; }
 038A           ; 
 038A           ; /***********************************************************************
 038A           ; 函数功能：根目录所在第一个簇的簇号，FAT32有效
 038A           ; 操作内容：1、FAT32根目录项是不确定的，FAT16为固定值512
 038A           ;           2、根目录项不限制
 038A           ; ***********************************************************************/
 038A           ; uint32 GetDirStartClus(void)
 038A           ; {
 038A                   .dbline 241
 038A           ;       return BPB_RootClus;
 038A 20910500          lds R18,_BPB_RootClus+2
 038E 30910600          lds R19,_BPB_RootClus+2+1
 0392 00910300          lds R16,_BPB_RootClus
 0396 10910400          lds R17,_BPB_RootClus+1
 039A                   .dbline -2
 039A           L42:
 039A                   .dbline 0 ; func end
 039A 0895              ret
 039C                   .dbend
 039C                   .dbfunc e ClusConvLBA _ClusConvLBA fl
 039C           ;         ClusID -> R20,R21
                        .even
 039C           _ClusConvLBA::
 039C 4A93              st -y,R20
 039E 5A93              st -y,R21
 03A0 A801              movw R20,R16
 03A2                   .dbline -1
 03A2                   .dbline 252
 03A2           ; }
 03A2           ; 
 03A2           ; /***********************************************************************
 03A2           ; 函数功能：获取一个给定的簇的扇区开始地址
 03A2           ; 操作内容：1、计算簇开始扇区号    
 03A2           ;           2、它是针对FAT卷扇区0的偏移量
 03A2           ;           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
 03A2           ; ***********************************************************************/
 03A2           ; 
 03A2           ; uint32 ClusConvLBA(uint16 ClusID)
 03A2           ; {
 03A2                   .dbline 253
 03A2           ;       return DataStartSec() + BPB_SecPerClus * (ClusID - 2);
 03A2 CADF              xcall _DataStartSec
 03A4 1801              movw R2,R16
 03A6 2901              movw R4,R18
 03A8 9A01              movw R18,R20
 03AA 2250              subi R18,2
 03AC 3040              sbci R19,0
 03AE 00911800          lds R16,_BPB_SecPerClus
 03B2 1127              clr R17
 03B4 0E940000          xcall empy16s
 03B8 3801              movw R6,R16
 03BA 8824              clr R8
 03BC 9924              clr R9
 03BE 8101              movw R16,R2
 03C0 9201              movw R18,R4
 03C2 060D              add R16,R6
 03C4 171D              adc R17,R7
 03C6 281D              adc R18,R8
 03C8 391D              adc R19,R9
 03CA                   .dbline -2
 03CA           L43:
 03CA                   .dbline 0 ; func end
 03CA 5991              ld R21,y+
 03CC 4991              ld R20,y+
 03CE 0895              ret
 03D0                   .dbsym r ClusID 20 i
 03D0                   .dbend
 03D0                   .dbfunc e FATSystemType _FATSystemType fV
                        .even
 03D0           _FATSystemType::
 03D0                   .dbline -1
 03D0                   .dbline 265
 03D0           ; }
 03D0           ; 
 03D0           ; /***********************************************************************
 03D0           ; 函数功能：判断文件系统类型，FAT16/FAT32中的一种，FAT12目前基本不用了
 03D0           ; 操作内容：1、实际上文件系统类型的判断只有唯一的方法：判断簇的大小   
 03D0           ;           2、FAT12的簇数最大4084，FAT16最大65524，FAT32大于65524
 03D0           ;           3、簇数完全由BPB信息确定，可以计算
 03D0           ;           4、考虑到FAT32文件系统不存在固定的FAT表区，因此FATSz16=0
 03D0           ;           5、通过FATSz16是否为0即可判断是FAT16还是FAT32
 03D0           ; ***********************************************************************/
 03D0           ; void FATSystemType(void)
 03D0           ; { 
 03D0                   .dbline 266
 03D0           ;   if(BPB_FATSz16!=0)
 03D0 20900F00          lds R2,_BPB_FATSz16
 03D4 30901000          lds R3,_BPB_FATSz16+1
 03D8 2220              tst R2
 03DA 11F4              brne X6
 03DC 3320              tst R3
 03DE 21F0              breq L45
 03E0           X6:
 03E0                   .dbline 267
 03E0           ;     FAT32_EN=0;                            //FAT16文件系统
 03E0 2224              clr R2
 03E2 20920000          sts _FAT32_EN,R2
 03E6 03C0              xjmp L46
 03E8           L45:
 03E8                   .dbline 269
 03E8           ;   else 
 03E8           ;     FAT32_EN=1;                            //FAT32文件系统
 03E8 81E0              ldi R24,1
 03EA 80930000          sts _FAT32_EN,R24
 03EE           L46:
 03EE                   .dbline -2
 03EE           L44:
 03EE                   .dbline 0 ; func end
 03EE 0895              ret
 03F0                   .dbend
 03F0                   .dbfunc e ReadFAT _ReadFAT fi
 03F0           ;            RAM -> R20,R21
 03F0           ;          Index -> R22,R23
                        .even
 03F0           _ReadFAT::
 03F0 0E940000          xcall push_xgsetF000
 03F4 B801              movw R22,R16
 03F6                   .dbline -1
 03F6                   .dbline 291
 03F6           ;   
 03F6           ;   //return FAT32_EN;
 03F6           ; /*    FATSz=BPB_FATSz32;
 03F6           ;   if(BPB_TotSec16!=0) 
 03F6           ;     TotSec=BPB_TotSec16;
 03F6           ;   else
 03F6           ;     TotSec=BPB_TotSec32;
 03F6           ;   DataSec=TotSec-(BPB_RsvdSecCnt+BPB_NumFATs*FATSz)+RootDirSectors);
 03F6           ;   CountofClusters=Data / BPB_SecPerClus;  */
 03F6           ; }
 03F6           ; 
 03F6           ; /***********************************************************************
 03F6           ; 函数功能：读取文件分配表的指定项，第一个FAT表FAT1
 03F6           ; 操作内容：1、FAT表位于启动扇区之后，一般是2个   
 03F6           ;           2、它用来管理文件簇，每个文件对应一个FAT表
 03F6           ;           3、FAT16系统可以管理2^16个文件簇
 03F6           ;           4、记录磁盘中有关文件如何被分散存储在不同扇区的信息
 03F6           ;           5、每个文件的FAT表占2个字节，FAT32系统是4个字节
 03F6           ; ***********************************************************************/
 03F6           ; 
 03F6           ; uint16 ReadFAT(uint16 Index)
 03F6           ; {
 03F6                   .dbline 292
 03F6           ;       uint16 *RAM = (uint16*)BUFFER;
 03F6 40E0              ldi R20,<_BUFFER
 03F8 50E0              ldi R21,>_BUFFER
 03FA                   .dbline 293
 03FA           ;       ReadBlock(BPB_HiddSec+BPB_RsvdSecCnt + Index / 256);//?????????????
 03FA 20901600          lds R2,_BPB_RsvdSecCnt
 03FE 30901700          lds R3,_BPB_RsvdSecCnt+1
 0402 4424              clr R4
 0404 5524              clr R5
 0406 20910D00          lds R18,_BPB_HiddSec+2
 040A 30910E00          lds R19,_BPB_HiddSec+2+1
 040E 00910B00          lds R16,_BPB_HiddSec
 0412 10910C00          lds R17,_BPB_HiddSec+1
 0416 020D              add R16,R2
 0418 131D              adc R17,R3
 041A 241D              adc R18,R4
 041C 351D              adc R19,R5
 041E 1B01              movw R2,R22
 0420 232C              mov R2,R3
 0422 3324              clr R3
 0424 4424              clr R4
 0426 5524              clr R5
 0428 020D              add R16,R2
 042A 131D              adc R17,R3
 042C 241D              adc R18,R4
 042E 351D              adc R19,R5
 0430 E7DD              xcall _ReadBlock
 0432                   .dbline 294
 0432           ;       return RAM[Index % 256];                //求余数以后就是对应扇区内的偏移量，占2个字节
 0432 FB01              movw R30,R22
 0434 F070              andi R31,0
 0436 EE0F              lsl R30
 0438 FF1F              rol R31
 043A E40F              add R30,R20
 043C F51F              adc R31,R21
 043E 0081              ldd R16,z+0
 0440 1181              ldd R17,z+1
 0442                   .dbline -2
 0442           L47:
 0442                   .dbline 0 ; func end
 0442 0C940000          xjmp pop_xgsetF000
 0446                   .dbsym r RAM 20 pi
 0446                   .dbsym r Index 22 i
 0446                   .dbend
 0446                   .dbfunc e Read32FAT _Read32FAT fl
 0446           ;            RAM -> R10,R11
 0446           ;          Index -> y+6
                        .even
 0446           _Read32FAT::
 0446 0E940000          xcall push_arg4
 044A 0E940000          xcall push_xgsetF00C
 044E                   .dbline -1
 044E                   .dbline 298
 044E           ; }
 044E           ; 
 044E           ; uint32 Read32FAT(uint32 Index)
 044E           ; {
 044E                   .dbline 299
 044E           ;       uint32 *RAM = (uint32*)BUFFER;
 044E 80E0              ldi R24,<_BUFFER
 0450 90E0              ldi R25,>_BUFFER
 0452 5C01              movw R10,R24
 0454                   .dbline 300
 0454           ;       ReadBlock(BPB_HiddSec + BPB_RsvdSecCnt + Index / 128);
 0454 87E0              ldi R24,7
 0456 90E0              ldi R25,0
 0458 0E81              ldd R16,y+6
 045A 1F81              ldd R17,y+7
 045C 2885              ldd R18,y+8
 045E 3985              ldd R19,y+9
 0460 8A93              st -y,R24
 0462 0E940000          xcall lsr32
 0466 20901600          lds R2,_BPB_RsvdSecCnt
 046A 30901700          lds R3,_BPB_RsvdSecCnt+1
 046E 4424              clr R4
 0470 5524              clr R5
 0472 80900D00          lds R8,_BPB_HiddSec+2
 0476 90900E00          lds R9,_BPB_HiddSec+2+1
 047A 60900B00          lds R6,_BPB_HiddSec
 047E 70900C00          lds R7,_BPB_HiddSec+1
 0482 620C              add R6,R2
 0484 731C              adc R7,R3
 0486 841C              adc R8,R4
 0488 951C              adc R9,R5
 048A 600E              add R6,R16
 048C 711E              adc R7,R17
 048E 821E              adc R8,R18
 0490 931E              adc R9,R19
 0492 8301              movw R16,R6
 0494 9401              movw R18,R8
 0496 B4DD              xcall _ReadBlock
 0498                   .dbline 301
 0498           ;       return RAM[Index % 128];                //求余数以后就是对应扇区内的偏移量，占4个字节
 0498 4FE7              ldi R20,127
 049A 50E0              ldi R21,0
 049C 60E0              ldi R22,0
 049E 70E0              ldi R23,0
 04A0 0E81              ldd R16,y+6
 04A2 1F81              ldd R17,y+7
 04A4 2885              ldd R18,y+8
 04A6 3985              ldd R19,y+9
 04A8 0423              and R16,R20
 04AA 1523              and R17,R21
 04AC 2623              and R18,R22
 04AE 3723              and R19,R23
 04B0 82E0              ldi R24,2
 04B2 90E0              ldi R25,0
 04B4 8A93              st -y,R24
 04B6 0E940000          xcall lsl32
 04BA F801              movw R30,R16
 04BC EA0D              add R30,R10
 04BE FB1D              adc R31,R11
 04C0 0081              ldd R16,z+0
 04C2 1181              ldd R17,z+1
 04C4 2281              ldd R18,z+2
 04C6 3381              ldd R19,z+3
 04C8                   .dbline -2
 04C8           L48:
 04C8                   .dbline 0 ; func end
 04C8 0E940000          xcall pop_xgsetF00C
 04CC 2496              adiw R28,4
 04CE 0895              ret
 04D0                   .dbsym r RAM 10 pl
 04D0                   .dbsym l Index 6 l
 04D0                   .dbend
 04D0                   .dbfunc e WriteFAT _WriteFAT fV
 04D0           ;            RAM -> R20,R21
 04D0           ;          SecID -> y+0
 04D0           ;          Value -> R10,R11
 04D0           ;          Index -> R22,R23
                        .even
 04D0           _WriteFAT::
 04D0 0E940000          xcall push_xgsetF00C
 04D4 5901              movw R10,R18
 04D6 B801              movw R22,R16
 04D8 2497              sbiw R28,4
 04DA                   .dbline -1
 04DA                   .dbline 314
 04DA           ; }
 04DA           ; 
 04DA           ; 
 04DA           ; 
 04DA           ; /***********************************************************************
 04DA           ; 函数功能：写文件分配表的指定项，第一个FAT表FAT1
 04DA           ; 操作内容：1、FAT表位于启动扇区之后，一般是2个   
 04DA           ;           2、它用来管理文件簇，每个文件对应一个FAT表
 04DA           ;           3、FAT16系统可以管理2^16个文件簇
 04DA           ; ***********************************************************************/
 04DA           ; 
 04DA           ; void WriteFAT(uint16 Index, uint16 Value)
 04DA           ; {
 04DA                   .dbline 315
 04DA           ;       uint16 *RAM = (uint16*)BUFFER;
 04DA 40E0              ldi R20,<_BUFFER
 04DC 50E0              ldi R21,>_BUFFER
 04DE                   .dbline 317
 04DE           ;       uint32 SecID;
 04DE           ;       SecID = BPB_HiddSec + BPB_RsvdSecCnt + Index / 256;    //扇区号，将写入FAT值到对应扇区???????????????????????
 04DE 20901600          lds R2,_BPB_RsvdSecCnt
 04E2 30901700          lds R3,_BPB_RsvdSecCnt+1
 04E6 4424              clr R4
 04E8 5524              clr R5
 04EA 80900D00          lds R8,_BPB_HiddSec+2
 04EE 90900E00          lds R9,_BPB_HiddSec+2+1
 04F2 60900B00          lds R6,_BPB_HiddSec
 04F6 70900C00          lds R7,_BPB_HiddSec+1
 04FA 620C              add R6,R2
 04FC 731C              adc R7,R3
 04FE 841C              adc R8,R4
 0500 951C              adc R9,R5
 0502 1B01              movw R2,R22
 0504 232C              mov R2,R3
 0506 3324              clr R3
 0508 4424              clr R4
 050A 5524              clr R5
 050C 620C              add R6,R2
 050E 731C              adc R7,R3
 0510 841C              adc R8,R4
 0512 951C              adc R9,R5
 0514 6882              std y+0,R6
 0516 7982              std y+1,R7
 0518 8A82              std y+2,R8
 051A 9B82              std y+3,R9
 051C                   .dbline 318
 051C           ;       ReadBlock(SecID);
 051C 0881              ldd R16,y+0
 051E 1981              ldd R17,y+1
 0520 2A81              ldd R18,y+2
 0522 3B81              ldd R19,y+3
 0524 6DDD              xcall _ReadBlock
 0526                   .dbline 319
 0526           ;       RAM[Index % 256] = Value;                //这是文件对应FAT表的值
 0526 FB01              movw R30,R22
 0528 F070              andi R31,0
 052A EE0F              lsl R30
 052C FF1F              rol R31
 052E E40F              add R30,R20
 0530 F51F              adc R31,R21
 0532 B182              std z+1,R11
 0534 A082              std z+0,R10
 0536                   .dbline 320
 0536           ;       WriteBlock(SecID);
 0536 0881              ldd R16,y+0
 0538 1981              ldd R17,y+1
 053A 2A81              ldd R18,y+2
 053C 3B81              ldd R19,y+3
 053E 73DD              xcall _WriteBlock
 0540                   .dbline -2
 0540           L49:
 0540                   .dbline 0 ; func end
 0540 2496              adiw R28,4
 0542 0C940000          xjmp pop_xgsetF00C
 0546                   .dbsym r RAM 20 pi
 0546                   .dbsym l SecID 0 l
 0546                   .dbsym r Value 10 i
 0546                   .dbsym r Index 22 i
 0546                   .dbend
 0546                   .dbfunc e Write32FAT _Write32FAT fV
 0546           ;            RAM -> R10,R11
 0546           ;          SecID -> y+0
 0546           ;          Value -> y+14
 0546           ;          Index -> y+10
                        .even
 0546           _Write32FAT::
 0546 0E940000          xcall push_arg4
 054A 0E940000          xcall push_xgsetF00C
 054E 2497              sbiw R28,4
 0550                   .dbline -1
 0550                   .dbline 324
 0550           ; }
 0550           ; 
 0550           ; void Write32FAT(uint32 Index, uint32 Value)
 0550           ; {
 0550                   .dbline 325
 0550           ;         uint32 *RAM = (uint32*)BUFFER;
 0550 80E0              ldi R24,<_BUFFER
 0552 90E0              ldi R25,>_BUFFER
 0554 5C01              movw R10,R24
 0556                   .dbline 327
 0556           ;       uint32 SecID;
 0556           ;       SecID = BPB_HiddSec + BPB_RsvdSecCnt + Index / 128;    //扇区号，将写入FAT值到对应扇区
 0556 87E0              ldi R24,7
 0558 90E0              ldi R25,0
 055A 0A85              ldd R16,y+10
 055C 1B85              ldd R17,y+11
 055E 2C85              ldd R18,y+12
 0560 3D85              ldd R19,y+13
 0562 8A93              st -y,R24
 0564 0E940000          xcall lsr32
 0568 20901600          lds R2,_BPB_RsvdSecCnt
 056C 30901700          lds R3,_BPB_RsvdSecCnt+1
 0570 4424              clr R4
 0572 5524              clr R5
 0574 80900D00          lds R8,_BPB_HiddSec+2
 0578 90900E00          lds R9,_BPB_HiddSec+2+1
 057C 60900B00          lds R6,_BPB_HiddSec
 0580 70900C00          lds R7,_BPB_HiddSec+1
 0584 620C              add R6,R2
 0586 731C              adc R7,R3
 0588 841C              adc R8,R4
 058A 951C              adc R9,R5
 058C 600E              add R6,R16
 058E 711E              adc R7,R17
 0590 821E              adc R8,R18
 0592 931E              adc R9,R19
 0594 6882              std y+0,R6
 0596 7982              std y+1,R7
 0598 8A82              std y+2,R8
 059A 9B82              std y+3,R9
 059C                   .dbline 328
 059C           ;       ReadBlock(SecID);
 059C 0881              ldd R16,y+0
 059E 1981              ldd R17,y+1
 05A0 2A81              ldd R18,y+2
 05A2 3B81              ldd R19,y+3
 05A4 2DDD              xcall _ReadBlock
 05A6                   .dbline 329
 05A6           ;       RAM[Index % 128] = Value;                //这是文件对应FAT表的值
 05A6 4FE7              ldi R20,127
 05A8 50E0              ldi R21,0
 05AA 60E0              ldi R22,0
 05AC 70E0              ldi R23,0
 05AE 0A85              ldd R16,y+10
 05B0 1B85              ldd R17,y+11
 05B2 2C85              ldd R18,y+12
 05B4 3D85              ldd R19,y+13
 05B6 0423              and R16,R20
 05B8 1523              and R17,R21
 05BA 2623              and R18,R22
 05BC 3723              and R19,R23
 05BE 82E0              ldi R24,2
 05C0 90E0              ldi R25,0
 05C2 8A93              st -y,R24
 05C4 0E940000          xcall lsl32
 05C8 F801              movw R30,R16
 05CA EA0D              add R30,R10
 05CC FB1D              adc R31,R11
 05CE 2E84              ldd R2,y+14
 05D0 3F84              ldd R3,y+15
 05D2 4888              ldd R4,y+16
 05D4 5988              ldd R5,y+17
 05D6 2082              std z+0,R2
 05D8 3182              std z+1,R3
 05DA 4282              std z+2,R4
 05DC 5382              std z+3,R5
 05DE                   .dbline 330
 05DE           ;       WriteBlock(SecID);
 05DE 0881              ldd R16,y+0
 05E0 1981              ldd R17,y+1
 05E2 2A81              ldd R18,y+2
 05E4 3B81              ldd R19,y+3
 05E6 1FDD              xcall _WriteBlock
 05E8                   .dbline -2
 05E8           L50:
 05E8                   .dbline 0 ; func end
 05E8 2496              adiw R28,4
 05EA 0E940000          xcall pop_xgsetF00C
 05EE 2496              adiw R28,4
 05F0 0895              ret
 05F2                   .dbsym r RAM 10 pl
 05F2                   .dbsym l SecID 0 l
 05F2                   .dbsym l Value 14 l
 05F2                   .dbsym l Index 10 l
 05F2                   .dbend
 05F2                   .dbfunc e WriteFAT2 _WriteFAT2 fV
 05F2           ;            RAM -> R20,R21
 05F2           ;          SecID -> y+0
 05F2           ;          Value -> R10,R11
 05F2           ;          Index -> R22,R23
                        .even
 05F2           _WriteFAT2::
 05F2 0E940000          xcall push_xgsetF00C
 05F6 5901              movw R10,R18
 05F8 B801              movw R22,R16
 05FA 2497              sbiw R28,4
 05FC                   .dbline -1
 05FC                   .dbline 343
 05FC           ; }
 05FC           ; 
 05FC           ; 
 05FC           ; 
 05FC           ; /***********************************************************************
 05FC           ; 函数功能：写文件分配表的指定项，第二个FAT表FAT2
 05FC           ; 操作内容：1、FAT表位于启动扇区之后，一般是2个   
 05FC           ;           2、它用来管理文件簇，每个文件对应一个FAT表
 05FC           ;           3、FAT16系统可以管理2^16个文件簇
 05FC           ; ***********************************************************************/
 05FC           ; 
 05FC           ; void WriteFAT2(uint16 Index, uint16 Value)
 05FC           ; {
 05FC                   .dbline 344
 05FC           ;       uint16 *RAM = (uint16*)BUFFER;
 05FC 40E0              ldi R20,<_BUFFER
 05FE 50E0              ldi R21,>_BUFFER
 0600                   .dbline 346
 0600           ;       uint32 SecID;
 0600           ;       SecID = BPB_RsvdSecCnt + BPB_FATSz16 + Index / 256;   //第二个FAT表紧跟在第一个FAT表后面
 0600 20900F00          lds R2,_BPB_FATSz16
 0604 30901000          lds R3,_BPB_FATSz16+1
 0608 40901600          lds R4,_BPB_RsvdSecCnt
 060C 50901700          lds R5,_BPB_RsvdSecCnt+1
 0610 420C              add R4,R2
 0612 531C              adc R5,R3
 0614 1B01              movw R2,R22
 0616 232C              mov R2,R3
 0618 3324              clr R3
 061A 420C              add R4,R2
 061C 531C              adc R5,R3
 061E 1201              movw R2,R4
 0620 4424              clr R4
 0622 5524              clr R5
 0624 2882              std y+0,R2
 0626 3982              std y+1,R3
 0628 4A82              std y+2,R4
 062A 5B82              std y+3,R5
 062C                   .dbline 347
 062C           ;       ReadBlock(SecID);
 062C 0881              ldd R16,y+0
 062E 1981              ldd R17,y+1
 0630 2A81              ldd R18,y+2
 0632 3B81              ldd R19,y+3
 0634 E5DC              xcall _ReadBlock
 0636                   .dbline 348
 0636           ;       RAM[Index % 256] = Value;
 0636 FB01              movw R30,R22
 0638 F070              andi R31,0
 063A EE0F              lsl R30
 063C FF1F              rol R31
 063E E40F              add R30,R20
 0640 F51F              adc R31,R21
 0642 B182              std z+1,R11
 0644 A082              std z+0,R10
 0646                   .dbline 349
 0646           ;       WriteBlock(SecID);
 0646 0881              ldd R16,y+0
 0648 1981              ldd R17,y+1
 064A 2A81              ldd R18,y+2
 064C 3B81              ldd R19,y+3
 064E EBDC              xcall _WriteBlock
 0650                   .dbline -2
 0650           L51:
 0650                   .dbline 0 ; func end
 0650 2496              adiw R28,4
 0652 0C940000          xjmp pop_xgsetF00C
 0656                   .dbsym r RAM 20 pi
 0656                   .dbsym l SecID 0 l
 0656                   .dbsym r Value 10 i
 0656                   .dbsym r Index 22 i
 0656                   .dbend
 0656                   .dbfunc e Write32FAT2 _Write32FAT2 fV
 0656           ;            RAM -> R10,R11
 0656           ;          SecID -> y+0
 0656           ;          Value -> y+14
 0656           ;          Index -> y+10
                        .even
 0656           _Write32FAT2::
 0656 0E940000          xcall push_arg4
 065A 0E940000          xcall push_xgsetF00C
 065E 2497              sbiw R28,4
 0660                   .dbline -1
 0660                   .dbline 353
 0660           ; }
 0660           ; 
 0660           ; void Write32FAT2(uint32 Index, uint32 Value)
 0660           ; {
 0660                   .dbline 354
 0660           ;         uint32 *RAM = (uint32*)BUFFER;
 0660 80E0              ldi R24,<_BUFFER
 0662 90E0              ldi R25,>_BUFFER
 0664 5C01              movw R10,R24
 0666                   .dbline 356
 0666           ;       uint32 SecID;
 0666           ;       SecID = BPB_RsvdSecCnt + BPB_FATSz16 + Index / 128;    //扇区号，将写入FAT值到对应扇区
 0666 87E0              ldi R24,7
 0668 90E0              ldi R25,0
 066A 0A85              ldd R16,y+10
 066C 1B85              ldd R17,y+11
 066E 2C85              ldd R18,y+12
 0670 3D85              ldd R19,y+13
 0672 8A93              st -y,R24
 0674 0E940000          xcall lsr32
 0678 20900F00          lds R2,_BPB_FATSz16
 067C 30901000          lds R3,_BPB_FATSz16+1
 0680 40901600          lds R4,_BPB_RsvdSecCnt
 0684 50901700          lds R5,_BPB_RsvdSecCnt+1
 0688 420C              add R4,R2
 068A 531C              adc R5,R3
 068C 1201              movw R2,R4
 068E 4424              clr R4
 0690 5524              clr R5
 0692 200E              add R2,R16
 0694 311E              adc R3,R17
 0696 421E              adc R4,R18
 0698 531E              adc R5,R19
 069A 2882              std y+0,R2
 069C 3982              std y+1,R3
 069E 4A82              std y+2,R4
 06A0 5B82              std y+3,R5
 06A2                   .dbline 357
 06A2           ;       ReadBlock(SecID);
 06A2 0881              ldd R16,y+0
 06A4 1981              ldd R17,y+1
 06A6 2A81              ldd R18,y+2
 06A8 3B81              ldd R19,y+3
 06AA AADC              xcall _ReadBlock
 06AC                   .dbline 358
 06AC           ;       RAM[Index % 128] = Value;                              //这是文件对应FAT表的值
 06AC 4FE7              ldi R20,127
 06AE 50E0              ldi R21,0
 06B0 60E0              ldi R22,0
 06B2 70E0              ldi R23,0
 06B4 0A85              ldd R16,y+10
 06B6 1B85              ldd R17,y+11
 06B8 2C85              ldd R18,y+12
 06BA 3D85              ldd R19,y+13
 06BC 0423              and R16,R20
 06BE 1523              and R17,R21
 06C0 2623              and R18,R22
 06C2 3723              and R19,R23
 06C4 82E0              ldi R24,2
 06C6 90E0              ldi R25,0
 06C8 8A93              st -y,R24
 06CA 0E940000          xcall lsl32
 06CE F801              movw R30,R16
 06D0 EA0D              add R30,R10
 06D2 FB1D              adc R31,R11
 06D4 2E84              ldd R2,y+14
 06D6 3F84              ldd R3,y+15
 06D8 4888              ldd R4,y+16
 06DA 5988              ldd R5,y+17
 06DC 2082              std z+0,R2
 06DE 3182              std z+1,R3
 06E0 4282              std z+2,R4
 06E2 5382              std z+3,R5
 06E4                   .dbline 359
 06E4           ;       WriteBlock(SecID);
 06E4 0881              ldd R16,y+0
 06E6 1981              ldd R17,y+1
 06E8 2A81              ldd R18,y+2
 06EA 3B81              ldd R19,y+3
 06EC 9CDC              xcall _WriteBlock
 06EE                   .dbline -2
 06EE           L52:
 06EE                   .dbline 0 ; func end
 06EE 2496              adiw R28,4
 06F0 0E940000          xcall pop_xgsetF00C
 06F4 2496              adiw R28,4
 06F6 0895              ret
 06F8                   .dbsym r RAM 10 pl
 06F8                   .dbsym l SecID 0 l
 06F8                   .dbsym l Value 14 l
 06F8                   .dbsym l Index 10 l
 06F8                   .dbend
 06F8                   .dbfunc e GetEmptyDIR _GetEmptyDIR fi
 06F8           ;       DirStart -> R12,R13
 06F8           ;      DirSecCut -> R10,R11
 06F8           ;              i -> R22,R23
 06F8           ;             ID -> R20,R21
 06F8           ;              m -> R14,R15
                        .even
 06F8           _GetEmptyDIR::
 06F8 0E940000          xcall push_xgsetF0FC
 06FC                   .dbline -1
 06FC                   .dbline 372
 06FC           ; }
 06FC           ; 
 06FC           ; /***********************************************************************
 06FC           ; 函数功能：获取根目录中可以使用的一项
 06FC           ; 操作内容：1、计算簇开始扇区号    
 06FC           ;           2、它是针对FAT卷扇区0的偏移量
 06FC           ;           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
 06FC           ;           4、实际上如果FileName[0]=0x00或者0xE5，均表示为可以使用项，但意义不一样
 06FC           ;           5、0x00表示之后都是空，没有目录，可以不再查询；0xE5表示此目录项为空，可以使用
 06FC           ; ***********************************************************************/
 06FC           ; 
 06FC           ; uint16 GetEmptyDIR()
 06FC           ; {
 06FC                   .dbline 373
 06FC           ;       uint16 DirSecCut, DirStart, i, m, ID = 0;
 06FC 4427              clr R20
 06FE 5527              clr R21
 0700                   .dbline 374
 0700           ;       DirSecCut = 32;               //GetDirSecCount();     //根目录扇区总数，这里限制FAT16和FAT32都最多为512个根目录项
 0700 80E2              ldi R24,32
 0702 90E0              ldi R25,0
 0704 5C01              movw R10,R24
 0706                   .dbline 375
 0706           ;       DirStart = DirStartSec();                                            //根目录开始扇区地址,FAT16为512
 0706 D3DD              xcall _DirStartSec
 0708 6801              movw R12,R16
 070A                   .dbline 376
 070A           ;       for(i = 0; i < DirSecCut; i++)                                       //在整个扇区空间搜索
 070A 6627              clr R22
 070C 7727              clr R23
 070E 28C0              xjmp L57
 0710           L54:
 0710                   .dbline 377
 0710           ;       {
 0710                   .dbline 378
 0710           ;               ReadBlock(DirStart + i);                                     //读根目录扇区
 0710 8601              movw R16,R12
 0712 060F              add R16,R22
 0714 171F              adc R17,R23
 0716 2227              clr R18
 0718 3327              clr R19
 071A 72DC              xcall _ReadBlock
 071C                   .dbline 379
 071C           ;               for(m = 0; m < 16; m++)
 071C EE24              clr R14
 071E FF24              clr R15
 0720 18C0              xjmp L61
 0722           L58:
 0722                   .dbline 380
 0722           ;               {
 0722                   .dbline 381
 0722           ;                       if((BUFFER[m * 32] == 0) || (BUFFER[m * 32] == 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
 0722 00E2              ldi R16,32
 0724 10E0              ldi R17,0
 0726 9701              movw R18,R14
 0728 0E940000          xcall empy16s
 072C 80E0              ldi R24,<_BUFFER
 072E 90E0              ldi R25,>_BUFFER
 0730 F801              movw R30,R16
 0732 E80F              add R30,R24
 0734 F91F              adc R31,R25
 0736 2080              ldd R2,z+0
 0738 3324              clr R3
 073A 2220              tst R2
 073C 19F0              breq L64
 073E           X7:
 073E 822D              mov R24,R2
 0740 853E              cpi R24,229
 0742 11F4              brne L62
 0744           X8:
 0744           L64:
 0744                   .dbline 382
 0744           ;                               return ID;                                   //返回可以使用扇区ID
 0744 8A01              movw R16,R20
 0746 10C0              xjmp L53
 0748           L62:
 0748                   .dbline 384
 0748           ;                       else
 0748           ;                               ID++;
 0748 4F5F              subi R20,255  ; offset = 1
 074A 5F4F              sbci R21,255
 074C                   .dbline 385
 074C           ;               }
 074C           L59:
 074C                   .dbline 379
 074C C701              movw R24,R14
 074E 0196              adiw R24,1
 0750 7C01              movw R14,R24
 0752           L61:
 0752                   .dbline 379
 0752 C701              movw R24,R14
 0754 8031              cpi R24,16
 0756 E0E0              ldi R30,0
 0758 9E07              cpc R25,R30
 075A 18F3              brlo L58
 075C           X9:
 075C                   .dbline 386
 075C           ;       }
 075C           L55:
 075C                   .dbline 376
 075C 6F5F              subi R22,255  ; offset = 1
 075E 7F4F              sbci R23,255
 0760           L57:
 0760                   .dbline 376
 0760 6A15              cp R22,R10
 0762 7B05              cpc R23,R11
 0764 A8F2              brlo L54
 0766           X10:
 0766                   .dbline 387
 0766           ;       return ID;                                                            //表示没有空闲可以使用的项
 0766 8A01              movw R16,R20
 0768                   .dbline -2
 0768           L53:
 0768                   .dbline 0 ; func end
 0768 0C940000          xjmp pop_xgsetF0FC
 076C                   .dbsym r DirStart 12 i
 076C                   .dbsym r DirSecCut 10 i
 076C                   .dbsym r i 22 i
 076C                   .dbsym r ID 20 i
 076C                   .dbsym r m 14 i
 076C                   .dbend
 076C                   .dbfunc e GetDirectoryEmptyDIR _GetDirectoryEmptyDIR fi
 076C           ;       DirStart -> R12,R13
 076C           ;      DirSecCut -> R10,R11
 076C           ;              i -> R22,R23
 076C           ;             ID -> R20,R21
 076C           ;              m -> R14,R15
 076C           ;         ClusID -> R12,R13
                        .even
 076C           _GetDirectoryEmptyDIR::
 076C 0E940000          xcall push_xgsetF0FC
 0770 6801              movw R12,R16
 0772                   .dbline -1
 0772                   .dbline 400
 0772           ; }
 0772           ; 
 0772           ; /***********************************************************************
 0772           ; 函数功能：获取子目录中可以使用的一项
 0772           ; 操作内容：1、计算簇开始扇区号    
 0772           ;           2、它是针对父目录所在开始簇的偏移量
 0772           ;           3、参数ClusID为给定簇号，为2^n值，如2，4，8，16等
 0772           ;           4、实际上如果FileName[0]=0x00或者0xE5，均表示为可以使用项，但意义不一样
 0772           ;           5、0x00表示之后都是空，没有目录，可以不再查询；0xE5表示此目录项为空，可以使用
 0772           ; ***********************************************************************/
 0772           ; 
 0772           ; uint16 GetDirectoryEmptyDIR(uint16 ClusID)
 0772           ; {
 0772                   .dbline 401
 0772           ;       uint16 DirSecCut, DirStart, i, m, ID = 0;
 0772 4427              clr R20
 0774 5527              clr R21
 0776                   .dbline 402
 0776           ;       DirSecCut = BPB_SecPerClus*16;                                       //一个文件夹的子文件的目录项，一般一个文件夹占一簇，总项数为扇区数×每扇区的项数
 0776 10911800          lds R17,_BPB_SecPerClus
 077A 00E1              ldi R16,16
 077C 0103              mulsu R16,R17
 077E 5001              movw R10,R0
 0780                   .dbline 403
 0780           ;       DirStart = ClusConvLBA(ClusID);                                      //父文件夹的起始簇扇区地址
 0780 8601              movw R16,R12
 0782 0CDE              xcall _ClusConvLBA
 0784 6801              movw R12,R16
 0786                   .dbline 404
 0786           ;       for(i = 0; i < DirSecCut; i++)                                       //在整个扇区空间搜索
 0786 6627              clr R22
 0788 7727              clr R23
 078A 28C0              xjmp L69
 078C           L66:
 078C                   .dbline 405
 078C           ;       {
 078C                   .dbline 406
 078C           ;               ReadBlock(DirStart + i);                                     //读目录扇区
 078C 8601              movw R16,R12
 078E 060F              add R16,R22
 0790 171F              adc R17,R23
 0792 2227              clr R18
 0794 3327              clr R19
 0796 34DC              xcall _ReadBlock
 0798                   .dbline 407
 0798           ;               for(m = 0; m < 16; m++)
 0798 EE24              clr R14
 079A FF24              clr R15
 079C 18C0              xjmp L73
 079E           L70:
 079E                   .dbline 408
 079E           ;               {
 079E                   .dbline 409
 079E           ;                       if((BUFFER[m * 32] == 0) || (BUFFER[m * 32] == 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
 079E 00E2              ldi R16,32
 07A0 10E0              ldi R17,0
 07A2 9701              movw R18,R14
 07A4 0E940000          xcall empy16s
 07A8 80E0              ldi R24,<_BUFFER
 07AA 90E0              ldi R25,>_BUFFER
 07AC F801              movw R30,R16
 07AE E80F              add R30,R24
 07B0 F91F              adc R31,R25
 07B2 2080              ldd R2,z+0
 07B4 3324              clr R3
 07B6 2220              tst R2
 07B8 19F0              breq L76
 07BA           X11:
 07BA 822D              mov R24,R2
 07BC 853E              cpi R24,229
 07BE 11F4              brne L74
 07C0           X12:
 07C0           L76:
 07C0                   .dbline 410
 07C0           ;                               return ID;                                   //返回可以使用扇区ID，即偏移量
 07C0 8A01              movw R16,R20
 07C2 10C0              xjmp L65
 07C4           L74:
 07C4                   .dbline 412
 07C4           ;                       else
 07C4           ;                               ID++;
 07C4 4F5F              subi R20,255  ; offset = 1
 07C6 5F4F              sbci R21,255
 07C8                   .dbline 413
 07C8           ;               }
 07C8           L71:
 07C8                   .dbline 407
 07C8 C701              movw R24,R14
 07CA 0196              adiw R24,1
 07CC 7C01              movw R14,R24
 07CE           L73:
 07CE                   .dbline 407
 07CE C701              movw R24,R14
 07D0 8031              cpi R24,16
 07D2 E0E0              ldi R30,0
 07D4 9E07              cpc R25,R30
 07D6 18F3              brlo L70
 07D8           X13:
 07D8                   .dbline 414
 07D8           ;       }
 07D8           L67:
 07D8                   .dbline 404
 07D8 6F5F              subi R22,255  ; offset = 1
 07DA 7F4F              sbci R23,255
 07DC           L69:
 07DC                   .dbline 404
 07DC 6A15              cp R22,R10
 07DE 7B05              cpc R23,R11
 07E0 A8F2              brlo L66
 07E2           X14:
 07E2                   .dbline 415
 07E2           ;       return ID;                                                            //表示没有空闲可以使用的项
 07E2 8A01              movw R16,R20
 07E4                   .dbline -2
 07E4           L65:
 07E4                   .dbline 0 ; func end
 07E4 0C940000          xjmp pop_xgsetF0FC
 07E8                   .dbsym r DirStart 12 i
 07E8                   .dbsym r DirSecCut 10 i
 07E8                   .dbsym r i 22 i
 07E8                   .dbsym r ID 20 i
 07E8                   .dbsym r m 14 i
 07E8                   .dbsym r ClusID 12 i
 07E8                   .dbend
 07E8                   .dbfunc e GetFileID _GetFileID fc
 07E8                   .dbstruct 0 11 .4
 07E8                   .dbfield 0 NAME A[8:8]c
 07E8                   .dbfield 8 TYPE A[3:3]c
 07E8                   .dbend
 07E8                   .dbstruct 0 6 .5
 07E8                   .dbfield 0 Start i
 07E8                   .dbfield 2 Size l
 07E8                   .dbend
 07E8                   .dbstruct 0 32 .6
 07E8                   .dbfield 0 FileName S[.4]
 07E8                   .dbfield 11 FileAttrib c
 07E8                   .dbfield 12 UnUsed c
 07E8                   .dbfield 13 FileCrtTimeTeenth c
 07E8                   .dbfield 14 FileCrtTime A[2:2]c
 07E8                   .dbfield 16 FileCrtDate A[2:2]c
 07E8                   .dbfield 18 FileLastAccDate i
 07E8                   .dbfield 20 FileFstClusHI i
 07E8                   .dbfield 22 FileUpdateTime A[2:2]c
 07E8                   .dbfield 24 FileUpdateData A[2:2]c
 07E8                   .dbfield 26 FilePosit S[.5]
 07E8                   .dbend
 07E8           ;       DirStart -> R10,R11
 07E8           ;      DirSecCut -> R22,R23
 07E8           ;              i -> R20,R21
 07E8           ;          Index -> R14,R15
 07E8           ;              m -> R12,R13
 07E8           ;             ID -> y+13
 07E8           ;           Name -> y+11
                        .even
 07E8           _GetFileID::
 07E8 0E940000          xcall push_arg4
 07EC 0E940000          xcall push_xgsetF0FC
 07F0 2197              sbiw R28,1
 07F2                   .dbline -1
 07F2                   .dbline 426
 07F2           ; }
 07F2           ; 
 07F2           ; /***********************************************************************
 07F2           ; 函数功能：获得和文件名对应的根目录项以及该目录的位置
 07F2           ; 操作内容：1、比较文件名相符   
 07F2           ;           2、每个文件都有对应的FAT表
 07F2           ;           3、ID的首地址是对应的根目录项的首地址，类型为DIR(见头文件fat.h)
 07F2           ; ***********************************************************************/
 07F2           ; 
 07F2           ; uint8 GetFileID(uint8 Name[11], DIR* ID)
 07F2           ; {
 07F2                   .dbline 428
 07F2           ;       uint16 DirSecCut, DirStart, i, m,Index;
 07F2           ;       DirSecCut = 32;                                  //GetDirSecCount();根目录总扇区数，这里将FAT16/32统一到512个根目录项
 07F2 60E2              ldi R22,32
 07F4 70E0              ldi R23,0
 07F6                   .dbline 429
 07F6           ;       DirStart = DirStartSec();                       //根目录开始扇区
 07F6 5BDD              xcall _DirStartSec
 07F8 5801              movw R10,R16
 07FA                   .dbline 430
 07FA           ;       for(i = 0; i < DirSecCut; i++)
 07FA 4427              clr R20
 07FC 5527              clr R21
 07FE 43C0              xjmp L81
 0800           L78:
 0800                   .dbline 431
 0800           ;       {
 0800                   .dbline 432
 0800           ;               ReadBlock(DirStart + i);                //读取扇区数据
 0800 8501              movw R16,R10
 0802 040F              add R16,R20
 0804 151F              adc R17,R21
 0806 2227              clr R18
 0808 3327              clr R19
 080A FADB              xcall _ReadBlock
 080C                   .dbline 433
 080C           ;               for(m = 0; m <16; m++)                  //一个扇区里面有16个项，因为每个项的长度是32位
 080C CC24              clr R12
 080E DD24              clr R13
 0810 32C0              xjmp L85
 0812           L82:
 0812                   .dbline 434
 0812           ;               {
 0812                   .dbline 435
 0812           ;                       if(IsEqual(Name, &((DIR*)&BUFFER[m * 32])->FileName, 11))   //进行比较，相等返回index
 0812 8BE0              ldi R24,11
 0814 8883              std y+0,R24
 0816 00E2              ldi R16,32
 0818 10E0              ldi R17,0
 081A 9601              movw R18,R12
 081C 0E940000          xcall empy16s
 0820 9801              movw R18,R16
 0822 80E0              ldi R24,<_BUFFER
 0824 90E0              ldi R25,>_BUFFER
 0826 280F              add R18,R24
 0828 391F              adc R19,R25
 082A 0B85              ldd R16,y+11
 082C 1C85              ldd R17,y+12
 082E 3CDC              xcall _IsEqual
 0830 0023              tst R16
 0832 F1F0              breq L86
 0834           X15:
 0834                   .dbline 436
 0834           ;                       {
 0834                   .dbline 437
 0834           ;                               *ID = *((DIR*)&BUFFER[m * 32]);   //ID实际就是根目录项
 0834 00E2              ldi R16,32
 0836 10E0              ldi R17,0
 0838 9601              movw R18,R12
 083A 0E940000          xcall empy16s
 083E 1801              movw R2,R16
 0840 80E0              ldi R24,<_BUFFER
 0842 90E0              ldi R25,>_BUFFER
 0844 280E              add R2,R24
 0846 391E              adc R3,R25
 0848 4D84              ldd R4,y+13
 084A 5E84              ldd R5,y+14
 084C 00E2              ldi R16,32
 084E 10E0              ldi R17,0
 0850 5A92              st -y,R5
 0852 4A92              st -y,R4
 0854 3A92              st -y,R3
 0856 2A92              st -y,R2
 0858 0E940000          xcall asgnblk
 085C                   .dbline 438
 085C           ;                                 Index = i*16+m;                   //FAT16下一般最大是511，也就是说FAT16下根目录项数一般为512，为保证兼容性
 085C 00E1              ldi R16,16
 085E 10E0              ldi R17,0
 0860 9A01              movw R18,R20
 0862 0E940000          xcall empy16s
 0866 7801              movw R14,R16
 0868 EC0C              add R14,R12
 086A FD1C              adc R15,R13
 086C                   .dbline 439
 086C           ;                               return Index;                     //找到对应的目录项,返回目录的位置.
 086C 0E2D              mov R16,R14
 086E 10C0              xjmp L77
 0870           L86:
 0870                   .dbline 441
 0870           ;                       }
 0870           ;               }
 0870           L83:
 0870                   .dbline 433
 0870 C601              movw R24,R12
 0872 0196              adiw R24,1
 0874 6C01              movw R12,R24
 0876           L85:
 0876                   .dbline 433
 0876 C601              movw R24,R12
 0878 8031              cpi R24,16
 087A E0E0              ldi R30,0
 087C 9E07              cpc R25,R30
 087E 08F4              brsh X18
 0880 C8CF              xjmp L82
 0882           X18:
 0882           X16:
 0882                   .dbline 442
 0882           ;       }
 0882           L79:
 0882                   .dbline 430
 0882 4F5F              subi R20,255  ; offset = 1
 0884 5F4F              sbci R21,255
 0886           L81:
 0886                   .dbline 430
 0886 4617              cp R20,R22
 0888 5707              cpc R21,R23
 088A 08F4              brsh X19
 088C B9CF              xjmp L78
 088E           X19:
 088E           X17:
 088E                   .dbline 443
 088E           ;       return 0;                                         //没有找到对应的目录项,返回0.
 088E 0027              clr R16
 0890                   .dbline -2
 0890           L77:
 0890                   .dbline 0 ; func end
 0890 2196              adiw R28,1
 0892 0E940000          xcall pop_xgsetF0FC
 0896 2496              adiw R28,4
 0898 0895              ret
 089A                   .dbsym r DirStart 10 i
 089A                   .dbsym r DirSecCut 22 i
 089A                   .dbsym r i 20 i
 089A                   .dbsym r Index 14 i
 089A                   .dbsym r m 12 i
 089A                   .dbsym l ID 13 pS[.6]
 089A                   .dbsym l Name 11 pc
 089A                   .dbend
 089A                   .dbfunc e GetFileID32 _GetFileID32 fc
 089A                   .dbstruct 0 30 .7
 089A                   .dbfield 0 FileName S[.4]
 089A                   .dbfield 11 FileAttrib c
 089A                   .dbfield 12 DIR_NTRes c
 089A                   .dbfield 13 DIR_CrtTimeTeenth c
 089A                   .dbfield 14 DIR_CrtTime i
 089A                   .dbfield 16 DIR_CrtDate i
 089A                   .dbfield 18 DIR_LastAccDate i
 089A                   .dbfield 20 DIR_FstClusHI i
 089A                   .dbfield 22 DIR_WrtTime A[2:2]c
 089A                   .dbfield 24 DIR_WrtDate A[2:2]c
 089A                   .dbfield 26 DIR_FstClusLo i
 089A                   .dbfield 28 DIR_FileSize i
 089A                   .dbend
 089A           ;       DirStart -> R10,R11
 089A           ;      DirSecCut -> R22,R23
 089A           ;              i -> R20,R21
 089A           ;          Index -> R14,R15
 089A           ;              m -> R12,R13
 089A           ;             ID -> y+13
 089A           ;           Name -> y+11
                        .even
 089A           _GetFileID32::
 089A 0E940000          xcall push_arg4
 089E 0E940000          xcall push_xgsetF0FC
 08A2 2197              sbiw R28,1
 08A4                   .dbline -1
 08A4                   .dbline 447
 08A4           ; }
 08A4           ; 
 08A4           ; uint8 GetFileID32(uint8 Name[11], DIR32* ID)
 08A4           ; {
 08A4                   .dbline 449
 08A4           ;       uint16 DirSecCut, DirStart, i, m,Index;
 08A4           ;       DirSecCut = 32;                                  //GetDirSecCount();根目录总扇区数，这里将FAT16/32统一到512个根目录项
 08A4 60E2              ldi R22,32
 08A6 70E0              ldi R23,0
 08A8                   .dbline 450
 08A8           ;       DirStart = DirStartSec();                       //根目录开始扇区
 08A8 02DD              xcall _DirStartSec
 08AA 5801              movw R10,R16
 08AC                   .dbline 451
 08AC           ;       for(i = 0; i < DirSecCut; i++)
 08AC 4427              clr R20
 08AE 5527              clr R21
 08B0 43C0              xjmp L92
 08B2           L89:
 08B2                   .dbline 452
 08B2           ;       {
 08B2                   .dbline 453
 08B2           ;               ReadBlock(DirStart + i);                //读取扇区数据
 08B2 8501              movw R16,R10
 08B4 040F              add R16,R20
 08B6 151F              adc R17,R21
 08B8 2227              clr R18
 08BA 3327              clr R19
 08BC A1DB              xcall _ReadBlock
 08BE                   .dbline 454
 08BE           ;               for(m = 0; m <16; m++)                  //一个扇区里面有16个项，因为每个项的长度是32位
 08BE CC24              clr R12
 08C0 DD24              clr R13
 08C2 32C0              xjmp L96
 08C4           L93:
 08C4                   .dbline 455
 08C4           ;               {
 08C4                   .dbline 456
 08C4           ;                       if(IsEqual(Name, &((DIR32*)&BUFFER[m * 32])->FileName, 11))   //进行比较，相等返回1
 08C4 8BE0              ldi R24,11
 08C6 8883              std y+0,R24
 08C8 00E2              ldi R16,32
 08CA 10E0              ldi R17,0
 08CC 9601              movw R18,R12
 08CE 0E940000          xcall empy16s
 08D2 9801              movw R18,R16
 08D4 80E0              ldi R24,<_BUFFER
 08D6 90E0              ldi R25,>_BUFFER
 08D8 280F              add R18,R24
 08DA 391F              adc R19,R25
 08DC 0B85              ldd R16,y+11
 08DE 1C85              ldd R17,y+12
 08E0 E3DB              xcall _IsEqual
 08E2 0023              tst R16
 08E4 F1F0              breq L97
 08E6           X20:
 08E6                   .dbline 457
 08E6           ;                       {
 08E6                   .dbline 458
 08E6           ;                               *ID = *((DIR32*)&BUFFER[m * 32]);   //ID实际就是根目录项
 08E6 00E2              ldi R16,32
 08E8 10E0              ldi R17,0
 08EA 9601              movw R18,R12
 08EC 0E940000          xcall empy16s
 08F0 1801              movw R2,R16
 08F2 80E0              ldi R24,<_BUFFER
 08F4 90E0              ldi R25,>_BUFFER
 08F6 280E              add R2,R24
 08F8 391E              adc R3,R25
 08FA 4D84              ldd R4,y+13
 08FC 5E84              ldd R5,y+14
 08FE 0EE1              ldi R16,30
 0900 10E0              ldi R17,0
 0902 5A92              st -y,R5
 0904 4A92              st -y,R4
 0906 3A92              st -y,R3
 0908 2A92              st -y,R2
 090A 0E940000          xcall asgnblk
 090E                   .dbline 459
 090E           ;                                 Index = i*16+m;                   //FAT16下一般最大是511，也就是说FAT16下根目录项数一般为512，为保证兼容性
 090E 00E1              ldi R16,16
 0910 10E0              ldi R17,0
 0912 9A01              movw R18,R20
 0914 0E940000          xcall empy16s
 0918 7801              movw R14,R16
 091A EC0C              add R14,R12
 091C FD1C              adc R15,R13
 091E                   .dbline 460
 091E           ;                               return Index;                     //找到对应的目录项,返回目录的位置.
 091E 0E2D              mov R16,R14
 0920 10C0              xjmp L88
 0922           L97:
 0922                   .dbline 462
 0922           ;                       }
 0922           ;               }
 0922           L94:
 0922                   .dbline 454
 0922 C601              movw R24,R12
 0924 0196              adiw R24,1
 0926 6C01              movw R12,R24
 0928           L96:
 0928                   .dbline 454
 0928 C601              movw R24,R12
 092A 8031              cpi R24,16
 092C E0E0              ldi R30,0
 092E 9E07              cpc R25,R30
 0930 08F4              brsh X23
 0932 C8CF              xjmp L93
 0934           X23:
 0934           X21:
 0934                   .dbline 463
 0934           ;       }
 0934           L90:
 0934                   .dbline 451
 0934 4F5F              subi R20,255  ; offset = 1
 0936 5F4F              sbci R21,255
 0938           L92:
 0938                   .dbline 451
 0938 4617              cp R20,R22
 093A 5707              cpc R21,R23
 093C 08F4              brsh X24
 093E B9CF              xjmp L89
 0940           X24:
 0940           X22:
 0940                   .dbline 464
 0940           ;       return 0;                                         //没有找到对应的目录项,返回0.
 0940 0027              clr R16
 0942                   .dbline -2
 0942           L88:
 0942                   .dbline 0 ; func end
 0942 2196              adiw R28,1
 0944 0E940000          xcall pop_xgsetF0FC
 0948 2496              adiw R28,4
 094A 0895              ret
 094C                   .dbsym r DirStart 10 i
 094C                   .dbsym r DirSecCut 22 i
 094C                   .dbsym r i 20 i
 094C                   .dbsym r Index 14 i
 094C                   .dbsym r m 12 i
 094C                   .dbsym l ID 13 pS[.7]
 094C                   .dbsym l Name 11 pc
 094C                   .dbend
 094C                   .dbfunc e GetNextFAT _GetNextFAT fi
 094C           ;      FAT_Count -> R10,R11
 094C           ;              i -> R20,R21
                        .even
 094C           _GetNextFAT::
 094C 0E940000          xcall push_xgset300C
 0950                   .dbline -1
 0950                   .dbline 474
 0950           ; }
 0950           ; 
 0950           ; /***********************************************************************
 0950           ; 函数功能：获取一个空的FAT项
 0950           ; 操作内容：1、用来准备写入FAT表    
 0950           ;           2、每个文件都有对应的FAT表
 0950           ; ***********************************************************************/
 0950           ; 
 0950           ; uint16 GetNextFAT(void)
 0950           ; {
 0950                   .dbline 476
 0950           ;       uint16 FAT_Count, i;
 0950           ;       FAT_Count = BPB_FATSz16 * 256;                      //FAT表总项数，一个扇区是256个项，FAT16一个项是2个字节
 0950 20910F00          lds R18,_BPB_FATSz16
 0954 30911000          lds R19,_BPB_FATSz16+1
 0958 00E0              ldi R16,256
 095A 11E0              ldi R17,1
 095C 0E940000          xcall empy16s
 0960 5801              movw R10,R16
 0962                   .dbline 477
 0962           ;       for(i = 0; i < FAT_Count; i++)
 0962 4427              clr R20
 0964 5527              clr R21
 0966 09C0              xjmp L103
 0968           L100:
 0968                   .dbline 478
 0968           ;       {
 0968                   .dbline 479
 0968           ;               if(ReadFAT(i) == 0)                         //为0表示空，可以作为新创建的文件的FAT项
 0968 8A01              movw R16,R20
 096A 42DD              xcall _ReadFAT
 096C 0030              cpi R16,0
 096E 0107              cpc R16,R17
 0970 11F4              brne L104
 0972           X25:
 0972                   .dbline 480
 0972           ;                       return i;
 0972 8A01              movw R16,R20
 0974 07C0              xjmp L99
 0976           L104:
 0976                   .dbline 481
 0976           ;       }
 0976           L101:
 0976                   .dbline 477
 0976 4F5F              subi R20,255  ; offset = 1
 0978 5F4F              sbci R21,255
 097A           L103:
 097A                   .dbline 477
 097A 4A15              cp R20,R10
 097C 5B05              cpc R21,R11
 097E A0F3              brlo L100
 0980           X26:
 0980                   .dbline 482
 0980           ;       return 0;
 0980 0027              clr R16
 0982 1127              clr R17
 0984                   .dbline -2
 0984           L99:
 0984                   .dbline 0 ; func end
 0984 0C940000          xjmp pop_xgset300C
 0988                   .dbsym r FAT_Count 10 i
 0988                   .dbsym r i 20 i
 0988                   .dbend
 0988                   .dbfunc e GetNext32FAT _GetNext32FAT fl
 0988           ;      FAT_Count -> y+4
 0988           ;              i -> y+0
                        .even
 0988           _GetNext32FAT::
 0988 0E940000          xcall push_xgsetF000
 098C 2897              sbiw R28,8
 098E                   .dbline -1
 098E                   .dbline 486
 098E           ; }
 098E           ; 
 098E           ; uint32 GetNext32FAT(void)
 098E           ; {
 098E                   .dbline 488
 098E           ;       uint32 FAT_Count, i;
 098E           ;       FAT_Count = BPB_FATSz32 * 128;                      //FAT表总项数，一个扇区是128个项，FAT32一个项是4个字节
 098E 40900900          lds R4,_BPB_FATSz32+2
 0992 50900A00          lds R5,_BPB_FATSz32+2+1
 0996 20900700          lds R2,_BPB_FATSz32
 099A 30900800          lds R3,_BPB_FATSz32+1
 099E 40E8              ldi R20,128
 09A0 50E0              ldi R21,0
 09A2 60E0              ldi R22,0
 09A4 70E0              ldi R23,0
 09A6 5A92              st -y,R5
 09A8 4A92              st -y,R4
 09AA 3A92              st -y,R3
 09AC 2A92              st -y,R2
 09AE 8A01              movw R16,R20
 09B0 9B01              movw R18,R22
 09B2 0E940000          xcall empy32u
 09B6 0C83              std y+4,R16
 09B8 1D83              std y+5,R17
 09BA 2E83              std y+6,R18
 09BC 3F83              std y+7,R19
 09BE                   .dbline 489
 09BE           ;       for(i = 0; i < FAT_Count; i++)
 09BE 80E0              ldi R24,0
 09C0 8883              std y+0,R24
 09C2 8983              std y+1,R24
 09C4 8A83              std y+2,R24
 09C6 8B83              std y+3,R24
 09C8 20C0              xjmp L110
 09CA           L107:
 09CA                   .dbline 490
 09CA           ;       {
 09CA                   .dbline 491
 09CA           ;               if(Read32FAT(i) == 0)                         //为0表示空，可以作为新创建的文件的FAT项
 09CA 0881              ldd R16,y+0
 09CC 1981              ldd R17,y+1
 09CE 2A81              ldd R18,y+2
 09D0 3B81              ldd R19,y+3
 09D2 39DD              xcall _Read32FAT
 09D4 8894              clc
 09D6 0023              tst R16
 09D8 1007              cpc R17,R16
 09DA 2007              cpc R18,R16
 09DC 3007              cpc R19,R16
 09DE 29F4              brne L111
 09E0           X27:
 09E0                   .dbline 492
 09E0           ;                       return i;
 09E0 0881              ldd R16,y+0
 09E2 1981              ldd R17,y+1
 09E4 2A81              ldd R18,y+2
 09E6 3B81              ldd R19,y+3
 09E8 21C0              xjmp L106
 09EA           L111:
 09EA                   .dbline 493
 09EA           ;       }
 09EA           L108:
 09EA                   .dbline 489
 09EA 41E0              ldi R20,1
 09EC 50E0              ldi R21,0
 09EE 60E0              ldi R22,0
 09F0 70E0              ldi R23,0
 09F2 2880              ldd R2,y+0
 09F4 3980              ldd R3,y+1
 09F6 4A80              ldd R4,y+2
 09F8 5B80              ldd R5,y+3
 09FA 240E              add R2,R20
 09FC 351E              adc R3,R21
 09FE 461E              adc R4,R22
 0A00 571E              adc R5,R23
 0A02 2882              std y+0,R2
 0A04 3982              std y+1,R3
 0A06 4A82              std y+2,R4
 0A08 5B82              std y+3,R5
 0A0A           L110:
 0A0A                   .dbline 489
 0A0A 2C80              ldd R2,y+4
 0A0C 3D80              ldd R3,y+5
 0A0E 4E80              ldd R4,y+6
 0A10 5F80              ldd R5,y+7
 0A12 6880              ldd R6,y+0
 0A14 7980              ldd R7,y+1
 0A16 8A80              ldd R8,y+2
 0A18 9B80              ldd R9,y+3
 0A1A 6214              cp R6,R2
 0A1C 7304              cpc R7,R3
 0A1E 8404              cpc R8,R4
 0A20 9504              cpc R9,R5
 0A22 98F2              brlo L107
 0A24           X28:
 0A24                   .dbline 494
 0A24           ;       return 0;
 0A24 00E0              ldi R16,0
 0A26 10E0              ldi R17,0
 0A28 20E0              ldi R18,0
 0A2A 30E0              ldi R19,0
 0A2C                   .dbline -2
 0A2C           L106:
 0A2C                   .dbline 0 ; func end
 0A2C 2896              adiw R28,8
 0A2E 0C940000          xjmp pop_xgsetF000
 0A32                   .dbsym l FAT_Count 4 l
 0A32                   .dbsym l i 0 l
 0A32                   .dbend
 0A32                   .dbfunc e ReadDIR _ReadDIR fV
 0A32           ;       DirStart -> y+2
 0A32           ;          Value -> R10,R11
 0A32           ;          Index -> R20,R21
                        .even
 0A32           _ReadDIR::
 0A32 0E940000          xcall push_xgset300C
 0A36 5901              movw R10,R18
 0A38 A801              movw R20,R16
 0A3A 2697              sbiw R28,6
 0A3C                   .dbline -1
 0A3C                   .dbline 504
 0A3C           ; }
 0A3C           ; 
 0A3C           ; /***********************************************************************
 0A3C           ; 函数功能：读取根目录的指定项
 0A3C           ; 操作内容：1、读取指定项的根目录数据   
 0A3C           ;           2、一个项的长度是32位，类似一个“文件”
 0A3C           ; ***********************************************************************/
 0A3C           ; 
 0A3C           ; void ReadDIR(uint16 Index, DIR* Value)
 0A3C           ; {
 0A3C                   .dbline 505
 0A3C           ;       uint32 DirStart = DirStartSec();
 0A3C 38DC              xcall _DirStartSec
 0A3E 0A83              std y+2,R16
 0A40 1B83              std y+3,R17
 0A42 2C83              std y+4,R18
 0A44 3D83              std y+5,R19
 0A46                   .dbline 506
 0A46           ;       ReadBlock(DirStart + Index / 16);
 0A46 1A01              movw R2,R20
 0A48 3694              lsr R3
 0A4A 2794              ror R2
 0A4C 3694              lsr R3
 0A4E 2794              ror R2
 0A50 3694              lsr R3
 0A52 2794              ror R2
 0A54 3694              lsr R3
 0A56 2794              ror R2
 0A58 4424              clr R4
 0A5A 5524              clr R5
 0A5C 0A81              ldd R16,y+2
 0A5E 1B81              ldd R17,y+3
 0A60 2C81              ldd R18,y+4
 0A62 3D81              ldd R19,y+5
 0A64 020D              add R16,R2
 0A66 131D              adc R17,R3
 0A68 241D              adc R18,R4
 0A6A 351D              adc R19,R5
 0A6C C9DA              xcall _ReadBlock
 0A6E                   .dbline 507
 0A6E           ;       CopyBytes(&BUFFER[(Index % 16) * 32], Value, 32);
 0A6E 80E2              ldi R24,32
 0A70 90E0              ldi R25,0
 0A72 9983              std y+1,R25
 0A74 8883              std y+0,R24
 0A76 CA01              movw R24,R20
 0A78 8F70              andi R24,15
 0A7A 9070              andi R25,0
 0A7C 00E2              ldi R16,32
 0A7E 10E0              ldi R17,0
 0A80 AF92              push R10
 0A82 BF92              push R11
 0A84 9C01              movw R18,R24
 0A86 0E940000          xcall empy16s
 0A8A 1801              movw R2,R16
 0A8C 3F91              pop R19
 0A8E 2F91              pop R18
 0A90 80E0              ldi R24,<_BUFFER
 0A92 90E0              ldi R25,>_BUFFER
 0A94 280E              add R2,R24
 0A96 391E              adc R3,R25
 0A98 8101              movw R16,R2
 0A9A D8DA              xcall _CopyBytes
 0A9C                   .dbline -2
 0A9C           L113:
 0A9C                   .dbline 0 ; func end
 0A9C 2696              adiw R28,6
 0A9E 0C940000          xjmp pop_xgset300C
 0AA2                   .dbsym l DirStart 2 l
 0AA2                   .dbsym r Value 10 pS[.6]
 0AA2                   .dbsym r Index 20 i
 0AA2                   .dbend
 0AA2                   .dbfunc e WriteDIR _WriteDIR fV
 0AA2           ;            LBA -> y+2
 0AA2           ;          Value -> R10,R11
 0AA2           ;          Index -> R20,R21
                        .even
 0AA2           _WriteDIR::
 0AA2 0E940000          xcall push_xgset300C
 0AA6 5901              movw R10,R18
 0AA8 A801              movw R20,R16
 0AAA 2697              sbiw R28,6
 0AAC                   .dbline -1
 0AAC                   .dbline 518
 0AAC           ; }
 0AAC           ; 
 0AAC           ; 
 0AAC           ; /***********************************************************************
 0AAC           ; 函数功能：写根目录的指定项
 0AAC           ; 操作内容：1、新建文件时，查找到可用根目录项后进行写入   
 0AAC           ;           2、一个项的长度是32位，类似一个“文件”
 0AAC           ; ***********************************************************************/
 0AAC           ; 
 0AAC           ; void WriteDIR(uint16 Index, DIR* Value)
 0AAC           ; {
 0AAC                   .dbline 519
 0AAC           ;       uint32 LBA = DirStartSec() + Index / 16;
 0AAC 00DC              xcall _DirStartSec
 0AAE 1A01              movw R2,R20
 0AB0 3694              lsr R3
 0AB2 2794              ror R2
 0AB4 3694              lsr R3
 0AB6 2794              ror R2
 0AB8 3694              lsr R3
 0ABA 2794              ror R2
 0ABC 3694              lsr R3
 0ABE 2794              ror R2
 0AC0 4424              clr R4
 0AC2 5524              clr R5
 0AC4 3801              movw R6,R16
 0AC6 4901              movw R8,R18
 0AC8 620C              add R6,R2
 0ACA 731C              adc R7,R3
 0ACC 841C              adc R8,R4
 0ACE 951C              adc R9,R5
 0AD0 6A82              std y+2,R6
 0AD2 7B82              std y+3,R7
 0AD4 8C82              std y+4,R8
 0AD6 9D82              std y+5,R9
 0AD8                   .dbline 520
 0AD8           ;       ReadBlock(LBA);
 0AD8 0A81              ldd R16,y+2
 0ADA 1B81              ldd R17,y+3
 0ADC 2C81              ldd R18,y+4
 0ADE 3D81              ldd R19,y+5
 0AE0 8FDA              xcall _ReadBlock
 0AE2                   .dbline 521
 0AE2           ;       CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
 0AE2 80E2              ldi R24,32
 0AE4 90E0              ldi R25,0
 0AE6 9983              std y+1,R25
 0AE8 8883              std y+0,R24
 0AEA 9A01              movw R18,R20
 0AEC 2F70              andi R18,15
 0AEE 3070              andi R19,0
 0AF0 00E2              ldi R16,32
 0AF2 10E0              ldi R17,0
 0AF4 0E940000          xcall empy16s
 0AF8 9801              movw R18,R16
 0AFA 80E0              ldi R24,<_BUFFER
 0AFC 90E0              ldi R25,>_BUFFER
 0AFE 280F              add R18,R24
 0B00 391F              adc R19,R25
 0B02 8501              movw R16,R10
 0B04 A3DA              xcall _CopyBytes
 0B06                   .dbline 522
 0B06           ;       WriteBlock(LBA);
 0B06 0A81              ldd R16,y+2
 0B08 1B81              ldd R17,y+3
 0B0A 2C81              ldd R18,y+4
 0B0C 3D81              ldd R19,y+5
 0B0E 8BDA              xcall _WriteBlock
 0B10                   .dbline -2
 0B10           L114:
 0B10                   .dbline 0 ; func end
 0B10 2696              adiw R28,6
 0B12 0C940000          xjmp pop_xgset300C
 0B16                   .dbsym l LBA 2 l
 0B16                   .dbsym r Value 10 pS[.6]
 0B16                   .dbsym r Index 20 i
 0B16                   .dbend
 0B16                   .dbfunc e WriteDIR32 _WriteDIR32 fV
 0B16           ;            LBA -> y+2
 0B16           ;          Value -> R10,R11
 0B16           ;          Index -> R20,R21
                        .even
 0B16           _WriteDIR32::
 0B16 0E940000          xcall push_xgset300C
 0B1A 5901              movw R10,R18
 0B1C A801              movw R20,R16
 0B1E 2697              sbiw R28,6
 0B20                   .dbline -1
 0B20                   .dbline 526
 0B20           ; }
 0B20           ; 
 0B20           ; void WriteDIR32(uint16 Index, DIR32* Value)
 0B20           ; {
 0B20                   .dbline 527
 0B20           ;       uint32 LBA = DirStartSec() + Index / 16;
 0B20 C6DB              xcall _DirStartSec
 0B22 1A01              movw R2,R20
 0B24 3694              lsr R3
 0B26 2794              ror R2
 0B28 3694              lsr R3
 0B2A 2794              ror R2
 0B2C 3694              lsr R3
 0B2E 2794              ror R2
 0B30 3694              lsr R3
 0B32 2794              ror R2
 0B34 4424              clr R4
 0B36 5524              clr R5
 0B38 3801              movw R6,R16
 0B3A 4901              movw R8,R18
 0B3C 620C              add R6,R2
 0B3E 731C              adc R7,R3
 0B40 841C              adc R8,R4
 0B42 951C              adc R9,R5
 0B44 6A82              std y+2,R6
 0B46 7B82              std y+3,R7
 0B48 8C82              std y+4,R8
 0B4A 9D82              std y+5,R9
 0B4C                   .dbline 528
 0B4C           ;       ReadBlock(LBA);
 0B4C 0A81              ldd R16,y+2
 0B4E 1B81              ldd R17,y+3
 0B50 2C81              ldd R18,y+4
 0B52 3D81              ldd R19,y+5
 0B54 55DA              xcall _ReadBlock
 0B56                   .dbline 529
 0B56           ;       CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
 0B56 80E2              ldi R24,32
 0B58 90E0              ldi R25,0
 0B5A 9983              std y+1,R25
 0B5C 8883              std y+0,R24
 0B5E 9A01              movw R18,R20
 0B60 2F70              andi R18,15
 0B62 3070              andi R19,0
 0B64 00E2              ldi R16,32
 0B66 10E0              ldi R17,0
 0B68 0E940000          xcall empy16s
 0B6C 9801              movw R18,R16
 0B6E 80E0              ldi R24,<_BUFFER
 0B70 90E0              ldi R25,>_BUFFER
 0B72 280F              add R18,R24
 0B74 391F              adc R19,R25
 0B76 8501              movw R16,R10
 0B78 69DA              xcall _CopyBytes
 0B7A                   .dbline 530
 0B7A           ;       WriteBlock(LBA);
 0B7A 0A81              ldd R16,y+2
 0B7C 1B81              ldd R17,y+3
 0B7E 2C81              ldd R18,y+4
 0B80 3D81              ldd R19,y+5
 0B82 51DA              xcall _WriteBlock
 0B84                   .dbline -2
 0B84           L115:
 0B84                   .dbline 0 ; func end
 0B84 2696              adiw R28,6
 0B86 0C940000          xjmp pop_xgset300C
 0B8A                   .dbsym l LBA 2 l
 0B8A                   .dbsym r Value 10 pS[.7]
 0B8A                   .dbsym r Index 20 i
 0B8A                   .dbend
 0B8A                   .dbfunc e WriteDirectoryDIR _WriteDirectoryDIR fV
 0B8A           ;            LBA -> y+2
 0B8A           ;          Value -> R10,R11
 0B8A           ;          Index -> R20,R21
 0B8A           ;         ClusID -> R12,R13
                        .even
 0B8A           _WriteDirectoryDIR::
 0B8A 0E940000          xcall push_xgset303C
 0B8E A901              movw R20,R18
 0B90 6801              movw R12,R16
 0B92 2697              sbiw R28,6
 0B94 AC84              ldd R10,y+12
 0B96 BD84              ldd R11,y+13
 0B98                   .dbline -1
 0B98                   .dbline 541
 0B98           ; }
 0B98           ; 
 0B98           ; /***********************************************************************
 0B98           ; 函数功能：写子目录的“.”和“..”项内容
 0B98           ; 操作内容：1、一共是2个32Bytes  
 0B98           ;           2、一个项的长度是32位，类似一个“文件”
 0B98           ;           3、起始地址是子目录的起始簇地址
 0B98           ; ***********************************************************************/
 0B98           ; 
 0B98           ; void WriteDirectoryDIR(uint16 ClusID, uint16 Index, DIR* Value)
 0B98           ; {
 0B98                   .dbline 542
 0B98           ;       uint32 LBA = ClusConvLBA(ClusID);
 0B98 8601              movw R16,R12
 0B9A 00DC              xcall _ClusConvLBA
 0B9C 0A83              std y+2,R16
 0B9E 1B83              std y+3,R17
 0BA0 2C83              std y+4,R18
 0BA2 3D83              std y+5,R19
 0BA4                   .dbline 543
 0BA4           ;       ReadBlock(LBA);
 0BA4 0A81              ldd R16,y+2
 0BA6 1B81              ldd R17,y+3
 0BA8 2C81              ldd R18,y+4
 0BAA 3D81              ldd R19,y+5
 0BAC 29DA              xcall _ReadBlock
 0BAE                   .dbline 544
 0BAE           ;       CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
 0BAE 80E2              ldi R24,32
 0BB0 90E0              ldi R25,0
 0BB2 9983              std y+1,R25
 0BB4 8883              std y+0,R24
 0BB6 9A01              movw R18,R20
 0BB8 2F70              andi R18,15
 0BBA 3070              andi R19,0
 0BBC 00E2              ldi R16,32
 0BBE 10E0              ldi R17,0
 0BC0 0E940000          xcall empy16s
 0BC4 9801              movw R18,R16
 0BC6 80E0              ldi R24,<_BUFFER
 0BC8 90E0              ldi R25,>_BUFFER
 0BCA 280F              add R18,R24
 0BCC 391F              adc R19,R25
 0BCE 8501              movw R16,R10
 0BD0 3DDA              xcall _CopyBytes
 0BD2                   .dbline 545
 0BD2           ;       WriteBlock(LBA);
 0BD2 0A81              ldd R16,y+2
 0BD4 1B81              ldd R17,y+3
 0BD6 2C81              ldd R18,y+4
 0BD8 3D81              ldd R19,y+5
 0BDA 25DA              xcall _WriteBlock
 0BDC                   .dbline -2
 0BDC           L116:
 0BDC                   .dbline 0 ; func end
 0BDC 2696              adiw R28,6
 0BDE 0C940000          xjmp pop_xgset303C
 0BE2                   .dbsym l LBA 2 l
 0BE2                   .dbsym r Value 10 pS[.6]
 0BE2                   .dbsym r Index 20 i
 0BE2                   .dbsym r ClusID 12 i
 0BE2                   .dbend
 0BE2                   .dbfunc e WriteDirectoryDIR32 _WriteDirectoryDIR32 fV
 0BE2           ;            LBA -> y+2
 0BE2           ;          Value -> R10,R11
 0BE2           ;          Index -> R20,R21
                        .even
 0BE2           _WriteDirectoryDIR32::
 0BE2 0E940000          xcall push_xgset300C
 0BE6 5901              movw R10,R18
 0BE8 A801              movw R20,R16
 0BEA 2697              sbiw R28,6
 0BEC                   .dbline -1
 0BEC                   .dbline 549
 0BEC           ; }
 0BEC           ; 
 0BEC           ; void WriteDirectoryDIR32(uint16 Index, DIR32* Value)
 0BEC           ; {
 0BEC                   .dbline 550
 0BEC           ;       uint32 LBA = DirStartSec() + Index / 16;
 0BEC 60DB              xcall _DirStartSec
 0BEE 1A01              movw R2,R20
 0BF0 3694              lsr R3
 0BF2 2794              ror R2
 0BF4 3694              lsr R3
 0BF6 2794              ror R2
 0BF8 3694              lsr R3
 0BFA 2794              ror R2
 0BFC 3694              lsr R3
 0BFE 2794              ror R2
 0C00 4424              clr R4
 0C02 5524              clr R5
 0C04 3801              movw R6,R16
 0C06 4901              movw R8,R18
 0C08 620C              add R6,R2
 0C0A 731C              adc R7,R3
 0C0C 841C              adc R8,R4
 0C0E 951C              adc R9,R5
 0C10 6A82              std y+2,R6
 0C12 7B82              std y+3,R7
 0C14 8C82              std y+4,R8
 0C16 9D82              std y+5,R9
 0C18                   .dbline 551
 0C18           ;       ReadBlock(LBA);
 0C18 0A81              ldd R16,y+2
 0C1A 1B81              ldd R17,y+3
 0C1C 2C81              ldd R18,y+4
 0C1E 3D81              ldd R19,y+5
 0C20 EFD9              xcall _ReadBlock
 0C22                   .dbline 552
 0C22           ;       CopyBytes(Value, &BUFFER[(Index % 16) * 32], 32);
 0C22 80E2              ldi R24,32
 0C24 90E0              ldi R25,0
 0C26 9983              std y+1,R25
 0C28 8883              std y+0,R24
 0C2A 9A01              movw R18,R20
 0C2C 2F70              andi R18,15
 0C2E 3070              andi R19,0
 0C30 00E2              ldi R16,32
 0C32 10E0              ldi R17,0
 0C34 0E940000          xcall empy16s
 0C38 9801              movw R18,R16
 0C3A 80E0              ldi R24,<_BUFFER
 0C3C 90E0              ldi R25,>_BUFFER
 0C3E 280F              add R18,R24
 0C40 391F              adc R19,R25
 0C42 8501              movw R16,R10
 0C44 03DA              xcall _CopyBytes
 0C46                   .dbline 553
 0C46           ;       WriteBlock(LBA);
 0C46 0A81              ldd R16,y+2
 0C48 1B81              ldd R17,y+3
 0C4A 2C81              ldd R18,y+4
 0C4C 3D81              ldd R19,y+5
 0C4E EBD9              xcall _WriteBlock
 0C50                   .dbline -2
 0C50           L117:
 0C50                   .dbline 0 ; func end
 0C50 2696              adiw R28,6
 0C52 0C940000          xjmp pop_xgset300C
 0C56                   .dbsym l LBA 2 l
 0C56                   .dbsym r Value 10 pS[.7]
 0C56                   .dbsym r Index 20 i
 0C56                   .dbend
 0C56                   .dbfunc e GetFileCrtDate _GetFileCrtDate fi
 0C56           ;    FileCrtDate -> R10,R11
 0C56           ;            Day -> R10
 0C56           ;          Month -> R12
 0C56           ;           Year -> R20,R21
                        .even
 0C56           _GetFileCrtDate::
 0C56 0E940000          xcall push_xgset303C
 0C5A C22E              mov R12,R18
 0C5C A801              movw R20,R16
 0C5E AE80              ldd R10,y+6
 0C60                   .dbline -1
 0C60                   .dbline 563
 0C60           ; }
 0C60           ; 
 0C60           ; /***********************************************************************
 0C60           ; 函数功能：文件修改日期转换为对应格式，如2010年07月01日转换为0x3CE1
 0C60           ; 操作内容：1、修改日期计算公式   
 0C60           ;           2、日期数据为2个字节长度
 0C60           ;           3、可配合实时时钟使用，这样可以得到实时的更改日期
 0C60           ; ***********************************************************************/
 0C60           ; uint16 GetFileCrtDate(uint16 Year, uint8 Month, uint8 Day)//年、月、日
 0C60           ; {
 0C60                   .dbline 565
 0C60           ;         uint16 FileCrtDate;
 0C60           ;         FileCrtDate=(Year-1980)*512+Month*32+Day;    // 0~4位为日(1~31)，5～8位为月(1~12)，9～15位为年(0~127)，相对于1980年1月1日的偏移量
 0C60 00E2              ldi R16,32
 0C62 1C2D              mov R17,R12
 0C64 0103              mulsu R16,R17
 0C66 1001              movw R2,R0
 0C68 9A01              movw R18,R20
 0C6A 2C5B              subi R18,188
 0C6C 3740              sbci R19,7
 0C6E 00E0              ldi R16,512
 0C70 12E0              ldi R17,2
 0C72 0E940000          xcall empy16s
 0C76 2801              movw R4,R16
 0C78 420C              add R4,R2
 0C7A 531C              adc R5,R3
 0C7C 2A2C              mov R2,R10
 0C7E 3324              clr R3
 0C80 420C              add R4,R2
 0C82 531C              adc R5,R3
 0C84 5201              movw R10,R4
 0C86                   .dbline 566
 0C86           ;         return FileCrtDate;
 0C86 8201              movw R16,R4
 0C88                   .dbline -2
 0C88           L118:
 0C88                   .dbline 0 ; func end
 0C88 0C940000          xjmp pop_xgset303C
 0C8C                   .dbsym r FileCrtDate 10 i
 0C8C                   .dbsym r Day 10 c
 0C8C                   .dbsym r Month 12 c
 0C8C                   .dbsym r Year 20 i
 0C8C                   .dbend
 0C8C                   .dbfunc e GetFileCrtTime _GetFileCrtTime fi
 0C8C           ;    FileCrtTime -> R10,R11
 0C8C           ;            Sec -> R10
 0C8C           ;            Min -> R14
 0C8C           ;           Hour -> R12
                        .even
 0C8C           _GetFileCrtTime::
 0C8C 0E940000          xcall push_xgset00FC
 0C90 E22E              mov R14,R18
 0C92 C02E              mov R12,R16
 0C94 AE80              ldd R10,y+6
 0C96                   .dbline -1
 0C96                   .dbline 577
 0C96           ; }
 0C96           ; 
 0C96           ; /***********************************************************************
 0C96           ; 函数功能：文件修改时间转换为对应格式
 0C96           ; 操作内容：1、修改时间计算公式   
 0C96           ;           2、时间数据为2个字节长度
 0C96           ;           3、可配合实时时钟使用，这样可以得到实时的更改时间
 0C96           ; ***********************************************************************/
 0C96           ; 
 0C96           ; uint16 GetFileCrtTime(uint8 Hour, uint8 Min, uint8 Sec)//时、分、秒
 0C96           ; {
 0C96                   .dbline 579
 0C96           ;         uint16 FileCrtTime;
 0C96           ;         FileCrtTime=Hour*2048+Min*32+Sec/2;       // 0~4位为秒，2秒为1个单位(0~29)，5～10位为分(0~59)，11～15位为时(0~23)
 0C96 00E2              ldi R16,32
 0C98 1E2D              mov R17,R14
 0C9A 0103              mulsu R16,R17
 0C9C 1001              movw R2,R0
 0C9E 2C2D              mov R18,R12
 0CA0 3327              clr R19
 0CA2 00E0              ldi R16,2048
 0CA4 18E0              ldi R17,8
 0CA6 0E940000          xcall empy16s
 0CAA 2801              movw R4,R16
 0CAC 420C              add R4,R2
 0CAE 531C              adc R5,R3
 0CB0 22E0              ldi R18,2
 0CB2 30E0              ldi R19,0
 0CB4 0A2D              mov R16,R10
 0CB6 1127              clr R17
 0CB8 0E940000          xcall div16s
 0CBC 400E              add R4,R16
 0CBE 511E              adc R5,R17
 0CC0 5201              movw R10,R4
 0CC2                   .dbline 580
 0CC2           ;         return FileCrtTime;
 0CC2 8201              movw R16,R4
 0CC4                   .dbline -2
 0CC4           L119:
 0CC4                   .dbline 0 ; func end
 0CC4 0C940000          xjmp pop_xgset00FC
 0CC8                   .dbsym r FileCrtTime 10 i
 0CC8                   .dbsym r Sec 10 c
 0CC8                   .dbsym r Min 14 c
 0CC8                   .dbsym r Hour 12 c
 0CC8                   .dbend
 0CC8                   .dbfunc e CreateDirectoryFile _CreateDirectoryFile fV
 0CC8           ;          Index -> R20,R21
 0CC8           ;     ClusIDFile -> R12,R13
 0CC8           ;    FileCrtTime -> y+36
 0CC8           ;    FileCrtDate -> y+34
 0CC8           ; FileCrtTimeTmp -> R20,R21
 0CC8           ; FileCrtDateTmp -> R20,R21
 0CC8           ;         ClusID -> R10,R11
 0CC8           ;        FileDir -> y+2
 0CC8           ;       FileName -> R14,R15
 0CC8           ;  DirectoryName -> R20,R21
                        .even
 0CC8           _CreateDirectoryFile::
 0CC8 0E940000          xcall push_xgset30FC
 0CCC 7901              movw R14,R18
 0CCE A801              movw R20,R16
 0CD0 A697              sbiw R28,38
 0CD2                   .dbline -1
 0CD2                   .dbline 594
 0CD2           ; }
 0CD2           ; 
 0CD2           ; 
 0CD2           ; 
 0CD2           ; /***********************************************************************
 0CD2           ; 函数功能：创建一个子空文件
 0CD2           ; 操作内容：1、文件名必须是数字或者大写字母，小于8位则用空格，扩展名为空格 
 0CD2           ;           2、文件大小事先不用设置,均为0;
 0CD2           ;           3、创建子文件的过程实际就是写子目录和FAT表，这里不写文件里的数据
 0CD2           ;           4、这里文件名为短名，8个字节，也就是8个字符
 0CD2           ;           5、子文件的目录写在其父目录的起始簇的空白目录项
 0CD2           ; ***********************************************************************/
 0CD2           ; void CreateDirectoryFile(uint8 DirectoryName[11], uint8 FileName[11])  //父文件夹名和新建文件名，短文件名
 0CD2           ; {
 0CD2                   .dbline 600
 0CD2           ;       uint16 ClusID,ClusIDFile,Index;
 0CD2           ;         DIR FileDir;
 0CD2           ;         uint16 FileCrtDateTmp,FileCrtTimeTmp;                 //双字节数据       
 0CD2           ;         uint8 FileCrtDate[2],FileCrtTime[2];                  //单字节时间日期数据
 0CD2           ;  
 0CD2           ;       FileDir.FilePosit.Start = GetNextFAT();               //得到一个空的FAT项，下面用来写对应文件的FAT表       
 0CD2 3CDE              xcall _GetNextFAT
 0CD4 1D8F              std y+29,R17
 0CD6 0C8F              std y+28,R16
 0CD8                   .dbline 601
 0CD8           ;       ClusID = FileDir.FilePosit.Start;                     //文件簇开始簇号，这是子文件的起始簇地址
 0CD8 5801              movw R10,R16
 0CDA                   .dbline 602
 0CDA           ;         ClusIDFile = FileDir.FilePosit.Start;                 //暂存下来，以备后面写入
 0CDA 6501              movw R12,R10
 0CDC                   .dbline 604
 0CDC           ; 
 0CDC           ;       WriteFAT(ClusID, 0xffff);                             //写对应文件的FAT表1，即FAT1,0xffff表示文件结束
 0CDC 2FEF              ldi R18,65535
 0CDE 3FEF              ldi R19,255
 0CE0 F7DB              xcall _WriteFAT
 0CE2                   .dbline 605
 0CE2           ;         WriteFAT2(ClusID, 0xffff);                            //写对应文件的FAT表2，即FAT2，0xffff表示文件结束     
 0CE2 2FEF              ldi R18,65535
 0CE4 3FEF              ldi R19,255
 0CE6 8501              movw R16,R10
 0CE8 84DC              xcall _WriteFAT2
 0CEA                   .dbline 607
 0CEA           ;                              
 0CEA           ;         Index = GetFileID(DirectoryName,&FileDir);            //搜索得到文件夹的属性，主要是获得起始簇位置，方便写文件的目录项
 0CEA 9E01              movw R18,R28
 0CEC 2E5F              subi R18,254  ; offset = 2
 0CEE 3F4F              sbci R19,255
 0CF0 8A01              movw R16,R20
 0CF2 7ADD              xcall _GetFileID
 0CF4 402F              mov R20,R16
 0CF6 5527              clr R21
 0CF8                   .dbline 608
 0CF8           ;         ReadDIR(Index, &FileDir);                             //读取父文件夹的目录项，只需要其起始簇
 0CF8 9E01              movw R18,R28
 0CFA 2E5F              subi R18,254  ; offset = 2
 0CFC 3F4F              sbci R19,255
 0CFE 8A01              movw R16,R20
 0D00 98DE              xcall _ReadDIR
 0D02                   .dbline 610
 0D02           ;         
 0D02           ;         FileCrtDateTmp=GetFileCrtDate(2010,7,2);              //文件修改日期2010年7月2日
 0D02 82E0              ldi R24,2
 0D04 8883              std y+0,R24
 0D06 27E0              ldi R18,7
 0D08 0AED              ldi R16,2010
 0D0A 17E0              ldi R17,7
 0D0C A4DF              xcall _GetFileCrtDate
 0D0E A801              movw R20,R16
 0D10                   .dbline 611
 0D10           ;         FileCrtDate[0]=(uint8)FileCrtDateTmp&0x00ff;          //低字节提取
 0D10 842F              mov R24,R20
 0D12 8F7F              andi R24,255
 0D14 8AA3              std y+34,R24
 0D16                   .dbline 612
 0D16           ;         FileCrtDate[1]=(uint8)(FileCrtDateTmp>>8);            //高字节提取       
 0D16 1A01              movw R2,R20
 0D18 232C              mov R2,R3
 0D1A 3324              clr R3
 0D1C 2BA2              std y+35,R2
 0D1E                   .dbline 613
 0D1E           ;         FileCrtTimeTmp=GetFileCrtTime(21,20,10);              //文件修改时间21点20分10秒
 0D1E 8AE0              ldi R24,10
 0D20 8883              std y+0,R24
 0D22 24E1              ldi R18,20
 0D24 05E1              ldi R16,21
 0D26 B2DF              xcall _GetFileCrtTime
 0D28 A801              movw R20,R16
 0D2A                   .dbline 614
 0D2A           ;         FileCrtTime[0]=(uint8)FileCrtTimeTmp&0x00ff;          //低字节提取
 0D2A 842F              mov R24,R20
 0D2C 8F7F              andi R24,255
 0D2E 8CA3              std y+36,R24
 0D30                   .dbline 615
 0D30           ;         FileCrtTime[1]=(uint8)(FileCrtTimeTmp>>8);            //高字节提取      
 0D30 1A01              movw R2,R20
 0D32 232C              mov R2,R3
 0D34 3324              clr R3
 0D36 2DA2              std y+37,R2
 0D38                   .dbline 617
 0D38           ;         
 0D38           ;         CopyBytes(FileName, &FileDir.FileName, 11);           //写入文件名
 0D38 8BE0              ldi R24,11
 0D3A 90E0              ldi R25,0
 0D3C 9983              std y+1,R25
 0D3E 8883              std y+0,R24
 0D40 9E01              movw R18,R28
 0D42 2E5F              subi R18,254  ; offset = 2
 0D44 3F4F              sbci R19,255
 0D46 8701              movw R16,R14
 0D48 81D9              xcall _CopyBytes
 0D4A                   .dbline 619
 0D4A           ;         
 0D4A           ;         CopyBytes(FileCrtDate, &FileDir.FileCrtDate, 2);       //写入文件创建日期
 0D4A 82E0              ldi R24,2
 0D4C 90E0              ldi R25,0
 0D4E 9983              std y+1,R25
 0D50 8883              std y+0,R24
 0D52 9E01              movw R18,R28
 0D54 2E5E              subi R18,238  ; offset = 18
 0D56 3F4F              sbci R19,255
 0D58 8E01              movw R16,R28
 0D5A 0E5D              subi R16,222  ; offset = 34
 0D5C 1F4F              sbci R17,255
 0D5E 76D9              xcall _CopyBytes
 0D60                   .dbline 620
 0D60           ;         CopyBytes(FileCrtTime, &FileDir.FileCrtTime, 2);       //写入文件创建时间
 0D60 82E0              ldi R24,2
 0D62 90E0              ldi R25,0
 0D64 9983              std y+1,R25
 0D66 8883              std y+0,R24
 0D68 9E01              movw R18,R28
 0D6A 205F              subi R18,240  ; offset = 16
 0D6C 3F4F              sbci R19,255
 0D6E 8E01              movw R16,R28
 0D70 0C5D              subi R16,220  ; offset = 36
 0D72 1F4F              sbci R17,255
 0D74 6BD9              xcall _CopyBytes
 0D76                   .dbline 622
 0D76           ;         
 0D76           ;         FileDir.FileAttrib = 0x20;                             //文件属性填充，0x10为子目录属性，即文件夹       
 0D76 80E2              ldi R24,32
 0D78 8D87              std y+13,R24
 0D7A                   .dbline 624
 0D7A           ;        
 0D7A           ;         ClusID = FileDir.FilePosit.Start;                      //父文件夹的开始簇号，子文件目录项写入这个簇中
 0D7A AC8C              ldd R10,y+28
 0D7C BD8C              ldd R11,y+29
 0D7E                   .dbline 625
 0D7E           ;         FileDir.FilePosit.Start=ClusIDFile;                    //新建文件的起始簇
 0D7E DD8E              std y+29,R13
 0D80 CC8E              std y+28,R12
 0D82                   .dbline 626
 0D82           ;         WriteDirectoryDIR(ClusID,GetDirectoryEmptyDIR(ClusID),&FileDir);//需要扫描父目录的起始簇中空白可以写入子目录的项
 0D82 8501              movw R16,R10
 0D84 F3DC              xcall _GetDirectoryEmptyDIR
 0D86 6801              movw R12,R16
 0D88 CE01              movw R24,R28
 0D8A 0296              adiw R24,2
 0D8C 9983              std y+1,R25
 0D8E 8883              std y+0,R24
 0D90 9601              movw R18,R12
 0D92 8501              movw R16,R10
 0D94 FADE              xcall _WriteDirectoryDIR
 0D96                   .dbline -2
 0D96           L120:
 0D96                   .dbline 0 ; func end
 0D96 A696              adiw R28,38
 0D98 0C940000          xjmp pop_xgset30FC
 0D9C                   .dbsym r Index 20 i
 0D9C                   .dbsym r ClusIDFile 12 i
 0D9C                   .dbsym l FileCrtTime 36 A[2:2]c
 0D9C                   .dbsym l FileCrtDate 34 A[2:2]c
 0D9C                   .dbsym r FileCrtTimeTmp 20 i
 0D9C                   .dbsym r FileCrtDateTmp 20 i
 0D9C                   .dbsym r ClusID 10 i
 0D9C                   .dbsym l FileDir 2 S[.6]
 0D9C                   .dbsym r FileName 14 pc
 0D9C                   .dbsym r DirectoryName 20 pc
 0D9C                   .dbend
                        .area data(ram, con, rel)
 0004                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0004           L132:
 0004                   .blkb 11
                        .area idata
 0004 2E20202020202020202020    .byte 46,32,32,32,32,32,32,32,32,32,32
                        .area data(ram, con, rel)
 000F                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 000F           L133:
 000F                   .blkb 11
                        .area idata
 000F 2E2E202020202020202020    .byte 46,46,32,32,32,32,32,32,32,32,32
                        .area data(ram, con, rel)
 001A                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
                        .area text(rom, con, rel)
 0D9C                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0D9C                   .dbfunc e CreateFile _CreateFile fV
 0D9C           ; DirectoryDIRFileName1 -> y+49
 0D9C           ; DirectoryDIRFileName0 -> y+38
 0D9C           ;    FileCrtTime -> y+36
 0D9C           ;    FileCrtDate -> y+34
 0D9C           ; FileCrtTimeTmp -> R14,R15
 0D9C           ; FileCrtDateTmp -> R14,R15
 0D9C           ;         ClusID -> R10,R11
 0D9C           ;        FileDir -> y+2
 0D9C           ;     FileAttrib -> R10
 0D9C           ;       FileName -> R12,R13
                        .even
 0D9C           _CreateFile::
 0D9C 0E940000          xcall push_xgset00FC
 0DA0 A22E              mov R10,R18
 0DA2 6801              movw R12,R16
 0DA4 EC97              sbiw R28,60
 0DA6                   .dbline -1
 0DA6                   .dbline 643
 0DA6           ;         
 0DA6           ; }
 0DA6           ; 
 0DA6           ; 
 0DA6           ; /***********************************************************************
 0DA6           ; 函数功能：在根目录创建一个空文件或文件夹
 0DA6           ; 操作内容：1、FileName文件名必须是数字或者大写字母，扩展名也是如此   
 0DA6           ;           2、文件大小事先不用设置,均为0;
 0DA6           ;           3、创建文件的过程实际就是写根目录和FAT表，这里不写文件里的数据
 0DA6           ;           4、这里文件名为短名，8个字节，也就是8个字符
 0DA6           ;           5、第二个参数为属性，0x10为文件夹，0x20为文件
 0DA6           ;           6、该文件夹只建立于根目录下，可以更改
 0DA6           ;           7、根目录，没有"."和".."项，如果是子目录，也就是文件夹，则有
 0DA6           ; ***********************************************************************/
 0DA6           ; 
 0DA6           ; void CreateFile(uint8 FileName[11], uint8 FileAttrib)
 0DA6           ; {
 0DA6                   .dbline 646
 0DA6           ;       uint16 ClusID;
 0DA6           ;         DIR FileDir;
 0DA6           ;         uint8 DirectoryDIRFileName0[11]=".          ";
 0DA6 80E0              ldi R24,<L132
 0DA8 90E0              ldi R25,>L132
 0DAA FE01              movw R30,R28
 0DAC B696              adiw R30,38
 0DAE 0BE0              ldi R16,11
 0DB0 10E0              ldi R17,0
 0DB2 FA93              st -y,R31
 0DB4 EA93              st -y,R30
 0DB6 9A93              st -y,R25
 0DB8 8A93              st -y,R24
 0DBA 0E940000          xcall asgnblk
 0DBE                   .dbline 647
 0DBE           ;         uint8 DirectoryDIRFileName1[11]="..         ";
 0DBE 80E0              ldi R24,<L133
 0DC0 90E0              ldi R25,>L133
 0DC2 FE01              movw R30,R28
 0DC4 F196              adiw R30,49
 0DC6 0BE0              ldi R16,11
 0DC8 10E0              ldi R17,0
 0DCA FA93              st -y,R31
 0DCC EA93              st -y,R30
 0DCE 9A93              st -y,R25
 0DD0 8A93              st -y,R24
 0DD2 0E940000          xcall asgnblk
 0DD6                   .dbline 652
 0DD6           ;         
 0DD6           ;         uint16 FileCrtDateTmp,FileCrtTimeTmp;                 //双字节数据       
 0DD6           ;         uint8 FileCrtDate[2],FileCrtTime[2];                  //单字节时间日期数据
 0DD6           ;         
 0DD6           ;         FileCrtDateTmp=GetFileCrtDate(2012,5,2);              //文件修改日期2010年7月2日
 0DD6 82E0              ldi R24,2
 0DD8 8883              std y+0,R24
 0DDA 25E0              ldi R18,5
 0DDC 0CED              ldi R16,2012
 0DDE 17E0              ldi R17,7
 0DE0 3ADF              xcall _GetFileCrtDate
 0DE2 7801              movw R14,R16
 0DE4                   .dbline 653
 0DE4           ;         FileCrtDate[0]=(uint8)FileCrtDateTmp&0x00ff;          //低字节提取
 0DE4 8E2D              mov R24,R14
 0DE6 8F7F              andi R24,255
 0DE8 8AA3              std y+34,R24
 0DEA                   .dbline 654
 0DEA           ;         FileCrtDate[1]=(uint8)(FileCrtDateTmp>>8);            //高字节提取
 0DEA 1701              movw R2,R14
 0DEC 232C              mov R2,R3
 0DEE 3324              clr R3
 0DF0 2BA2              std y+35,R2
 0DF2                   .dbline 656
 0DF2           ;         
 0DF2           ;         FileCrtTimeTmp=GetFileCrtTime(21,20,10);              //文件修改时间21点20分10秒
 0DF2 8AE0              ldi R24,10
 0DF4 8883              std y+0,R24
 0DF6 24E1              ldi R18,20
 0DF8 05E1              ldi R16,21
 0DFA 48DF              xcall _GetFileCrtTime
 0DFC 7801              movw R14,R16
 0DFE                   .dbline 657
 0DFE           ;         FileCrtTime[0]=(uint8)FileCrtTimeTmp&0x00ff;          //低字节提取
 0DFE 8E2D              mov R24,R14
 0E00 8F7F              andi R24,255
 0E02 8CA3              std y+36,R24
 0E04                   .dbline 658
 0E04           ;         FileCrtTime[1]=(uint8)(FileCrtTimeTmp>>8);            //高字节提取
 0E04 1701              movw R2,R14
 0E06 232C              mov R2,R3
 0E08 3324              clr R3
 0E0A 2DA2              std y+37,R2
 0E0C                   .dbline 662
 0E0C           ;         
 0E0C           ;         
 0E0C           ;       //ClusNum = Size / (BPB_SecPerClus * 512) + 1;
 0E0C           ;       EmptyBytes(&FileDir, sizeof(DIR));                          //先全部填充0
 0E0C 20E2              ldi R18,32
 0E0E 30E0              ldi R19,0
 0E10 8E01              movw R16,R28
 0E12 0E5F              subi R16,254  ; offset = 2
 0E14 1F4F              sbci R17,255
 0E16 63D9              xcall _EmptyBytes
 0E18                   .dbline 663
 0E18           ;         CopyBytes(FileName, &FileDir.FileName, 11);                 //写入文件名
 0E18 8BE0              ldi R24,11
 0E1A 90E0              ldi R25,0
 0E1C 9983              std y+1,R25
 0E1E 8883              std y+0,R24
 0E20 9E01              movw R18,R28
 0E22 2E5F              subi R18,254  ; offset = 2
 0E24 3F4F              sbci R19,255
 0E26 8601              movw R16,R12
 0E28 11D9              xcall _CopyBytes
 0E2A                   .dbline 665
 0E2A           ;         
 0E2A           ;         FileDir.FileAttrib = FileAttrib;                            //文件属性填充，0x10则为文件夹，0x20则为文件
 0E2A AD86              std y+13,R10
 0E2C                   .dbline 667
 0E2C           ;         
 0E2C           ;         CopyBytes(FileCrtDate, &FileDir.FileCrtDate, 2);            //写入文件创建日期
 0E2C 82E0              ldi R24,2
 0E2E 90E0              ldi R25,0
 0E30 9983              std y+1,R25
 0E32 8883              std y+0,R24
 0E34 9E01              movw R18,R28
 0E36 2E5E              subi R18,238  ; offset = 18
 0E38 3F4F              sbci R19,255
 0E3A 8E01              movw R16,R28
 0E3C 0E5D              subi R16,222  ; offset = 34
 0E3E 1F4F              sbci R17,255
 0E40 05D9              xcall _CopyBytes
 0E42                   .dbline 668
 0E42           ;         CopyBytes(FileCrtTime, &FileDir.FileCrtTime, 2);            //写入文件创建时间
 0E42 82E0              ldi R24,2
 0E44 90E0              ldi R25,0
 0E46 9983              std y+1,R25
 0E48 8883              std y+0,R24
 0E4A 9E01              movw R18,R28
 0E4C 205F              subi R18,240  ; offset = 16
 0E4E 3F4F              sbci R19,255
 0E50 8E01              movw R16,R28
 0E52 0C5D              subi R16,220  ; offset = 36
 0E54 1F4F              sbci R17,255
 0E56 FAD8              xcall _CopyBytes
 0E58                   .dbline 671
 0E58           ;         
 0E58           ;       //FileDir.FilePosit.Size = 0;
 0E58           ;       FileDir.FilePosit.Start = GetNextFAT();                     //得到一个空的FAT项，下面用来写对应文件的FAT表
 0E58 79DD              xcall _GetNextFAT
 0E5A 5801              movw R10,R16
 0E5C BD8E              std y+29,R11
 0E5E AC8E              std y+28,R10
 0E60                   .dbline 673
 0E60           ;         
 0E60           ;       ClusID = FileDir.FilePosit.Start;                           //文件簇开始簇号
 0E60                   .dbline 675
 0E60           ; 
 0E60           ;       WriteFAT(ClusID, 0xffff);                                   //写对应文件的FAT表1，即FAT1,0xffff表示文件结束
 0E60 2FEF              ldi R18,65535
 0E62 3FEF              ldi R19,255
 0E64 35DB              xcall _WriteFAT
 0E66                   .dbline 676
 0E66           ;         WriteFAT2(ClusID, 0xffff);                                  //写对应文件的FAT表2，即FAT2，0xffff表示文件结束
 0E66 2FEF              ldi R18,65535
 0E68 3FEF              ldi R19,255
 0E6A 8501              movw R16,R10
 0E6C C2DB              xcall _WriteFAT2
 0E6E                   .dbline 677
 0E6E           ;       WriteDIR(GetEmptyDIR(), &FileDir);                          //写根目录指定项，首先搜索可以使用项，再写入
 0E6E 44DC              xcall _GetEmptyDIR
 0E70 6801              movw R12,R16
 0E72 9E01              movw R18,R28
 0E74 2E5F              subi R18,254  ; offset = 2
 0E76 3F4F              sbci R19,255
 0E78 14DE              xcall _WriteDIR
 0E7A                   .dbline 680
 0E7A           ;         
 0E7A           ;     
 0E7A           ;   if(FileDir.FileAttrib==0x10)                                      //如果是建立文件夹，则写“.”项和“..项”
 0E7A 8D85              ldd R24,y+13
 0E7C 8031              cpi R24,16
 0E7E 51F5              brne L141
 0E80           X29:
 0E80                   .dbline 681
 0E80           ;      {
 0E80                   .dbline 682
 0E80           ;         CopyBytes(DirectoryDIRFileName0, &FileDir.FileName, 11);    //写入".项目录内容"，该项为自身目录项内容
 0E80 8BE0              ldi R24,11
 0E82 90E0              ldi R25,0
 0E84 9983              std y+1,R25
 0E86 8883              std y+0,R24
 0E88 9E01              movw R18,R28
 0E8A 2E5F              subi R18,254  ; offset = 2
 0E8C 3F4F              sbci R19,255
 0E8E 8E01              movw R16,R28
 0E90 0A5D              subi R16,218  ; offset = 38
 0E92 1F4F              sbci R17,255
 0E94 DBD8              xcall _CopyBytes
 0E96                   .dbline 683
 0E96           ;         WriteDirectoryDIR(ClusID,0,&FileDir);                       //写入，地址为新建目录的起始簇地址的前2个32Bytes，这项为第0个
 0E96 CE01              movw R24,R28
 0E98 0296              adiw R24,2
 0E9A 9983              std y+1,R25
 0E9C 8883              std y+0,R24
 0E9E 2227              clr R18
 0EA0 3327              clr R19
 0EA2 8501              movw R16,R10
 0EA4 72DE              xcall _WriteDirectoryDIR
 0EA6                   .dbline 685
 0EA6           ;         
 0EA6           ;         CopyBytes(DirectoryDIRFileName1, &FileDir.FileName, 11);    //写入"..项目录内容"，该项为与父目录关系，起始簇地址为父目录的起始簇地址
 0EA6 8BE0              ldi R24,11
 0EA8 90E0              ldi R25,0
 0EAA 9983              std y+1,R25
 0EAC 8883              std y+0,R24
 0EAE 9E01              movw R18,R28
 0EB0 2E5F              subi R18,254  ; offset = 2
 0EB2 3F4F              sbci R19,255
 0EB4 8E01              movw R16,R28
 0EB6 0F5C              subi R16,207  ; offset = 49
 0EB8 1F4F              sbci R17,255
 0EBA C8D8              xcall _CopyBytes
 0EBC                   .dbline 686
 0EBC           ;         FileDir.FilePosit.Start=0x0000;                             //文件夹位于根目录下，可更改为文件夹的父文件夹起始簇地址
 0EBC 2224              clr R2
 0EBE 3324              clr R3
 0EC0 3D8E              std y+29,R3
 0EC2 2C8E              std y+28,R2
 0EC4                   .dbline 687
 0EC4           ;         WriteDirectoryDIR(ClusID,1,&FileDir);                       //写入，地址为新建目录的起始簇地址的前2个32Bytes，这项为第1个
 0EC4 CE01              movw R24,R28
 0EC6 0296              adiw R24,2
 0EC8 9983              std y+1,R25
 0ECA 8883              std y+0,R24
 0ECC 21E0              ldi R18,1
 0ECE 30E0              ldi R19,0
 0ED0 8501              movw R16,R10
 0ED2 5BDE              xcall _WriteDirectoryDIR
 0ED4                   .dbline 688
 0ED4           ;      }
 0ED4           L141:
 0ED4                   .dbline -2
 0ED4           L131:
 0ED4                   .dbline 0 ; func end
 0ED4 EC96              adiw R28,60
 0ED6 0C940000          xjmp pop_xgset00FC
 0EDA                   .dbsym l DirectoryDIRFileName1 49 A[11:11]c
 0EDA                   .dbsym l DirectoryDIRFileName0 38 A[11:11]c
 0EDA                   .dbsym l FileCrtTime 36 A[2:2]c
 0EDA                   .dbsym l FileCrtDate 34 A[2:2]c
 0EDA                   .dbsym r FileCrtTimeTmp 14 i
 0EDA                   .dbsym r FileCrtDateTmp 14 i
 0EDA                   .dbsym r ClusID 10 i
 0EDA                   .dbsym l FileDir 2 S[.6]
 0EDA                   .dbsym r FileAttrib 10 c
 0EDA                   .dbsym r FileName 12 pc
 0EDA                   .dbend
 0EDA                   .dbfunc e FAT32CreateFile _FAT32CreateFile fV
 0EDA           ;     FileWrTime -> y+40
 0EDA           ;     FileWrData -> y+38
 0EDA           ;  FileWrTimeTmp -> R12,R13
 0EDA           ;  FileWrDataTmp -> R12,R13
 0EDA           ;         ClusID -> y+34
 0EDA           ;        FileDir -> y+4
 0EDA           ;       FileName -> R10,R11
                        .even
 0EDA           _FAT32CreateFile::
 0EDA 0E940000          xcall push_xgset003C
 0EDE 5801              movw R10,R16
 0EE0 AA97              sbiw R28,42
 0EE2                   .dbline -1
 0EE2                   .dbline 692
 0EE2           ; }
 0EE2           ; 
 0EE2           ; void FAT32CreateFile(uint8 FileName[11])
 0EE2           ; {
 0EE2                   .dbline 698
 0EE2           ;       uint32 ClusID;
 0EE2           ;         DIR32 FileDir;
 0EE2           ;         uint16 FileWrDataTmp,FileWrTimeTmp;                         //双字节数据       
 0EE2           ;         uint8 FileWrData[2],FileWrTime[2];                          //单字节时间日期数据
 0EE2           ;         
 0EE2           ;         FileWrDataTmp=GetFileCrtDate(2012,5,2);                     //文件修改日期2010年7月2日
 0EE2 82E0              ldi R24,2
 0EE4 8883              std y+0,R24
 0EE6 25E0              ldi R18,5
 0EE8 0CED              ldi R16,2012
 0EEA 17E0              ldi R17,7
 0EEC B4DE              xcall _GetFileCrtDate
 0EEE 6801              movw R12,R16
 0EF0                   .dbline 699
 0EF0           ;         FileWrData[0]=(uint8)FileWrDataTmp&0x00ff;                  //低字节提取
 0EF0 8C2D              mov R24,R12
 0EF2 8F7F              andi R24,255
 0EF4 8EA3              std y+38,R24
 0EF6                   .dbline 700
 0EF6           ;         FileWrData[1]=(uint8)(FileWrDataTmp>>8);                    //高字节提取
 0EF6 1601              movw R2,R12
 0EF8 232C              mov R2,R3
 0EFA 3324              clr R3
 0EFC 2FA2              std y+39,R2
 0EFE                   .dbline 702
 0EFE           ;         
 0EFE           ;         FileWrTimeTmp=GetFileCrtTime(21,20,10);                     //文件修改时间21点20分10秒
 0EFE 8AE0              ldi R24,10
 0F00 8883              std y+0,R24
 0F02 24E1              ldi R18,20
 0F04 05E1              ldi R16,21
 0F06 C2DE              xcall _GetFileCrtTime
 0F08 6801              movw R12,R16
 0F0A                   .dbline 703
 0F0A           ;         FileWrTime[0]=(uint8)FileWrTimeTmp&0x00ff;                  //低字节提取
 0F0A 8C2D              mov R24,R12
 0F0C 8F7F              andi R24,255
 0F0E 88A7              std y+40,R24
 0F10                   .dbline 704
 0F10           ;         FileWrTime[1]=(uint8)(FileWrTimeTmp>>8);                    //高字节提取
 0F10 1601              movw R2,R12
 0F12 232C              mov R2,R3
 0F14 3324              clr R3
 0F16 29A6              std y+41,R2
 0F18                   .dbline 707
 0F18           ;                 
 0F18           ;       //ClusNum = Size / (BPB_SecPerClus * 512) + 1;
 0F18           ;       EmptyBytes(&FileDir, sizeof(DIR));                          //先全部填充0
 0F18 20E2              ldi R18,32
 0F1A 30E0              ldi R19,0
 0F1C 8E01              movw R16,R28
 0F1E 0C5F              subi R16,252  ; offset = 4
 0F20 1F4F              sbci R17,255
 0F22 DDD8              xcall _EmptyBytes
 0F24                   .dbline 708
 0F24           ;         CopyBytes(FileName, &FileDir.FileName, 11);                 //写入文件名
 0F24 8BE0              ldi R24,11
 0F26 90E0              ldi R25,0
 0F28 9983              std y+1,R25
 0F2A 8883              std y+0,R24
 0F2C 9E01              movw R18,R28
 0F2E 2C5F              subi R18,252  ; offset = 4
 0F30 3F4F              sbci R19,255
 0F32 8501              movw R16,R10
 0F34 8BD8              xcall _CopyBytes
 0F36                   .dbline 710
 0F36           ;         
 0F36           ;         FileDir.FileAttrib = 0x20;                                  //文件属性填充
 0F36 80E2              ldi R24,32
 0F38 8F87              std y+15,R24
 0F3A                   .dbline 712
 0F3A           ;         
 0F3A           ;         CopyBytes(FileWrData, &FileDir.DIR_WrtDate, 2);             //写入文件修改日期
 0F3A 82E0              ldi R24,2
 0F3C 90E0              ldi R25,0
 0F3E 9983              std y+1,R25
 0F40 8883              std y+0,R24
 0F42 9E01              movw R18,R28
 0F44 245E              subi R18,228  ; offset = 28
 0F46 3F4F              sbci R19,255
 0F48 8E01              movw R16,R28
 0F4A 0A5D              subi R16,218  ; offset = 38
 0F4C 1F4F              sbci R17,255
 0F4E 7ED8              xcall _CopyBytes
 0F50                   .dbline 713
 0F50           ;         CopyBytes(FileWrTime, &FileDir.DIR_WrtTime, 2);             //写入文件修改时间
 0F50 82E0              ldi R24,2
 0F52 90E0              ldi R25,0
 0F54 9983              std y+1,R25
 0F56 8883              std y+0,R24
 0F58 9E01              movw R18,R28
 0F5A 265E              subi R18,230  ; offset = 26
 0F5C 3F4F              sbci R19,255
 0F5E 8E01              movw R16,R28
 0F60 085D              subi R16,216  ; offset = 40
 0F62 1F4F              sbci R17,255
 0F64 73D8              xcall _CopyBytes
 0F66                   .dbline 716
 0F66           ;         
 0F66           ;       //FileDir.FilePosit.Size = 0;
 0F66           ;       ClusID = GetNext32FAT();                                    //得到一个空的FAT项，下面用来写对应文件的FAT表
 0F66 10DD              xcall _GetNext32FAT
 0F68 0AA3              std y+34,R16
 0F6A 1BA3              std y+35,R17
 0F6C 2CA3              std y+36,R18
 0F6E 3DA3              std y+37,R19
 0F70                   .dbline 718
 0F70           ;         
 0F70           ;       FileDir.DIR_FstClusHI=(uint16)(ClusID>>16);                 //文件开始簇高字
 0F70 2AA0              ldd R2,y+34
 0F72 3BA0              ldd R3,y+35
 0F74 4CA0              ldd R4,y+36
 0F76 5DA0              ldd R5,y+37
 0F78 1201              movw R2,R4
 0F7A 398E              std y+25,R3
 0F7C 288E              std y+24,R2
 0F7E                   .dbline 719
 0F7E           ;         FileDir.DIR_FstClusLo=(uint16)ClusID&0x0000ffff;            //文件簇开始簇号低字
 0F7E 2AA0              ldd R2,y+34
 0F80 3BA0              ldd R3,y+35
 0F82 3F8E              std y+31,R3
 0F84 2E8E              std y+30,R2
 0F86                   .dbline 721
 0F86           ; 
 0F86           ;       Write32FAT(ClusID, 0xffffffff);                             //写对应文件的FAT表1，即FAT1,0x0fffffff表示文件结束
 0F86 8FEF              ldi R24,255
 0F88 8883              std y+0,R24
 0F8A 8983              std y+1,R24
 0F8C 8A83              std y+2,R24
 0F8E 8B83              std y+3,R24
 0F90 0AA1              ldd R16,y+34
 0F92 1BA1              ldd R17,y+35
 0F94 2CA1              ldd R18,y+36
 0F96 3DA1              ldd R19,y+37
 0F98 D6DA              xcall _Write32FAT
 0F9A                   .dbline 722
 0F9A           ;         Write32FAT2(ClusID, 0xffffffff);                            //写对应文件的FAT表2，即FAT2,0x0fffffff表示文件结束
 0F9A 8FEF              ldi R24,255
 0F9C 8883              std y+0,R24
 0F9E 8983              std y+1,R24
 0FA0 8A83              std y+2,R24
 0FA2 8B83              std y+3,R24
 0FA4 0AA1              ldd R16,y+34
 0FA6 1BA1              ldd R17,y+35
 0FA8 2CA1              ldd R18,y+36
 0FAA 3DA1              ldd R19,y+37
 0FAC 54DB              xcall _Write32FAT2
 0FAE                   .dbline 723
 0FAE           ;       WriteDIR32(GetEmptyDIR(), &FileDir);                        //写根目录指定项，首先搜索可以使用项，再写入
 0FAE A4DB              xcall _GetEmptyDIR
 0FB0 5801              movw R10,R16
 0FB2 9E01              movw R18,R28
 0FB4 2C5F              subi R18,252  ; offset = 4
 0FB6 3F4F              sbci R19,255
 0FB8 AEDD              xcall _WriteDIR32
 0FBA                   .dbline -2
 0FBA           L145:
 0FBA                   .dbline 0 ; func end
 0FBA AA96              adiw R28,42
 0FBC 0C940000          xjmp pop_xgset003C
 0FC0                   .dbsym l FileWrTime 40 A[2:2]c
 0FC0                   .dbsym l FileWrData 38 A[2:2]c
 0FC0                   .dbsym r FileWrTimeTmp 12 i
 0FC0                   .dbsym r FileWrDataTmp 12 i
 0FC0                   .dbsym l ClusID 34 l
 0FC0                   .dbsym l FileDir 4 S[.7]
 0FC0                   .dbsym r FileName 10 pc
 0FC0                   .dbend
 0FC0                   .dbfunc e DelFile _DelFile fV
 0FC0           ;          Index -> R10,R11
 0FC0           ;         ClusID -> R12,R13
 0FC0           ;        FileDir -> y+0
 0FC0           ;           Name -> R10,R11
                        .even
 0FC0           _DelFile::
 0FC0 0E940000          xcall push_xgset003C
 0FC4 5801              movw R10,R16
 0FC6 A097              sbiw R28,32
 0FC8                   .dbline -1
 0FC8                   .dbline 735
 0FC8           ; }
 0FC8           ; 
 0FC8           ; /***********************************************************************
 0FC8           ; 函数功能：删除文件
 0FC8           ; 操作内容：1、FileName文件名必须是数字或者大写字母，扩展名也是如此   
 0FC8           ;           2、先搜索文件目录项及位置，采取比较匹配的方法
 0FC8           ;           3、文件名的第一个字节写0xE5，表示此目录下无文件
 0FC8           ;           4、清FAT表，写根目录
 0FC8           ; ***********************************************************************/
 0FC8           ; 
 0FC8           ; void DelFile(uint8 Name[11])
 0FC8           ; {
 0FC8                   .dbline 738
 0FC8           ;       DIR FileDir;
 0FC8           ;       uint16 ClusID,Index;
 0FC8           ;       Index = GetFileID(Name,&FileDir);                      //搜索得到文件所在根目录项位置
 0FC8 9E01              movw R18,R28
 0FCA 8501              movw R16,R10
 0FCC 0DDC              xcall _GetFileID
 0FCE A02E              mov R10,R16
 0FD0 BB24              clr R11
 0FD2                   .dbline 739
 0FD2           ;       FileDir.FileName.NAME[0] = 0xE5;                       //删除根目录下文件
 0FD2 85EE              ldi R24,229
 0FD4 8883              std y+0,R24
 0FD6                   .dbline 740
 0FD6           ;       ClusID = FileDir.FilePosit.Start;                      //文件所在的簇号
 0FD6 CA8C              ldd R12,y+26
 0FD8 DB8C              ldd R13,y+27
 0FDA                   .dbline 741
 0FDA           ;       WriteFAT(ClusID,0x0000);                               //清空对应的FAT表FAT1
 0FDA 2227              clr R18
 0FDC 3327              clr R19
 0FDE 8601              movw R16,R12
 0FE0 77DA              xcall _WriteFAT
 0FE2                   .dbline 742
 0FE2           ;       WriteFAT2(ClusID,0x0000);                              //使FAT2和FAT1保持一致
 0FE2 2227              clr R18
 0FE4 3327              clr R19
 0FE6 8601              movw R16,R12
 0FE8 04DB              xcall _WriteFAT2
 0FEA                   .dbline 743
 0FEA           ;       WriteDIR(Index,&FileDir);                              //写指定根目录项
 0FEA 9E01              movw R18,R28
 0FEC 8501              movw R16,R10
 0FEE 59DD              xcall _WriteDIR
 0FF0                   .dbline -2
 0FF0           L153:
 0FF0                   .dbline 0 ; func end
 0FF0 A096              adiw R28,32
 0FF2 0C940000          xjmp pop_xgset003C
 0FF6                   .dbsym r Index 10 i
 0FF6                   .dbsym r ClusID 12 i
 0FF6                   .dbsym l FileDir 0 S[.6]
 0FF6                   .dbsym r Name 10 pc
 0FF6                   .dbend
 0FF6                   .dbfunc e DelFile32 _DelFile32 fV
 0FF6           ;          Index -> R10,R11
 0FF6           ;         ClusID -> y+34
 0FF6           ;        FileDir -> y+4
 0FF6           ;           Name -> R10,R11
                        .even
 0FF6           _DelFile32::
 0FF6 AA92              st -y,R10
 0FF8 BA92              st -y,R11
 0FFA 5801              movw R10,R16
 0FFC A697              sbiw R28,38
 0FFE                   .dbline -1
 0FFE                   .dbline 748
 0FFE           ;       
 0FFE           ; }
 0FFE           ; 
 0FFE           ; void DelFile32(uint8 Name[11])
 0FFE           ; {
 0FFE                   .dbline 752
 0FFE           ;       DIR32 FileDir;
 0FFE           ;       uint32 ClusID;
 0FFE           ;       uint16 Index;
 0FFE           ;       Index = GetFileID32(Name,&FileDir);                      //搜索得到文件所在根目录项位置
 0FFE 9E01              movw R18,R28
 1000 2C5F              subi R18,252  ; offset = 4
 1002 3F4F              sbci R19,255
 1004 8501              movw R16,R10
 1006 49DC              xcall _GetFileID32
 1008 A02E              mov R10,R16
 100A BB24              clr R11
 100C                   .dbline 753
 100C           ;       FileDir.FileName.NAME[0] = 0xE5;                       //删除根目录下文件
 100C 85EE              ldi R24,229
 100E 8C83              std y+4,R24
 1010                   .dbline 754
 1010           ;       ClusID = ((uint32)FileDir.DIR_FstClusHI)<<16+(uint32)FileDir.DIR_FstClusLo;  //文件所在的簇号
 1010 80E1              ldi R24,16
 1012 90E0              ldi R25,0
 1014 A0E0              ldi R26,0
 1016 B0E0              ldi R27,0
 1018 2E8C              ldd R2,y+30
 101A 3F8C              ldd R3,y+31
 101C 4424              clr R4
 101E 5524              clr R5
 1020 280E              add R2,R24
 1022 391E              adc R3,R25
 1024 4A1E              adc R4,R26
 1026 5B1E              adc R5,R27
 1028 088D              ldd R16,y+24
 102A 198D              ldd R17,y+25
 102C 2227              clr R18
 102E 3327              clr R19
 1030 2A92              st -y,R2
 1032 0E940000          xcall lsl32
 1036 0AA3              std y+34,R16
 1038 1BA3              std y+35,R17
 103A 2CA3              std y+36,R18
 103C 3DA3              std y+37,R19
 103E                   .dbline 755
 103E           ;       Write32FAT(ClusID,0x00000000);                                //清空对应的FAT表FAT1
 103E 80E0              ldi R24,0
 1040 8883              std y+0,R24
 1042 8983              std y+1,R24
 1044 8A83              std y+2,R24
 1046 8B83              std y+3,R24
 1048 0AA1              ldd R16,y+34
 104A 1BA1              ldd R17,y+35
 104C 2CA1              ldd R18,y+36
 104E 3DA1              ldd R19,y+37
 1050 7ADA              xcall _Write32FAT
 1052                   .dbline 756
 1052           ;       Write32FAT2(ClusID,0x00000000);                               //使FAT2和FAT1保持一致
 1052 80E0              ldi R24,0
 1054 8883              std y+0,R24
 1056 8983              std y+1,R24
 1058 8A83              std y+2,R24
 105A 8B83              std y+3,R24
 105C 0AA1              ldd R16,y+34
 105E 1BA1              ldd R17,y+35
 1060 2CA1              ldd R18,y+36
 1062 3DA1              ldd R19,y+37
 1064 F8DA              xcall _Write32FAT2
 1066                   .dbline 757
 1066           ;       WriteDIR32(Index,&FileDir);                                   //写指定根目录项
 1066 9E01              movw R18,R28
 1068 2C5F              subi R18,252  ; offset = 4
 106A 3F4F              sbci R19,255
 106C 8501              movw R16,R10
 106E 53DD              xcall _WriteDIR32
 1070                   .dbline -2
 1070           L155:
 1070                   .dbline 0 ; func end
 1070 A696              adiw R28,38
 1072 B990              ld R11,y+
 1074 A990              ld R10,y+
 1076 0895              ret
 1078                   .dbsym r Index 10 i
 1078                   .dbsym l ClusID 34 l
 1078                   .dbsym l FileDir 4 S[.7]
 1078                   .dbsym r Name 10 pc
 1078                   .dbend
 1078                   .dbfunc e CopyFAT _CopyFAT fV
 1078           ;     RsvdSecCnt -> R12,R13
 1078           ;          FATSz -> R10,R11
 1078           ;              i -> R20,R21
                        .even
 1078           _CopyFAT::
 1078 0E940000          xcall push_xgset303C
 107C                   .dbline -1
 107C                   .dbline 769
 107C           ;       
 107C           ; }
 107C           ; 
 107C           ; /***********************************************************************
 107C           ; 函数功能：复制文件分配表,使其和备份一致
 107C           ; 操作内容：1、将FAT表FAT1复制到FAT2区域 
 107C           ;           2、FATSz16表示FAT表占用的扇区数，BPB区获取的值
 107C           ;           3、备份FAT表
 107C           ; ***********************************************************************/
 107C           ; 
 107C           ; void CopyFAT(void)
 107C           ; {
 107C                   .dbline 771
 107C           ;       uint16 FATSz, RsvdSecCnt, i;
 107C           ;         if(FAT32_EN==0) 
 107C 20900000          lds R2,_FAT32_EN
 1080 2220              tst R2
 1082 29F4              brne L159
 1084           X30:
 1084                   .dbline 772
 1084           ;           FATSz=BPB_FATSz16;
 1084 A0900F00          lds R10,_BPB_FATSz16
 1088 B0901000          lds R11,_BPB_FATSz16+1
 108C 04C0              xjmp L160
 108E           L159:
 108E                   .dbline 774
 108E           ;         else
 108E           ;           FATSz=BPB_FATSz32;
 108E A0900700          lds R10,_BPB_FATSz32
 1092 B0900800          lds R11,_BPB_FATSz32+1
 1096           L160:
 1096                   .dbline 775
 1096           ;       RsvdSecCnt = BPB_HiddSec + BPB_RsvdSecCnt;
 1096 20901600          lds R2,_BPB_RsvdSecCnt
 109A 30901700          lds R3,_BPB_RsvdSecCnt+1
 109E 4424              clr R4
 10A0 5524              clr R5
 10A2 80900D00          lds R8,_BPB_HiddSec+2
 10A6 90900E00          lds R9,_BPB_HiddSec+2+1
 10AA 60900B00          lds R6,_BPB_HiddSec
 10AE 70900C00          lds R7,_BPB_HiddSec+1
 10B2 620C              add R6,R2
 10B4 731C              adc R7,R3
 10B6 841C              adc R8,R4
 10B8 951C              adc R9,R5
 10BA 6301              movw R12,R6
 10BC                   .dbline 776
 10BC           ;       for(i = 0; i < FATSz; i++)
 10BC 4427              clr R20
 10BE 5527              clr R21
 10C0 12C0              xjmp L164
 10C2           L161:
 10C2                   .dbline 777
 10C2           ;       {
 10C2                   .dbline 778
 10C2           ;               ReadBlock(RsvdSecCnt + i);
 10C2 8601              movw R16,R12
 10C4 040F              add R16,R20
 10C6 151F              adc R17,R21
 10C8 2227              clr R18
 10CA 3327              clr R19
 10CC 0E940000          xcall _ReadBlock
 10D0                   .dbline 779
 10D0           ;               WriteBlock(RsvdSecCnt + FATSz + i);
 10D0 8601              movw R16,R12
 10D2 0A0D              add R16,R10
 10D4 1B1D              adc R17,R11
 10D6 040F              add R16,R20
 10D8 151F              adc R17,R21
 10DA 2227              clr R18
 10DC 3327              clr R19
 10DE 0E941300          xcall _WriteBlock
 10E2                   .dbline 780
 10E2           ;       }
 10E2           L162:
 10E2                   .dbline 776
 10E2 4F5F              subi R20,255  ; offset = 1
 10E4 5F4F              sbci R21,255
 10E6           L164:
 10E6                   .dbline 776
 10E6 4A15              cp R20,R10
 10E8 5B05              cpc R21,R11
 10EA 58F3              brlo L161
 10EC           X31:
 10EC                   .dbline -2
 10EC           L158:
 10EC                   .dbline 0 ; func end
 10EC 0C940000          xjmp pop_xgset303C
 10F0                   .dbsym r RsvdSecCnt 12 i
 10F0                   .dbsym r FATSz 10 i
 10F0                   .dbsym r i 20 i
 10F0                   .dbend
 10F0                   .dbfunc e OperateFile _OperateFile fV
 10F0           ;    BytePerClus -> y+60
 10F0           ;        ClusNum -> y+58
 10F0           ;     SecPerClus -> y+56
 10F0           ;    ClusIDValue -> R10,R11
 10F0           ;         length -> y+40
 10F0           ;          Index -> y+54
 10F0           ;       ClusNext -> R12,R13
 10F0           ;            LBA -> y+36
 10F0           ;              i -> y+32
 10F0           ;        FileDir -> y+0
 10F0           ;         ClusID -> R14,R15
 10F0           ;           data -> y+52
 10F0           ;              m -> R10,R11
 10F0           ;           Data -> R12,R13
 10F0           ;         Length -> y+80
 10F0           ;          Start -> y+76
 10F0           ;           Name -> R10,R11
 10F0           ;          Write -> y+72
                        .even
 10F0           _OperateFile::
 10F0 0E940000          xcall push_arg4
 10F4 0E940000          xcall push_xgsetF0FC
 10F8 5901              movw R10,R18
 10FA EE97              sbiw R28,62
 10FC FE01              movw R30,R28
 10FE EC5A              subi R30,172  ; addi 84
 1100 FF4F              sbci R31,255
 1102 C080              ldd R12,z+0
 1104 D180              ldd R13,z+1
 1106                   .dbline -1
 1106                   .dbline 791
 1106           ; }
 1106           ; 
 1106           ; /***********************************************************************
 1106           ; 函数功能：FAT16操作文件的数据，支持读写
 1106           ; 操作内容：1、Write为1是写操作，为0是读操作，Start为开始字节，Length为操作长度 
 1106           ;           2、Data为操作数据，先写入缓冲区
 1106           ;           3、需要同步更新FAT表，记录文件所占大小位置
 1106           ; ***********************************************************************/
 1106           ; 
 1106           ; void OperateFile(uint8 Write ,uint8 Name[11], uint32 Start, uint32 Length, void* Data)
 1106           ; {
 1106                   .dbline 792
 1106           ;       uint8 *data = Data;
 1106 DDAA              std y+53,R13
 1108 CCAA              std y+52,R12
 110A                   .dbline 796
 110A           ;       uint16 BytePerClus, SecPerClus, ClusNum, ClusNext,ClusID,ClusIDValue ,m,Index;
 110A           ;       uint32 LBA, i,length;
 110A           ;       DIR FileDir;
 110A           ;       SecPerClus = BPB_SecPerClus;
 110A 20901800          lds R2,_BPB_SecPerClus
 110E 3324              clr R3
 1110 39AE              std y+57,R3
 1112 28AE              std y+56,R2
 1114                   .dbline 797
 1114           ;       BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
 1114 20911900          lds R18,_BPB_BytesPerSec
 1118 30911A00          lds R19,_BPB_BytesPerSec+1
 111C 022D              mov R16,R2
 111E 1127              clr R17
 1120 0E940000          xcall empy16s
 1124 1DAF              std y+61,R17
 1126 0CAF              std y+60,R16
 1128                   .dbline 798
 1128           ;       Index = GetFileID(Name, &FileDir);                            //文件根目录位置0～511
 1128 9E01              movw R18,R28
 112A 8501              movw R16,R10
 112C 5DDB              xcall _GetFileID
 112E 202E              mov R2,R16
 1130 3324              clr R3
 1132 3FAA              std y+55,R3
 1134 2EAA              std y+54,R2
 1136                   .dbline 799
 1136           ;         length = Length;
 1136 DE01              movw R26,R28
 1138 A05B              subi R26,176  ; addi 80
 113A BF4F              sbci R27,255
 113C 2D90              ld R2,x+
 113E 3D90              ld R3,x+
 1140 4D90              ld R4,x+
 1142 5C90              ld R5,x
 1144 28A6              std y+40,R2
 1146 39A6              std y+41,R3
 1148 4AA6              std y+42,R4
 114A 5BA6              std y+43,R5
 114C                   .dbline 802
 114C           ; 
 114C           ;       //计算开始位置所在簇的簇号
 114C           ;       ClusNum = Start / BytePerClus;
 114C 2CAC              ldd R2,y+60
 114E 3DAC              ldd R3,y+61
 1150 4424              clr R4
 1152 5524              clr R5
 1154 DE01              movw R26,R28
 1156 A45B              subi R26,180  ; addi 76
 1158 BF4F              sbci R27,255
 115A 0D91              ld R16,x+
 115C 1D91              ld R17,x+
 115E 2D91              ld R18,x+
 1160 3C91              ld R19,x
 1162 5A92              st -y,R5
 1164 4A92              st -y,R4
 1166 3A92              st -y,R3
 1168 2A92              st -y,R2
 116A 0E940000          xcall div32u
 116E 1BAF              std y+59,R17
 1170 0AAF              std y+58,R16
 1172                   .dbline 803
 1172           ;       ClusID = FileDir.FilePosit.Start;
 1172 EA8C              ldd R14,y+26
 1174 FB8C              ldd R15,y+27
 1176                   .dbline 805
 1176           ; 
 1176           ;       for(i = 0; i < ClusNum; i++)
 1176 80E0              ldi R24,0
 1178 88A3              std y+32+0,R24
 117A 89A3              std y+32+1,R24
 117C 8AA3              std y+32+2,R24
 117E 8BA3              std y+32+3,R24
 1180 2BC0              xjmp L170
 1182           L167:
 1182                   .dbline 806
 1182           ;       {
 1182                   .dbline 807
 1182           ;                 ClusIDValue = ReadFAT(ClusID);                        //读取对应文件的FAT表，0xFFFF表示文件结束
 1182 8701              movw R16,R14
 1184 35D9              xcall _ReadFAT
 1186 5801              movw R10,R16
 1188                   .dbline 808
 1188           ;               WriteFAT(ClusID, 0xffff);
 1188 2FEF              ldi R18,65535
 118A 3FEF              ldi R19,255
 118C 8701              movw R16,R14
 118E A0D9              xcall _WriteFAT
 1190                   .dbline 809
 1190           ;                 WriteFAT2(ClusID, 0xffff);
 1190 2FEF              ldi R18,65535
 1192 3FEF              ldi R19,255
 1194 8701              movw R16,R14
 1196 2DDA              xcall _WriteFAT2
 1198                   .dbline 810
 1198           ;                 if(ClusIDValue==0xffff)                               //如过ClusIDValue值不为0xFFFF，其他的表示下一个簇地址
 1198 C501              movw R24,R10
 119A 8F3F              cpi R24,255
 119C EFEF              ldi R30,255
 119E 9E07              cpc R25,R30
 11A0 19F4              brne L171
 11A2           X32:
 11A2                   .dbline 811
 11A2           ;                   ClusNext = GetNextFAT();
 11A2 D4DB              xcall _GetNextFAT
 11A4 6801              movw R12,R16
 11A6 01C0              xjmp L172
 11A8           L171:
 11A8                   .dbline 813
 11A8           ;                 else
 11A8           ;                   ClusNext = ClusIDValue; 
 11A8 6501              movw R12,R10
 11AA           L172:
 11AA                   .dbline 815
 11AA           ;                 
 11AA           ;               WriteFAT(ClusID, ClusNext);
 11AA 9601              movw R18,R12
 11AC 8701              movw R16,R14
 11AE 90D9              xcall _WriteFAT
 11B0                   .dbline 816
 11B0           ;                 WriteFAT2(ClusID, ClusNext);
 11B0 9601              movw R18,R12
 11B2 8701              movw R16,R14
 11B4 1EDA              xcall _WriteFAT2
 11B6                   .dbline 817
 11B6           ;               ClusID = ClusNext;
 11B6 7601              movw R14,R12
 11B8                   .dbline 818
 11B8           ;       }
 11B8           L168:
 11B8                   .dbline 805
 11B8 41E0              ldi R20,1
 11BA 50E0              ldi R21,0
 11BC 60E0              ldi R22,0
 11BE 70E0              ldi R23,0
 11C0 28A0              ldd R2,y+32
 11C2 39A0              ldd R3,y+33
 11C4 4AA0              ldd R4,y+34
 11C6 5BA0              ldd R5,y+35
 11C8 240E              add R2,R20
 11CA 351E              adc R3,R21
 11CC 461E              adc R4,R22
 11CE 571E              adc R5,R23
 11D0 28A2              std y+32,R2
 11D2 39A2              std y+33,R3
 11D4 4AA2              std y+34,R4
 11D6 5BA2              std y+35,R5
 11D8           L170:
 11D8                   .dbline 805
 11D8 2AAC              ldd R2,y+58
 11DA 3BAC              ldd R3,y+59
 11DC 4424              clr R4
 11DE 5524              clr R5
 11E0 68A0              ldd R6,y+32
 11E2 79A0              ldd R7,y+33
 11E4 8AA0              ldd R8,y+34
 11E6 9BA0              ldd R9,y+35
 11E8 6214              cp R6,R2
 11EA 7304              cpc R7,R3
 11EC 8404              cpc R8,R4
 11EE 9504              cpc R9,R5
 11F0 08F4              brsh X41
 11F2 C7CF              xjmp L167
 11F4           X41:
 11F4           X33:
 11F4                   .dbline 819
 11F4           ;         WriteFAT(ClusID, 0xffff);
 11F4 2FEF              ldi R18,65535
 11F6 3FEF              ldi R19,255
 11F8 8701              movw R16,R14
 11FA 6AD9              xcall _WriteFAT
 11FC                   .dbline 820
 11FC           ;         WriteFAT2(ClusID, 0xffff);
 11FC 2FEF              ldi R18,65535
 11FE 3FEF              ldi R19,255
 1200 8701              movw R16,R14
 1202 F7D9              xcall _WriteFAT2
 1204                   .dbline 823
 1204           ; 
 1204           ;       //计算开始位置所在扇区簇内偏移
 1204           ;       i = (Start % BytePerClus) / 512;
 1204 2CAC              ldd R2,y+60
 1206 3DAC              ldd R3,y+61
 1208 4424              clr R4
 120A 5524              clr R5
 120C DE01              movw R26,R28
 120E A45B              subi R26,180  ; addi 76
 1210 BF4F              sbci R27,255
 1212 0D91              ld R16,x+
 1214 1D91              ld R17,x+
 1216 2D91              ld R18,x+
 1218 3C91              ld R19,x
 121A 5A92              st -y,R5
 121C 4A92              st -y,R4
 121E 3A92              st -y,R3
 1220 2A92              st -y,R2
 1222 0E940000          xcall mod32u
 1226 89E0              ldi R24,9
 1228 90E0              ldi R25,0
 122A 8A93              st -y,R24
 122C 0E940000          xcall lsr32
 1230 08A3              std y+32,R16
 1232 19A3              std y+33,R17
 1234 2AA3              std y+34,R18
 1236 3BA3              std y+35,R19
 1238                   .dbline 826
 1238           ; 
 1238           ;       //计算开始位置扇区内偏移
 1238           ;       m = (Start % BytePerClus) % 512;
 1238 2CAC              ldd R2,y+60
 123A 3DAC              ldd R3,y+61
 123C 4424              clr R4
 123E 5524              clr R5
 1240 FE01              movw R30,R28
 1242 E45B              subi R30,180  ; addi 76
 1244 FF4F              sbci R31,255
 1246 0081              ldd R16,z+0
 1248 1181              ldd R17,z+1
 124A 2281              ldd R18,z+2
 124C 3381              ldd R19,z+3
 124E 5A92              st -y,R5
 1250 4A92              st -y,R4
 1252 3A92              st -y,R3
 1254 2A92              st -y,R2
 1256 0E940000          xcall mod32u
 125A 4FEF              ldi R20,255
 125C 51E0              ldi R21,1
 125E 60E0              ldi R22,0
 1260 70E0              ldi R23,0
 1262 1801              movw R2,R16
 1264 2901              movw R4,R18
 1266 2422              and R2,R20
 1268 3522              and R3,R21
 126A 4622              and R4,R22
 126C 5722              and R5,R23
 126E 5101              movw R10,R2
 1270                   .dbline 828
 1270           ; 
 1270           ;       LBA = ClusConvLBA(ClusID) + i;
 1270 8701              movw R16,R14
 1272 94D8              xcall _ClusConvLBA
 1274 28A0              ldd R2,y+32
 1276 39A0              ldd R3,y+33
 1278 4AA0              ldd R4,y+34
 127A 5BA0              ldd R5,y+35
 127C 3801              movw R6,R16
 127E 4901              movw R8,R18
 1280 620C              add R6,R2
 1282 731C              adc R7,R3
 1284 841C              adc R8,R4
 1286 951C              adc R9,R5
 1288 6CA2              std y+36,R6
 128A 7DA2              std y+37,R7
 128C 8EA2              std y+38,R8
 128E 9FA2              std y+39,R9
 1290                   .dbline 831
 1290           ; 
 1290           ; 
 1290           ;               for(i = 0; i < SecPerClus; i++)
 1290 80E0              ldi R24,0
 1292 88A3              std y+32+0,R24
 1294 89A3              std y+32+1,R24
 1296 8AA3              std y+32+2,R24
 1298 8BA3              std y+32+3,R24
 129A D5C0              xjmp L176
 129C           L173:
 129C                   .dbline 832
 129C           ;               {
 129C                   .dbline 833
 129C           ;                       if(Write)
 129C DE01              movw R26,R28
 129E A85B              subi R26,184  ; addi 72
 12A0 BF4F              sbci R27,255
 12A2 0C90              ld R0,x
 12A4 0020              tst R0
 12A6 39F0              breq L177
 12A8           X34:
 12A8                   .dbline 834
 12A8           ;                               ReadBlock(LBA);
 12A8 0CA1              ldd R16,y+36
 12AA 1DA1              ldd R17,y+37
 12AC 2EA1              ldd R18,y+38
 12AE 3FA1              ldd R19,y+39
 12B0 0E940000          xcall _ReadBlock
 12B4 1EC0              xjmp L178
 12B6           L177:
 12B6                   .dbline 836
 12B6           ;                       else
 12B6           ;                               ReadBlock(LBA++);
 12B6 2CA0              ldd R2,y+36
 12B8 3DA0              ldd R3,y+37
 12BA 4EA0              ldd R4,y+38
 12BC 5FA0              ldd R5,y+39
 12BE 2CA6              std y+44,R2
 12C0 3DA6              std y+45,R3
 12C2 4EA6              std y+46,R4
 12C4 5FA6              std y+47,R5
 12C6 41E0              ldi R20,1
 12C8 50E0              ldi R21,0
 12CA 60E0              ldi R22,0
 12CC 70E0              ldi R23,0
 12CE 2CA4              ldd R2,y+44
 12D0 3DA4              ldd R3,y+45
 12D2 4EA4              ldd R4,y+46
 12D4 5FA4              ldd R5,y+47
 12D6 240E              add R2,R20
 12D8 351E              adc R3,R21
 12DA 461E              adc R4,R22
 12DC 571E              adc R5,R23
 12DE 2CA2              std y+36,R2
 12E0 3DA2              std y+37,R3
 12E2 4EA2              std y+38,R4
 12E4 5FA2              std y+39,R5
 12E6 0CA5              ldd R16,y+44
 12E8 1DA5              ldd R17,y+45
 12EA 2EA5              ldd R18,y+46
 12EC 3FA5              ldd R19,y+47
 12EE 0E940000          xcall _ReadBlock
 12F2           L178:
 12F2                   .dbline 838
 12F2           ; 
 12F2           ;                       for(m = 0; m < 512; m++)
 12F2 AA24              clr R10
 12F4 BB24              clr R11
 12F6 6DC0              xjmp L182
 12F8           L179:
 12F8                   .dbline 839
 12F8           ;                       {
 12F8                   .dbline 841
 12F8           ; 
 12F8           ;                               if(Write)
 12F8 FE01              movw R30,R28
 12FA E85B              subi R30,184  ; addi 72
 12FC FF4F              sbci R31,255
 12FE 0080              ldd R0,z+0
 1300 0020              tst R0
 1302 61F0              breq L183
 1304           X35:
 1304                   .dbline 842
 1304           ;                                       BUFFER[m] = *data++;
 1304 80E0              ldi R24,<_BUFFER
 1306 90E0              ldi R25,>_BUFFER
 1308 F501              movw R30,R10
 130A E80F              add R30,R24
 130C F91F              adc R31,R25
 130E ACA9              ldd R26,y+52
 1310 BDA9              ldd R27,y+53
 1312 2D90              ld R2,X+
 1314 BDAB              std y+53,R27
 1316 ACAB              std y+52,R26
 1318 2082              std z+0,R2
 131A 0BC0              xjmp L184
 131C           L183:
 131C                   .dbline 844
 131C           ;                               else
 131C           ;                                       *data++ = BUFFER[m];
 131C 80E0              ldi R24,<_BUFFER
 131E 90E0              ldi R25,>_BUFFER
 1320 F501              movw R30,R10
 1322 E80F              add R30,R24
 1324 F91F              adc R31,R25
 1326 2080              ldd R2,z+0
 1328 ECA9              ldd R30,y+52
 132A FDA9              ldd R31,y+53
 132C 2192              st Z+,R2
 132E FDAB              std y+53,R31
 1330 ECAB              std y+52,R30
 1332           L184:
 1332                   .dbline 847
 1332           ; 
 1332           ;                               //如果读取完成就退出
 1332           ;                               if(--Length == 0)
 1332 41E0              ldi R20,1
 1334 50E0              ldi R21,0
 1336 60E0              ldi R22,0
 1338 70E0              ldi R23,0
 133A DE01              movw R26,R28
 133C A05B              subi R26,176  ; addi 80
 133E BF4F              sbci R27,255
 1340 2D90              ld R2,x+
 1342 3D90              ld R3,x+
 1344 4D90              ld R4,x+
 1346 5C90              ld R5,x
 1348 241A              sub R2,R20
 134A 350A              sbc R3,R21
 134C 460A              sbc R4,R22
 134E 570A              sbc R5,R23
 1350 28AA              std y+48,R2
 1352 39AA              std y+49,R3
 1354 4AAA              std y+50,R4
 1356 5BAA              std y+51,R5
 1358 28A8              ldd R2,y+48
 135A 39A8              ldd R3,y+49
 135C 4AA8              ldd R4,y+50
 135E 5BA8              ldd R5,y+51
 1360 DE01              movw R26,R28
 1362 A05B              subi R26,176  ; addi 80
 1364 BF4F              sbci R27,255
 1366 2D92              st x+,R2
 1368 3D92              st x+,R3
 136A 4D92              st x+,R4
 136C 5C92              st x,R5
 136E 28A8              ldd R2,y+48
 1370 39A8              ldd R3,y+49
 1372 4AA8              ldd R4,y+50
 1374 5BA8              ldd R5,y+51
 1376 8894              clc
 1378 2220              tst R2
 137A 3204              cpc R3,R2
 137C 4204              cpc R4,R2
 137E 5204              cpc R5,R2
 1380 29F5              brne L185
 1382           X36:
 1382                   .dbline 848
 1382           ;                               {
 1382                   .dbline 849
 1382           ;                                       if(Write)
 1382 DE01              movw R26,R28
 1384 A85B              subi R26,184  ; addi 72
 1386 BF4F              sbci R27,255
 1388 0C90              ld R0,x
 138A 0020              tst R0
 138C 09F4              brne X42
 138E 69C0              xjmp L165
 1390           X42:
 1390           X37:
 1390                   .dbline 850
 1390           ;                                         {
 1390                   .dbline 852
 1390           ;                                                 //回写扇区
 1390           ;                                               WriteBlock(LBA); 
 1390 0CA1              ldd R16,y+36
 1392 1DA1              ldd R17,y+37
 1394 2EA1              ldd R18,y+38
 1396 3FA1              ldd R19,y+39
 1398 0E941300          xcall _WriteBlock
 139C                   .dbline 854
 139C           ;                                                //回写目录
 139C           ;                                                 FileDir.FilePosit.Size = Start+length;
 139C 28A4              ldd R2,y+40
 139E 39A4              ldd R3,y+41
 13A0 4AA4              ldd R4,y+42
 13A2 5BA4              ldd R5,y+43
 13A4 DE01              movw R26,R28
 13A6 A45B              subi R26,180  ; addi 76
 13A8 BF4F              sbci R27,255
 13AA 6D90              ld R6,x+
 13AC 7D90              ld R7,x+
 13AE 8D90              ld R8,x+
 13B0 9C90              ld R9,x
 13B2 620C              add R6,R2
 13B4 731C              adc R7,R3
 13B6 841C              adc R8,R4
 13B8 951C              adc R9,R5
 13BA 6C8E              std y+28,R6
 13BC 7D8E              std y+29,R7
 13BE 8E8E              std y+30,R8
 13C0 9F8E              std y+31,R9
 13C2                   .dbline 855
 13C2           ;                                                 WriteDIR(Index,&FileDir);
 13C2 9E01              movw R18,R28
 13C4 0EA9              ldd R16,y+54
 13C6 1FA9              ldd R17,y+55
 13C8 6CDB              xcall _WriteDIR
 13CA                   .dbline 856
 13CA           ;                                         }
 13CA                   .dbline 857
 13CA           ;                                       return;
 13CA 4BC0              xjmp L165
 13CC           L185:
 13CC                   .dbline 859
 13CC           ;                               }
 13CC           ;                       }
 13CC           L180:
 13CC                   .dbline 838
 13CC C501              movw R24,R10
 13CE 0196              adiw R24,1
 13D0 5C01              movw R10,R24
 13D2           L182:
 13D2                   .dbline 838
 13D2 C501              movw R24,R10
 13D4 8030              cpi R24,0
 13D6 A2E0              ldi R26,2
 13D8 9A07              cpc R25,R26
 13DA 08F4              brsh X43
 13DC 8DCF              xjmp L179
 13DE           X43:
 13DE           X38:
 13DE                   .dbline 860
 13DE           ;                       if(Write)
 13DE DE01              movw R26,R28
 13E0 A85B              subi R26,184  ; addi 72
 13E2 BF4F              sbci R27,255
 13E4 0C90              ld R0,x
 13E6 0020              tst R0
 13E8 F1F0              breq L191
 13EA           X39:
 13EA                   .dbline 861
 13EA           ;                               WriteBlock(LBA++); //回写扇区,指针下移
 13EA 2CA0              ldd R2,y+36
 13EC 3DA0              ldd R3,y+37
 13EE 4EA0              ldd R4,y+38
 13F0 5FA0              ldd R5,y+39
 13F2 28AA              std y+48,R2
 13F4 39AA              std y+49,R3
 13F6 4AAA              std y+50,R4
 13F8 5BAA              std y+51,R5
 13FA 41E0              ldi R20,1
 13FC 50E0              ldi R21,0
 13FE 60E0              ldi R22,0
 1400 70E0              ldi R23,0
 1402 28A8              ldd R2,y+48
 1404 39A8              ldd R3,y+49
 1406 4AA8              ldd R4,y+50
 1408 5BA8              ldd R5,y+51
 140A 240E              add R2,R20
 140C 351E              adc R3,R21
 140E 461E              adc R4,R22
 1410 571E              adc R5,R23
 1412 2CA2              std y+36,R2
 1414 3DA2              std y+37,R3
 1416 4EA2              std y+38,R4
 1418 5FA2              std y+39,R5
 141A 08A9              ldd R16,y+48
 141C 19A9              ldd R17,y+49
 141E 2AA9              ldd R18,y+50
 1420 3BA9              ldd R19,y+51
 1422 0E941300          xcall _WriteBlock
 1426           L191:
 1426                   .dbline 862
 1426           ;               }
 1426           L174:
 1426                   .dbline 831
 1426 41E0              ldi R20,1
 1428 50E0              ldi R21,0
 142A 60E0              ldi R22,0
 142C 70E0              ldi R23,0
 142E 28A0              ldd R2,y+32
 1430 39A0              ldd R3,y+33
 1432 4AA0              ldd R4,y+34
 1434 5BA0              ldd R5,y+35
 1436 240E              add R2,R20
 1438 351E              adc R3,R21
 143A 461E              adc R4,R22
 143C 571E              adc R5,R23
 143E 28A2              std y+32,R2
 1440 39A2              std y+33,R3
 1442 4AA2              std y+34,R4
 1444 5BA2              std y+35,R5
 1446           L176:
 1446                   .dbline 831
 1446 28AC              ldd R2,y+56
 1448 39AC              ldd R3,y+57
 144A 4424              clr R4
 144C 5524              clr R5
 144E 68A0              ldd R6,y+32
 1450 79A0              ldd R7,y+33
 1452 8AA0              ldd R8,y+34
 1454 9BA0              ldd R9,y+35
 1456 6214              cp R6,R2
 1458 7304              cpc R7,R3
 145A 8404              cpc R8,R4
 145C 9504              cpc R9,R5
 145E 08F4              brsh X44
 1460 1DCF              xjmp L173
 1462           X44:
 1462           X40:
 1462                   .dbline -2
 1462           L165:
 1462                   .dbline 0 ; func end
 1462 EE96              adiw R28,62
 1464 0E940000          xcall pop_xgsetF0FC
 1468 2496              adiw R28,4
 146A 0895              ret
 146C                   .dbsym l BytePerClus 60 i
 146C                   .dbsym l ClusNum 58 i
 146C                   .dbsym l SecPerClus 56 i
 146C                   .dbsym r ClusIDValue 10 i
 146C                   .dbsym l length 40 l
 146C                   .dbsym l Index 54 i
 146C                   .dbsym r ClusNext 12 i
 146C                   .dbsym l LBA 36 l
 146C                   .dbsym l i 32 l
 146C                   .dbsym l FileDir 0 S[.6]
 146C                   .dbsym r ClusID 14 i
 146C                   .dbsym l data 52 pc
 146C                   .dbsym r m 10 i
 146C                   .dbsym r Data 12 pV
 146C                   .dbsym l Length 80 l
 146C                   .dbsym l Start 76 l
 146C                   .dbsym r Name 10 pc
 146C                   .dbsym l Write 72 c
 146C                   .dbend
 146C                   .dbfunc e Operate32File _Operate32File fV
 146C           ;    BytePerClus -> R10,R11
 146C           ;        ClusNum -> R14,R15
 146C           ;     SecPerClus -> y+68
 146C           ;    ClusIDValue -> y+54
 146C           ;         length -> y+50
 146C           ;          Index -> R12,R13
 146C           ;       ClusNext -> y+46
 146C           ;            LBA -> y+42
 146C           ;              i -> y+38
 146C           ;        FileDir -> y+8
 146C           ;         ClusID -> y+4
 146C           ;           data -> y+66
 146C           ;              m -> R10,R11
 146C           ;           Data -> R10,R11
 146C           ;         Length -> y+88
 146C           ;          Start -> y+84
 146C           ;           Name -> R12,R13
 146C           ;          Write -> y+80
                        .even
 146C           _Operate32File::
 146C 0E940000          xcall push_arg4
 1470 0E940000          xcall push_xgsetF0FC
 1474 6901              movw R12,R18
 1476 EF97              sbiw R28,63
 1478 2797              sbiw R28,7  ; offset = 70
 147A FE01              movw R30,R28
 147C E45A              subi R30,164  ; addi 92
 147E FF4F              sbci R31,255
 1480 A080              ldd R10,z+0
 1482 B180              ldd R11,z+1
 1484                   .dbline -1
 1484                   .dbline 873
 1484           ;       }
 1484           ; 
 1484           ; /***********************************************************************
 1484           ; 函数功能：FAT32操作文件的数据，支持读写
 1484           ; 操作内容：1、Write为1是写操作，为0是读操作，Start为开始字节，Length为操作长度 
 1484           ;           2、Data为操作数据，先写入缓冲区
 1484           ;           3、需要同步更新FAT表，记录文件所占大小位置
 1484           ; ***********************************************************************/
 1484           ; 
 1484           ; void Operate32File(uint8 Write ,uint8 Name[11], uint32 Start, uint32 Length, void* Data)
 1484           ; {
 1484                   .dbline 874
 1484           ;       uint8 *data = Data;
 1484 FE01              movw R30,R28
 1486 EE5B              subi R30,190  ; addi 66
 1488 FF4F              sbci R31,255
 148A B182              std z+1,R11
 148C A082              std z+0,R10
 148E                   .dbline 879
 148E           ;       uint16 BytePerClus, SecPerClus, ClusNum ,m,Index;
 148E           ;         uint32 ClusID,ClusIDValue, ClusNext;
 148E           ;       uint32 LBA, i,length;
 148E           ;       DIR32 FileDir;
 148E           ;       SecPerClus = BPB_SecPerClus;
 148E 20901800          lds R2,_BPB_SecPerClus
 1492 3324              clr R3
 1494 FE01              movw R30,R28
 1496 EC5B              subi R30,188  ; addi 68
 1498 FF4F              sbci R31,255
 149A 3182              std z+1,R3
 149C 2082              std z+0,R2
 149E                   .dbline 880
 149E           ;       BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
 149E 20911900          lds R18,_BPB_BytesPerSec
 14A2 30911A00          lds R19,_BPB_BytesPerSec+1
 14A6 022D              mov R16,R2
 14A8 1127              clr R17
 14AA 0E940000          xcall empy16s
 14AE 5801              movw R10,R16
 14B0                   .dbline 881
 14B0           ;       Index = GetFileID32(Name, &FileDir);                            //文件根目录位置0～511
 14B0 9E01              movw R18,R28
 14B2 285F              subi R18,248  ; offset = 8
 14B4 3F4F              sbci R19,255
 14B6 8601              movw R16,R12
 14B8 F0D9              xcall _GetFileID32
 14BA C02E              mov R12,R16
 14BC DD24              clr R13
 14BE                   .dbline 882
 14BE           ;         length = Length;
 14BE DE01              movw R26,R28
 14C0 A85A              subi R26,168  ; addi 88
 14C2 BF4F              sbci R27,255
 14C4 2D90              ld R2,x+
 14C6 3D90              ld R3,x+
 14C8 4D90              ld R4,x+
 14CA 5C90              ld R5,x
 14CC 2AAA              std y+50,R2
 14CE 3BAA              std y+51,R3
 14D0 4CAA              std y+52,R4
 14D2 5DAA              std y+53,R5
 14D4                   .dbline 885
 14D4           ; 
 14D4           ;       //计算开始位置所在簇的簇号
 14D4           ;       ClusNum = Start / BytePerClus;
 14D4 1501              movw R2,R10
 14D6 4424              clr R4
 14D8 5524              clr R5
 14DA DE01              movw R26,R28
 14DC AC5A              subi R26,172  ; addi 84
 14DE BF4F              sbci R27,255
 14E0 0D91              ld R16,x+
 14E2 1D91              ld R17,x+
 14E4 2D91              ld R18,x+
 14E6 3C91              ld R19,x
 14E8 5A92              st -y,R5
 14EA 4A92              st -y,R4
 14EC 3A92              st -y,R3
 14EE 2A92              st -y,R2
 14F0 0E940000          xcall div32u
 14F4 7801              movw R14,R16
 14F6                   .dbline 886
 14F6           ;         ClusID=((uint32)FileDir.DIR_FstClusHI<<16)+(uint32)FileDir.DIR_FstClusLo;
 14F6 2AA0              ldd R2,y+34
 14F8 3BA0              ldd R3,y+35
 14FA 4424              clr R4
 14FC 5524              clr R5
 14FE 6C8C              ldd R6,y+28
 1500 7D8C              ldd R7,y+29
 1502 8824              clr R8
 1504 9924              clr R9
 1506 4301              movw R8,R6
 1508 6624              clr R6
 150A 7724              clr R7
 150C 620C              add R6,R2
 150E 731C              adc R7,R3
 1510 841C              adc R8,R4
 1512 951C              adc R9,R5
 1514 6C82              std y+4,R6
 1516 7D82              std y+5,R7
 1518 8E82              std y+6,R8
 151A 9F82              std y+7,R9
 151C                   .dbline 887
 151C           ;       for(i = 0; i < ClusNum; i++)
 151C 80E0              ldi R24,0
 151E 8EA3              std y+38+0,R24
 1520 8FA3              std y+38+1,R24
 1522 88A7              std y+38+2,R24
 1524 89A7              std y+38+3,R24
 1526 6FC0              xjmp L199
 1528           L196:
 1528                   .dbline 888
 1528           ;       {
 1528                   .dbline 889
 1528           ;                 ClusIDValue = Read32FAT(ClusID);                        //读取对应文件的FAT表，0xFFFF表示文件结束
 1528 0C81              ldd R16,y+4
 152A 1D81              ldd R17,y+5
 152C 2E81              ldd R18,y+6
 152E 3F81              ldd R19,y+7
 1530 0E942302          xcall _Read32FAT
 1534 0EAB              std y+54,R16
 1536 1FAB              std y+55,R17
 1538 28AF              std y+56,R18
 153A 39AF              std y+57,R19
 153C                   .dbline 890
 153C           ;               Write32FAT(ClusID, 0x0fffffff);
 153C 8FEF              ldi R24,255
 153E 8883              std y+0,R24
 1540 8983              std y+1,R24
 1542 8A83              std y+2,R24
 1544 8FE0              ldi R24,15
 1546 8B83              std y+3,R24
 1548 0C81              ldd R16,y+4
 154A 1D81              ldd R17,y+5
 154C 2E81              ldd R18,y+6
 154E 3F81              ldd R19,y+7
 1550 0E94A302          xcall _Write32FAT
 1554                   .dbline 891
 1554           ;                 Write32FAT2(ClusID, 0x0fffffff);
 1554 8FEF              ldi R24,255
 1556 8883              std y+0,R24
 1558 8983              std y+1,R24
 155A 8A83              std y+2,R24
 155C 8FE0              ldi R24,15
 155E 8B83              std y+3,R24
 1560 0C81              ldd R16,y+4
 1562 1D81              ldd R17,y+5
 1564 2E81              ldd R18,y+6
 1566 3F81              ldd R19,y+7
 1568 76D8              xcall _Write32FAT2
 156A                   .dbline 892
 156A           ;                 if(ClusIDValue==0x0fffffff)                               //如过ClusIDValue值不为0xFFFF，其他的表示下一个簇地址
 156A 4FEF              ldi R20,255
 156C 5FEF              ldi R21,255
 156E 6FEF              ldi R22,255
 1570 7FE0              ldi R23,15
 1572 2EA8              ldd R2,y+54
 1574 3FA8              ldd R3,y+55
 1576 48AC              ldd R4,y+56
 1578 59AC              ldd R5,y+57
 157A 2416              cp R2,R20
 157C 3506              cpc R3,R21
 157E 4606              cpc R4,R22
 1580 5706              cpc R5,R23
 1582 31F4              brne L200
 1584           X45:
 1584                   .dbline 893
 1584           ;                   ClusNext = GetNext32FAT();
 1584 01DA              xcall _GetNext32FAT
 1586 0EA7              std y+46,R16
 1588 1FA7              std y+47,R17
 158A 28AB              std y+48,R18
 158C 39AB              std y+49,R19
 158E 08C0              xjmp L201
 1590           L200:
 1590                   .dbline 895
 1590           ;                 else
 1590           ;                   ClusNext = ClusIDValue; 
 1590 2EA8              ldd R2,y+54
 1592 3FA8              ldd R3,y+55
 1594 48AC              ldd R4,y+56
 1596 59AC              ldd R5,y+57
 1598 2EA6              std y+46,R2
 159A 3FA6              std y+47,R3
 159C 48AA              std y+48,R4
 159E 59AA              std y+49,R5
 15A0           L201:
 15A0                   .dbline 897
 15A0           ;                 
 15A0           ;               Write32FAT(ClusID, ClusNext);
 15A0 2EA4              ldd R2,y+46
 15A2 3FA4              ldd R3,y+47
 15A4 48A8              ldd R4,y+48
 15A6 59A8              ldd R5,y+49
 15A8 2882              std y+0,R2
 15AA 3982              std y+1,R3
 15AC 4A82              std y+2,R4
 15AE 5B82              std y+3,R5
 15B0 0C81              ldd R16,y+4
 15B2 1D81              ldd R17,y+5
 15B4 2E81              ldd R18,y+6
 15B6 3F81              ldd R19,y+7
 15B8 0E94A302          xcall _Write32FAT
 15BC                   .dbline 898
 15BC           ;                 Write32FAT2(ClusID, ClusNext);
 15BC 2EA4              ldd R2,y+46
 15BE 3FA4              ldd R3,y+47
 15C0 48A8              ldd R4,y+48
 15C2 59A8              ldd R5,y+49
 15C4 2882              std y+0,R2
 15C6 3982              std y+1,R3
 15C8 4A82              std y+2,R4
 15CA 5B82              std y+3,R5
 15CC 0C81              ldd R16,y+4
 15CE 1D81              ldd R17,y+5
 15D0 2E81              ldd R18,y+6
 15D2 3F81              ldd R19,y+7
 15D4 40D8              xcall _Write32FAT2
 15D6                   .dbline 899
 15D6           ;               ClusID = ClusNext;
 15D6 2EA4              ldd R2,y+46
 15D8 3FA4              ldd R3,y+47
 15DA 48A8              ldd R4,y+48
 15DC 59A8              ldd R5,y+49
 15DE 2C82              std y+4,R2
 15E0 3D82              std y+5,R3
 15E2 4E82              std y+6,R4
 15E4 5F82              std y+7,R5
 15E6                   .dbline 900
 15E6           ;       }
 15E6           L197:
 15E6                   .dbline 887
 15E6 41E0              ldi R20,1
 15E8 50E0              ldi R21,0
 15EA 60E0              ldi R22,0
 15EC 70E0              ldi R23,0
 15EE 2EA0              ldd R2,y+38
 15F0 3FA0              ldd R3,y+39
 15F2 48A4              ldd R4,y+40
 15F4 59A4              ldd R5,y+41
 15F6 240E              add R2,R20
 15F8 351E              adc R3,R21
 15FA 461E              adc R4,R22
 15FC 571E              adc R5,R23
 15FE 2EA2              std y+38,R2
 1600 3FA2              std y+39,R3
 1602 48A6              std y+40,R4
 1604 59A6              std y+41,R5
 1606           L199:
 1606                   .dbline 887
 1606 1701              movw R2,R14
 1608 4424              clr R4
 160A 5524              clr R5
 160C 6EA0              ldd R6,y+38
 160E 7FA0              ldd R7,y+39
 1610 88A4              ldd R8,y+40
 1612 99A4              ldd R9,y+41
 1614 6214              cp R6,R2
 1616 7304              cpc R7,R3
 1618 8404              cpc R8,R4
 161A 9504              cpc R9,R5
 161C 08F4              brsh X54
 161E 84CF              xjmp L196
 1620           X54:
 1620           X46:
 1620                   .dbline 901
 1620           ;         Write32FAT(ClusID, 0x0fffffff);
 1620 8FEF              ldi R24,255
 1622 8883              std y+0,R24
 1624 8983              std y+1,R24
 1626 8A83              std y+2,R24
 1628 8FE0              ldi R24,15
 162A 8B83              std y+3,R24
 162C 0C81              ldd R16,y+4
 162E 1D81              ldd R17,y+5
 1630 2E81              ldd R18,y+6
 1632 3F81              ldd R19,y+7
 1634 0E94A302          xcall _Write32FAT
 1638                   .dbline 902
 1638           ;         Write32FAT2(ClusID, 0x0fffffff);
 1638 8FEF              ldi R24,255
 163A 8883              std y+0,R24
 163C 8983              std y+1,R24
 163E 8A83              std y+2,R24
 1640 8FE0              ldi R24,15
 1642 8B83              std y+3,R24
 1644 0C81              ldd R16,y+4
 1646 1D81              ldd R17,y+5
 1648 2E81              ldd R18,y+6
 164A 3F81              ldd R19,y+7
 164C 04D8              xcall _Write32FAT2
 164E                   .dbline 905
 164E           ; 
 164E           ;       //计算开始位置所在扇区簇内偏移
 164E           ;       i = (Start % BytePerClus) / 512;
 164E 1501              movw R2,R10
 1650 4424              clr R4
 1652 5524              clr R5
 1654 DE01              movw R26,R28
 1656 AC5A              subi R26,172  ; addi 84
 1658 BF4F              sbci R27,255
 165A 0D91              ld R16,x+
 165C 1D91              ld R17,x+
 165E 2D91              ld R18,x+
 1660 3C91              ld R19,x
 1662 5A92              st -y,R5
 1664 4A92              st -y,R4
 1666 3A92              st -y,R3
 1668 2A92              st -y,R2
 166A 0E940000          xcall mod32u
 166E 89E0              ldi R24,9
 1670 90E0              ldi R25,0
 1672 8A93              st -y,R24
 1674 0E940000          xcall lsr32
 1678 0EA3              std y+38,R16
 167A 1FA3              std y+39,R17
 167C 28A7              std y+40,R18
 167E 39A7              std y+41,R19
 1680                   .dbline 908
 1680           ; 
 1680           ;       //计算开始位置扇区内偏移
 1680           ;       m = (Start % BytePerClus) % 512;
 1680 1501              movw R2,R10
 1682 4424              clr R4
 1684 5524              clr R5
 1686 FE01              movw R30,R28
 1688 EC5A              subi R30,172  ; addi 84
 168A FF4F              sbci R31,255
 168C 0081              ldd R16,z+0
 168E 1181              ldd R17,z+1
 1690 2281              ldd R18,z+2
 1692 3381              ldd R19,z+3
 1694 5A92              st -y,R5
 1696 4A92              st -y,R4
 1698 3A92              st -y,R3
 169A 2A92              st -y,R2
 169C 0E940000          xcall mod32u
 16A0 4FEF              ldi R20,255
 16A2 51E0              ldi R21,1
 16A4 60E0              ldi R22,0
 16A6 70E0              ldi R23,0
 16A8 1801              movw R2,R16
 16AA 2901              movw R4,R18
 16AC 2422              and R2,R20
 16AE 3522              and R3,R21
 16B0 4622              and R4,R22
 16B2 5722              and R5,R23
 16B4 5101              movw R10,R2
 16B6                   .dbline 910
 16B6           ; 
 16B6           ;       LBA = ClusConvLBA(ClusID) + i;
 16B6 0C81              ldd R16,y+4
 16B8 1D81              ldd R17,y+5
 16BA 0E94CE01          xcall _ClusConvLBA
 16BE 2EA0              ldd R2,y+38
 16C0 3FA0              ldd R3,y+39
 16C2 48A4              ldd R4,y+40
 16C4 59A4              ldd R5,y+41
 16C6 3801              movw R6,R16
 16C8 4901              movw R8,R18
 16CA 620C              add R6,R2
 16CC 731C              adc R7,R3
 16CE 841C              adc R8,R4
 16D0 951C              adc R9,R5
 16D2 6AA6              std y+42,R6
 16D4 7BA6              std y+43,R7
 16D6 8CA6              std y+44,R8
 16D8 9DA6              std y+45,R9
 16DA                   .dbline 913
 16DA           ; 
 16DA           ; 
 16DA           ;               for(i = 0; i < SecPerClus; i++)
 16DA 80E0              ldi R24,0
 16DC 8EA3              std y+38+0,R24
 16DE 8FA3              std y+38+1,R24
 16E0 88A7              std y+38+2,R24
 16E2 89A7              std y+38+3,R24
 16E4 EAC0              xjmp L205
 16E6           L202:
 16E6                   .dbline 914
 16E6           ;               {
 16E6                   .dbline 915
 16E6           ;                       if(Write)
 16E6 DE01              movw R26,R28
 16E8 A05B              subi R26,176  ; addi 80
 16EA BF4F              sbci R27,255
 16EC 0C90              ld R0,x
 16EE 0020              tst R0
 16F0 39F0              breq L206
 16F2           X47:
 16F2                   .dbline 916
 16F2           ;                               ReadBlock(LBA);
 16F2 0AA5              ldd R16,y+42
 16F4 1BA5              ldd R17,y+43
 16F6 2CA5              ldd R18,y+44
 16F8 3DA5              ldd R19,y+45
 16FA 0E940000          xcall _ReadBlock
 16FE 1EC0              xjmp L207
 1700           L206:
 1700                   .dbline 918
 1700           ;                       else
 1700           ;                               ReadBlock(LBA++);
 1700 2AA4              ldd R2,y+42
 1702 3BA4              ldd R3,y+43
 1704 4CA4              ldd R4,y+44
 1706 5DA4              ldd R5,y+45
 1708 2AAE              std y+58,R2
 170A 3BAE              std y+59,R3
 170C 4CAE              std y+60,R4
 170E 5DAE              std y+61,R5
 1710 41E0              ldi R20,1
 1712 50E0              ldi R21,0
 1714 60E0              ldi R22,0
 1716 70E0              ldi R23,0
 1718 2AAC              ldd R2,y+58
 171A 3BAC              ldd R3,y+59
 171C 4CAC              ldd R4,y+60
 171E 5DAC              ldd R5,y+61
 1720 240E              add R2,R20
 1722 351E              adc R3,R21
 1724 461E              adc R4,R22
 1726 571E              adc R5,R23
 1728 2AA6              std y+42,R2
 172A 3BA6              std y+43,R3
 172C 4CA6              std y+44,R4
 172E 5DA6              std y+45,R5
 1730 0AAD              ldd R16,y+58
 1732 1BAD              ldd R17,y+59
 1734 2CAD              ldd R18,y+60
 1736 3DAD              ldd R19,y+61
 1738 0E940000          xcall _ReadBlock
 173C           L207:
 173C                   .dbline 920
 173C           ; 
 173C           ;                       for(m = 0; m < 512; m++)
 173C AA24              clr R10
 173E BB24              clr R11
 1740 7CC0              xjmp L211
 1742           L208:
 1742                   .dbline 921
 1742           ;                       {
 1742                   .dbline 923
 1742           ; 
 1742           ;                               if(Write)
 1742 FE01              movw R30,R28
 1744 E05B              subi R30,176  ; addi 80
 1746 FF4F              sbci R31,255
 1748 0080              ldd R0,z+0
 174A 0020              tst R0
 174C B1F0              breq L212
 174E           X48:
 174E                   .dbline 924
 174E           ;                                       BUFFER[m] = *data++;
 174E 80E0              ldi R24,<_BUFFER
 1750 90E0              ldi R25,>_BUFFER
 1752 F501              movw R30,R10
 1754 E80F              add R30,R24
 1756 F91F              adc R31,R25
 1758 EF93              push R30
 175A FF93              push R31
 175C FE01              movw R30,R28
 175E EE5B              subi R30,190  ; addi 66
 1760 FF4F              sbci R31,255
 1762 A081              ldd R26,z+0
 1764 B181              ldd R27,z+1
 1766 FF91              pop R31
 1768 EF91              pop R30
 176A 2D90              ld R2,X+
 176C DE01              movw R26,R28
 176E AE5B              subi R26,190  ; addi 66
 1770 BF4F              sbci R27,255
 1772 AD93              st x+,R26
 1774 BC93              st x,R27
 1776 2082              std z+0,R2
 1778 11C0              xjmp L213
 177A           L212:
 177A                   .dbline 926
 177A           ;                               else
 177A           ;                                       *data++ = BUFFER[m];
 177A 80E0              ldi R24,<_BUFFER
 177C 90E0              ldi R25,>_BUFFER
 177E F501              movw R30,R10
 1780 E80F              add R30,R24
 1782 F91F              adc R31,R25
 1784 2080              ldd R2,z+0
 1786 DE01              movw R26,R28
 1788 AE5B              subi R26,190  ; addi 66
 178A BF4F              sbci R27,255
 178C ED91              ld R30,x+
 178E FC91              ld R31,x
 1790 2192              st Z+,R2
 1792 DE01              movw R26,R28
 1794 AE5B              subi R26,190  ; addi 66
 1796 BF4F              sbci R27,255
 1798 ED93              st x+,R30
 179A FC93              st x,R31
 179C           L213:
 179C                   .dbline 929
 179C           ; 
 179C           ;                               //如果读取完成就退出
 179C           ;                               if(--Length == 0)
 179C 41E0              ldi R20,1
 179E 50E0              ldi R21,0
 17A0 60E0              ldi R22,0
 17A2 70E0              ldi R23,0
 17A4 DE01              movw R26,R28
 17A6 A85A              subi R26,168  ; addi 88
 17A8 BF4F              sbci R27,255
 17AA 2D90              ld R2,x+
 17AC 3D90              ld R3,x+
 17AE 4D90              ld R4,x+
 17B0 5C90              ld R5,x
 17B2 241A              sub R2,R20
 17B4 350A              sbc R3,R21
 17B6 460A              sbc R4,R22
 17B8 570A              sbc R5,R23
 17BA DE01              movw R26,R28
 17BC DE96              adiw R26,62
 17BE 2D92              st x+,R2
 17C0 3D92              st x+,R3
 17C2 4D92              st x+,R4
 17C4 5C92              st x,R5
 17C6 DE01              movw R26,R28
 17C8 DE96              adiw R26,62
 17CA 2D90              ld R2,x+
 17CC 3D90              ld R3,x+
 17CE 4D90              ld R4,x+
 17D0 5C90              ld R5,x
 17D2 DE01              movw R26,R28
 17D4 A85A              subi R26,168  ; addi 88
 17D6 BF4F              sbci R27,255
 17D8 2D92              st x+,R2
 17DA 3D92              st x+,R3
 17DC 4D92              st x+,R4
 17DE 5C92              st x,R5
 17E0 DE01              movw R26,R28
 17E2 DE96              adiw R26,62
 17E4 2D90              ld R2,x+
 17E6 3D90              ld R3,x+
 17E8 4D90              ld R4,x+
 17EA 5C90              ld R5,x
 17EC 8894              clc
 17EE 2220              tst R2
 17F0 3204              cpc R3,R2
 17F2 4204              cpc R4,R2
 17F4 5204              cpc R5,R2
 17F6 F1F4              brne L214
 17F8           X49:
 17F8                   .dbline 930
 17F8           ;                               {
 17F8                   .dbline 931
 17F8           ;                                       if(Write)
 17F8 DE01              movw R26,R28
 17FA A05B              subi R26,176  ; addi 80
 17FC BF4F              sbci R27,255
 17FE 0C90              ld R0,x
 1800 0020              tst R0
 1802 09F4              brne X55
 1804 6BC0              xjmp L193
 1806           X55:
 1806           X50:
 1806                   .dbline 932
 1806           ;                                         {
 1806                   .dbline 934
 1806           ;                                                 //回写扇区
 1806           ;                                               WriteBlock(LBA); 
 1806 0AA5              ldd R16,y+42
 1808 1BA5              ldd R17,y+43
 180A 2CA5              ldd R18,y+44
 180C 3DA5              ldd R19,y+45
 180E 0E941300          xcall _WriteBlock
 1812                   .dbline 936
 1812           ;                                                //回写目录
 1812           ;                                                 FileDir.DIR_FileSize = Start+length;
 1812 2AA8              ldd R2,y+50
 1814 3BA8              ldd R3,y+51
 1816 FE01              movw R30,R28
 1818 EC5A              subi R30,172  ; addi 84
 181A FF4F              sbci R31,255
 181C 4080              ldd R4,z+0
 181E 5180              ldd R5,z+1
 1820 420C              add R4,R2
 1822 531C              adc R5,R3
 1824 5DA2              std y+37,R5
 1826 4CA2              std y+36,R4
 1828                   .dbline 937
 1828           ;                                                 WriteDIR32(Index,&FileDir);
 1828 9E01              movw R18,R28
 182A 285F              subi R18,248  ; offset = 8
 182C 3F4F              sbci R19,255
 182E 8601              movw R16,R12
 1830 72D9              xcall _WriteDIR32
 1832                   .dbline 938
 1832           ;                                         }
 1832                   .dbline 939
 1832           ;                                       return;
 1832 54C0              xjmp L193
 1834           L214:
 1834                   .dbline 941
 1834           ;                               }
 1834           ;                       }
 1834           L209:
 1834                   .dbline 920
 1834 C501              movw R24,R10
 1836 0196              adiw R24,1
 1838 5C01              movw R10,R24
 183A           L211:
 183A                   .dbline 920
 183A C501              movw R24,R10
 183C 8030              cpi R24,0
 183E A2E0              ldi R26,2
 1840 9A07              cpc R25,R26
 1842 08F4              brsh X56
 1844 7ECF              xjmp L208
 1846           X56:
 1846           X51:
 1846                   .dbline 942
 1846           ;                       if(Write)
 1846 DE01              movw R26,R28
 1848 A05B              subi R26,176  ; addi 80
 184A BF4F              sbci R27,255
 184C 0C90              ld R0,x
 184E 0020              tst R0
 1850 21F1              breq L219
 1852           X52:
 1852                   .dbline 943
 1852           ;                               WriteBlock(LBA++); //回写扇区,指针下移
 1852 2AA4              ldd R2,y+42
 1854 3BA4              ldd R3,y+43
 1856 4CA4              ldd R4,y+44
 1858 5DA4              ldd R5,y+45
 185A DE01              movw R26,R28
 185C DE96              adiw R26,62
 185E 2D92              st x+,R2
 1860 3D92              st x+,R3
 1862 4D92              st x+,R4
 1864 5C92              st x,R5
 1866 41E0              ldi R20,1
 1868 50E0              ldi R21,0
 186A 60E0              ldi R22,0
 186C 70E0              ldi R23,0
 186E DE01              movw R26,R28
 1870 DE96              adiw R26,62
 1872 2D90              ld R2,x+
 1874 3D90              ld R3,x+
 1876 4D90              ld R4,x+
 1878 5C90              ld R5,x
 187A 240E              add R2,R20
 187C 351E              adc R3,R21
 187E 461E              adc R4,R22
 1880 571E              adc R5,R23
 1882 2AA6              std y+42,R2
 1884 3BA6              std y+43,R3
 1886 4CA6              std y+44,R4
 1888 5DA6              std y+45,R5
 188A FE01              movw R30,R28
 188C FE96              adiw R30,62
 188E 0081              ldd R16,z+0
 1890 1181              ldd R17,z+1
 1892 2281              ldd R18,z+2
 1894 3381              ldd R19,z+3
 1896 0E941300          xcall _WriteBlock
 189A           L219:
 189A                   .dbline 944
 189A           ;               }
 189A           L203:
 189A                   .dbline 913
 189A 41E0              ldi R20,1
 189C 50E0              ldi R21,0
 189E 60E0              ldi R22,0
 18A0 70E0              ldi R23,0
 18A2 2EA0              ldd R2,y+38
 18A4 3FA0              ldd R3,y+39
 18A6 48A4              ldd R4,y+40
 18A8 59A4              ldd R5,y+41
 18AA 240E              add R2,R20
 18AC 351E              adc R3,R21
 18AE 461E              adc R4,R22
 18B0 571E              adc R5,R23
 18B2 2EA2              std y+38,R2
 18B4 3FA2              std y+39,R3
 18B6 48A6              std y+40,R4
 18B8 59A6              std y+41,R5
 18BA           L205:
 18BA                   .dbline 913
 18BA DE01              movw R26,R28
 18BC AC5B              subi R26,188  ; addi 68
 18BE BF4F              sbci R27,255
 18C0 2D90              ld R2,x+
 18C2 3C90              ld R3,x
 18C4 4424              clr R4
 18C6 5524              clr R5
 18C8 6EA0              ldd R6,y+38
 18CA 7FA0              ldd R7,y+39
 18CC 88A4              ldd R8,y+40
 18CE 99A4              ldd R9,y+41
 18D0 6214              cp R6,R2
 18D2 7304              cpc R7,R3
 18D4 8404              cpc R8,R4
 18D6 9504              cpc R9,R5
 18D8 08F4              brsh X57
 18DA 05CF              xjmp L202
 18DC           X57:
 18DC           X53:
 18DC                   .dbline -2
 18DC           L193:
 18DC                   .dbline 0 ; func end
 18DC EF96              adiw R28,63
 18DE 2796              adiw R28,7  ; offset = 70
 18E0 0E940000          xcall pop_xgsetF0FC
 18E4 2496              adiw R28,4
 18E6 0895              ret
 18E8                   .dbsym r BytePerClus 10 i
 18E8                   .dbsym r ClusNum 14 i
 18E8                   .dbsym l SecPerClus 68 i
 18E8                   .dbsym l ClusIDValue 54 l
 18E8                   .dbsym l length 50 l
 18E8                   .dbsym r Index 12 i
 18E8                   .dbsym l ClusNext 46 l
 18E8                   .dbsym l LBA 42 l
 18E8                   .dbsym l i 38 l
 18E8                   .dbsym l FileDir 8 S[.7]
 18E8                   .dbsym l ClusID 4 l
 18E8                   .dbsym l data 66 pc
 18E8                   .dbsym r m 10 i
 18E8                   .dbsym r Data 10 pV
 18E8                   .dbsym l Length 88 l
 18E8                   .dbsym l Start 84 l
 18E8                   .dbsym r Name 12 pc
 18E8                   .dbsym l Write 80 c
 18E8                   .dbend
 18E8                   .dbfunc e FormatCard _FormatCard fV
 18E8           ;      FatSecNum -> R12,R13
 18E8           ;       FatStart -> R10,R11
 18E8           ;      DirSecNum -> R10,R11
 18E8           ;       DirStart -> R12,R13
 18E8           ;              i -> R20,R21
                        .even
 18E8           _FormatCard::
 18E8 0E940000          xcall push_xgset303C
 18EC                   .dbline -1
 18EC                   .dbline 954
 18EC           ;       }
 18EC           ; 
 18EC           ; /***********************************************************************
 18EC           ; 函数功能：格式化磁盘
 18EC           ; 操作内容：1、不是真正意义上的格式化，只是清除根目录
 18EC           ;           2、实际文件的数据依然存在
 18EC           ; ***********************************************************************/
 18EC           ; 
 18EC           ; void FormatCard(void)
 18EC           ; {
 18EC                   .dbline 959
 18EC           ;     uint16 i,DirStart,DirSecNum,FatStart,FatSecNum;
 18EC           ;    
 18EC           ;     //ReadBPB();
 18EC           ; 
 18EC           ;     for(i = 0; i < 512;i++ )BUFFER[i]=0;                  //清除根目录，填入数据0
 18EC 4427              clr R20
 18EE 5527              clr R21
 18F0 09C0              xjmp L225
 18F2           L222:
 18F2                   .dbline 959
 18F2 80E0              ldi R24,<_BUFFER
 18F4 90E0              ldi R25,>_BUFFER
 18F6 FA01              movw R30,R20
 18F8 E80F              add R30,R24
 18FA F91F              adc R31,R25
 18FC 2224              clr R2
 18FE 2082              std z+0,R2
 1900           L223:
 1900                   .dbline 959
 1900 4F5F              subi R20,255  ; offset = 1
 1902 5F4F              sbci R21,255
 1904           L225:
 1904                   .dbline 959
 1904 4030              cpi R20,0
 1906 E2E0              ldi R30,2
 1908 5E07              cpc R21,R30
 190A 98F3              brlo L222
 190C           X58:
 190C                   .dbline 960
 190C           ;     DirSecNum = GetDirSecCount();                          //FAT16的根目录项数位512，占32个扇区，FAT32根目录项数不定
 190C 0E94B701          xcall _GetDirSecCount
 1910 5801              movw R10,R16
 1912                   .dbline 961
 1912           ;     DirStart = DirStartSec();                              //获取根目录开始地址
 1912 0E945701          xcall _DirStartSec
 1916 6801              movw R12,R16
 1918                   .dbline 962
 1918           ;     for(i=0;i<DirSecNum;i++)                               //按扇区依次填入0
 1918 4427              clr R20
 191A 5527              clr R21
 191C 09C0              xjmp L229
 191E           L226:
 191E                   .dbline 963
 191E           ;     {
 191E                   .dbline 964
 191E           ;       WriteBlock(DirStart+i);
 191E 8601              movw R16,R12
 1920 040F              add R16,R20
 1922 151F              adc R17,R21
 1924 2227              clr R18
 1926 3327              clr R19
 1928 0E941300          xcall _WriteBlock
 192C                   .dbline 965
 192C           ;     }
 192C           L227:
 192C                   .dbline 962
 192C 4F5F              subi R20,255  ; offset = 1
 192E 5F4F              sbci R21,255
 1930           L229:
 1930                   .dbline 962
 1930 4A15              cp R20,R10
 1932 5B05              cpc R21,R11
 1934 A0F3              brlo L226
 1936           X59:
 1936                   .dbline 968
 1936           ;  
 1936           ; 
 1936           ;     FatStart = BPB_HiddSec + BPB_RsvdSecCnt;              //清除FAT表
 1936 20901600          lds R2,_BPB_RsvdSecCnt
 193A 30901700          lds R3,_BPB_RsvdSecCnt+1
 193E 4424              clr R4
 1940 5524              clr R5
 1942 80900D00          lds R8,_BPB_HiddSec+2
 1946 90900E00          lds R9,_BPB_HiddSec+2+1
 194A 60900B00          lds R6,_BPB_HiddSec
 194E 70900C00          lds R7,_BPB_HiddSec+1
 1952 620C              add R6,R2
 1954 731C              adc R7,R3
 1956 841C              adc R8,R4
 1958 951C              adc R9,R5
 195A 5301              movw R10,R6
 195C                   .dbline 969
 195C           ;     FatSecNum = BPB_FATSz16;                              //FAT表所占扇区数大小
 195C C0900F00          lds R12,_BPB_FATSz16
 1960 D0901000          lds R13,_BPB_FATSz16+1
 1964                   .dbline 970
 1964           ;     for(i=0;i<FatSecNum;i++)
 1964 4427              clr R20
 1966 5527              clr R21
 1968 09C0              xjmp L233
 196A           L230:
 196A                   .dbline 971
 196A           ;     {
 196A                   .dbline 972
 196A           ;       WriteBlock(FatStart+i);
 196A 8501              movw R16,R10
 196C 040F              add R16,R20
 196E 151F              adc R17,R21
 1970 2227              clr R18
 1972 3327              clr R19
 1974 0E941300          xcall _WriteBlock
 1978                   .dbline 973
 1978           ;     }
 1978           L231:
 1978                   .dbline 970
 1978 4F5F              subi R20,255  ; offset = 1
 197A 5F4F              sbci R21,255
 197C           L233:
 197C                   .dbline 970
 197C 4C15              cp R20,R12
 197E 5D05              cpc R21,R13
 1980 A0F3              brlo L230
 1982           X60:
 1982                   .dbline 974
 1982           ;     WriteFAT(0,0xfff8);                                   //FAT表的第一个字固定为0xfff8
 1982 28EF              ldi R18,65528
 1984 3FEF              ldi R19,255
 1986 0027              clr R16
 1988 1127              clr R17
 198A 0E946802          xcall _WriteFAT
 198E                   .dbline 975
 198E           ;     WriteFAT(1,0xffff);                                   //FAT表的第二个字固定为0xffff
 198E 2FEF              ldi R18,65535
 1990 3FEF              ldi R19,255
 1992 01E0              ldi R16,1
 1994 10E0              ldi R17,0
 1996 0E946802          xcall _WriteFAT
 199A                   .dbline 977
 199A           ; 
 199A           ;     CopyFAT();                                            //备份FAT表，保持与FAT1一致
 199A 6EDB              xcall _CopyFAT
 199C                   .dbline -2
 199C           L221:
 199C                   .dbline 0 ; func end
 199C 0C940000          xjmp pop_xgset303C
 19A0                   .dbsym r FatSecNum 12 i
 19A0                   .dbsym r FatStart 10 i
 19A0                   .dbsym r DirSecNum 10 i
 19A0                   .dbsym r DirStart 12 i
 19A0                   .dbsym r i 20 i
 19A0                   .dbend
 19A0                   .dbfunc e FileCountSearch _FileCountSearch fV
 19A0           ;       DirStart -> R10,R11
 19A0           ;      DirSecCut -> R22,R23
 19A0           ;              i -> R20,R21
 19A0           ;              m -> R12,R13
                        .even
 19A0           _FileCountSearch::
 19A0 0E940000          xcall push_xgsetF03C
 19A4                   .dbline -1
 19A4                   .dbline 989
 19A4           ;     
 19A4           ; 
 19A4           ; }
 19A4           ;        
 19A4           ; /***********************************************************************
 19A4           ; 函数功能：根目录下文件夹和文件数量搜索
 19A4           ; 操作内容：1、搜索根目录项的目录项数以及属性 
 19A4           ;           2、可以判断文件类型，如文件夹、txt文件、BMP文件、MP3文件等
 19A4           ;           3、返回文件数量
 19A4           ; ***********************************************************************/  
 19A4           ; void FileCountSearch(void)
 19A4           ; {/*
 19A4                   .dbline 999
 19A4           ;       uint16 BytePerClus, SecPerClus, ClusNum, ClusNext,ClusID,ClusIDValue ,m,Index;
 19A4           ;       uint32 LBA, i;
 19A4           ;       DIR FileDir;
 19A4           ;       SecPerClus = BPB_SecPerClus;
 19A4           ;       BytePerClus = BPB_SecPerClus * BPB_BytesPerSec;               //每簇的字节数
 19A4           ;       Index = GetFileID(Name, &FileDir);                            //文件根目录位置0～511
 19A4           ;   
 19A4           ;       */  
 19A4           ;         uint16 DirSecCut, DirStart, i, m;//, Count = 0;
 19A4           ;       DirSecCut = 32;                                               //根目录扇区总数，这里限制FAT16和FAT32都最多为512个根目录项
 19A4 60E2              ldi R22,32
 19A6 70E0              ldi R23,0
 19A8                   .dbline 1000
 19A8           ;       DirStart = DirStartSec();                                     //根目录开始扇区地址,FAT16为512
 19A8 0E945701          xcall _DirStartSec
 19AC 5801              movw R10,R16
 19AE                   .dbline 1001
 19AE           ;         DirectoryCount = 0,FileCount = 0;
 19AE 2224              clr R2
 19B0 3324              clr R3
 19B2 30920100          sts _DirectoryCount+1,R3
 19B6 20920000          sts _DirectoryCount,R2
 19BA 30920300          sts _FileCount+1,R3
 19BE 20920200          sts _FileCount,R2
 19C2                   .dbline 1002
 19C2           ;       for(i = 0; i < DirSecCut; i++)                                //在整个扇区空间搜索
 19C2 4427              clr R20
 19C4 5527              clr R21
 19C6 55C0              xjmp L238
 19C8           L235:
 19C8                   .dbline 1003
 19C8           ;       {
 19C8                   .dbline 1004
 19C8           ;               ReadBlock(DirStart + i);                              //读根目录扇区
 19C8 8501              movw R16,R10
 19CA 040F              add R16,R20
 19CC 151F              adc R17,R21
 19CE 2227              clr R18
 19D0 3327              clr R19
 19D2 0E940000          xcall _ReadBlock
 19D6                   .dbline 1005
 19D6           ;               for(m = 0; m < 16; m++)
 19D6 CC24              clr R12
 19D8 DD24              clr R13
 19DA 43C0              xjmp L242
 19DC           L239:
 19DC                   .dbline 1006
 19DC           ;               {
 19DC                   .dbline 1007
 19DC           ;                       if((BUFFER[m * 32] != 0) && (BUFFER[m * 32] != 0xe5))//搜索为0x00区域或者0xe5区域，根目录为32位长度的”文件“
 19DC 00E2              ldi R16,32
 19DE 10E0              ldi R17,0
 19E0 9601              movw R18,R12
 19E2 0E940000          xcall empy16s
 19E6 80E0              ldi R24,<_BUFFER
 19E8 90E0              ldi R25,>_BUFFER
 19EA F801              movw R30,R16
 19EC E80F              add R30,R24
 19EE F91F              adc R31,R25
 19F0 2080              ldd R2,z+0
 19F2 3324              clr R3
 19F4 2220              tst R2
 19F6 09F4              brne X67
 19F8 31C0              xjmp L243
 19FA           X67:
 19FA           X61:
 19FA 822D              mov R24,R2
 19FC 853E              cpi R24,229
 19FE 71F1              breq L243
 1A00           X62:
 1A00                   .dbline 1008
 1A00           ;                         {
 1A00                   .dbline 1009
 1A00           ;                           if(BUFFER[m * 32+11] == 0x10)               //0x10为文件夹
 1A00 00E2              ldi R16,32
 1A02 10E0              ldi R17,0
 1A04 9601              movw R18,R12
 1A06 0E940000          xcall empy16s
 1A0A F801              movw R30,R16
 1A0C 3B96              adiw R30,11
 1A0E 80E0              ldi R24,<_BUFFER
 1A10 90E0              ldi R25,>_BUFFER
 1A12 E80F              add R30,R24
 1A14 F91F              adc R31,R25
 1A16 8081              ldd R24,z+0
 1A18 8031              cpi R24,16
 1A1A 49F4              brne L245
 1A1C           X63:
 1A1C                   .dbline 1010
 1A1C           ;                             DirectoryCount++;
 1A1C 80910000          lds R24,_DirectoryCount
 1A20 90910100          lds R25,_DirectoryCount+1
 1A24 0196              adiw R24,1
 1A26 90930100          sts _DirectoryCount+1,R25
 1A2A 80930000          sts _DirectoryCount,R24
 1A2E           L245:
 1A2E                   .dbline 1011
 1A2E           ;                           if(BUFFER[m * 32+11] == 0x20)               //0x20为文件
 1A2E 00E2              ldi R16,32
 1A30 10E0              ldi R17,0
 1A32 9601              movw R18,R12
 1A34 0E940000          xcall empy16s
 1A38 F801              movw R30,R16
 1A3A 3B96              adiw R30,11
 1A3C 80E0              ldi R24,<_BUFFER
 1A3E 90E0              ldi R25,>_BUFFER
 1A40 E80F              add R30,R24
 1A42 F91F              adc R31,R25
 1A44 8081              ldd R24,z+0
 1A46 8032              cpi R24,32
 1A48 49F4              brne L247
 1A4A           X64:
 1A4A                   .dbline 1012
 1A4A           ;                             FileCount++;
 1A4A 80910200          lds R24,_FileCount
 1A4E 90910300          lds R25,_FileCount+1
 1A52 0196              adiw R24,1
 1A54 90930300          sts _FileCount+1,R25
 1A58 80930200          sts _FileCount,R24
 1A5C           L247:
 1A5C                   .dbline 1015
 1A5C           ;                         //  else
 1A5C           ;                             //Count=0;
 1A5C           ;                       }
 1A5C           L243:
 1A5C                   .dbline 1016
 1A5C           ;               }
 1A5C           L240:
 1A5C                   .dbline 1005
 1A5C C601              movw R24,R12
 1A5E 0196              adiw R24,1
 1A60 6C01              movw R12,R24
 1A62           L242:
 1A62                   .dbline 1005
 1A62 C601              movw R24,R12
 1A64 8031              cpi R24,16
 1A66 E0E0              ldi R30,0
 1A68 9E07              cpc R25,R30
 1A6A 08F4              brsh X68
 1A6C B7CF              xjmp L239
 1A6E           X68:
 1A6E           X65:
 1A6E                   .dbline 1017
 1A6E           ;       }
 1A6E           L236:
 1A6E                   .dbline 1002
 1A6E 4F5F              subi R20,255  ; offset = 1
 1A70 5F4F              sbci R21,255
 1A72           L238:
 1A72                   .dbline 1002
 1A72 4617              cp R20,R22
 1A74 5707              cpc R21,R23
 1A76 08F4              brsh X69
 1A78 A7CF              xjmp L235
 1A7A           X69:
 1A7A           X66:
 1A7A                   .dbline -2
 1A7A           L234:
 1A7A                   .dbline 0 ; func end
 1A7A 0C940000          xjmp pop_xgsetF03C
 1A7E                   .dbsym r DirStart 10 i
 1A7E                   .dbsym r DirSecCut 22 i
 1A7E                   .dbsym r i 20 i
 1A7E                   .dbsym r m 12 i
 1A7E                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile E:\DMAVR-~3\FAT-NE~1\FAT.C
 0000           _FAT32_EN::
 0000                   .blkb 1
 0001                   .dbsym e FAT32_EN _FAT32_EN c
 0001           _BPB_FSInfo::
 0001                   .blkb 2
 0003                   .dbsym e BPB_FSInfo _BPB_FSInfo i
 0003           _BPB_RootClus::
 0003                   .blkb 4
 0007                   .dbsym e BPB_RootClus _BPB_RootClus l
 0007           _BPB_FATSz32::
 0007                   .blkb 4
 000B                   .dbsym e BPB_FATSz32 _BPB_FATSz32 l
 000B           _BPB_HiddSec::
 000B                   .blkb 4
 000F                   .dbsym e BPB_HiddSec _BPB_HiddSec l
 000F           _BPB_FATSz16::
 000F                   .blkb 2
 0011                   .dbsym e BPB_FATSz16 _BPB_FATSz16 i
 0011           _BPB_TotSec16::
 0011                   .blkb 2
 0013                   .dbsym e BPB_TotSec16 _BPB_TotSec16 i
 0013           _BPB_RootEntCnt::
 0013                   .blkb 2
 0015                   .dbsym e BPB_RootEntCnt _BPB_RootEntCnt i
 0015           _BPB_NumFATs::
 0015                   .blkb 1
 0016                   .dbsym e BPB_NumFATs _BPB_NumFATs c
 0016           _BPB_RsvdSecCnt::
 0016                   .blkb 2
 0018                   .dbsym e BPB_RsvdSecCnt _BPB_RsvdSecCnt i
 0018           _BPB_SecPerClus::
 0018                   .blkb 1
 0019                   .dbsym e BPB_SecPerClus _BPB_SecPerClus c
 0019           _BPB_BytesPerSec::
 0019                   .blkb 2
 001B                   .dbsym e BPB_BytesPerSec _BPB_BytesPerSec i
 001B           ; }
