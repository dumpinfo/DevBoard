//DMAVR-128的温度传感器DS18B20控制程序，显示环境温度
//DS18b20的C语言驱动程序，三位数码管显示，读取当前环境温度，精度达0.1度，温度范围0-99度
//DS18B20 详细引脚功能描述1、GND 地信号；2、DQ数据输入出引脚。开漏单总线接口引脚。当被用在寄生电源下
//也可以向器件提供电源；3、VDD可选择的VDD 引脚。当工作于寄生电源时，此引脚必须接地。
//DS18B20 的使用方法。DS18B20 采用的是1－Wire 总线协议方式
//即在一根数据线实现数据的双向传输
//编译环境 AVR Studio 4.17/AVR GCC
//系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
//作者：阿迪 www.avrgcc.com
//日期：2010.01.14
//***********************************************************************
//			包含文件
//***********************************************************************

#include <string.h>
#include <stdio.h>
#define	 F_CPU	7372800		/* 单片机主频为7.3728MHz,用于延时子程序 */
#include <util/delay.h>
#include <avr/io.h>
#include <avr/iom128.h>

//***********************************************************************
//			定义变量区
//***********************************************************************

#define delay_us(x)     _delay_us(x)         //AVR GCC延时函数 x(us)
#define delay_ms(x)     _delay_ms(x)         //AVR GCC延时函数 x(ms)

#define uchar           unsigned char
#define uint            unsigned int

#define Data_IO	        PORTA                //数码管数据口
#define Data_DDR        DDRA                 //数码管数据口方向寄存器
#define D_LE0	        PORTD &= ~(1 << PD4) //数码管段控制位为0，锁存端口数据
#define D_LE1           PORTD |= (1 << PD4)  //数码管段控制位为1，锁存器输出与端口一致
#define W_LE0	        PORTD &= ~(1 << PD5) //数码管位控制位为0
#define W_LE1           PORTD |= (1 << PD5)  //数码管位控制位为1

#define DQ_IN	        DDRC &= ~(1 << PE4)		//设置输入
#define DQ_OUT	        DDRC |= (1 << PE4)		//设置输出
#define DQ_CLR	        PORTC &= ~(1 << PE4)	//置低电平
#define DQ_SET	        PORTC |= (1 << PE4)		//置高电平
#define DQ_R	        PINC & (1 << PE4)		//读电平

uchar key;
uint temp_value;
uint temp,A1,A2,A3;             		      //定义的变量,显示数据处理
uchar flag1; 

//***********************************************************************
//			共阴数码管显示的断码表0～F
//***********************************************************************

uchar table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

//***********************************************************************
//			IO端口初始化
//***********************************************************************

void system_init()
{
    Data_IO=0xFF;             //数据口为输出
    Data_DDR=0xFF;

    PORTD=0xFF;               //74HC573的控制口，设置为输出
    DDRD=0xFF;
}

//*************************************************************************
//			74HC573控制数码管动态扫描显示函数
//*************************************************************************

void Display_DS18B20(uint data_b,uint data_s,uint data_g)
{
	 uchar i,j;
	 system_init();
     j=0x01;                    //此数据用来控制位选
 for(i=0;i<5;i++)
  {
     D_LE1;                    //控制数码管段数据的74HC573的LE管脚置高
     W_LE1;                    //控制数码管位的74HC573的LE管脚置高
     Data_IO=~j;               //设置要显示的位，也就是哪一个数码管亮，这里是八个一起显示
     W_LE0;                    //锁存位数据，下面送上段数据以后，就显示出来了
	 j=(j<<1);
     Data_IO=0x00;         //送要显示的数据，就是段数据，如显示0送的是0x3f
     D_LE0;                    //锁存段数据，数码管亮一个时间片刻
     delay_ms(1);              //显示一个时间片刻，会影响亮度和闪烁性
  }
     D_LE1;                    //控制数码管段数据的74HC573的LE管脚置高
     W_LE1;                    //控制数码管位的74HC573的LE管脚置高
     Data_IO=~j;               //设置要显示的位，也就是哪一个数码管亮，这里是八个一起显示
     W_LE0;                    //锁存位数据，下面送上段数据以后，就显示出来了
	 j=(j<<1);
     Data_IO=table[A1];         //送要显示的数据，就是段数据，如显示0送的是0x3f
     D_LE0;                    //锁存段数据，数码管亮一个时间片刻
     delay_ms(1);              //显示一个时间片刻，会影响亮度和闪烁性

     D_LE1;                    //控制数码管段数据的74HC573的LE管脚置高
     W_LE1;                    //控制数码管位的74HC573的LE管脚置高
     Data_IO=~j;               //设置要显示的位，也就是哪一个数码管亮，这里是八个一起显示
     W_LE0;                    //锁存位数据，下面送上段数据以后，就显示出来了
	 j=(j<<1);
     Data_IO=table[A2]|0x80;         //送要显示的数据，就是段数据，如显示0送的是0x3f
     D_LE0;                    //锁存段数据，数码管亮一个时间片刻
     delay_ms(1);              //显示一个时间片刻，会影响亮度和闪烁性

	 D_LE1;                    //控制数码管段数据的74HC573的LE管脚置高
     W_LE1;                    //控制数码管位的74HC573的LE管脚置高
     Data_IO=~j;               //设置要显示的位，也就是哪一个数码管亮，这里是八个一起显示
     W_LE0;                    //锁存位数据，下面送上段数据以后，就显示出来了
	 j=(j<<1);
     Data_IO=table[A3];         //送要显示的数据，就是段数据，如显示0送的是0x3f
     D_LE0;                    //锁存段数据，数码管亮一个时间片刻
     delay_ms(1);              //显示一个时间片刻，会影响亮度和闪烁性

}


//************************************************************************* 
//			DS18B20初始化
//*************************************************************************

unsigned char ds1820_reset(void)                 //初始化和复位

{
unsigned char i;
        DQ_OUT;
	DQ_CLR;
	delay_us(500);				//延时500uS(480-960)
	DQ_SET;
	DQ_IN;
	delay_us(80);				//延时80uS
	i = DQ_R;
	delay_us(500);				//延时500uS(保持>480uS)
	
	if (i) 
        {
		return 0x00;
		
        }
	else 
        {
		return 0x01;
		
        }

}


//************************************************************************* 
//			DS18B20读一个字节函数
//************************************************************************* 
   
unsigned char ds1820_read_byte(void) 
{

	unsigned char i;
	unsigned char value = 0;
	for (i = 8; i != 0; i--) 
        {
		value >>= 1;
		DQ_OUT;
		DQ_CLR;
                delay_us(4);				//*延时4uS
		
		DQ_SET;
		DQ_IN;
                delay_us(10);				//*延时10uS
		
		if (DQ_R) 
                {
			value|=0x80;
			
                }
		delay_us(60);			       //*延时60uS
		
        }
	
	return(value);
}

//************************************************************************* 
//			向18B20写一个字节函数
//*************************************************************************  

/*DS18B20字节写入函数*/
void ds1820_write_byte(unsigned char value) 
{

	unsigned char i;
	for (i = 8; i != 0; i--) 
        {
		DQ_OUT;
		DQ_CLR;
                delay_us(4);			//延时4uS
		if (value & 0x01) 
                {
			DQ_SET;
			
                }
		delay_us(80);			//延时80uS
		DQ_SET;			        //位结束
		value >>= 1;
		
        }
	
}
//*************************************************************************
//				发送温度转换命令
//************************************************************************* 

/*启动ds1820转换*/
void ds1820_start(void) {

	ds1820_reset();
	ds1820_write_byte(0xCC);	//勿略地址
	ds1820_write_byte(0x44);	//启动转换
}

//*************************************************************************
//				DS8B20读取温度信息
//************************************************************************* 

unsigned int ds1820_read_temp(void) 
{

	unsigned int i;
	unsigned char buf[9];

	ds1820_reset();
	ds1820_write_byte(0xCC);	//勿略地址
	ds1820_write_byte(0xBE);	//读取温度
	for (i = 0; i < 9; i++) 
        {
		buf[i] = ds1820_read_byte();
		
        }
	i = buf[1];
	i <<= 8;
	i |= buf[0];
	temp_value=i;
        temp_value=temp_value*0.625;    //不是乘以0.0625的原因是为了把小数点后一位数据也转化为可以显示的数据
		                        //比如温度本身为27.5度，为了在后续的数据处理程序中得到BCD码，我们先放大到275
                                        //然后在显示的时候确定小数点的位置即可，就能显示出27.5度了
        //temp_value=temp_value*10;
	return i;
}



//*************************************************************************
//		温度数据处理函数
//*************************************************************************
 void data_do(uint temp_d)
 {
     uint A2t;
     A1=temp_d/100;                       //分出百，十，和个位
     A2t=temp_d%100;
     A2=A2t/10;
     A3=A2t%10;
}

//*************************************************************************
//			主程序
//*************************************************************************

void main(void)
{
    uint j;
	DDRE = 0x00;
	PORTE = 0xFF;
	system_init();                         //系统初始化
	delay_ms(250); 
	ds1820_reset();			      //复位D18B20
	while (1)
        {
		ds1820_start();		       //启动一次转换
		delay_ms(300);			//等待转换结束
		ds1820_read_temp();		//读取温度数值
        data_do(temp_value);            //处理数据，得到要显示的值
//for(j=0;j<100;j++)
//{	    
		Display_DS18B20(A1,A2,A3);              //显示温度值

	//	}
	    delay_ms(1000);                 //延时1S
		
        }
}
