__text_start:
__start:
    07BB EFCF      LDI	R28,0xFF
    07BC E1D0      LDI	R29,0x10
    07BD BFCD      OUT	0x3D,R28
    07BE BFDE      OUT	0x3E,R29
    07BF 51CE      SUBI	R28,0x1E
    07C0 40D0      SBCI	R29,0
    07C1 EA0A      LDI	R16,0xAA
    07C2 8308      STD	Y+0,R16
    07C3 2400      CLR	R0
    07C4 EEE3      LDI	R30,0xE3
    07C5 E0FE      LDI	R31,0xE
    07C6 E01F      LDI	R17,0xF
    07C7 33E9      CPI	R30,0x39
    07C8 07F1      CPC	R31,R17
    07C9 F011      BEQ	0x07CC
    07CA 9201      ST	R0,Z+
    07CB CFFB      RJMP	0x07C7
    07CC 8300      STD	Z+0,R16
    07CD E9E3      LDI	R30,0x93
    07CE E0F1      LDI	R31,1
    07CF E0A0      LDI	R26,0
    07D0 E0B1      LDI	R27,1
    07D1 E01F      LDI	R17,0xF
    07D2 37E6      CPI	R30,0x76
    07D3 07F1      CPC	R31,R17
    07D4 F021      BEQ	0x07D9
    07D5 95C8      LPM
    07D6 9631      ADIW	R30,1
    07D7 920D      ST	R0,X+
    07D8 CFF9      RJMP	0x07D2
    07D9 940E0B05  CALL	_main
_exit:
    07DB CFFF      RJMP	_exit
FILE: C:\icc\include\delay.h
(0001) //********************************************************************
(0002) /*函 数 名：delay_us
(0003) 建立日期：2010年1月28日
(0004) 编译环境：ICCAVR7.16A
(0005) 函数作用：微秒级的延时程序
(0006) 说    明：7.3728M晶振下
(0007) ********************************************************************/
(0008) void delay_1us(void);
(0009) void delay_3us(void);
(0010) void delay_10us(void);
(0011) void delay_50us(void);
(0012) void delay_100us(void);
(0013) void delay_n100us(unsigned char n100us);
(0014) void delay_1ms(void);
(0015) void delay_nms(unsigned int nms);
(0016) void delay_ns(unsigned char ns);
(0017) 
(0018) 
(0019) void delay_1us(void)                 //1us延时函数，不能连续调用， 
(0020) { 
(0021)    asm("nop");                       //1时钟周期
_delay_1us:
    07DC 0000      NOP
(0022)    asm("nop");
    07DD 0000      NOP
(0023)    asm("nop");
    07DE 0000      NOP
(0024)    asm("nop");
    07DF 0000      NOP
(0025)    asm("nop");                       //1T
    07E0 0000      NOP
(0026)    asm("nop");
    07E1 0000      NOP
    07E2 9508      RET
(0027) 
(0028) }
(0029) void delay_3us(void)                 //3us延时函数,,可重复调用不影响精度
(0030) { 
(0031)    
(0032)    asm("nop");
_delay_3us:
    07E3 0000      NOP
(0033)    asm("nop");
    07E4 0000      NOP
(0034)    asm("nop");                       
    07E5 0000      NOP
(0035)    asm("nop");
    07E6 0000      NOP
(0036)    asm("nop");
    07E7 0000      NOP
(0037)    asm("nop");
    07E8 0000      NOP
(0038)    asm("nop");                       
    07E9 0000      NOP
(0039)    asm("nop");
    07EA 0000      NOP
(0040)    asm("nop");
    07EB 0000      NOP
(0041)    asm("nop");
    07EC 0000      NOP
(0042)    asm("nop");                       
    07ED 0000      NOP
(0043)    asm("nop");
    07EE 0000      NOP
(0044)    asm("nop");
    07EF 0000      NOP
(0045)    asm("nop");
    07F0 0000      NOP
(0046)    asm("nop");                       
    07F1 0000      NOP
(0047)    asm("nop");
    07F2 0000      NOP
(0048)    asm("nop");
    07F3 0000      NOP
(0049)    asm("nop");
    07F4 0000      NOP
(0050)    asm("nop");
    07F5 0000      NOP
(0051)    asm("nop");
    07F6 0000      NOP
(0052)    asm("nop");                       
    07F7 0000      NOP
    07F8 9508      RET
(0053) } 
(0054) 
(0055) void delay_10us(void)                 //10us延时函数,,可重复调用不影响精度
(0056) {
(0057)    delay_3us();
_delay_10us:
    07F9 DFE9      RCALL	_delay_3us
(0058)    delay_3us(); 
    07FA DFE8      RCALL	_delay_3us
(0059)    delay_3us();  
    07FB DFE7      RCALL	_delay_3us
    07FC 9508      RET
(0060) }
(0061)   
(0062) void delay_50us(void)                 //48us延时函数,,可重复调用不影响精度
(0063) { 
(0064)    delay_10us();
_delay_50us:
    07FD DFFB      RCALL	_delay_10us
(0065)    delay_10us(); 
    07FE DFFA      RCALL	_delay_10us
(0066)    delay_10us();
    07FF DFF9      RCALL	_delay_10us
(0067)    delay_10us();
    0800 DFF8      RCALL	_delay_10us
    0801 9508      RET
(0068) }
(0069) void delay_100us(void)     //exactly 98us延时函数,,可重复调用不影响精度
(0070) {
(0071)  delay_50us();
_delay_100us:
    0802 DFFA      RCALL	_delay_50us
(0072)  delay_50us();
    0803 DFF9      RCALL	_delay_50us
    0804 9508      RET
_delay_n100us:
  n100us               --> R20
    0805 940E23DA  CALL	push_gset1
    0807 2F40      MOV	R20,R16
(0073) }
(0074) void delay_n100us(unsigned char n100us)
(0075) {
    0808 C001      RJMP	0x080A
(0076)  while(n100us--)                          
(0077)  delay_100us();
    0809 DFF8      RCALL	_delay_100us
    080A 2E24      MOV	R2,R20
    080B 2433      CLR	R3
    080C 5041      SUBI	R20,1
    080D 2022      TST	R2
    080E F7D1      BNE	0x0809
    080F 940E23DD  CALL	pop_gset1
    0811 9508      RET
(0078) }
(0079) /*delay_n100us(2)        250us
(0080) delay_n100us(3)          360us
(0081) delay_n100us(4)          470us
(0082) delay_n100us(5)          580us
(0083) delay_n100us(6)          690us
(0084) delay_n100us(7)       800us
(0085) delay_n100us(8)          900us              主要是由于函数声明及while,,,大概6us
(0086) 
(0087) */
(0088) void delay_1ms()
(0089) {
(0090)  delay_100us();
_delay_1ms:
    0812 DFEF      RCALL	_delay_100us
(0091)  delay_100us();
    0813 DFEE      RCALL	_delay_100us
(0092)  delay_100us();
    0814 DFED      RCALL	_delay_100us
(0093)  delay_100us();
    0815 DFEC      RCALL	_delay_100us
(0094)  delay_100us();
    0816 DFEB      RCALL	_delay_100us
(0095)  delay_100us();
    0817 DFEA      RCALL	_delay_100us
(0096)  delay_100us();
    0818 DFE9      RCALL	_delay_100us
(0097)  delay_100us();
    0819 DFE8      RCALL	_delay_100us
(0098)  delay_100us();
    081A DFE7      RCALL	_delay_100us
(0099)  delay_100us();
    081B DFE6      RCALL	_delay_100us
    081C 9508      RET
_delay_nms:
  nms                  --> R20
    081D 940E23DA  CALL	push_gset1
    081F 01A8      MOVW	R20,R16
(0100) }
(0101) /********************************************************************
(0102) 函 数 名：Delay_ms
(0103) 建立日期：2010年1月28日
(0104) 修改日期：
(0105) 函数作用：毫秒级的精确延时程序
(0106) 说    明：
(0107) ********************************************************************/
(0108) void delay_nms(unsigned int nms)
(0109) {
    0820 C001      RJMP	0x0822
(0110)  while(nms--) 
(0111)  delay_1ms();
    0821 DFF0      RCALL	_delay_1ms
    0822 011A      MOVW	R2,R20
    0823 5041      SUBI	R20,1
    0824 4050      SBCI	R21,0
    0825 2022      TST	R2
    0826 F7D1      BNE	0x0821
    0827 2033      TST	R3
    0828 F7C1      BNE	0x0821
    0829 940E23DD  CALL	pop_gset1
    082B 9508      RET
_delay_ns:
  ns                   --> R20
    082C 940E23DA  CALL	push_gset1
    082E 2F40      MOV	R20,R16
(0112) }
(0113) void delay_ns(unsigned char ns)
(0114) {
    082F C003      RJMP	0x0833
(0115)  while(ns--) 
(0116)  delay_nms(1000);
    0830 EE08      LDI	R16,0xE8
    0831 E013      LDI	R17,3
    0832 DFEA      RCALL	_delay_nms
    0833 2E24      MOV	R2,R20
    0834 2433      CLR	R3
    0835 5041      SUBI	R20,1
    0836 2022      TST	R2
    0837 F7C1      BNE	0x0830
    0838 940E23DD  CALL	pop_gset1
    083A 9508      RET
_disp_image:
  FileInfo             --> Y+41
  type                 --> Y+40
  BMPInfo              --> Y+8
  byte3                --> Y+71
  byte2                --> R10
  byte1                --> Y+70
  p                    --> Y+4
  first                --> Y+69
  i                    --> Y+67
  tmp_color            --> R14
  buffer               --> Y+65
  y                    --> Y+63
  color                --> R12
  x                    --> Y+62
  count                --> Y+60
  color_byte           --> Y+59
  rgb                  --> Y+58
    083B 940E23D2  CALL	push_gset5
    083D 97EF      SBIW	R28,0x3F
    083E 9729      SBIW	R28,0x9
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\main.c
(0001) //ATMEGA128读取SD卡中BMP图片实验，基于FAT16/32文件系统
(0002) //SD卡中图片文件为BMP形式，用Img2LCD将JPG图片转换为24位BMP图形式即可
(0003) //编译环境 ICCAVR 7.16A
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //忠兴电子元件店
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <BMP_main.h>
(0012) 
(0013) int i;
(0014) WORD image_count = 0 ,image_all = 0 ;
(0015) 
(0016) extern u16 SectorsPerClust;//每簇扇区数
(0017) 
(0018) extern u08  FAT32_Enable;
(0019)  extern char _bss_end;
(0020) 
(0021) //***********************************************************************
(0022) //			显示图片函数，每张图片轮流显示，文件位于根目录下，24位色
(0023) //***********************************************************************
(0024) void disp_image(void)
(0025)   {
(0026)     WORD count= 1 ,i =0   ;
    083F E081      LDI	R24,1
    0840 E090      LDI	R25,0
    0841 AF9D      STD	Y+61,R25
    0842 AF8C      STD	Y+60,R24
    0843 2400      CLR	R0
    0844 2411      CLR	R1
    0845 01FE      MOVW	R30,R28
    0846 5BED      SUBI	R30,0xBD
    0847 4FFF      SBCI	R31,0xFF
    0848 8211      STD	Z+1,R1
    0849 8200      STD	Z+0,R0
(0027) 	u08 *buffer ;
(0028) 	u08 type ,x , rgb,first ,color_byte,byte1,byte2,byte3 ;
(0029) 	u16 y ,color,tmp_color ;
(0030)     u32 p;							//簇指示值		
(0031) 	struct FileInfoStruct FileInfo;	//文件信息	
(0032) 	struct direntry BMPInfo;		//要显示的BMP文件信息	
(0033) 	type = 1 ;
    084A A788      STD	Y+40,R24
(0034) 	
(0035) 	
(0036) 	
(0037) 	
(0038) 	if( image_all == 0 )    		//读取总图片数
    084B 90200102  LDS	R2,image_all
    084D 90300103  LDS	R3,image_all+1
    084F 2022      TST	R2
    0850 F009      BEQ	0x0852
    0851 C065      RJMP	0x08B7
    0852 2033      TST	R3
    0853 F009      BEQ	0x0855
    0854 C062      RJMP	0x08B7
(0039) 	  {
(0040)          image_count =  0 ;
    0855 2422      CLR	R2
    0856 2433      CLR	R3
    0857 92300101  STS	image_count+1,R3
    0859 92200100  STS	image_count,R2
(0041) 	     byte1 = Search(&BMPInfo,&image_count,&type) ;
    085B 01CE      MOVW	R24,R28
    085C 9688      ADIW	R24,0x28
    085D 8399      STD	Y+1,R25
    085E 8388      STD	Y+0,R24
    085F E020      LDI	R18,0
    0860 E031      LDI	R19,1
    0861 018E      MOVW	R16,R28
    0862 5F08      SUBI	R16,0xF8
    0863 4F1F      SBCI	R17,0xFF
    0864 940E13BB  CALL	_Search
    0866 01FE      MOVW	R30,R28
    0867 5BEA      SUBI	R30,0xBA
    0868 4FFF      SBCI	R31,0xFF
    0869 8300      STD	Z+0,R16
(0042) 		 image_all = image_count ;
    086A 90200100  LDS	R2,image_count
    086C 90300101  LDS	R3,image_count+1
    086E 92300103  STS	image_all+1,R3
    0870 92200102  STS	image_all,R2
(0043)  		 DisplayChar(image_all/10+'0',8,9,0xffff);  //BMP图片数量显示
    0872 EF8F      LDI	R24,0xFF
    0873 EF9F      LDI	R25,0xFF
    0874 839B      STD	Y+3,R25
    0875 838A      STD	Y+2,R24
    0876 E089      LDI	R24,0x9
    0877 8388      STD	Y+0,R24
    0878 E028      LDI	R18,0x8
    0879 E08A      LDI	R24,0xA
    087A E090      LDI	R25,0
    087B 91000102  LDS	R16,image_all
    087D 91100103  LDS	R17,image_all+1
    087F 932F      PUSH	R18
    0880 933F      PUSH	R19
    0881 019C      MOVW	R18,R24
    0882 940E22FB  CALL	div16u
    0884 913F      POP	R19
    0885 912F      POP	R18
    0886 5D00      SUBI	R16,0xD0
    0887 4F1F      SBCI	R17,0xFF
    0888 940E1A52  CALL	_DisplayChar
(0044) 		 DisplayChar(image_all%10+'0',9,9,0xffff);  //BMP图片数量显示
    088A EF8F      LDI	R24,0xFF
    088B EF9F      LDI	R25,0xFF
    088C 839B      STD	Y+3,R25
    088D 838A      STD	Y+2,R24
    088E E089      LDI	R24,0x9
    088F 8388      STD	Y+0,R24
    0890 E029      LDI	R18,0x9
    0891 E08A      LDI	R24,0xA
    0892 E090      LDI	R25,0
    0893 91000102  LDS	R16,image_all
    0895 91100103  LDS	R17,image_all+1
    0897 932F      PUSH	R18
    0898 933F      PUSH	R19
    0899 019C      MOVW	R18,R24
    089A 940E22F9  CALL	mod16u
    089C 913F      POP	R19
    089D 912F      POP	R18
    089E 5D00      SUBI	R16,0xD0
    089F 4F1F      SBCI	R17,0xFF
    08A0 940E1A52  CALL	_DisplayChar
(0045) 		 DisplayString("       ",10,9,0xffff);  	//BMP图片数量，最大显示99张，可以更改算法
    08A2 EF8F      LDI	R24,0xFF
    08A3 EF9F      LDI	R25,0xFF
    08A4 839B      STD	Y+3,R25
    08A5 838A      STD	Y+2,R24
    08A6 E089      LDI	R24,0x9
    08A7 8388      STD	Y+0,R24
    08A8 E02A      LDI	R18,0xA
    08A9 E900      LDI	R16,0x90
    08AA E011      LDI	R17,1
    08AB 940E1B2A  CALL	_DisplayString
(0046) 		 delay_nms(1000);
    08AD EE08      LDI	R16,0xE8
    08AE E013      LDI	R17,3
    08AF DF6D      RCALL	_delay_nms
(0047) 		 image_count = 1 ;
    08B0 E081      LDI	R24,1
    08B1 E090      LDI	R25,0
    08B2 93900101  STS	image_count+1,R25
    08B4 93800100  STS	image_count,R24
(0048) 		 		 
(0049) 	  }
    08B6 C00F      RJMP	0x08C6
(0050) 	else  
(0051)       {		
(0052)           byte1 = Search(&BMPInfo,&image_count,&type) ;
    08B7 01CE      MOVW	R24,R28
    08B8 9688      ADIW	R24,0x28
    08B9 8399      STD	Y+1,R25
    08BA 8388      STD	Y+0,R24
    08BB E020      LDI	R18,0
    08BC E031      LDI	R19,1
    08BD 018E      MOVW	R16,R28
    08BE 5F08      SUBI	R16,0xF8
    08BF 4F1F      SBCI	R17,0xFF
    08C0 940E13BB  CALL	_Search
    08C2 01FE      MOVW	R30,R28
    08C3 5BEA      SUBI	R30,0xBA
    08C4 4FFF      SBCI	R31,0xFF
    08C5 8300      STD	Z+0,R16
(0053)       }	
(0054) 	 
(0055) 	 
(0056) 	 
(0057) 	p = BMPInfo.deStartCluster+(((u32)BMPInfo.deHighClust)<<16);//读文件首簇
    08C6 8C2C      LDD	R2,Y+28
    08C7 8C3D      LDD	R3,Y+29
    08C8 2444      CLR	R4
    08C9 2455      CLR	R5
    08CA 0121      MOVW	R4,R2
    08CB 2422      CLR	R2
    08CC 2433      CLR	R3
    08CD A06A      LDD	R6,Y+34
    08CE A07B      LDD	R7,Y+35
    08CF 2488      CLR	R8
    08D0 2499      CLR	R9
    08D1 0C62      ADD	R6,R2
    08D2 1C73      ADC	R7,R3
    08D3 1C84      ADC	R8,R4
    08D4 1C95      ADC	R9,R5
    08D5 01FE      MOVW	R30,R28
    08D6 8264      STD	Z+4,R6
    08D7 8275      STD	Z+5,R7
    08D8 8286      STD	Z+6,R8
    08D9 8297      STD	Z+7,R9
(0058) 	
(0059) 	x = 0 ;
    08DA 2400      CLR	R0
    08DB AE0E      STD	Y+62,R0
(0060) 	y = 159 ;
    08DC E98F      LDI	R24,0x9F
    08DD E090      LDI	R25,0
    08DE 01FE      MOVW	R30,R28
    08DF 96FF      ADIW	R30,0x3F
    08E0 8391      STD	Z+1,R25
    08E1 8380      STD	Z+0,R24
(0061) 	rgb = 0 ;
    08E2 AE0A      STD	Y+58,R0
(0062) 	count = 0 ;
    08E3 2411      CLR	R1
    08E4 AE1D      STD	Y+61,R1
    08E5 AE0C      STD	Y+60,R0
(0063) 	first = 0 ;
    08E6 01FE      MOVW	R30,R28
    08E7 5BEB      SUBI	R30,0xBB
    08E8 4FFF      SBCI	R31,0xFF
    08E9 8200      STD	Z+0,R0
(0064) 	buffer=malloc(512);	
    08EA E000      LDI	R16,0
    08EB E012      LDI	R17,2
    08EC 940E24AF  CALL	_malloc
    08EE 01FE      MOVW	R30,R28
    08EF 5BEF      SUBI	R30,0xBF
    08F0 4FFF      SBCI	R31,0xFF
    08F1 8311      STD	Z+1,R17
    08F2 8300      STD	Z+0,R16
    08F3 C1FC      RJMP	0x0AF0
(0065) 	while(1)
(0066) 	 {
(0067) 		i = 0 ;
    08F4 2400      CLR	R0
    08F5 2411      CLR	R1
    08F6 01FE      MOVW	R30,R28
    08F7 5BED      SUBI	R30,0xBD
    08F8 4FFF      SBCI	R31,0xFF
    08F9 8211      STD	Z+1,R1
    08FA 8200      STD	Z+0,R0
(0068) 	
(0069) 	    for( ; i < SectorsPerClust ; i++ )      //簇
    08FB C195      RJMP	0x0A91
(0070) 	     {
(0071) 	 
(0072) 	        FAT_LoadPartCluster(p,i,buffer);	//读一个扇区	
    08FC 01FE      MOVW	R30,R28
    08FD 5BEF      SUBI	R30,0xBF
    08FE 4FFF      SBCI	R31,0xFF
    08FF 8000      LDD	R0,Z+0
    0900 8011      LDD	R1,Z+1
    0901 821B      STD	Y+3,R1
    0902 820A      STD	Y+2,R0
    0903 01FE      MOVW	R30,R28
    0904 5BED      SUBI	R30,0xBD
    0905 4FFF      SBCI	R31,0xFF
    0906 8000      LDD	R0,Z+0
    0907 8011      LDD	R1,Z+1
    0908 8219      STD	Y+1,R1
    0909 8208      STD	Y+0,R0
    090A 01FE      MOVW	R30,R28
    090B 8104      LDD	R16,Z+4
    090C 8115      LDD	R17,Z+5
    090D 8126      LDD	R18,Z+6
    090E 8137      LDD	R19,Z+7
    090F 940E0E77  CALL	_FAT_LoadPartCluster
(0073) 	   
(0074) 	        if(i==0 && first==0) { count= buffer[0x0a] ; color_byte = buffer[0x1c] / 8  ;  first = 1 ; } 
    0911 01FE      MOVW	R30,R28
    0912 5BED      SUBI	R30,0xBD
    0913 4FFF      SBCI	R31,0xFF
    0914 8000      LDD	R0,Z+0
    0915 8011      LDD	R1,Z+1
    0916 2000      TST	R0
    0917 F511      BNE	0x093A
    0918 2011      TST	R1
    0919 F501      BNE	0x093A
    091A 01FE      MOVW	R30,R28
    091B 5BEB      SUBI	R30,0xBB
    091C 4FFF      SBCI	R31,0xFF
    091D 8000      LDD	R0,Z+0
    091E 2000      TST	R0
    091F F4D1      BNE	0x093A
    0920 01DE      MOVW	R26,R28
    0921 5BAF      SUBI	R26,0xBF
    0922 4FBF      SBCI	R27,0xFF
    0923 91ED      LD	R30,X+
    0924 91FC      LD	R31,0(X)
    0925 8422      LDD	R2,Z+10
    0926 2433      CLR	R3
    0927 AE3D      STD	Y+61,R3
    0928 AE2C      STD	Y+60,R2
    0929 01DE      MOVW	R26,R28
    092A 5BAF      SUBI	R26,0xBF
    092B 4FBF      SBCI	R27,0xFF
    092C 91ED      LD	R30,X+
    092D 91FC      LD	R31,0(X)
    092E 8C24      LDD	R2,Z+28
    092F 9426      LSR	R2
    0930 9426      LSR	R2
    0931 9426      LSR	R2
    0932 AE2B      STD	Y+59,R2
    0933 2400      CLR	R0
    0934 9403      INC	R0
    0935 01FE      MOVW	R30,R28
    0936 5BEB      SUBI	R30,0xBB
    0937 4FFF      SBCI	R31,0xFF
    0938 8200      STD	Z+0,R0
    0939 C145      RJMP	0x0A7F
(0075) 	        else { count=0 ; }
    093A 2400      CLR	R0
    093B 2411      CLR	R1
    093C AE1D      STD	Y+61,R1
    093D AE0C      STD	Y+60,R0
    093E C140      RJMP	0x0A7F
(0076) 	   
(0077) 	        
(0078) 			
(0079) 			while(count<512)  //读取一簇512扇区 (SectorsPerClust 每簇扇区数)
(0080) 	          {
(0081) 		   
(0082) 		        if(color_byte == 3)   //24位颜色图
    093F AD8B      LDD	R24,Y+59
    0940 3083      CPI	R24,3
    0941 F009      BEQ	0x0943
    0942 C05C      RJMP	0x099F
(0083) 		          {
(0084)                       switch ( rgb ) 
    0943 AC2A      LDD	R2,Y+58
    0944 2433      CLR	R3
    0945 AE39      STD	Y+57,R3
    0946 AE28      STD	Y+56,R2
    0947 2022      TST	R2
    0948 F411      BNE	0x094B
    0949 2033      TST	R3
    094A F059      BEQ	0x0956
    094B AD88      LDD	R24,Y+56
    094C AD99      LDD	R25,Y+57
    094D 3081      CPI	R24,1
    094E E0E0      LDI	R30,0
    094F 079E      CPC	R25,R30
    0950 F0C9      BEQ	0x096A
    0951 3082      CPI	R24,2
    0952 E0E0      LDI	R30,0
    0953 079E      CPC	R25,R30
    0954 F169      BEQ	0x0982
    0955 C045      RJMP	0x099B
(0085)                         {
(0086) 			               case 0 : tmp_color = buffer[count]>>3 ;
    0956 ADEC      LDD	R30,Y+60
    0957 ADFD      LDD	R31,Y+61
    0958 01DE      MOVW	R26,R28
    0959 5BAF      SUBI	R26,0xBF
    095A 4FBF      SBCI	R27,0xFF
    095B 900D      LD	R0,X+
    095C 901C      LD	R1,0(X)
    095D 0DE0      ADD	R30,R0
    095E 1DF1      ADC	R31,R1
    095F 80E0      LDD	R14,Z+0
    0960 24FF      CLR	R15
    0961 94F5      ASR	R15
    0962 94E7      ROR	R14
    0963 94F5      ASR	R15
    0964 94E7      ROR	R14
    0965 94F5      ASR	R15
    0966 94E7      ROR	R14
(0087) 			                        color |= tmp_color;
    0967 28CE      OR	R12,R14
    0968 28DF      OR	R13,R15
(0088) 					                break ;
    0969 C031      RJMP	0x099B
(0089) 					  
(0090) 			               case 1 : tmp_color = buffer[count]>>2 ;
    096A ADEC      LDD	R30,Y+60
    096B ADFD      LDD	R31,Y+61
    096C 01DE      MOVW	R26,R28
    096D 5BAF      SUBI	R26,0xBF
    096E 4FBF      SBCI	R27,0xFF
    096F 900D      LD	R0,X+
    0970 901C      LD	R1,0(X)
    0971 0DE0      ADD	R30,R0
    0972 1DF1      ADC	R31,R1
    0973 80E0      LDD	R14,Z+0
    0974 24FF      CLR	R15
    0975 94F5      ASR	R15
    0976 94E7      ROR	R14
    0977 94F5      ASR	R15
    0978 94E7      ROR	R14
(0091) 			                        tmp_color <<= 5 ;
    0979 E025      LDI	R18,5
    097A E030      LDI	R19,0
    097B 0187      MOVW	R16,R14
    097C 940E2428  CALL	lsl16
    097E 0178      MOVW	R14,R16
(0092) 			                        color |= tmp_color ;
    097F 2AC0      OR	R12,R16
    0980 2AD1      OR	R13,R17
(0093) 					                break ;
    0981 C019      RJMP	0x099B
(0094) 					   
(0095)        			           case 2 : tmp_color = buffer[count]>>3 ;
    0982 ADEC      LDD	R30,Y+60
    0983 ADFD      LDD	R31,Y+61
    0984 01DE      MOVW	R26,R28
    0985 5BAF      SUBI	R26,0xBF
    0986 4FBF      SBCI	R27,0xFF
    0987 900D      LD	R0,X+
    0988 901C      LD	R1,0(X)
    0989 0DE0      ADD	R30,R0
    098A 1DF1      ADC	R31,R1
    098B 80E0      LDD	R14,Z+0
    098C 24FF      CLR	R15
    098D 94F5      ASR	R15
    098E 94E7      ROR	R14
    098F 94F5      ASR	R15
    0990 94E7      ROR	R14
    0991 94F5      ASR	R15
    0992 94E7      ROR	R14
(0096) 			                        tmp_color <<= 11 ;
    0993 E02B      LDI	R18,0xB
    0994 E030      LDI	R19,0
    0995 0187      MOVW	R16,R14
    0996 940E2428  CALL	lsl16
    0998 0178      MOVW	R14,R16
(0097) 			                        color |= tmp_color ;
    0999 2AC0      OR	R12,R16
    099A 2AD1      OR	R13,R17
(0098) 					                 break ;			
(0099) 			            }
(0100) 			
(0101)                       rgb ++ ;
    099B AC0A      LDD	R0,Y+58
    099C 9403      INC	R0
    099D AE0A      STD	Y+58,R0
(0102) 			      }
    099E C0AE      RJMP	0x0A4D
(0103) 		        else
(0104) 		          {
(0105) 			          if(color_byte==2)  //16位颜色图
    099F AD8B      LDD	R24,Y+59
    09A0 3082      CPI	R24,2
    09A1 F009      BEQ	0x09A3
    09A2 C036      RJMP	0x09D9
(0106) 				        {
(0107) 				          switch ( rgb )
    09A3 AC2A      LDD	R2,Y+58
    09A4 2433      CLR	R3
    09A5 AE39      STD	Y+57,R3
    09A6 AE28      STD	Y+56,R2
    09A7 2022      TST	R2
    09A8 F411      BNE	0x09AB
    09A9 2033      TST	R3
    09AA F039      BEQ	0x09B2
    09AB AD88      LDD	R24,Y+56
    09AC AD99      LDD	R25,Y+57
    09AD 3081      CPI	R24,1
    09AE E0E0      LDI	R30,0
    09AF 079E      CPC	R25,R30
    09B0 F081      BEQ	0x09C1
    09B1 C023      RJMP	0x09D5
(0108) 					        {
(0109) 					          case 0 : byte1 = buffer[count] ;
    09B2 ADEC      LDD	R30,Y+60
    09B3 ADFD      LDD	R31,Y+61
    09B4 01DE      MOVW	R26,R28
    09B5 5BAF      SUBI	R26,0xBF
    09B6 4FBF      SBCI	R27,0xFF
    09B7 900D      LD	R0,X+
    09B8 901C      LD	R1,0(X)
    09B9 0DE0      ADD	R30,R0
    09BA 1DF1      ADC	R31,R1
    09BB 8020      LDD	R2,Z+0
    09BC 01FE      MOVW	R30,R28
    09BD 5BEA      SUBI	R30,0xBA
    09BE 4FFF      SBCI	R31,0xFF
    09BF 8220      STD	Z+0,R2
(0110) 								       break ; 
    09C0 C014      RJMP	0x09D5
(0111) 								   
(0112) 						      case 1 :    
(0113) 								       color = buffer[count] ;
    09C1 ADEC      LDD	R30,Y+60
    09C2 ADFD      LDD	R31,Y+61
    09C3 01DE      MOVW	R26,R28
    09C4 5BAF      SUBI	R26,0xBF
    09C5 4FBF      SBCI	R27,0xFF
    09C6 900D      LD	R0,X+
    09C7 901C      LD	R1,0(X)
    09C8 0DE0      ADD	R30,R0
    09C9 1DF1      ADC	R31,R1
    09CA 80C0      LDD	R12,Z+0
    09CB 24DD      CLR	R13
(0114) 								       color<<=8 ;
    09CC 2CDC      MOV	R13,R12
    09CD 24CC      CLR	R12
(0115) 								       color |= byte1 ;
    09CE 01FE      MOVW	R30,R28
    09CF 5BEA      SUBI	R30,0xBA
    09D0 4FFF      SBCI	R31,0xFF
    09D1 8020      LDD	R2,Z+0
    09D2 2433      CLR	R3
    09D3 28C2      OR	R12,R2
    09D4 28D3      OR	R13,R3
(0116) 								       break ;
(0117) 					     
(0118) 					        }
(0119) 					      rgb ++ ;
    09D5 AC0A      LDD	R0,Y+58
    09D6 9403      INC	R0
    09D7 AE0A      STD	Y+58,R0
(0120) 				    
(0121) 				        }
    09D8 C074      RJMP	0x0A4D
(0122) 				      else 
(0123) 				        {
(0124) 				          if(color_byte==4) //32位颜色图
    09D9 AD8B      LDD	R24,Y+59
    09DA 3084      CPI	R24,4
    09DB F009      BEQ	0x09DD
    09DC C070      RJMP	0x0A4D
(0125) 				            {
(0126) 				              switch ( rgb )
    09DD AC2A      LDD	R2,Y+58
    09DE 2433      CLR	R3
    09DF AE39      STD	Y+57,R3
    09E0 AE28      STD	Y+56,R2
    09E1 2022      TST	R2
    09E2 F411      BNE	0x09E5
    09E3 2033      TST	R3
    09E4 F079      BEQ	0x09F4
    09E5 AD88      LDD	R24,Y+56
    09E6 AD99      LDD	R25,Y+57
    09E7 3081      CPI	R24,1
    09E8 E0E0      LDI	R30,0
    09E9 079E      CPC	R25,R30
    09EA F0C1      BEQ	0x0A03
    09EB 3082      CPI	R24,2
    09EC E0E0      LDI	R30,0
    09ED 079E      CPC	R25,R30
    09EE F0F9      BEQ	0x0A0E
    09EF 3083      CPI	R24,3
    09F0 E0E0      LDI	R30,0
    09F1 079E      CPC	R25,R30
    09F2 F151      BEQ	0x0A1D
    09F3 C056      RJMP	0x0A4A
(0127) 					            {
(0128) 					              case 0 :  byte1 = buffer[count] ;
    09F4 ADEC      LDD	R30,Y+60
    09F5 ADFD      LDD	R31,Y+61
    09F6 01DE      MOVW	R26,R28
    09F7 5BAF      SUBI	R26,0xBF
    09F8 4FBF      SBCI	R27,0xFF
    09F9 900D      LD	R0,X+
    09FA 901C      LD	R1,0(X)
    09FB 0DE0      ADD	R30,R0
    09FC 1DF1      ADC	R31,R1
    09FD 8020      LDD	R2,Z+0
    09FE 01FE      MOVW	R30,R28
    09FF 5BEA      SUBI	R30,0xBA
    0A00 4FFF      SBCI	R31,0xFF
    0A01 8220      STD	Z+0,R2
(0129) 								            break ; 
    0A02 C047      RJMP	0x0A4A
(0130) 								   
(0131) 						          case 1 :  byte2 = buffer[count] ;
    0A03 ADEC      LDD	R30,Y+60
    0A04 ADFD      LDD	R31,Y+61
    0A05 01DE      MOVW	R26,R28
    0A06 5BAF      SUBI	R26,0xBF
    0A07 4FBF      SBCI	R27,0xFF
    0A08 900D      LD	R0,X+
    0A09 901C      LD	R1,0(X)
    0A0A 0DE0      ADD	R30,R0
    0A0B 1DF1      ADC	R31,R1
    0A0C 80A0      LDD	R10,Z+0
(0132)                                             break ;
    0A0D C03C      RJMP	0x0A4A
(0133) 									   
(0134) 							      case 2 :  byte3 = buffer[count] ;
    0A0E ADEC      LDD	R30,Y+60
    0A0F ADFD      LDD	R31,Y+61
    0A10 01DE      MOVW	R26,R28
    0A11 5BAF      SUBI	R26,0xBF
    0A12 4FBF      SBCI	R27,0xFF
    0A13 900D      LD	R0,X+
    0A14 901C      LD	R1,0(X)
    0A15 0DE0      ADD	R30,R0
    0A16 1DF1      ADC	R31,R1
    0A17 8020      LDD	R2,Z+0
    0A18 01FE      MOVW	R30,R28
    0A19 5BE9      SUBI	R30,0xB9
    0A1A 4FFF      SBCI	R31,0xFF
    0A1B 8220      STD	Z+0,R2
(0135) 							                break ;
    0A1C C02D      RJMP	0x0A4A
(0136) 									   
(0137) 							      case 3 :  tmp_color = byte1 >> 3 ;
    0A1D 01FE      MOVW	R30,R28
    0A1E 5BEA      SUBI	R30,0xBA
    0A1F 4FFF      SBCI	R31,0xFF
    0A20 80E0      LDD	R14,Z+0
    0A21 24FF      CLR	R15
    0A22 94F5      ASR	R15
    0A23 94E7      ROR	R14
    0A24 94F5      ASR	R15
    0A25 94E7      ROR	R14
    0A26 94F5      ASR	R15
    0A27 94E7      ROR	R14
(0138) 			                                color |= tmp_color;
    0A28 28CE      OR	R12,R14
    0A29 28DF      OR	R13,R15
(0139) 									        tmp_color = byte2 >>2 ;
    0A2A 2CEA      MOV	R14,R10
    0A2B 24FF      CLR	R15
    0A2C 94F5      ASR	R15
    0A2D 94E7      ROR	R14
    0A2E 94F5      ASR	R15
    0A2F 94E7      ROR	R14
(0140) 			                                tmp_color <<= 5 ;
    0A30 E025      LDI	R18,5
    0A31 E030      LDI	R19,0
    0A32 0187      MOVW	R16,R14
    0A33 940E2428  CALL	lsl16
(0141) 			                                color |= tmp_color ;
    0A35 2AC0      OR	R12,R16
    0A36 2AD1      OR	R13,R17
(0142) 									        tmp_color = byte3 >>3 ;
    0A37 01FE      MOVW	R30,R28
    0A38 5BE9      SUBI	R30,0xB9
    0A39 4FFF      SBCI	R31,0xFF
    0A3A 80E0      LDD	R14,Z+0
    0A3B 24FF      CLR	R15
    0A3C 94F5      ASR	R15
    0A3D 94E7      ROR	R14
    0A3E 94F5      ASR	R15
    0A3F 94E7      ROR	R14
    0A40 94F5      ASR	R15
    0A41 94E7      ROR	R14
(0143) 			                                tmp_color <<= 11 ;
    0A42 E02B      LDI	R18,0xB
    0A43 E030      LDI	R19,0
    0A44 0187      MOVW	R16,R14
    0A45 940E2428  CALL	lsl16
    0A47 0178      MOVW	R14,R16
(0144) 			                                color |= tmp_color ;
    0A48 2AC0      OR	R12,R16
    0A49 2AD1      OR	R13,R17
(0145) 									        break ;
(0146) 					     
(0147) 					            }
(0148) 					           rgb ++ ;
    0A4A AC0A      LDD	R0,Y+58
    0A4B 9403      INC	R0
    0A4C AE0A      STD	Y+58,R0
(0149) 				    
(0150) 				            }
(0151) 				     
(0152) 				        }   
(0153) 			 
(0154) 			       }
(0155)            
(0156) 		   count ++ ;
    0A4D AD8C      LDD	R24,Y+60
    0A4E AD9D      LDD	R25,Y+61
    0A4F 9601      ADIW	R24,1
    0A50 AF9D      STD	Y+61,R25
    0A51 AF8C      STD	Y+60,R24
(0157) 		   
(0158) 		   if(rgb == color_byte)        //读取1像素数数据后显示
    0A52 AC0A      LDD	R0,Y+58
    0A53 AD0B      LDD	R16,Y+59
    0A54 1600      CP	R0,R16
    0A55 F009      BEQ	0x0A57
    0A56 C028      RJMP	0x0A7F
(0159) 		     {
(0160) 			    GUIpoint(x, y,color) ;
    0A57 82D9      STD	Y+1,R13
    0A58 82C8      STD	Y+0,R12
    0A59 01FE      MOVW	R30,R28
    0A5A 96FF      ADIW	R30,0x3F
    0A5B 8120      LDD	R18,Z+0
    0A5C 8131      LDD	R19,Z+1
    0A5D AD0E      LDD	R16,Y+62
    0A5E 940E1B7E  CALL	_GUIpoint
(0161) 				color = 0x00 ;
    0A60 24CC      CLR	R12
    0A61 24DD      CLR	R13
(0162) 			    x++ ;
    0A62 AC0E      LDD	R0,Y+62
    0A63 9403      INC	R0
    0A64 AE0E      STD	Y+62,R0
(0163) 			    if(x>=128)
    0A65 2D80      MOV	R24,R0
    0A66 3880      CPI	R24,0x80
    0A67 F0A8      BCS	0x0A7D
(0164) 				  {
(0165) 				    y-- ;
    0A68 01FE      MOVW	R30,R28
    0A69 96FF      ADIW	R30,0x3F
    0A6A 8180      LDD	R24,Z+0
    0A6B 8191      LDD	R25,Z+1
    0A6C 9701      SBIW	R24,1
    0A6D 01FE      MOVW	R30,R28
    0A6E 96FF      ADIW	R30,0x3F
    0A6F 8391      STD	Z+1,R25
    0A70 8380      STD	Z+0,R24
(0166) 					
(0167) 					if( (y+1)<=0 )
    0A71 9601      ADIW	R24,1
    0A72 F441      BNE	0x0A7B
(0168) 		              {
(0169) 					    
(0170) 						free(buffer) ;
    0A73 01FE      MOVW	R30,R28
    0A74 5BEF      SUBI	R30,0xBF
    0A75 4FFF      SBCI	R31,0xFF
    0A76 8100      LDD	R16,Z+0
    0A77 8111      LDD	R17,Z+1
    0A78 940E2601  CALL	_free
(0171) 			            return ;
    0A7A C07D      RJMP	0x0AF8
(0172) 			          }
(0173) 					x = 0 ;
    0A7B 2400      CLR	R0
    0A7C AE0E      STD	Y+62,R0
(0174) 				  }
(0175) 		        
(0176) 				rgb = 0 ;
    0A7D 2400      CLR	R0
    0A7E AE0A      STD	Y+58,R0
    0A7F AD8C      LDD	R24,Y+60
    0A80 AD9D      LDD	R25,Y+61
    0A81 3080      CPI	R24,0
    0A82 E0E2      LDI	R30,2
    0A83 079E      CPC	R25,R30
    0A84 F408      BCC	0x0A86
    0A85 CEB9      RJMP	0x093F
    0A86 01FE      MOVW	R30,R28
    0A87 5BED      SUBI	R30,0xBD
    0A88 4FFF      SBCI	R31,0xFF
    0A89 8180      LDD	R24,Z+0
    0A8A 8191      LDD	R25,Z+1
    0A8B 9601      ADIW	R24,1
    0A8C 01FE      MOVW	R30,R28
    0A8D 5BED      SUBI	R30,0xBD
    0A8E 4FFF      SBCI	R31,0xFF
    0A8F 8391      STD	Z+1,R25
    0A90 8380      STD	Z+0,R24
    0A91 90200F0D  LDS	R2,SectorsPerClust
    0A93 90300F0E  LDS	R3,SectorsPerClust+1
    0A95 01FE      MOVW	R30,R28
    0A96 5BED      SUBI	R30,0xBD
    0A97 4FFF      SBCI	R31,0xFF
    0A98 8000      LDD	R0,Z+0
    0A99 8011      LDD	R1,Z+1
    0A9A 1402      CP	R0,R2
    0A9B 0413      CPC	R1,R3
    0A9C F408      BCC	0x0A9E
    0A9D CE5E      RJMP	0x08FC
(0177) 			 }
(0178) 			 
(0179) 			
(0180) 		}
(0181) 	   
(0182) 	 }  // 读取完一簇数据
(0183) 	 
(0184) 	 free(buffer) ;
    0A9E 01FE      MOVW	R30,R28
    0A9F 5BEF      SUBI	R30,0xBF
    0AA0 4FFF      SBCI	R31,0xFF
    0AA1 8100      LDD	R16,Z+0
    0AA2 8111      LDD	R17,Z+1
    0AA3 940E2601  CALL	_free
(0185) 	 p=FAT_NextCluster(p);//读下一簇数据			
    0AA5 01FE      MOVW	R30,R28
    0AA6 8104      LDD	R16,Z+4
    0AA7 8115      LDD	R17,Z+5
    0AA8 8126      LDD	R18,Z+6
    0AA9 8137      LDD	R19,Z+7
    0AAA 940E0ECB  CALL	_FAT_NextCluster
    0AAC 01FE      MOVW	R30,R28
    0AAD 8304      STD	Z+4,R16
    0AAE 8315      STD	Z+5,R17
    0AAF 8326      STD	Z+6,R18
    0AB0 8337      STD	Z+7,R19
(0186) 	 buffer=malloc(512);	
    0AB1 E000      LDI	R16,0
    0AB2 E012      LDI	R17,2
    0AB3 940E24AF  CALL	_malloc
    0AB5 01FE      MOVW	R30,R28
    0AB6 5BEF      SUBI	R30,0xBF
    0AB7 4FFF      SBCI	R31,0xFF
    0AB8 8311      STD	Z+1,R17
    0AB9 8300      STD	Z+0,R16
(0187) 	
(0188) 	if(p == 0x0fffffff || p == 0x0ffffff8 || (FAT32_Enable == 0 && p == 0xffff))//如果无后续簇则结束
    0ABA EF4F      LDI	R20,0xFF
    0ABB EF5F      LDI	R21,0xFF
    0ABC EF6F      LDI	R22,0xFF
    0ABD E07F      LDI	R23,0xF
    0ABE 01FE      MOVW	R30,R28
    0ABF 8024      LDD	R2,Z+4
    0AC0 8035      LDD	R3,Z+5
    0AC1 8046      LDD	R4,Z+6
    0AC2 8057      LDD	R5,Z+7
    0AC3 1624      CP	R2,R20
    0AC4 0635      CPC	R3,R21
    0AC5 0646      CPC	R4,R22
    0AC6 0657      CPC	R5,R23
    0AC7 F101      BEQ	0x0AE8
    0AC8 EF48      LDI	R20,0xF8
    0AC9 EF5F      LDI	R21,0xFF
    0ACA EF6F      LDI	R22,0xFF
    0ACB E07F      LDI	R23,0xF
    0ACC 01FE      MOVW	R30,R28
    0ACD 8024      LDD	R2,Z+4
    0ACE 8035      LDD	R3,Z+5
    0ACF 8046      LDD	R4,Z+6
    0AD0 8057      LDD	R5,Z+7
    0AD1 1624      CP	R2,R20
    0AD2 0635      CPC	R3,R21
    0AD3 0646      CPC	R4,R22
    0AD4 0657      CPC	R5,R23
    0AD5 F091      BEQ	0x0AE8
    0AD6 90200EFC  LDS	R2,FAT32_Enable
    0AD8 2022      TST	R2
    0AD9 F4B1      BNE	0x0AF0
    0ADA EF4F      LDI	R20,0xFF
    0ADB EF5F      LDI	R21,0xFF
    0ADC E060      LDI	R22,0
    0ADD E070      LDI	R23,0
    0ADE 01FE      MOVW	R30,R28
    0ADF 8024      LDD	R2,Z+4
    0AE0 8035      LDD	R3,Z+5
    0AE1 8046      LDD	R4,Z+6
    0AE2 8057      LDD	R5,Z+7
    0AE3 1624      CP	R2,R20
    0AE4 0635      CPC	R3,R21
    0AE5 0646      CPC	R4,R22
    0AE6 0657      CPC	R5,R23
    0AE7 F441      BNE	0x0AF0
(0189) 		{
(0190) 		        free(buffer) ;
    0AE8 01FE      MOVW	R30,R28
    0AE9 5BEF      SUBI	R30,0xBF
    0AEA 4FFF      SBCI	R31,0xFF
    0AEB 8100      LDD	R16,Z+0
    0AEC 8111      LDD	R17,Z+1
    0AED 940E2601  CALL	_free
(0191) 				return ;
    0AEF C008      RJMP	0x0AF8
    0AF0 CE03      RJMP	0x08F4
(0192) 		}
(0193) 	 
(0194)   }
(0195) 		
(0196) 	free(buffer) ;
    0AF1 01FE      MOVW	R30,R28
    0AF2 5BEF      SUBI	R30,0xBF
    0AF3 4FFF      SBCI	R31,0xFF
    0AF4 8100      LDD	R16,Z+0
    0AF5 8111      LDD	R17,Z+1
    0AF6 940E2601  CALL	_free
    0AF8 96EF      ADIW	R28,0x3F
    0AF9 9629      ADIW	R28,0x9
    0AFA 940E23CF  CALL	pop_gset5
    0AFC 9508      RET
(0197)   
(0198)  }
(0199) //***********************************************************************
(0200) //			关闭数码管，防止显示乱码
(0201) //***********************************************************************
(0202) void LED_Off()
(0203) {
(0204)     PORTD=0xFF;
_LED_Off:
    0AFD EF8F      LDI	R24,0xFF
    0AFE BB82      OUT	0x12,R24
(0205) 	DDRD=0xFF;
    0AFF BB81      OUT	0x11,R24
(0206) 	D_LE1;                             				//关掉数码管，以免显示乱码                   
    0B00 9A94      SBI	0x12,4
(0207)     W_LE1;                     
    0B01 9A95      SBI	0x12,5
(0208)     Data_IO=0xFF;                      				//关数码管            
    0B02 BB8B      OUT	0x1B,R24
(0209)     W_LE0; 
    0B03 9895      CBI	0x12,5
    0B04 9508      RET
_main:
  y                    --> R20
  er                   --> R10
  ok                   --> R12
  x                    --> R20
  retry                --> R22
  i                    --> R20
    0B05 9726      SBIW	R28,6
(0210) }
(0211) //***********************************************************************
(0212) //			主函数，初始化及函数调用
(0213) //***********************************************************************
(0214) void main(void)
(0215) {
(0216)   unsigned char i, x,retry=0;
    0B06 2766      CLR	R22
(0217)   u08 ok,er ;
(0218)   unsigned int y ;
(0219)   delay_nms(10);
    0B07 E00A      LDI	R16,0xA
    0B08 E010      LDI	R17,0
    0B09 DD13      RCALL	_delay_nms
(0220)   McuInit();
    0B0A 940E1825  CALL	_McuInit
(0221)   UART_Init();
    0B0C 940E1DC6  CALL	_UART_Init
(0222)   LCD_RD1; 
    0B0E 91800065  LDS	R24,0x65
    0B10 6180      ORI	R24,0x10
    0B11 93800065  STS	0x65,R24
(0223)   LCD_Init();     									//LCD初始化
    0B13 940E1972  CALL	_LCD_Init
(0224)   x = 1 ;
    0B15 E041      LDI	R20,1
(0225)   y = 0 ;
    0B16 2744      CLR	R20
    0B17 2755      CLR	R21
(0226)   LCD_clear(0) ;
    0B18 2700      CLR	R16
    0B19 2711      CLR	R17
    0B1A 940E1A03  CALL	_LCD_clear
(0227)   	
(0228)   for(i=0; i<5 ;i++)
    0B1C C00D      RJMP	0x0B2A
(0229)    {
(0230) 	DisplayGB2312(i+18,i+1,0,0x07E0) ;    			//显示欣世纪电子
    0B1D EE80      LDI	R24,0xE0
    0B1E E097      LDI	R25,7
    0B1F 839B      STD	Y+3,R25
    0B20 838A      STD	Y+2,R24
    0B21 2422      CLR	R2
    0B22 8228      STD	Y+0,R2
    0B23 2F24      MOV	R18,R20
    0B24 5F2F      SUBI	R18,0xFF
    0B25 2F04      MOV	R16,R20
    0B26 5E0E      SUBI	R16,0xEE
    0B27 940E1ABE  CALL	_DisplayGB2312
    0B29 9543      INC	R20
    0B2A 3045      CPI	R20,5
    0B2B F388      BCS	0x0B1D
(0231)    }
(0232) 	DisplayString("DMAVR-128 Board",0,1,0xf800);  	//字符串显示调用
    0B2C E080      LDI	R24,0
    0B2D EF98      LDI	R25,0xF8
    0B2E 839B      STD	Y+3,R25
    0B2F 838A      STD	Y+2,R24
    0B30 E081      LDI	R24,1
    0B31 8388      STD	Y+0,R24
    0B32 2722      CLR	R18
    0B33 E800      LDI	R16,0x80
    0B34 E011      LDI	R17,1
    0B35 940E1B2A  CALL	_DisplayString
(0233) 	DisplayString("Show BMP from SD",0,2,0xeee);  	//字符串显示调用
    0B37 EE8E      LDI	R24,0xEE
    0B38 E09E      LDI	R25,0xE
    0B39 839B      STD	Y+3,R25
    0B3A 838A      STD	Y+2,R24
    0B3B E082      LDI	R24,2
    0B3C 8388      STD	Y+0,R24
    0B3D 2722      CLR	R18
    0B3E E60F      LDI	R16,0x6F
    0B3F E011      LDI	R17,1
    0B40 940E1B2A  CALL	_DisplayString
(0234) 	GUIline(0,49,127,49,0xe387);
    0B42 E887      LDI	R24,0x87
    0B43 EE93      LDI	R25,0xE3
    0B44 839D      STD	Y+5,R25
    0B45 838C      STD	Y+4,R24
    0B46 E381      LDI	R24,0x31
    0B47 838A      STD	Y+2,R24
    0B48 E78F      LDI	R24,0x7F
    0B49 8388      STD	Y+0,R24
    0B4A E321      LDI	R18,0x31
    0B4B 2700      CLR	R16
    0B4C 940E1BB0  CALL	_GUIline
(0235) 	GUIline(0,51,127,51,0xfef);
    0B4E EE8F      LDI	R24,0xEF
    0B4F E09F      LDI	R25,0xF
    0B50 839D      STD	Y+5,R25
    0B51 838C      STD	Y+4,R24
    0B52 E383      LDI	R24,0x33
    0B53 838A      STD	Y+2,R24
    0B54 E78F      LDI	R24,0x7F
    0B55 8388      STD	Y+0,R24
    0B56 E323      LDI	R18,0x33
    0B57 2700      CLR	R16
    0B58 940E1BB0  CALL	_GUIline
(0236) 		
(0237)  	ok = 0 ;
    0B5A 24CC      CLR	R12
(0238)  	er = 0 ;
    0B5B 24AA      CLR	R10
(0239) 	DisplayString("Starting Init SD",0,4,0xffff);  //字符串显示调用
    0B5C EF8F      LDI	R24,0xFF
    0B5D EF9F      LDI	R25,0xFF
    0B5E 839B      STD	Y+3,R25
    0B5F 838A      STD	Y+2,R24
    0B60 E084      LDI	R24,4
    0B61 8388      STD	Y+0,R24
    0B62 2722      CLR	R18
    0B63 E50E      LDI	R16,0x5E
    0B64 E011      LDI	R17,1
    0B65 940E1B2A  CALL	_DisplayString
(0240) 	DisplayString("Waiting...",0,5,0xffff);  		//字符串显示调用
    0B67 EF8F      LDI	R24,0xFF
    0B68 EF9F      LDI	R25,0xFF
    0B69 839B      STD	Y+3,R25
    0B6A 838A      STD	Y+2,R24
    0B6B E085      LDI	R24,5
    0B6C 8388      STD	Y+0,R24
    0B6D 2722      CLR	R18
    0B6E E503      LDI	R16,0x53
    0B6F E011      LDI	R17,1
    0B70 940E1B2A  CALL	_DisplayString
(0241)   	mmcInit();
    0B72 940E15AB  CALL	_mmcInit
(0242)   	delay_nms(1);
    0B74 E001      LDI	R16,1
    0B75 E010      LDI	R17,0
    0B76 DCA6      RCALL	_delay_nms
    0B77 C01C      RJMP	0x0B94
(0243)   
(0244) 	  
(0245)   while(mmcReset())									//初始化SD卡					
(0246) 	{
(0247) 		retry++;
    0B78 9563      INC	R22
(0248) 		if(retry>20)
    0B79 E184      LDI	R24,0x14
    0B7A 1786      CP	R24,R22
    0B7B F4C0      BCC	0x0B94
(0249) 		{
    0B7C C016      RJMP	0x0B93
(0250) 			while(1)   											//初始化失败显示
(0251) 			{
(0252) 				DisplayString("Init Failure",0,7,0xf800);  		//字符串显示调用
    0B7D E080      LDI	R24,0
    0B7E EF98      LDI	R25,0xF8
    0B7F 839B      STD	Y+3,R25
    0B80 838A      STD	Y+2,R24
    0B81 E087      LDI	R24,7
    0B82 8388      STD	Y+0,R24
    0B83 2722      CLR	R18
    0B84 E406      LDI	R16,0x46
    0B85 E011      LDI	R17,1
    0B86 940E1B2A  CALL	_DisplayString
(0253) 	            DisplayString("Please Check SD",0,8,0xf800);  	//字符串显示调用
    0B88 E080      LDI	R24,0
    0B89 EF98      LDI	R25,0xF8
    0B8A 839B      STD	Y+3,R25
    0B8B 838A      STD	Y+2,R24
    0B8C E088      LDI	R24,0x8
    0B8D 8388      STD	Y+0,R24
    0B8E 2722      CLR	R18
    0B8F E306      LDI	R16,0x36
    0B90 E011      LDI	R17,1
    0B91 940E1B2A  CALL	_DisplayString
    0B93 CFE9      RJMP	0x0B7D
    0B94 940E15B8  CALL	_mmcReset
    0B96 2300      TST	R16
    0B97 F701      BNE	0x0B78
(0254) 			}
(0255) 		}
(0256) 	} 
(0257) 	  	  
(0258) 	DisplayString("Init SD Success!",0,6,0xffff);  				//字符串显示调用
    0B98 EF8F      LDI	R24,0xFF
    0B99 EF9F      LDI	R25,0xFF
    0B9A 839B      STD	Y+3,R25
    0B9B 838A      STD	Y+2,R24
    0B9C E086      LDI	R24,6
    0B9D 8388      STD	Y+0,R24
    0B9E 2722      CLR	R18
    0B9F E205      LDI	R16,0x25
    0BA0 E011      LDI	R17,1
    0BA1 940E1B2A  CALL	_DisplayString
(0259) 	 
(0260) 	
(0261) 	if(FAT_Init())												//初始化文件系统 支持FAT16和FAT32	
    0BA3 940E0CED  CALL	_FAT_Init
    0BA5 2300      TST	R16
    0BA6 F071      BEQ	0x0BB5
(0262) 	{
    0BA7 C00C      RJMP	0x0BB4
(0263) 		while(1)
(0264) 		{
(0265) 			while(1)
(0266) 			{
(0267) 				DisplayString("Init FAT Failure",0,7,0xf800);  //字符串显示调用
    0BA8 E080      LDI	R24,0
    0BA9 EF98      LDI	R25,0xF8
    0BAA 839B      STD	Y+3,R25
    0BAB 838A      STD	Y+2,R24
    0BAC E087      LDI	R24,7
    0BAD 8388      STD	Y+0,R24
    0BAE 2722      CLR	R18
    0BAF E104      LDI	R16,0x14
    0BB0 E011      LDI	R17,1
    0BB1 940E1B2A  CALL	_DisplayString
    0BB3 CFF4      RJMP	0x0BA8
    0BB4 CFFE      RJMP	0x0BB3
(0268) 			}
(0269) 		}
(0270) 
(0271) 	}
(0272) 	printf("Begin initing\r\n");
    0BB5 E004      LDI	R16,4
    0BB6 E011      LDI	R17,1
    0BB7 940E2859  CALL	_printf
(0273) 	_NewHeap(&_bss_end+1, &_bss_end + 550);                     //动态分配内存(malloc(512))需要初始化，空间比需要分配的要大才行
    0BB9 E52F      LDI	R18,0x5F
    0BBA E131      LDI	R19,0x11
    0BBB E30A      LDI	R16,0x3A
    0BBC E01F      LDI	R17,0xF
    0BBD 940E2471  CALL	__NewHeap
(0274) 	SearchInit();  												//搜索文件初始化
    0BBF 940E1320  CALL	_SearchInit
    0BC1 C022      RJMP	0x0BE4
(0275) 
(0276) 	
(0277) 	while(1)                               						//轮流显示SD卡中的图片
(0278) 	 {
(0279) 	    disp_image() ;
    0BC2 DC78      RCALL	_disp_image
(0280) 		delay_nms(1000) ;
    0BC3 EE08      LDI	R16,0xE8
    0BC4 E013      LDI	R17,3
    0BC5 DC57      RCALL	_delay_nms
(0281) 		delay_nms(1000) ;
    0BC6 EE08      LDI	R16,0xE8
    0BC7 E013      LDI	R17,3
    0BC8 DC54      RCALL	_delay_nms
(0282) 		delay_nms(1000) ;
    0BC9 EE08      LDI	R16,0xE8
    0BCA E013      LDI	R17,3
    0BCB DC51      RCALL	_delay_nms
(0283) 		                              			
(0284) 		if(image_count<image_all)								//轮流显示SD卡中的BMP图片
    0BCC 90200102  LDS	R2,image_all
    0BCE 90300103  LDS	R3,image_all+1
    0BD0 90400100  LDS	R4,image_count
    0BD2 90500101  LDS	R5,image_count+1
    0BD4 1442      CP	R4,R2
    0BD5 0453      CPC	R5,R3
    0BD6 F438      BCC	0x0BDE
(0285) 		    {
(0286) 		      image_count ++ ;
    0BD7 01C2      MOVW	R24,R4
    0BD8 9601      ADIW	R24,1
    0BD9 93900101  STS	image_count+1,R25
    0BDB 93800100  STS	image_count,R24
(0287) 		    }
    0BDD C006      RJMP	0x0BE4
(0288) 		 else 
(0289) 		    {
(0290) 			  image_count = 1 ;
    0BDE E081      LDI	R24,1
    0BDF E090      LDI	R25,0
    0BE0 93900101  STS	image_count+1,R25
    0BE2 93800100  STS	image_count,R24
    0BE4 CFDD      RJMP	0x0BC2
    0BE5 9626      ADIW	R28,6
    0BE6 9508      RET
_SD_SizeDisplay:
  Size                 --> Y+4
  Capacity             --> Y+12
    0BE7 940E22CF  CALL	push_arg4
    0BE9 940E23D8  CALL	push_gset2
    0BEB 9728      SBIW	R28,0x8
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\FAT.c
(0001) //FAT文件系统驱动程序，对网络开源代码的更改		
(0002) //编译环境 ICCAVR 7.16A
(0003) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0004) //忠兴电子元件店编辑
(0005) //日期：2010.01.14 
(0006) 
(0007) #include"FAT.h"
(0008) 
(0009) DWORD FirstDirClust;    //first directory cluster
(0010) DWORD FirstDataSector;	// The first sector number of data
(0011) WORD BytesPerSector;	// Bytes per sector
(0012) WORD FATsectors;		// The amount sector a FAT occupied
(0013) WORD SectorsPerClust;	// Sector per cluster
(0014) DWORD FirstFATSector;	// The first FAT sector
(0015) DWORD FirstDirSector;	// The first Dir sector
(0016) DWORD RootDirSectors;	// The sector number a Root dir occupied 
(0017) DWORD RootDirCount;		// The count of directory in root dir
(0018) BYTE FAT32_Enable;
(0019) 
(0020) BYTE (* FAT_ReadSector)(DWORD,BYTE *);
(0021) BYTE (* FAT_WriteSector)(DWORD,BYTE *);
(0022) void DisplayChar(unsigned char casc,unsigned char postion_x,unsigned char postion_y,unsigned int char_color);
(0023) void DisplayString(unsigned char *s,unsigned char x,unsigned char y,unsigned int s_color);
(0024) eeprom_read_byte(unsigned int addr);
(0025) void eeprom_write_byte(unsigned int addr, unsigned char p_buff);
(0026) 
(0027) //函数指针指向sd卡的读写函数
(0028) //function pointer to the sd card read & write single block
(0029) //wirte sector are not use in this player
(0030) BYTE (* FAT_ReadSector)(DWORD sector, BYTE * buffer)=mmcRead;//device read
(0031) BYTE (* FAT_WriteSector)(DWORD sector, BYTE * buffer)=mmcWrite;//device write
(0032) 
(0033) struct FileInfoStruct FileInfo;//temporarily buffer for file information
(0034) 
(0035) //读取SD卡容量并处理显示函数
(0036) void SD_SizeDisplay(DWORD Capacity)
(0037) {
(0038) 	static	unsigned int SizeQ,SizeB,SizeS,SizeG;
(0039) 	DWORD Size;
(0040)     DisplayString("SD Size:",0,8,0xf800);  //显示SD卡容量
    0BEC E080      LDI	R24,0
    0BED EF98      LDI	R25,0xF8
    0BEE 839B      STD	Y+3,R25
    0BEF 838A      STD	Y+2,R24
    0BF0 E088      LDI	R24,0x8
    0BF1 8388      STD	Y+0,R24
    0BF2 2722      CLR	R18
    0BF3 EE01      LDI	R16,0xE1
    0BF4 E012      LDI	R17,2
    0BF5 940E1B2A  CALL	_DisplayString
(0041) 	Size=Capacity/1024/1024;
    0BF7 E08A      LDI	R24,0xA
    0BF8 E090      LDI	R25,0
    0BF9 01FE      MOVW	R30,R28
    0BFA 8424      LDD	R2,Z+12
    0BFB 8435      LDD	R3,Z+13
    0BFC 8446      LDD	R4,Z+14
    0BFD 8457      LDD	R5,Z+15
    0BFE 938A      ST	R24,-Y
    0BFF 0181      MOVW	R16,R2
    0C00 0192      MOVW	R18,R4
    0C01 940E243B  CALL	lsr32
    0C03 E08A      LDI	R24,0xA
    0C04 E090      LDI	R25,0
    0C05 938A      ST	R24,-Y
    0C06 940E243B  CALL	lsr32
    0C08 01FE      MOVW	R30,R28
    0C09 8304      STD	Z+4,R16
    0C0A 8315      STD	Z+5,R17
    0C0B 8326      STD	Z+6,R18
    0C0C 8337      STD	Z+7,R19
(0042) 	SizeQ=Size/1000;
    0C0D EE48      LDI	R20,0xE8
    0C0E E053      LDI	R21,3
    0C0F E060      LDI	R22,0
    0C10 E070      LDI	R23,0
    0C11 01FE      MOVW	R30,R28
    0C12 8024      LDD	R2,Z+4
    0C13 8035      LDD	R3,Z+5
    0C14 8046      LDD	R4,Z+6
    0C15 8057      LDD	R5,Z+7
    0C16 937A      ST	R23,-Y
    0C17 936A      ST	R22,-Y
    0C18 935A      ST	R21,-Y
    0C19 934A      ST	R20,-Y
    0C1A 0181      MOVW	R16,R2
    0C1B 0192      MOVW	R18,R4
    0C1C 940E2315  CALL	div32u
    0C1E 93100EE6  STS	SizeQ+1,R17
    0C20 93000EE5  STS	SizeQ,R16
(0043) 	SizeB=(Size%1000)/100;
    0C22 EE48      LDI	R20,0xE8
    0C23 E053      LDI	R21,3
    0C24 E060      LDI	R22,0
    0C25 E070      LDI	R23,0
    0C26 01FE      MOVW	R30,R28
    0C27 8024      LDD	R2,Z+4
    0C28 8035      LDD	R3,Z+5
    0C29 8046      LDD	R4,Z+6
    0C2A 8057      LDD	R5,Z+7
    0C2B 937A      ST	R23,-Y
    0C2C 936A      ST	R22,-Y
    0C2D 935A      ST	R21,-Y
    0C2E 934A      ST	R20,-Y
    0C2F 0181      MOVW	R16,R2
    0C30 0192      MOVW	R18,R4
    0C31 940E2317  CALL	mod32u
    0C33 E644      LDI	R20,0x64
    0C34 E050      LDI	R21,0
    0C35 E060      LDI	R22,0
    0C36 E070      LDI	R23,0
    0C37 937A      ST	R23,-Y
    0C38 936A      ST	R22,-Y
    0C39 935A      ST	R21,-Y
    0C3A 934A      ST	R20,-Y
    0C3B 940E2315  CALL	div32u
    0C3D 93100EE8  STS	SizeB+1,R17
    0C3F 93000EE7  STS	SizeB,R16
(0044) 	SizeS=(Size%1000)%100/10;
    0C41 EE48      LDI	R20,0xE8
    0C42 E053      LDI	R21,3
    0C43 E060      LDI	R22,0
    0C44 E070      LDI	R23,0
    0C45 01FE      MOVW	R30,R28
    0C46 8024      LDD	R2,Z+4
    0C47 8035      LDD	R3,Z+5
    0C48 8046      LDD	R4,Z+6
    0C49 8057      LDD	R5,Z+7
    0C4A 937A      ST	R23,-Y
    0C4B 936A      ST	R22,-Y
    0C4C 935A      ST	R21,-Y
    0C4D 934A      ST	R20,-Y
    0C4E 0181      MOVW	R16,R2
    0C4F 0192      MOVW	R18,R4
    0C50 940E2317  CALL	mod32u
    0C52 E644      LDI	R20,0x64
    0C53 E050      LDI	R21,0
    0C54 E060      LDI	R22,0
    0C55 E070      LDI	R23,0
    0C56 937A      ST	R23,-Y
    0C57 936A      ST	R22,-Y
    0C58 935A      ST	R21,-Y
    0C59 934A      ST	R20,-Y
    0C5A 940E2317  CALL	mod32u
    0C5C E04A      LDI	R20,0xA
    0C5D E050      LDI	R21,0
    0C5E E060      LDI	R22,0
    0C5F E070      LDI	R23,0
    0C60 937A      ST	R23,-Y
    0C61 936A      ST	R22,-Y
    0C62 935A      ST	R21,-Y
    0C63 934A      ST	R20,-Y
    0C64 940E2315  CALL	div32u
    0C66 93100EEA  STS	SizeS+1,R17
    0C68 93000EE9  STS	SizeS,R16
(0045) 	SizeG=(Size%1000)%100%10;
    0C6A EE48      LDI	R20,0xE8
    0C6B E053      LDI	R21,3
    0C6C E060      LDI	R22,0
    0C6D E070      LDI	R23,0
    0C6E 01FE      MOVW	R30,R28
    0C6F 8024      LDD	R2,Z+4
    0C70 8035      LDD	R3,Z+5
    0C71 8046      LDD	R4,Z+6
    0C72 8057      LDD	R5,Z+7
    0C73 937A      ST	R23,-Y
    0C74 936A      ST	R22,-Y
    0C75 935A      ST	R21,-Y
    0C76 934A      ST	R20,-Y
    0C77 0181      MOVW	R16,R2
    0C78 0192      MOVW	R18,R4
    0C79 940E2317  CALL	mod32u
    0C7B E644      LDI	R20,0x64
    0C7C E050      LDI	R21,0
    0C7D E060      LDI	R22,0
    0C7E E070      LDI	R23,0
    0C7F 937A      ST	R23,-Y
    0C80 936A      ST	R22,-Y
    0C81 935A      ST	R21,-Y
    0C82 934A      ST	R20,-Y
    0C83 940E2317  CALL	mod32u
    0C85 E04A      LDI	R20,0xA
    0C86 E050      LDI	R21,0
    0C87 E060      LDI	R22,0
    0C88 E070      LDI	R23,0
    0C89 937A      ST	R23,-Y
    0C8A 936A      ST	R22,-Y
    0C8B 935A      ST	R21,-Y
    0C8C 934A      ST	R20,-Y
    0C8D 940E2317  CALL	mod32u
    0C8F 93100EEC  STS	SizeG+1,R17
    0C91 93000EEB  STS	SizeG,R16
(0046)     DisplayChar(SizeQ+'0',8,8,0x0eee);
    0C93 EE8E      LDI	R24,0xEE
    0C94 E09E      LDI	R25,0xE
    0C95 839B      STD	Y+3,R25
    0C96 838A      STD	Y+2,R24
    0C97 E088      LDI	R24,0x8
    0C98 8388      STD	Y+0,R24
    0C99 E028      LDI	R18,0x8
    0C9A 91000EE5  LDS	R16,SizeQ
    0C9C 5D00      SUBI	R16,0xD0
    0C9D 4F1F      SBCI	R17,0xFF
    0C9E 940E1A52  CALL	_DisplayChar
(0047) 	DisplayChar(SizeB+'0',9,8,0x0eee);
    0CA0 EE8E      LDI	R24,0xEE
    0CA1 E09E      LDI	R25,0xE
    0CA2 839B      STD	Y+3,R25
    0CA3 838A      STD	Y+2,R24
    0CA4 E088      LDI	R24,0x8
    0CA5 8388      STD	Y+0,R24
    0CA6 E029      LDI	R18,0x9
    0CA7 91000EE7  LDS	R16,SizeB
    0CA9 5D00      SUBI	R16,0xD0
    0CAA 4F1F      SBCI	R17,0xFF
    0CAB 940E1A52  CALL	_DisplayChar
(0048) 	DisplayChar(SizeS+'0',10,8,0x0eee);
    0CAD EE8E      LDI	R24,0xEE
    0CAE E09E      LDI	R25,0xE
    0CAF 839B      STD	Y+3,R25
    0CB0 838A      STD	Y+2,R24
    0CB1 E088      LDI	R24,0x8
    0CB2 8388      STD	Y+0,R24
    0CB3 E02A      LDI	R18,0xA
    0CB4 91000EE9  LDS	R16,SizeS
    0CB6 5D00      SUBI	R16,0xD0
    0CB7 4F1F      SBCI	R17,0xFF
    0CB8 940E1A52  CALL	_DisplayChar
(0049) 	DisplayChar(SizeG+'0',11,8,0x0eee);
    0CBA EE8E      LDI	R24,0xEE
    0CBB E09E      LDI	R25,0xE
    0CBC 839B      STD	Y+3,R25
    0CBD 838A      STD	Y+2,R24
    0CBE E088      LDI	R24,0x8
    0CBF 8388      STD	Y+0,R24
    0CC0 E02B      LDI	R18,0xB
    0CC1 91000EEB  LDS	R16,SizeG
    0CC3 5D00      SUBI	R16,0xD0
    0CC4 4F1F      SBCI	R17,0xFF
    0CC5 940E1A52  CALL	_DisplayChar
(0050) 	DisplayString("MB",13,8,0xf800);  		//显示SD卡容量
    0CC7 E080      LDI	R24,0
    0CC8 EF98      LDI	R25,0xF8
    0CC9 839B      STD	Y+3,R25
    0CCA 838A      STD	Y+2,R24
    0CCB E088      LDI	R24,0x8
    0CCC 8388      STD	Y+0,R24
    0CCD E02D      LDI	R18,0xD
    0CCE ED0E      LDI	R16,0xDE
    0CCF E012      LDI	R17,2
    0CD0 940E1B2A  CALL	_DisplayString
(0051) 	DisplayString("BMP Num:",0,9,0xf800);  	//BMP图片数量，最大显示99张，可以更改算法
    0CD2 E080      LDI	R24,0
    0CD3 EF98      LDI	R25,0xF8
    0CD4 839B      STD	Y+3,R25
    0CD5 838A      STD	Y+2,R24
    0CD6 E089      LDI	R24,0x9
    0CD7 8388      STD	Y+0,R24
    0CD8 2722      CLR	R18
    0CD9 ED05      LDI	R16,0xD5
    0CDA E012      LDI	R17,2
    0CDB 940E1B2A  CALL	_DisplayString
(0052) 	DisplayString("Finding.",8,9,0xffff);  	//BMP图片数量，最大显示99张，可以更改算法
    0CDD EF8F      LDI	R24,0xFF
    0CDE EF9F      LDI	R25,0xFF
    0CDF 839B      STD	Y+3,R25
    0CE0 838A      STD	Y+2,R24
    0CE1 E089      LDI	R24,0x9
    0CE2 8388      STD	Y+0,R24
    0CE3 E028      LDI	R18,0x8
    0CE4 EC0C      LDI	R16,0xCC
    0CE5 E012      LDI	R17,2
    0CE6 940E1B2A  CALL	_DisplayString
    0CE8 9628      ADIW	R28,0x8
    0CE9 940E23C6  CALL	pop_gset2
    0CEB 9624      ADIW	R28,4
    0CEC 9508      RET
_FAT_Init:
  CapacityDisp         --> Y+522
  pr                   --> R14
  Capacity             --> Y+518
  buffer               --> Y+6
  hidsec               --> Y+2
  bs                   --> R12
  bpb                  --> R10
    0CED 940E23D2  CALL	push_gset5
    0CEF 97EF      SBIW	R28,0x3F
    0CF0 97EF      SBIW	R28,0x3F
    0CF1 97EF      SBIW	R28,0x3F
    0CF2 97EF      SBIW	R28,0x3F
    0CF3 97EF      SBIW	R28,0x3F
    0CF4 97EF      SBIW	R28,0x3F
    0CF5 97EF      SBIW	R28,0x3F
    0CF6 97EF      SBIW	R28,0x3F
    0CF7 9766      SBIW	R28,0x16
(0053) }
(0054) 
(0055) //FAT初始化，不含SD的初始化，用之前应先调用sd的初始化
(0056) unsigned char FAT_Init()//Initialize of FAT  need initialize SD first
(0057) {
(0058) 	struct bootsector710 *bs  = 0;
    0CF8 24CC      CLR	R12
    0CF9 24DD      CLR	R13
(0059) 	struct bpb710        *bpb = 0;
    0CFA 24AA      CLR	R10
    0CFB 24BB      CLR	R11
(0060) //	struct partsector    *ps  = 0;
(0061) 	struct partrecord    *pr  = 0;
    0CFC 24EE      CLR	R14
    0CFD 24FF      CLR	R15
(0062) 
(0063) 	BYTE buffer[512];
(0064) 	DWORD hidsec=0;
    0CFE E040      LDI	R20,0
    0CFF E050      LDI	R21,0
    0D00 E060      LDI	R22,0
    0D01 E070      LDI	R23,0
    0D02 01FE      MOVW	R30,R28
    0D03 8342      STD	Z+2,R20
    0D04 8353      STD	Z+3,R21
    0D05 8364      STD	Z+4,R22
    0D06 8375      STD	Z+5,R23
(0065) 	DWORD Capacity,CapacityDisp;
(0066) 
(0067) 
(0068) 	Capacity = mmcCapacity();
    0D07 940E1714  CALL	_mmcCapacity
    0D09 01FE      MOVW	R30,R28
    0D0A 5FEA      SUBI	R30,0xFA
    0D0B 4FFD      SBCI	R31,0xFD
    0D0C 8300      STD	Z+0,R16
    0D0D 8311      STD	Z+1,R17
    0D0E 8322      STD	Z+2,R18
    0D0F 8333      STD	Z+3,R19
(0069) 	SD_SizeDisplay(Capacity);
    0D10 01FE      MOVW	R30,R28
    0D11 5FEA      SUBI	R30,0xFA
    0D12 4FFD      SBCI	R31,0xFD
    0D13 8100      LDD	R16,Z+0
    0D14 8111      LDD	R17,Z+1
    0D15 8122      LDD	R18,Z+2
    0D16 8133      LDD	R19,Z+3
    0D17 DECF      RCALL	_SD_SizeDisplay
(0070) 
(0071) 	if(Capacity<0xff)return 1;
    0D18 EF4F      LDI	R20,0xFF
    0D19 E050      LDI	R21,0
    0D1A E060      LDI	R22,0
    0D1B E070      LDI	R23,0
    0D1C 01FE      MOVW	R30,R28
    0D1D 5FEA      SUBI	R30,0xFA
    0D1E 4FFD      SBCI	R31,0xFD
    0D1F 8020      LDD	R2,Z+0
    0D20 8031      LDD	R3,Z+1
    0D21 8042      LDD	R4,Z+2
    0D22 8053      LDD	R5,Z+3
    0D23 1624      CP	R2,R20
    0D24 0635      CPC	R3,R21
    0D25 0646      CPC	R4,R22
    0D26 0657      CPC	R5,R23
    0D27 F410      BCC	0x0D2A
    0D28 E001      LDI	R16,1
    0D29 C141      RJMP	0x0E6B
(0072) 
(0073) 
(0074) 	if(FAT_ReadSector(0,buffer))return 1;
    0D2A 01CE      MOVW	R24,R28
    0D2B 9606      ADIW	R24,6
    0D2C 8399      STD	Y+1,R25
    0D2D 8388      STD	Y+0,R24
    0D2E E000      LDI	R16,0
    0D2F E010      LDI	R17,0
    0D30 E020      LDI	R18,0
    0D31 E030      LDI	R19,0
    0D32 91E00198  LDS	R30,FAT_ReadSector
    0D34 91F00199  LDS	R31,FAT_ReadSector+1
    0D36 940E23F1  CALL	xicall
    0D38 2300      TST	R16
    0D39 F011      BEQ	0x0D3C
    0D3A E001      LDI	R16,1
    0D3B C12F      RJMP	0x0E6B
(0075) 	bs = (struct bootsector710 *)buffer;		
    0D3C 01CE      MOVW	R24,R28
    0D3D 9606      ADIW	R24,6
    0D3E 016C      MOVW	R12,R24
(0076) 	pr = (struct partrecord *)((struct partsector *)buffer)->psPart;//first partition
    0D3F 01CE      MOVW	R24,R28
    0D40 538C      SUBI	R24,0x3C
    0D41 4F9E      SBCI	R25,0xFE
    0D42 017C      MOVW	R14,R24
(0077) 	hidsec = pr->prStartLBA;//the hidden sectors
    0D43 01FC      MOVW	R30,R24
    0D44 8420      LDD	R2,Z+8
    0D45 8431      LDD	R3,Z+9
    0D46 8442      LDD	R4,Z+10
    0D47 8453      LDD	R5,Z+11
    0D48 01FE      MOVW	R30,R28
    0D49 8222      STD	Z+2,R2
    0D4A 8233      STD	Z+3,R3
    0D4B 8244      STD	Z+4,R4
    0D4C 8255      STD	Z+5,R5
(0078) 	if(hidsec >= Capacity/512)
    0D4D E089      LDI	R24,0x9
    0D4E E090      LDI	R25,0
    0D4F 01FE      MOVW	R30,R28
    0D50 5FEA      SUBI	R30,0xFA
    0D51 4FFD      SBCI	R31,0xFD
    0D52 8020      LDD	R2,Z+0
    0D53 8031      LDD	R3,Z+1
    0D54 8042      LDD	R4,Z+2
    0D55 8053      LDD	R5,Z+3
    0D56 938A      ST	R24,-Y
    0D57 0181      MOVW	R16,R2
    0D58 0192      MOVW	R18,R4
    0D59 940E243B  CALL	lsr32
    0D5B 01FE      MOVW	R30,R28
    0D5C 8022      LDD	R2,Z+2
    0D5D 8033      LDD	R3,Z+3
    0D5E 8044      LDD	R4,Z+4
    0D5F 8055      LDD	R5,Z+5
    0D60 1620      CP	R2,R16
    0D61 0631      CPC	R3,R17
    0D62 0642      CPC	R4,R18
    0D63 0653      CPC	R5,R19
    0D64 F050      BCS	0x0D6F
(0079) 	{
(0080) 		hidsec = 0;
    0D65 E040      LDI	R20,0
    0D66 E050      LDI	R21,0
    0D67 E060      LDI	R22,0
    0D68 E070      LDI	R23,0
    0D69 01FE      MOVW	R30,R28
    0D6A 8342      STD	Z+2,R20
    0D6B 8353      STD	Z+3,R21
    0D6C 8364      STD	Z+4,R22
    0D6D 8375      STD	Z+5,R23
(0081) 	}
    0D6E C03C      RJMP	0x0DAB
(0082) 	else 
(0083) 	{
(0084) 		if(FAT_ReadSector(pr->prStartLBA,buffer))return 1;//read the bpb sector
    0D6F 01CE      MOVW	R24,R28
    0D70 9606      ADIW	R24,6
    0D71 8399      STD	Y+1,R25
    0D72 8388      STD	Y+0,R24
    0D73 01F7      MOVW	R30,R14
    0D74 8500      LDD	R16,Z+8
    0D75 8511      LDD	R17,Z+9
    0D76 8522      LDD	R18,Z+10
    0D77 8533      LDD	R19,Z+11
    0D78 91E00198  LDS	R30,FAT_ReadSector
    0D7A 91F00199  LDS	R31,FAT_ReadSector+1
    0D7C 940E23F1  CALL	xicall
    0D7E 2300      TST	R16
    0D7F F011      BEQ	0x0D82
    0D80 E001      LDI	R16,1
    0D81 C0E9      RJMP	0x0E6B
(0085) 		bs = (struct bootsector710 *)buffer;
    0D82 01CE      MOVW	R24,R28
    0D83 9606      ADIW	R24,6
    0D84 016C      MOVW	R12,R24
(0086) 		if(bs->bsJump[0]!=0xE9 && bs->bsJump[0]!=0xEB)
    0D85 01FC      MOVW	R30,R24
    0D86 8020      LDD	R2,Z+0
    0D87 2433      CLR	R3
    0D88 2D82      MOV	R24,R2
    0D89 3E89      CPI	R24,0xE9
    0D8A F101      BEQ	0x0DAB
    0D8B 3E8B      CPI	R24,0xEB
    0D8C F0F1      BEQ	0x0DAB
(0087) 		{
(0088) 			hidsec = 0;
    0D8D E040      LDI	R20,0
    0D8E E050      LDI	R21,0
    0D8F E060      LDI	R22,0
    0D90 E070      LDI	R23,0
    0D91 01FE      MOVW	R30,R28
    0D92 8342      STD	Z+2,R20
    0D93 8353      STD	Z+3,R21
    0D94 8364      STD	Z+4,R22
    0D95 8375      STD	Z+5,R23
(0089) 			if(FAT_ReadSector(0,buffer))return 1;//read the bpb sector
    0D96 01CE      MOVW	R24,R28
    0D97 9606      ADIW	R24,6
    0D98 8399      STD	Y+1,R25
    0D99 8388      STD	Y+0,R24
    0D9A E000      LDI	R16,0
    0D9B E010      LDI	R17,0
    0D9C E020      LDI	R18,0
    0D9D E030      LDI	R19,0
    0D9E 91E00198  LDS	R30,FAT_ReadSector
    0DA0 91F00199  LDS	R31,FAT_ReadSector+1
    0DA2 940E23F1  CALL	xicall
    0DA4 2300      TST	R16
    0DA5 F011      BEQ	0x0DA8
    0DA6 E001      LDI	R16,1
    0DA7 C0C3      RJMP	0x0E6B
(0090) 			bs = (struct bootsector710 *)buffer;	
    0DA8 01CE      MOVW	R24,R28
    0DA9 9606      ADIW	R24,6
    0DAA 016C      MOVW	R12,R24
(0091) 		}
(0092) 	}
(0093) 
(0094) 	if(bs->bsJump[0]!=0xE9 && bs->bsJump[0]!=0xEB)//对付没有bootsect的sd卡	//dead with the card which has no bootsect
    0DAB 01F6      MOVW	R30,R12
    0DAC 8020      LDD	R2,Z+0
    0DAD 2433      CLR	R3
    0DAE 2D82      MOV	R24,R2
    0DAF 3E89      CPI	R24,0xE9
    0DB0 F021      BEQ	0x0DB5
    0DB1 3E8B      CPI	R24,0xEB
    0DB2 F011      BEQ	0x0DB5
(0095) 	{
(0096) 		return 1;
    0DB3 E001      LDI	R16,1
    0DB4 C0B6      RJMP	0x0E6B
(0097) 	}
(0098) 	
(0099) 	
(0100) 	
(0101) 	bpb = (struct bpb710 *)bs->bsBPB;
    0DB5 01C6      MOVW	R24,R12
    0DB6 960B      ADIW	R24,0xB
    0DB7 015C      MOVW	R10,R24
(0102) 
(0103) 	
(0104) 	if(bpb->bpbFATsecs)						//判断文件系统类型，不支持FAT12,支持FAT16和FAT32
    0DB8 01FC      MOVW	R30,R24
    0DB9 8423      LDD	R2,Z+11
    0DBA 8434      LDD	R3,Z+12
    0DBB 2022      TST	R2
    0DBC F411      BNE	0x0DBF
    0DBD 2033      TST	R3
    0DBE F0B9      BEQ	0x0DD6
(0105) 	{
(0106) 		FAT32_Enable=0;						//FAT16
    0DBF 2422      CLR	R2
    0DC0 92200EFC  STS	FAT32_Enable,R2
(0107) 		FATsectors		= bpb->bpbFATsecs;	//FAT占用的扇区数	
    0DC2 01F5      MOVW	R30,R10
    0DC3 8423      LDD	R2,Z+11
    0DC4 8434      LDD	R3,Z+12
    0DC5 92300F10  STS	FATsectors+1,R3
    0DC7 92200F0F  STS	FATsectors,R2
(0108) 		FirstDirClust = 2;
    0DC9 E042      LDI	R20,2
    0DCA E050      LDI	R21,0
    0DCB E060      LDI	R22,0
    0DCC E070      LDI	R23,0
    0DCD 93500F18  STS	FirstDirClust+1,R21
    0DCF 93400F17  STS	FirstDirClust,R20
    0DD1 93700F1A  STS	FirstDirClust+3,R23
    0DD3 93600F19  STS	FirstDirClust+2,R22
(0109) 	}
    0DD5 C017      RJMP	0x0DED
(0110) 	else
(0111) 	{
(0112) 		FAT32_Enable=1;						 //FAT32
    0DD6 E081      LDI	R24,1
    0DD7 93800EFC  STS	FAT32_Enable,R24
(0113) 		FATsectors		= bpb->bpbBigFATsecs;//FAT占用的扇区数	//the sectors number occupied by one fat talbe
    0DD9 01F5      MOVW	R30,R10
    0DDA 8C21      LDD	R2,Z+25
    0DDB 8C32      LDD	R3,Z+26
    0DDC 92300F10  STS	FATsectors+1,R3
    0DDE 92200F0F  STS	FATsectors,R2
(0114) 		FirstDirClust = bpb->bpbRootClust;
    0DE0 01F5      MOVW	R30,R10
    0DE1 A021      LDD	R2,Z+33
    0DE2 A032      LDD	R3,Z+34
    0DE3 A043      LDD	R4,Z+35
    0DE4 A054      LDD	R5,Z+36
    0DE5 92300F18  STS	FirstDirClust+1,R3
    0DE7 92200F17  STS	FirstDirClust,R2
    0DE9 92500F1A  STS	FirstDirClust+3,R5
    0DEB 92400F19  STS	FirstDirClust+2,R4
(0115) 	}
(0116) 
(0117) 	BytesPerSector	= bpb->bpbBytesPerSec;	//每扇区字节数
    0DED 01F5      MOVW	R30,R10
    0DEE 8020      LDD	R2,Z+0
    0DEF 8031      LDD	R3,Z+1
    0DF0 92300F12  STS	BytesPerSector+1,R3
    0DF2 92200F11  STS	BytesPerSector,R2
(0118) 	
(0119) 	SectorsPerClust	= (BYTE)bpb->bpbSecPerClust;//每簇扇区数
    0DF4 8022      LDD	R2,Z+2
    0DF5 2433      CLR	R3
    0DF6 92300F0E  STS	SectorsPerClust+1,R3
    0DF8 92200F0D  STS	SectorsPerClust,R2
(0120) 	
(0121) 	FirstFATSector	= bpb->bpbResSectors+hidsec;//第一个FAT表扇区
    0DFA 01FE      MOVW	R30,R28
    0DFB 8022      LDD	R2,Z+2
    0DFC 8033      LDD	R3,Z+3
    0DFD 8044      LDD	R4,Z+4
    0DFE 8055      LDD	R5,Z+5
    0DFF 01F5      MOVW	R30,R10
    0E00 8063      LDD	R6,Z+3
    0E01 8074      LDD	R7,Z+4
    0E02 2488      CLR	R8
    0E03 2499      CLR	R9
    0E04 0C62      ADD	R6,R2
    0E05 1C73      ADC	R7,R3
    0E06 1C84      ADC	R8,R4
    0E07 1C95      ADC	R9,R5
    0E08 92700F0A  STS	FirstFATSector+1,R7
    0E0A 92600F09  STS	FirstFATSector,R6
    0E0C 92900F0C  STS	FirstFATSector+3,R9
    0E0E 92800F0B  STS	FirstFATSector+2,R8
(0122) 	RootDirCount	= bpb->bpbRootDirEnts;//根目录项数
    0E10 01F5      MOVW	R30,R10
    0E11 8026      LDD	R2,Z+6
    0E12 8037      LDD	R3,Z+7
    0E13 2444      CLR	R4
    0E14 2455      CLR	R5
    0E15 92300EFE  STS	RootDirCount+1,R3
    0E17 92200EFD  STS	RootDirCount,R2
    0E19 92500F00  STS	RootDirCount+3,R5
    0E1B 92400EFF  STS	RootDirCount+2,R4
(0123) 	RootDirSectors	= (RootDirCount*32)>>9;//根目录占用的扇区数
    0E1D E240      LDI	R20,0x20
    0E1E E050      LDI	R21,0
    0E1F E060      LDI	R22,0
    0E20 E070      LDI	R23,0
    0E21 925A      ST	R5,-Y
    0E22 924A      ST	R4,-Y
    0E23 923A      ST	R3,-Y
    0E24 922A      ST	R2,-Y
    0E25 018A      MOVW	R16,R20
    0E26 019B      MOVW	R18,R22
    0E27 940E2396  CALL	empy32s
    0E29 E089      LDI	R24,0x9
    0E2A E090      LDI	R25,0
    0E2B 938A      ST	R24,-Y
    0E2C 940E243B  CALL	lsr32
    0E2E 93100F02  STS	RootDirSectors+1,R17
    0E30 93000F01  STS	RootDirSectors,R16
    0E32 93300F04  STS	RootDirSectors+3,R19
    0E34 93200F03  STS	RootDirSectors+2,R18
(0124) 	FirstDirSector	= FirstFATSector+bpb->bpbFATs*FATsectors;//第一个目录扇区
    0E36 91200F0F  LDS	R18,FATsectors
    0E38 91300F10  LDS	R19,FATsectors+1
    0E3A 01F5      MOVW	R30,R10
    0E3B 8105      LDD	R16,Z+5
    0E3C 2711      CLR	R17
    0E3D 940E2386  CALL	empy16s
    0E3F 0118      MOVW	R2,R16
    0E40 2444      CLR	R4
    0E41 2455      CLR	R5
    0E42 90800F0B  LDS	R8,FirstFATSector+2
    0E44 90900F0C  LDS	R9,FirstFATSector+3
    0E46 90600F09  LDS	R6,FirstFATSector
    0E48 90700F0A  LDS	R7,FirstFATSector+1
    0E4A 0C62      ADD	R6,R2
    0E4B 1C73      ADC	R7,R3
    0E4C 1C84      ADC	R8,R4
    0E4D 1C95      ADC	R9,R5
    0E4E 92700F06  STS	FirstDirSector+1,R7
    0E50 92600F05  STS	FirstDirSector,R6
    0E52 92900F08  STS	FirstDirSector+3,R9
    0E54 92800F07  STS	FirstDirSector+2,R8
(0125) 	FirstDataSector	= FirstDirSector+RootDirSectors;//第一个数据扇区
    0E56 90400F03  LDS	R4,RootDirSectors+2
    0E58 90500F04  LDS	R5,RootDirSectors+3
    0E5A 90200F01  LDS	R2,RootDirSectors
    0E5C 90300F02  LDS	R3,RootDirSectors+1
    0E5E 0C62      ADD	R6,R2
    0E5F 1C73      ADC	R7,R3
    0E60 1C84      ADC	R8,R4
    0E61 1C95      ADC	R9,R5
    0E62 92700F14  STS	FirstDataSector+1,R7
    0E64 92600F13  STS	FirstDataSector,R6
    0E66 92900F16  STS	FirstDataSector+3,R9
    0E68 92800F15  STS	FirstDataSector+2,R8
(0126) 	return 0;
    0E6A 2700      CLR	R16
    0E6B 96EF      ADIW	R28,0x3F
    0E6C 96EF      ADIW	R28,0x3F
    0E6D 96EF      ADIW	R28,0x3F
    0E6E 96EF      ADIW	R28,0x3F
    0E6F 96EF      ADIW	R28,0x3F
    0E70 96EF      ADIW	R28,0x3F
    0E71 96EF      ADIW	R28,0x3F
    0E72 96EF      ADIW	R28,0x3F
    0E73 9666      ADIW	R28,0x16
    0E74 940E23CF  CALL	pop_gset5
    0E76 9508      RET
_FAT_LoadPartCluster:
  sector               --> Y+2
  buffer               --> Y+16
  part                 --> Y+14
  cluster              --> Y+10
    0E77 940E22CF  CALL	push_arg4
    0E79 940E23D8  CALL	push_gset2
    0E7B 9726      SBIW	R28,6
(0127) }
(0128) 
(0129) //读一个簇中的一个扇区
(0130) //read one sector of one cluster, parameter part indicate which sector
(0131) unsigned char FAT_LoadPartCluster(unsigned long cluster,unsigned part,BYTE * buffer)
(0132) {
(0133) 	DWORD sector;
(0134) 	sector=FirstDataSector+(DWORD)(cluster-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
    0E7C E042      LDI	R20,2
    0E7D E050      LDI	R21,0
    0E7E E060      LDI	R22,0
    0E7F E070      LDI	R23,0
    0E80 01FE      MOVW	R30,R28
    0E81 8422      LDD	R2,Z+10
    0E82 8433      LDD	R3,Z+11
    0E83 8444      LDD	R4,Z+12
    0E84 8455      LDD	R5,Z+13
    0E85 1A24      SUB	R2,R20
    0E86 0A35      SBC	R3,R21
    0E87 0A46      SBC	R4,R22
    0E88 0A57      SBC	R5,R23
    0E89 90600F0D  LDS	R6,SectorsPerClust
    0E8B 90700F0E  LDS	R7,SectorsPerClust+1
    0E8D 2488      CLR	R8
    0E8E 2499      CLR	R9
    0E8F 929A      ST	R9,-Y
    0E90 928A      ST	R8,-Y
    0E91 927A      ST	R7,-Y
    0E92 926A      ST	R6,-Y
    0E93 0181      MOVW	R16,R2
    0E94 0192      MOVW	R18,R4
    0E95 940E2396  CALL	empy32s
    0E97 90400F15  LDS	R4,FirstDataSector+2
    0E99 90500F16  LDS	R5,FirstDataSector+3
    0E9B 90200F13  LDS	R2,FirstDataSector
    0E9D 90300F14  LDS	R3,FirstDataSector+1
    0E9F 0E20      ADD	R2,R16
    0EA0 1E31      ADC	R3,R17
    0EA1 1E42      ADC	R4,R18
    0EA2 1E53      ADC	R5,R19
    0EA3 01FE      MOVW	R30,R28
    0EA4 8222      STD	Z+2,R2
    0EA5 8233      STD	Z+3,R3
    0EA6 8244      STD	Z+4,R4
    0EA7 8255      STD	Z+5,R5
(0135) 	if(FAT_ReadSector(sector+part,buffer))return 1;
    0EA8 8808      LDD	R0,Y+16
    0EA9 8819      LDD	R1,Y+17
    0EAA 8219      STD	Y+1,R1
    0EAB 8208      STD	Y+0,R0
    0EAC 842E      LDD	R2,Y+14
    0EAD 843F      LDD	R3,Y+15
    0EAE 2444      CLR	R4
    0EAF 2455      CLR	R5
    0EB0 01FE      MOVW	R30,R28
    0EB1 8062      LDD	R6,Z+2
    0EB2 8073      LDD	R7,Z+3
    0EB3 8084      LDD	R8,Z+4
    0EB4 8095      LDD	R9,Z+5
    0EB5 0C62      ADD	R6,R2
    0EB6 1C73      ADC	R7,R3
    0EB7 1C84      ADC	R8,R4
    0EB8 1C95      ADC	R9,R5
    0EB9 0183      MOVW	R16,R6
    0EBA 0194      MOVW	R18,R8
    0EBB 91E00198  LDS	R30,FAT_ReadSector
    0EBD 91F00199  LDS	R31,FAT_ReadSector+1
    0EBF 940E23F1  CALL	xicall
    0EC1 2300      TST	R16
    0EC2 F011      BEQ	0x0EC5
    0EC3 E001      LDI	R16,1
    0EC4 C001      RJMP	0x0EC6
(0136) 	else return 0;
    0EC5 2700      CLR	R16
    0EC6 9626      ADIW	R28,6
    0EC7 940E23C6  CALL	pop_gset2
    0EC9 9624      ADIW	R28,4
    0ECA 9508      RET
_FAT_NextCluster:
  buffer               --> Y+10
  offset               --> Y+6
  sector               --> Y+2
  cluster              --> Y+526
    0ECB 940E22CF  CALL	push_arg4
    0ECD 940E23D8  CALL	push_gset2
    0ECF 97EF      SBIW	R28,0x3F
    0ED0 97EF      SBIW	R28,0x3F
    0ED1 97EF      SBIW	R28,0x3F
    0ED2 97EF      SBIW	R28,0x3F
    0ED3 97EF      SBIW	R28,0x3F
    0ED4 97EF      SBIW	R28,0x3F
    0ED5 97EF      SBIW	R28,0x3F
    0ED6 97EF      SBIW	R28,0x3F
    0ED7 9762      SBIW	R28,0x12
(0137) }
(0138) 
(0139) 
(0140) //读下一簇簇号
(0141) //Return the cluster number of next cluster of file
(0142) //Suitable for system which has limited RAM
(0143) unsigned long FAT_NextCluster(unsigned long cluster)
(0144) {
(0145) 	BYTE buffer[512];
(0146) 	DWORD sector;
(0147) 	DWORD offset;
(0148) 	if(FAT32_Enable)offset = cluster/128;
    0ED8 90200EFC  LDS	R2,FAT32_Enable
    0EDA 2022      TST	R2
    0EDB F0A1      BEQ	0x0EF0
    0EDC E087      LDI	R24,7
    0EDD E090      LDI	R25,0
    0EDE 01FE      MOVW	R30,R28
    0EDF 5FE2      SUBI	R30,0xF2
    0EE0 4FFD      SBCI	R31,0xFD
    0EE1 8020      LDD	R2,Z+0
    0EE2 8031      LDD	R3,Z+1
    0EE3 8042      LDD	R4,Z+2
    0EE4 8053      LDD	R5,Z+3
    0EE5 938A      ST	R24,-Y
    0EE6 0181      MOVW	R16,R2
    0EE7 0192      MOVW	R18,R4
    0EE8 940E243B  CALL	lsr32
    0EEA 01FE      MOVW	R30,R28
    0EEB 8306      STD	Z+6,R16
    0EEC 8317      STD	Z+7,R17
    0EED 8720      STD	Z+8,R18
    0EEE 8731      STD	Z+9,R19
    0EEF C013      RJMP	0x0F03
(0149) 	else offset = cluster/256;
    0EF0 E088      LDI	R24,0x8
    0EF1 E090      LDI	R25,0
    0EF2 01FE      MOVW	R30,R28
    0EF3 5FE2      SUBI	R30,0xF2
    0EF4 4FFD      SBCI	R31,0xFD
    0EF5 8020      LDD	R2,Z+0
    0EF6 8031      LDD	R3,Z+1
    0EF7 8042      LDD	R4,Z+2
    0EF8 8053      LDD	R5,Z+3
    0EF9 938A      ST	R24,-Y
    0EFA 0181      MOVW	R16,R2
    0EFB 0192      MOVW	R18,R4
    0EFC 940E243B  CALL	lsr32
    0EFE 01FE      MOVW	R30,R28
    0EFF 8306      STD	Z+6,R16
    0F00 8317      STD	Z+7,R17
    0F01 8720      STD	Z+8,R18
    0F02 8731      STD	Z+9,R19
(0150) 	if(cluster<2)return 0x0ffffff8;
    0F03 E042      LDI	R20,2
    0F04 E050      LDI	R21,0
    0F05 E060      LDI	R22,0
    0F06 E070      LDI	R23,0
    0F07 01FE      MOVW	R30,R28
    0F08 5FE2      SUBI	R30,0xF2
    0F09 4FFD      SBCI	R31,0xFD
    0F0A 8020      LDD	R2,Z+0
    0F0B 8031      LDD	R3,Z+1
    0F0C 8042      LDD	R4,Z+2
    0F0D 8053      LDD	R5,Z+3
    0F0E 1624      CP	R2,R20
    0F0F 0635      CPC	R3,R21
    0F10 0646      CPC	R4,R22
    0F11 0657      CPC	R5,R23
    0F12 F428      BCC	0x0F18
    0F13 EF08      LDI	R16,0xF8
    0F14 EF1F      LDI	R17,0xFF
    0F15 EF2F      LDI	R18,0xFF
    0F16 E03F      LDI	R19,0xF
    0F17 C09D      RJMP	0x0FB5
(0151) 	sector=FirstFATSector+offset;//calculate the actual sector
    0F18 01FE      MOVW	R30,R28
    0F19 8026      LDD	R2,Z+6
    0F1A 8037      LDD	R3,Z+7
    0F1B 8440      LDD	R4,Z+8
    0F1C 8451      LDD	R5,Z+9
    0F1D 90800F0B  LDS	R8,FirstFATSector+2
    0F1F 90900F0C  LDS	R9,FirstFATSector+3
    0F21 90600F09  LDS	R6,FirstFATSector
    0F23 90700F0A  LDS	R7,FirstFATSector+1
    0F25 0C62      ADD	R6,R2
    0F26 1C73      ADC	R7,R3
    0F27 1C84      ADC	R8,R4
    0F28 1C95      ADC	R9,R5
    0F29 01FE      MOVW	R30,R28
    0F2A 8262      STD	Z+2,R6
    0F2B 8273      STD	Z+3,R7
    0F2C 8284      STD	Z+4,R8
    0F2D 8295      STD	Z+5,R9
(0152) 	if(FAT_ReadSector(sector,buffer))return 0x0ffffff8;//read fat table / return 0xfff8 when error occured
    0F2E 01CE      MOVW	R24,R28
    0F2F 960A      ADIW	R24,0xA
    0F30 8399      STD	Y+1,R25
    0F31 8388      STD	Y+0,R24
    0F32 01FE      MOVW	R30,R28
    0F33 8102      LDD	R16,Z+2
    0F34 8113      LDD	R17,Z+3
    0F35 8124      LDD	R18,Z+4
    0F36 8135      LDD	R19,Z+5
    0F37 91E00198  LDS	R30,FAT_ReadSector
    0F39 91F00199  LDS	R31,FAT_ReadSector+1
    0F3B 940E23F1  CALL	xicall
    0F3D 2300      TST	R16
    0F3E F029      BEQ	0x0F44
    0F3F EF08      LDI	R16,0xF8
    0F40 EF1F      LDI	R17,0xFF
    0F41 EF2F      LDI	R18,0xFF
    0F42 E03F      LDI	R19,0xF
    0F43 C071      RJMP	0x0FB5
(0153) 
(0154) 	if(FAT32_Enable)
    0F44 90200EFC  LDS	R2,FAT32_Enable
    0F46 2022      TST	R2
    0F47 F409      BNE	0x0F49
    0F48 C034      RJMP	0x0F7D
(0155) 	{
(0156) 		offset=cluster%128;//find the position
    0F49 E74F      LDI	R20,0x7F
    0F4A E050      LDI	R21,0
    0F4B E060      LDI	R22,0
    0F4C E070      LDI	R23,0
    0F4D 01FE      MOVW	R30,R28
    0F4E 5FE2      SUBI	R30,0xF2
    0F4F 4FFD      SBCI	R31,0xFD
    0F50 8020      LDD	R2,Z+0
    0F51 8031      LDD	R3,Z+1
    0F52 8042      LDD	R4,Z+2
    0F53 8053      LDD	R5,Z+3
    0F54 2224      AND	R2,R20
    0F55 2235      AND	R3,R21
    0F56 2246      AND	R4,R22
    0F57 2257      AND	R5,R23
    0F58 01FE      MOVW	R30,R28
    0F59 8226      STD	Z+6,R2
    0F5A 8237      STD	Z+7,R3
    0F5B 8640      STD	Z+8,R4
    0F5C 8651      STD	Z+9,R5
(0157) 		sector=((unsigned long *)buffer)[offset];	
    0F5D 01FE      MOVW	R30,R28
    0F5E 8026      LDD	R2,Z+6
    0F5F 8037      LDD	R3,Z+7
    0F60 8440      LDD	R4,Z+8
    0F61 8451      LDD	R5,Z+9
    0F62 E044      LDI	R20,4
    0F63 E050      LDI	R21,0
    0F64 E060      LDI	R22,0
    0F65 E070      LDI	R23,0
    0F66 925A      ST	R5,-Y
    0F67 924A      ST	R4,-Y
    0F68 923A      ST	R3,-Y
    0F69 922A      ST	R2,-Y
    0F6A 018A      MOVW	R16,R20
    0F6B 019B      MOVW	R18,R22
    0F6C 940E2396  CALL	empy32s
    0F6E 01F8      MOVW	R30,R16
    0F6F 01CE      MOVW	R24,R28
    0F70 960A      ADIW	R24,0xA
    0F71 0FE8      ADD	R30,R24
    0F72 1FF9      ADC	R31,R25
    0F73 8020      LDD	R2,Z+0
    0F74 8031      LDD	R3,Z+1
    0F75 8042      LDD	R4,Z+2
    0F76 8053      LDD	R5,Z+3
    0F77 01FE      MOVW	R30,R28
    0F78 8222      STD	Z+2,R2
    0F79 8233      STD	Z+3,R3
    0F7A 8244      STD	Z+4,R4
    0F7B 8255      STD	Z+5,R5
(0158) 	}
    0F7C C033      RJMP	0x0FB0
(0159) 	else
(0160) 	{
(0161) 		offset=cluster%256;//find the position
    0F7D EF4F      LDI	R20,0xFF
    0F7E E050      LDI	R21,0
    0F7F E060      LDI	R22,0
    0F80 E070      LDI	R23,0
    0F81 01FE      MOVW	R30,R28
    0F82 5FE2      SUBI	R30,0xF2
    0F83 4FFD      SBCI	R31,0xFD
    0F84 8020      LDD	R2,Z+0
    0F85 8031      LDD	R3,Z+1
    0F86 8042      LDD	R4,Z+2
    0F87 8053      LDD	R5,Z+3
    0F88 2224      AND	R2,R20
    0F89 2235      AND	R3,R21
    0F8A 2246      AND	R4,R22
    0F8B 2257      AND	R5,R23
    0F8C 01FE      MOVW	R30,R28
    0F8D 8226      STD	Z+6,R2
    0F8E 8237      STD	Z+7,R3
    0F8F 8640      STD	Z+8,R4
    0F90 8651      STD	Z+9,R5
(0162) 		sector=((unsigned int *)buffer)[offset];
    0F91 01FE      MOVW	R30,R28
    0F92 8026      LDD	R2,Z+6
    0F93 8037      LDD	R3,Z+7
    0F94 8440      LDD	R4,Z+8
    0F95 8451      LDD	R5,Z+9
    0F96 E042      LDI	R20,2
    0F97 E050      LDI	R21,0
    0F98 E060      LDI	R22,0
    0F99 E070      LDI	R23,0
    0F9A 925A      ST	R5,-Y
    0F9B 924A      ST	R4,-Y
    0F9C 923A      ST	R3,-Y
    0F9D 922A      ST	R2,-Y
    0F9E 018A      MOVW	R16,R20
    0F9F 019B      MOVW	R18,R22
    0FA0 940E2396  CALL	empy32s
    0FA2 01F8      MOVW	R30,R16
    0FA3 01CE      MOVW	R24,R28
    0FA4 960A      ADIW	R24,0xA
    0FA5 0FE8      ADD	R30,R24
    0FA6 1FF9      ADC	R31,R25
    0FA7 8020      LDD	R2,Z+0
    0FA8 8031      LDD	R3,Z+1
    0FA9 2444      CLR	R4
    0FAA 2455      CLR	R5
    0FAB 01FE      MOVW	R30,R28
    0FAC 8222      STD	Z+2,R2
    0FAD 8233      STD	Z+3,R3
    0FAE 8244      STD	Z+4,R4
    0FAF 8255      STD	Z+5,R5
(0163) 	}
(0164) 	return (unsigned long)sector;//return the cluste number
    0FB0 01FE      MOVW	R30,R28
    0FB1 8102      LDD	R16,Z+2
    0FB2 8113      LDD	R17,Z+3
    0FB3 8124      LDD	R18,Z+4
    0FB4 8135      LDD	R19,Z+5
    0FB5 96EF      ADIW	R28,0x3F
    0FB6 96EF      ADIW	R28,0x3F
    0FB7 96EF      ADIW	R28,0x3F
    0FB8 96EF      ADIW	R28,0x3F
    0FB9 96EF      ADIW	R28,0x3F
    0FBA 96EF      ADIW	R28,0x3F
    0FBB 96EF      ADIW	R28,0x3F
    0FBC 96EF      ADIW	R28,0x3F
    0FBD 9662      ADIW	R28,0x12
    0FBE 940E23C6  CALL	pop_gset2
    0FC0 9624      ADIW	R28,4
    0FC1 9508      RET
_CopyDirentruyItem:
  i                    --> R20
  Source               --> R18
  Desti                --> R16
    0FC2 940E23DA  CALL	push_gset1
(0165) }
(0166) 
(0167) #if FIX_DIRECTORY
(0168) //在给定目录下查找文件
(0169) //Find a item in the directory which specify by the parameter "cluster"
(0170) //Return the start cluster number
(0171) unsigned int FAT_FindItem(unsigned long cluster, BYTE *name, struct FileInfoStruct *FileInfo)
(0172) {
(0173) 	BYTE *buffer;
(0174) 	DWORD tempclust;
(0175) 	DWORD sector;
(0176) 	unsigned char cnt;
(0177) 	unsigned int offset;
(0178) 	unsigned char i;
(0179) 	struct direntry *item = 0;
(0180) 	if((cluster==0) && (FAT32_Enable == 0))// root directory
(0181) 	{
(0182) 		buffer=malloc(512);//apply memory
(0183) 		if(buffer==0)return 1;//if failed
(0184) 		for(cnt=0;cnt<RootDirSectors;cnt++)
(0185) 		{
(0186) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
(0187) 			for(offset=0;offset<512;offset+=32)
(0188) 			{
(0189) 				item=(struct direntry *)(&buffer[offset]);
(0190) 				if((item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0191) 				{
(0192) 					for(i=0;i<11;i++)
(0193) 					{
(0194) 						if(buffer[offset+i]!=name[i])break;
(0195) 					}
(0196) 					if(i==11)
(0197) 					{
(0198) 						//return the parameter of the item
(0199) 						FileInfo->StartCluster = item->deStartCluster + (((unsigned long)item->deHighClust)<<16);//don't care
(0200) 						FileInfo->Size         = item->deFileSize;
(0201) 						FileInfo->Attr         = item->deAttributes;
(0202) 						FileInfo->Sector       = FirstDirSector+cnt;
(0203) 						FileInfo->Offset       = offset;
(0204) 						free(buffer);
(0205) 						return 0;
(0206) 					}
(0207) 				}
(0208) 			}
(0209) 		}
(0210) 		free(buffer);//release
(0211) 	}
(0212) 	else//other folders
(0213) 	{
(0214) 		tempclust=cluster;
(0215) 		while(1)
(0216) 		{
(0217) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
(0218) 			buffer=malloc(512);//apply memory
(0219) 			if(buffer==0)return 1;//if failed
(0220) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
(0221) 			{
(0222) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
(0223) 				for(offset=0;offset<512;offset+=32)
(0224) 				{
(0225) 					item=(struct direntry *)(&buffer[offset]);
(0226) 					if((item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0227) 					{
(0228) 						for(i=0;i<11;i++)
(0229) 						{
(0230) 							if(buffer[offset+i]!=name[i])break;
(0231) 						}
(0232) 						if(i==11)
(0233) 						{
(0234) 							FileInfo->StartCluster = item->deStartCluster + (((unsigned long)item->deHighClust)<<16);//don't care
(0235) 							FileInfo->Size         = item->deFileSize;
(0236) 							FileInfo->Attr         = item->deAttributes;
(0237) 							FileInfo->Sector       = sector+cnt;
(0238) 							FileInfo->Offset       = offset;
(0239) 							free(buffer);
(0240) 							return 0;
(0241) 						}
(0242) 					}
(0243) 				}
(0244) 			}
(0245) 			free(buffer);//release
(0246) 			tempclust=FAT_NextCluster(tempclust);//next cluster
(0247) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
(0248) 		}
(0249) 	}
(0250) 	return 1;
(0251) }
(0252) 
(0253) // find a directory with the given path
(0254) unsigned long FAT_OpenDir(BYTE * dir)
(0255) {
(0256) 	BYTE name[11];
(0257) 	BYTE *p=dir;
(0258) 	BYTE deep=0;
(0259) 	BYTE i,j;
(0260) 	DWORD cluster=0;
(0261) 	if(FAT32_Enable)cluster = FirstDirClust;
(0262) 	if(*p != '\\')return 1;//invalid path
(0263) 	while(*p)
(0264) 	{
(0265) 		if(*p == '\\')
(0266) 		{
(0267) 			deep++;
(0268) 		}
(0269) 		p++;
(0270) 	}
(0271) 	p=dir;
(0272) 	for(i=0;i<deep-1;i++)
(0273) 	{
(0274) 		p++;
(0275) 		for(j=0;j<11;j++)name[j]=0x20;
(0276) 		j=0;
(0277) 		while(*p != '\\')
(0278) 		{
(0279) 			if((*p) >= 'a' && (*p) <= 'z')name[j] = (*p++)-0x20;
(0280) 			else name[j] = *p++;
(0281) 			j++;
(0282) 		}
(0283) 		if(FAT_FindItem(cluster,name, &FileInfo))return 1;//find the directory
(0284) 		cluster = FileInfo.StartCluster;
(0285) 	}
(0286) 	p++;
(0287) 	for(j=0;j<11;j++)name[j]=0x20;
(0288) 	j=0;
(0289) 	while(*p)
(0290) 	{
(0291) 		if(*p>='a' && *p<='z')name[j]=(*p++)-0x20;
(0292) 		else name[j]=*p++;
(0293) 		j++;
(0294) 	}
(0295) 	if(j == 0)return cluster;
(0296) 	if(FAT_FindItem(cluster,name, &FileInfo))return 1;//find the final directory
(0297) 	cluster = FileInfo.StartCluster;
(0298) 	return cluster;
(0299) }
(0300) #endif  
(0301) 
(0302) //复制记录项信息  //copy item
(0303) void CopyDirentruyItem(struct direntry *Desti,struct direntry *Source)
(0304) {
(0305) 	BYTE i;
(0306) 	for(i=0;i<8;i++)Desti->deName[i] = Source->deName[i];
    0FC4 2744      CLR	R20
    0FC5 C00B      RJMP	0x0FD1
    0FC6 2FE4      MOV	R30,R20
    0FC7 27FF      CLR	R31
    0FC8 0FE2      ADD	R30,R18
    0FC9 1FF3      ADC	R31,R19
    0FCA 8020      LDD	R2,Z+0
    0FCB 2FE4      MOV	R30,R20
    0FCC 27FF      CLR	R31
    0FCD 0FE0      ADD	R30,R16
    0FCE 1FF1      ADC	R31,R17
    0FCF 8220      STD	Z+0,R2
    0FD0 9543      INC	R20
    0FD1 3048      CPI	R20,0x8
    0FD2 F398      BCS	0x0FC6
(0307) 	for(i=0;i<3;i++)Desti->deExtension[i] = Source->deExtension[i];
    0FD3 2744      CLR	R20
    0FD4 C00F      RJMP	0x0FE4
    0FD5 01C9      MOVW	R24,R18
    0FD6 9608      ADIW	R24,0x8
    0FD7 2FE4      MOV	R30,R20
    0FD8 27FF      CLR	R31
    0FD9 0FE8      ADD	R30,R24
    0FDA 1FF9      ADC	R31,R25
    0FDB 8020      LDD	R2,Z+0
    0FDC 01C8      MOVW	R24,R16
    0FDD 9608      ADIW	R24,0x8
    0FDE 2FE4      MOV	R30,R20
    0FDF 27FF      CLR	R31
    0FE0 0FE8      ADD	R30,R24
    0FE1 1FF9      ADC	R31,R25
    0FE2 8220      STD	Z+0,R2
    0FE3 9543      INC	R20
    0FE4 3043      CPI	R20,3
    0FE5 F378      BCS	0x0FD5
(0308) 	Desti->deAttributes = Source->deAttributes;
    0FE6 01F9      MOVW	R30,R18
    0FE7 8423      LDD	R2,Z+11
    0FE8 01F8      MOVW	R30,R16
    0FE9 8623      STD	Z+11,R2
(0309) 	Desti->deLowerCase = Source->deLowerCase;
    0FEA 01F9      MOVW	R30,R18
    0FEB 8424      LDD	R2,Z+12
    0FEC 01F8      MOVW	R30,R16
    0FED 8624      STD	Z+12,R2
(0310) 	Desti->deCHundredth = Source->deCHundredth;
    0FEE 01F9      MOVW	R30,R18
    0FEF 8425      LDD	R2,Z+13
    0FF0 01F8      MOVW	R30,R16
    0FF1 8625      STD	Z+13,R2
(0311) 	for(i=0;i<2;i++)Desti->deCTime[i] = Source->deCTime[i];
    0FF2 2744      CLR	R20
    0FF3 C00F      RJMP	0x1003
    0FF4 01C9      MOVW	R24,R18
    0FF5 960E      ADIW	R24,0xE
    0FF6 2FE4      MOV	R30,R20
    0FF7 27FF      CLR	R31
    0FF8 0FE8      ADD	R30,R24
    0FF9 1FF9      ADC	R31,R25
    0FFA 8020      LDD	R2,Z+0
    0FFB 01C8      MOVW	R24,R16
    0FFC 960E      ADIW	R24,0xE
    0FFD 2FE4      MOV	R30,R20
    0FFE 27FF      CLR	R31
    0FFF 0FE8      ADD	R30,R24
    1000 1FF9      ADC	R31,R25
    1001 8220      STD	Z+0,R2
    1002 9543      INC	R20
    1003 3042      CPI	R20,2
    1004 F378      BCS	0x0FF4
(0312) 	for(i=0;i<2;i++)Desti->deCDate[i] = Source->deCDate[i];
    1005 2744      CLR	R20
    1006 C00F      RJMP	0x1016
    1007 01C9      MOVW	R24,R18
    1008 9640      ADIW	R24,0x10
    1009 2FE4      MOV	R30,R20
    100A 27FF      CLR	R31
    100B 0FE8      ADD	R30,R24
    100C 1FF9      ADC	R31,R25
    100D 8020      LDD	R2,Z+0
    100E 01C8      MOVW	R24,R16
    100F 9640      ADIW	R24,0x10
    1010 2FE4      MOV	R30,R20
    1011 27FF      CLR	R31
    1012 0FE8      ADD	R30,R24
    1013 1FF9      ADC	R31,R25
    1014 8220      STD	Z+0,R2
    1015 9543      INC	R20
    1016 3042      CPI	R20,2
    1017 F378      BCS	0x1007
(0313) 	for(i=0;i<2;i++)Desti->deADate[i] = Source->deADate[i];
    1018 2744      CLR	R20
    1019 C00F      RJMP	0x1029
    101A 01C9      MOVW	R24,R18
    101B 9642      ADIW	R24,0x12
    101C 2FE4      MOV	R30,R20
    101D 27FF      CLR	R31
    101E 0FE8      ADD	R30,R24
    101F 1FF9      ADC	R31,R25
    1020 8020      LDD	R2,Z+0
    1021 01C8      MOVW	R24,R16
    1022 9642      ADIW	R24,0x12
    1023 2FE4      MOV	R30,R20
    1024 27FF      CLR	R31
    1025 0FE8      ADD	R30,R24
    1026 1FF9      ADC	R31,R25
    1027 8220      STD	Z+0,R2
    1028 9543      INC	R20
    1029 3042      CPI	R20,2
    102A F378      BCS	0x101A
(0314) 	Desti->deHighClust = Source->deHighClust;
    102B 01F9      MOVW	R30,R18
    102C 8824      LDD	R2,Z+20
    102D 8835      LDD	R3,Z+21
    102E 01F8      MOVW	R30,R16
    102F 8A35      STD	Z+21,R3
    1030 8A24      STD	Z+20,R2
(0315) 	for(i=0;i<2;i++)Desti->deMTime[i] = Source->deMTime[i];
    1031 2744      CLR	R20
    1032 C00F      RJMP	0x1042
    1033 01C9      MOVW	R24,R18
    1034 9646      ADIW	R24,0x16
    1035 2FE4      MOV	R30,R20
    1036 27FF      CLR	R31
    1037 0FE8      ADD	R30,R24
    1038 1FF9      ADC	R31,R25
    1039 8020      LDD	R2,Z+0
    103A 01C8      MOVW	R24,R16
    103B 9646      ADIW	R24,0x16
    103C 2FE4      MOV	R30,R20
    103D 27FF      CLR	R31
    103E 0FE8      ADD	R30,R24
    103F 1FF9      ADC	R31,R25
    1040 8220      STD	Z+0,R2
    1041 9543      INC	R20
    1042 3042      CPI	R20,2
    1043 F378      BCS	0x1033
(0316) 	for(i=0;i<2;i++)Desti->deMDate[i] = Source->deMDate[i];
    1044 2744      CLR	R20
    1045 C00F      RJMP	0x1055
    1046 01C9      MOVW	R24,R18
    1047 9648      ADIW	R24,0x18
    1048 2FE4      MOV	R30,R20
    1049 27FF      CLR	R31
    104A 0FE8      ADD	R30,R24
    104B 1FF9      ADC	R31,R25
    104C 8020      LDD	R2,Z+0
    104D 01C8      MOVW	R24,R16
    104E 9648      ADIW	R24,0x18
    104F 2FE4      MOV	R30,R20
    1050 27FF      CLR	R31
    1051 0FE8      ADD	R30,R24
    1052 1FF9      ADC	R31,R25
    1053 8220      STD	Z+0,R2
    1054 9543      INC	R20
    1055 3042      CPI	R20,2
    1056 F378      BCS	0x1046
(0317) 	Desti->deStartCluster = Source->deStartCluster;
    1057 01F9      MOVW	R30,R18
    1058 8C22      LDD	R2,Z+26
    1059 8C33      LDD	R3,Z+27
    105A 01F8      MOVW	R30,R16
    105B 8E33      STD	Z+27,R3
    105C 8E22      STD	Z+26,R2
(0318) 	Desti->deFileSize = Source->deFileSize;
    105D 01F9      MOVW	R30,R18
    105E 8C24      LDD	R2,Z+28
    105F 8C35      LDD	R3,Z+29
    1060 8C46      LDD	R4,Z+30
    1061 8C57      LDD	R5,Z+31
    1062 01F8      MOVW	R30,R16
    1063 8E24      STD	Z+28,R2
    1064 8E35      STD	Z+29,R3
    1065 8E46      STD	Z+30,R4
    1066 8E57      STD	Z+31,R5
    1067 940E23DD  CALL	pop_gset1
    1069 9508      RET
_WriteFolderCluster:
  cluster              --> Y+6
  addr                 --> R20
    106A 933A      ST	R19,-Y
    106B 932A      ST	R18,-Y
    106C 940E23DA  CALL	push_gset1
    106E 01A8      MOVW	R20,R16
    106F 9724      SBIW	R28,4
(0319) }
(0320) 
(0321) 
(0322) #if FIX_DIRECTORY
(0323) 
(0324) BYTE Search(BYTE *dir,struct direntry *MusicInfo,WORD *Count,BYTE *type)//当COUNT为零时，有它带回这个目录下总共有多少图片
(0325) {                                                            //不为零时有MusicInfo带回第Count图片的详细文件信息
(0326) 	BYTE *buffer;
(0327) 	DWORD sector;
(0328) 	DWORD cluster;
(0329) 	DWORD tempclust;
(0330) 	unsigned char cnt;
(0331) 	unsigned int offset;
(0332) 	unsigned int i=0;
(0333) 	struct direntry *item = 0;
(0334) 	cluster = FAT_OpenDir(dir);
(0335) 	if(cluster == 1)return 1;
(0336) 	if(cluster==0 && FAT32_Enable==0)// 根目录，FAT16文件系统
(0337) 	{
(0338) 		buffer=malloc(512);//动态分配内存512大小
(0339) 		if(buffer==0)return 1;//动态分配失败
(0340) 		for(cnt=0;cnt<RootDirSectors;cnt++)
(0341) 		{
(0342) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
(0343) 			for(offset=0;offset<512;offset+=32)
(0344) 			{
(0345) 				item=(struct direntry *)(&buffer[offset]);//pointer convert
(0346) 				//find a valid item and display it
(0347) 				if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0348) 				{
(0349) 					if((item->deExtension[0] == 'b')&&(item->deExtension[1] == 'm')&&(item->deExtension[2] == 'p'))
(0350) 					{
(0351) 						CopyDirentruyItem(MusicInfo,item);
(0352) 						*type=1;
(0353) 						i++;
(0354) 						if(i==*Count){free(buffer);return 0;}	
(0355) 					}
(0356) 				}
(0357) 			}
(0358) 		}
(0359) 		free(buffer);//release
(0360) 	}
(0361) 	else//other folders
(0362) 	{
(0363) 		tempclust=cluster;
(0364) 		while(1)
(0365) 		{
(0366) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
(0367) 			buffer=malloc(512);//apply memory
(0368) 			if(buffer==0)return 1;//if failed
(0369) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
(0370) 			{
(0371) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
(0372) 				for(offset=0;offset<512;offset+=32)
(0373) 				{
(0374) 					item=(struct direntry *)(&buffer[offset]);
(0375) 					if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0376) 					{
(0377) 						if((item->deExtension[0] == 'b')&&(item->deExtension[1] == 'm')&&(item->deExtension[2] == 'p'))
(0378) 						{
(0379) 							CopyDirentruyItem(MusicInfo,item);
(0380) 							*type=1;
(0381) 							i++;
(0382) 							if(i==*Count){free(buffer);return 0;}	
(0383) 						}	
(0384) 					}
(0385) 				}
(0386) 			}
(0387) 			free(buffer);//release
(0388) 			tempclust=FAT_NextCluster(tempclust);//next cluster
(0389) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
(0390) 		}
(0391) 	}
(0392) 	if(*Count==0)*Count=i;
(0393) 	return 0;	
(0394) }
(0395) 
(0396) #else  
(0397) 
(0398) void WriteFolderCluster(WORD addr,DWORD cluster)
(0399) {
(0400) #if FAT_DEBUG
(0401) 	printf("\r\nWrite EEPROM address:%d with value:%ld",addr,cluster);
    1070 01FE      MOVW	R30,R28
    1071 8026      LDD	R2,Z+6
    1072 8037      LDD	R3,Z+7
    1073 8440      LDD	R4,Z+8
    1074 8451      LDD	R5,Z+9
    1075 8228      STD	Y+0,R2
    1076 8239      STD	Y+1,R3
    1077 824A      STD	Y+2,R4
    1078 825B      STD	Y+3,R5
    1079 019A      MOVW	R18,R20
    107A EA03      LDI	R16,0xA3
    107B E012      LDI	R17,2
    107C 940E2859  CALL	_printf
(0402) #endif
(0403) 	eeprom_write_byte(addr,cluster>>24);
    107E E188      LDI	R24,0x18
    107F E090      LDI	R25,0
    1080 01FE      MOVW	R30,R28
    1081 8026      LDD	R2,Z+6
    1082 8037      LDD	R3,Z+7
    1083 8440      LDD	R4,Z+8
    1084 8451      LDD	R5,Z+9
    1085 938A      ST	R24,-Y
    1086 0181      MOVW	R16,R2
    1087 0192      MOVW	R18,R4
    1088 940E243B  CALL	lsr32
    108A 2F20      MOV	R18,R16
    108B 018A      MOVW	R16,R20
    108C 940E1D9A  CALL	_eeprom_write_byte
(0404) 	eeprom_write_byte(addr+1,cluster>>16);
    108E 01FE      MOVW	R30,R28
    108F 8026      LDD	R2,Z+6
    1090 8037      LDD	R3,Z+7
    1091 8440      LDD	R4,Z+8
    1092 8451      LDD	R5,Z+9
    1093 0112      MOVW	R2,R4
    1094 2444      CLR	R4
    1095 2455      CLR	R5
    1096 2D22      MOV	R18,R2
    1097 018A      MOVW	R16,R20
    1098 5F0F      SUBI	R16,0xFF
    1099 4F1F      SBCI	R17,0xFF
    109A 940E1D9A  CALL	_eeprom_write_byte
(0405) 	eeprom_write_byte(addr+2,cluster>>8);
    109C E088      LDI	R24,0x8
    109D E090      LDI	R25,0
    109E 01FE      MOVW	R30,R28
    109F 8026      LDD	R2,Z+6
    10A0 8037      LDD	R3,Z+7
    10A1 8440      LDD	R4,Z+8
    10A2 8451      LDD	R5,Z+9
    10A3 938A      ST	R24,-Y
    10A4 0181      MOVW	R16,R2
    10A5 0192      MOVW	R18,R4
    10A6 940E243B  CALL	lsr32
    10A8 2F20      MOV	R18,R16
    10A9 018A      MOVW	R16,R20
    10AA 5F0E      SUBI	R16,0xFE
    10AB 4F1F      SBCI	R17,0xFF
    10AC 940E1D9A  CALL	_eeprom_write_byte
(0406) 	eeprom_write_byte(addr+3,cluster>>0);
    10AE 01FE      MOVW	R30,R28
    10AF 8026      LDD	R2,Z+6
    10B0 8037      LDD	R3,Z+7
    10B1 8440      LDD	R4,Z+8
    10B2 8451      LDD	R5,Z+9
    10B3 2D22      MOV	R18,R2
    10B4 018A      MOVW	R16,R20
    10B5 5F0D      SUBI	R16,0xFD
    10B6 4F1F      SBCI	R17,0xFF
    10B7 940E1D9A  CALL	_eeprom_write_byte
    10B9 9624      ADIW	R28,4
    10BA 940E23DD  CALL	pop_gset1
    10BC 9622      ADIW	R28,2
    10BD 9508      RET
_GetFolderCluster:
  temp                 --> Y+4
  addr                 --> R10
    10BE 940E23D6  CALL	push_gset3
    10C0 0158      MOVW	R10,R16
    10C1 9728      SBIW	R28,0x8
(0407) }
(0408) 
(0409) DWORD GetFolderCluster(WORD addr)
(0410) {
(0411) 	DWORD temp;
(0412) 	
(0413) 	temp = eeprom_read_byte(addr);
    10C2 0185      MOVW	R16,R10
    10C3 940E1D8C  CALL	_eeprom_read_byte
    10C5 0118      MOVW	R2,R16
    10C6 2444      CLR	R4
    10C7 FC37      SBRC	R3,7
    10C8 9440      COM	R4
    10C9 2455      CLR	R5
    10CA FC47      SBRC	R4,7
    10CB 9450      COM	R5
    10CC 01FE      MOVW	R30,R28
    10CD 8224      STD	Z+4,R2
    10CE 8235      STD	Z+5,R3
    10CF 8246      STD	Z+6,R4
    10D0 8257      STD	Z+7,R5
(0414) 	temp <<= 8;
    10D1 E088      LDI	R24,0x8
    10D2 E090      LDI	R25,0
    10D3 01FE      MOVW	R30,R28
    10D4 8024      LDD	R2,Z+4
    10D5 8035      LDD	R3,Z+5
    10D6 8046      LDD	R4,Z+6
    10D7 8057      LDD	R5,Z+7
    10D8 938A      ST	R24,-Y
    10D9 0181      MOVW	R16,R2
    10DA 0192      MOVW	R18,R4
    10DB 940E242F  CALL	lsl32
    10DD 01FE      MOVW	R30,R28
    10DE 8304      STD	Z+4,R16
    10DF 8315      STD	Z+5,R17
    10E0 8326      STD	Z+6,R18
    10E1 8337      STD	Z+7,R19
(0415) 	temp += eeprom_read_byte(addr+1);
    10E2 0185      MOVW	R16,R10
    10E3 5F0F      SUBI	R16,0xFF
    10E4 4F1F      SBCI	R17,0xFF
    10E5 940E1D8C  CALL	_eeprom_read_byte
    10E7 0118      MOVW	R2,R16
    10E8 2444      CLR	R4
    10E9 FC37      SBRC	R3,7
    10EA 9440      COM	R4
    10EB 2455      CLR	R5
    10EC FC47      SBRC	R4,7
    10ED 9450      COM	R5
    10EE 01FE      MOVW	R30,R28
    10EF 8064      LDD	R6,Z+4
    10F0 8075      LDD	R7,Z+5
    10F1 8086      LDD	R8,Z+6
    10F2 8097      LDD	R9,Z+7
    10F3 0C62      ADD	R6,R2
    10F4 1C73      ADC	R7,R3
    10F5 1C84      ADC	R8,R4
    10F6 1C95      ADC	R9,R5
    10F7 01FE      MOVW	R30,R28
    10F8 8264      STD	Z+4,R6
    10F9 8275      STD	Z+5,R7
    10FA 8286      STD	Z+6,R8
    10FB 8297      STD	Z+7,R9
(0416) 	temp <<= 8;
    10FC E088      LDI	R24,0x8
    10FD E090      LDI	R25,0
    10FE 01FE      MOVW	R30,R28
    10FF 8024      LDD	R2,Z+4
    1100 8035      LDD	R3,Z+5
    1101 8046      LDD	R4,Z+6
    1102 8057      LDD	R5,Z+7
    1103 938A      ST	R24,-Y
    1104 0181      MOVW	R16,R2
    1105 0192      MOVW	R18,R4
    1106 940E242F  CALL	lsl32
    1108 01FE      MOVW	R30,R28
    1109 8304      STD	Z+4,R16
    110A 8315      STD	Z+5,R17
    110B 8326      STD	Z+6,R18
    110C 8337      STD	Z+7,R19
(0417) 	temp += eeprom_read_byte(addr+2);
    110D 0185      MOVW	R16,R10
    110E 5F0E      SUBI	R16,0xFE
    110F 4F1F      SBCI	R17,0xFF
    1110 940E1D8C  CALL	_eeprom_read_byte
    1112 0118      MOVW	R2,R16
    1113 2444      CLR	R4
    1114 FC37      SBRC	R3,7
    1115 9440      COM	R4
    1116 2455      CLR	R5
    1117 FC47      SBRC	R4,7
    1118 9450      COM	R5
    1119 01FE      MOVW	R30,R28
    111A 8064      LDD	R6,Z+4
    111B 8075      LDD	R7,Z+5
    111C 8086      LDD	R8,Z+6
    111D 8097      LDD	R9,Z+7
    111E 0C62      ADD	R6,R2
    111F 1C73      ADC	R7,R3
    1120 1C84      ADC	R8,R4
    1121 1C95      ADC	R9,R5
    1122 01FE      MOVW	R30,R28
    1123 8264      STD	Z+4,R6
    1124 8275      STD	Z+5,R7
    1125 8286      STD	Z+6,R8
    1126 8297      STD	Z+7,R9
(0418) 	temp <<= 8;
    1127 E088      LDI	R24,0x8
    1128 E090      LDI	R25,0
    1129 01FE      MOVW	R30,R28
    112A 8024      LDD	R2,Z+4
    112B 8035      LDD	R3,Z+5
    112C 8046      LDD	R4,Z+6
    112D 8057      LDD	R5,Z+7
    112E 938A      ST	R24,-Y
    112F 0181      MOVW	R16,R2
    1130 0192      MOVW	R18,R4
    1131 940E242F  CALL	lsl32
    1133 01FE      MOVW	R30,R28
    1134 8304      STD	Z+4,R16
    1135 8315      STD	Z+5,R17
    1136 8326      STD	Z+6,R18
    1137 8337      STD	Z+7,R19
(0419) 	temp += eeprom_read_byte(addr+3);
    1138 0185      MOVW	R16,R10
    1139 5F0D      SUBI	R16,0xFD
    113A 4F1F      SBCI	R17,0xFF
    113B 940E1D8C  CALL	_eeprom_read_byte
    113D 0118      MOVW	R2,R16
    113E 2444      CLR	R4
    113F FC37      SBRC	R3,7
    1140 9440      COM	R4
    1141 2455      CLR	R5
    1142 FC47      SBRC	R4,7
    1143 9450      COM	R5
    1144 01FE      MOVW	R30,R28
    1145 8064      LDD	R6,Z+4
    1146 8075      LDD	R7,Z+5
    1147 8086      LDD	R8,Z+6
    1148 8097      LDD	R9,Z+7
    1149 0C62      ADD	R6,R2
    114A 1C73      ADC	R7,R3
    114B 1C84      ADC	R8,R4
    114C 1C95      ADC	R9,R5
    114D 01FE      MOVW	R30,R28
    114E 8264      STD	Z+4,R6
    114F 8275      STD	Z+5,R7
    1150 8286      STD	Z+6,R8
    1151 8297      STD	Z+7,R9
(0420) #if FAT_DEBUG
(0421) 	printf("\r\nRead EEPROM address: %d value is: %ld",addr,temp);
    1152 01FE      MOVW	R30,R28
    1153 8024      LDD	R2,Z+4
    1154 8035      LDD	R3,Z+5
    1155 8046      LDD	R4,Z+6
    1156 8057      LDD	R5,Z+7
    1157 8228      STD	Y+0,R2
    1158 8239      STD	Y+1,R3
    1159 824A      STD	Y+2,R4
    115A 825B      STD	Y+3,R5
    115B 0195      MOVW	R18,R10
    115C E70B      LDI	R16,0x7B
    115D E012      LDI	R17,2
    115E 940E2859  CALL	_printf
(0422) #endif
(0423) 	return temp;
    1160 01FE      MOVW	R30,R28
    1161 8104      LDD	R16,Z+4
    1162 8115      LDD	R17,Z+5
    1163 8126      LDD	R18,Z+6
    1164 8137      LDD	R19,Z+7
    1165 9628      ADIW	R28,0x8
    1166 940E23C9  CALL	pop_gset3
    1168 9508      RET
_SearchFolder:
  tempclust            --> Y+6
  sector               --> Y+2
  cnt                  --> R10
  buffer               --> R12
  offset               --> R14
  item                 --> Y+10
  addr                 --> Y+26
  cluster              --> Y+22
    1169 940E22CF  CALL	push_arg4
    116B 940E23D2  CALL	push_gset5
    116D 972C      SBIW	R28,0xC
(0424) }
(0425) 
(0426) BYTE SearchFolder(DWORD cluster,WORD *addr)
(0427) {
(0428) 	BYTE *buffer;
(0429) 	//BYTE buff[3];
(0430) 	DWORD sector;
(0431) 	//DWORD cluster;
(0432) 	DWORD tempclust;
(0433) 	unsigned char cnt;
(0434) 	unsigned int offset;
(0435) 	//unsigned int i=0;
(0436) 	//unsigned char j;//long name buffer offset;
(0437) //	unsigned char *p;//long name buffer pointer
(0438) 	struct direntry *item = 0;
    116E 2400      CLR	R0
    116F 2411      CLR	R1
    1170 861B      STD	Y+11,R1
    1171 860A      STD	Y+10,R0
(0439) 	//struct winentry *we =0;
(0440) 	
(0441) 	if(cluster==0 && FAT32_Enable==0)// root directory
    1172 E040      LDI	R20,0
    1173 E050      LDI	R21,0
    1174 E060      LDI	R22,0
    1175 E070      LDI	R23,0
    1176 01FE      MOVW	R30,R28
    1177 8826      LDD	R2,Z+22
    1178 8837      LDD	R3,Z+23
    1179 8C40      LDD	R4,Z+24
    117A 8C51      LDD	R5,Z+25
    117B 1624      CP	R2,R20
    117C 0635      CPC	R3,R21
    117D 0646      CPC	R4,R22
    117E 0657      CPC	R5,R23
    117F F009      BEQ	0x1181
    1180 C09E      RJMP	0x121F
    1181 90200EFC  LDS	R2,FAT32_Enable
    1183 2022      TST	R2
    1184 F009      BEQ	0x1186
    1185 C099      RJMP	0x121F
(0442) 	{
(0443) 		
(0444) 		buffer=malloc(512);//apply memory
    1186 E000      LDI	R16,0
    1187 E012      LDI	R17,2
    1188 940E24AF  CALL	_malloc
    118A 0168      MOVW	R12,R16
(0445) 		if(buffer==0) {printf("Apply Memory Failure");return 1;}//if failed
    118B 3000      CPI	R16,0
    118C 0701      CPC	R16,R17
    118D F431      BNE	0x1194
    118E E606      LDI	R16,0x66
    118F E012      LDI	R17,2
    1190 940E2859  CALL	_printf
    1192 E001      LDI	R16,1
    1193 C187      RJMP	0x131B
(0446) 		for(cnt=0;cnt<RootDirSectors;cnt++)
    1194 24AA      CLR	R10
    1195 C073      RJMP	0x1209
(0447) 		{
(0448) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
    1196 82D9      STD	Y+1,R13
    1197 82C8      STD	Y+0,R12
    1198 2C2A      MOV	R2,R10
    1199 2433      CLR	R3
    119A 2444      CLR	R4
    119B 2455      CLR	R5
    119C 90800F07  LDS	R8,FirstDirSector+2
    119E 90900F08  LDS	R9,FirstDirSector+3
    11A0 90600F05  LDS	R6,FirstDirSector
    11A2 90700F06  LDS	R7,FirstDirSector+1
    11A4 0C62      ADD	R6,R2
    11A5 1C73      ADC	R7,R3
    11A6 1C84      ADC	R8,R4
    11A7 1C95      ADC	R9,R5
    11A8 0183      MOVW	R16,R6
    11A9 0194      MOVW	R18,R8
    11AA 91E00198  LDS	R30,FAT_ReadSector
    11AC 91F00199  LDS	R31,FAT_ReadSector+1
    11AE 940E23F1  CALL	xicall
    11B0 2300      TST	R16
    11B1 F029      BEQ	0x11B7
    11B2 0186      MOVW	R16,R12
    11B3 940E2601  CALL	_free
    11B5 E001      LDI	R16,1
    11B6 C164      RJMP	0x131B
(0449) 			for(offset=0;offset<512;offset+=32)
    11B7 24EE      CLR	R14
    11B8 24FF      CLR	R15
    11B9 C048      RJMP	0x1202
(0450) 			{
(0451) 				item=(struct direntry *)(&buffer[offset]);//pointer convert
    11BA 0117      MOVW	R2,R14
    11BB 0C2C      ADD	R2,R12
    11BC 1C3D      ADC	R3,R13
    11BD 863B      STD	Y+11,R3
    11BE 862A      STD	Y+10,R2
(0452) 				//find a valid item and display it
(0453) 				if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5))
    11BF 01F1      MOVW	R30,R2
    11C0 8020      LDD	R2,Z+0
    11C1 2433      CLR	R3
    11C2 2D82      MOV	R24,R2
    11C3 328E      CPI	R24,0x2E
    11C4 F409      BNE	0x11C6
    11C5 C039      RJMP	0x11FF
    11C6 2388      TST	R24
    11C7 F409      BNE	0x11C9
    11C8 C036      RJMP	0x11FF
    11C9 3E85      CPI	R24,0xE5
    11CA F409      BNE	0x11CC
    11CB C033      RJMP	0x11FF
(0454) 				{
(0455) 					if(item->deAttributes & ATTR_DIRECTORY )
    11CC 8423      LDD	R2,Z+11
    11CD FE24      SBRS	R2,4
    11CE C030      RJMP	0x11FF
(0456) 					{
(0457) 						#if FAT_DEBUG
(0458) 							printf("\r\nFound a folder!");
    11CF E504      LDI	R16,0x54
    11D0 E012      LDI	R17,2
    11D1 940E2859  CALL	_printf
(0459) 						#endif
(0460) 						if(*addr==RECORD_ADDR_END)return 0;
    11D3 8DEA      LDD	R30,Y+26
    11D4 8DFB      LDD	R31,Y+27
    11D5 8180      LDD	R24,Z+0
    11D6 8191      LDD	R25,Z+1
    11D7 3080      CPI	R24,0
    11D8 E0E2      LDI	R30,2
    11D9 079E      CPC	R25,R30
    11DA F411      BNE	0x11DD
    11DB 2700      CLR	R16
    11DC C13E      RJMP	0x131B
(0461) 						else
(0462) 						{
(0463) 							WriteFolderCluster(*addr,item->deStartCluster+(((unsigned long)item->deHighClust)<<16));
    11DD 85EA      LDD	R30,Y+10
    11DE 85FB      LDD	R31,Y+11
    11DF 8824      LDD	R2,Z+20
    11E0 8835      LDD	R3,Z+21
    11E1 2444      CLR	R4
    11E2 2455      CLR	R5
    11E3 0121      MOVW	R4,R2
    11E4 2422      CLR	R2
    11E5 2433      CLR	R3
    11E6 85EA      LDD	R30,Y+10
    11E7 85FB      LDD	R31,Y+11
    11E8 8C62      LDD	R6,Z+26
    11E9 8C73      LDD	R7,Z+27
    11EA 2488      CLR	R8
    11EB 2499      CLR	R9
    11EC 0C62      ADD	R6,R2
    11ED 1C73      ADC	R7,R3
    11EE 1C84      ADC	R8,R4
    11EF 1C95      ADC	R9,R5
    11F0 8288      STD	Y+0,R8
    11F1 8299      STD	Y+1,R9
    11F2 0193      MOVW	R18,R6
    11F3 8DEA      LDD	R30,Y+26
    11F4 8DFB      LDD	R31,Y+27
    11F5 8100      LDD	R16,Z+0
    11F6 8111      LDD	R17,Z+1
    11F7 DE72      RCALL	_WriteFolderCluster
(0464) 							*addr+=4;
    11F8 8DEA      LDD	R30,Y+26
    11F9 8DFB      LDD	R31,Y+27
    11FA 8180      LDD	R24,Z+0
    11FB 8191      LDD	R25,Z+1
    11FC 9604      ADIW	R24,4
    11FD 8391      STD	Z+1,R25
    11FE 8380      STD	Z+0,R24
    11FF 01C7      MOVW	R24,R14
    1200 9680      ADIW	R24,0x20
    1201 017C      MOVW	R14,R24
    1202 01C7      MOVW	R24,R14
    1203 3080      CPI	R24,0
    1204 E0E2      LDI	R30,2
    1205 079E      CPC	R25,R30
    1206 F408      BCC	0x1208
    1207 CFB2      RJMP	0x11BA
    1208 94A3      INC	R10
    1209 90400F03  LDS	R4,RootDirSectors+2
    120B 90500F04  LDS	R5,RootDirSectors+3
    120D 90200F01  LDS	R2,RootDirSectors
    120F 90300F02  LDS	R3,RootDirSectors+1
    1211 2C6A      MOV	R6,R10
    1212 2477      CLR	R7
    1213 2488      CLR	R8
    1214 2499      CLR	R9
    1215 1462      CP	R6,R2
    1216 0473      CPC	R7,R3
    1217 0484      CPC	R8,R4
    1218 0495      CPC	R9,R5
    1219 F408      BCC	0x121B
    121A CF7B      RJMP	0x1196
(0465) 						}
(0466) 					}
(0467) 				}
(0468) 			}
(0469) 		}
(0470) 		free(buffer);//release
    121B 0186      MOVW	R16,R12
    121C 940E2601  CALL	_free
(0471) 	}
    121E C0FB      RJMP	0x131A
(0472) 	else//other folders
(0473) 	{
(0474) 		tempclust=cluster;
    121F 01FE      MOVW	R30,R28
    1220 8826      LDD	R2,Z+22
    1221 8837      LDD	R3,Z+23
    1222 8C40      LDD	R4,Z+24
    1223 8C51      LDD	R5,Z+25
    1224 01FE      MOVW	R30,R28
    1225 8226      STD	Z+6,R2
    1226 8237      STD	Z+7,R3
    1227 8640      STD	Z+8,R4
    1228 8651      STD	Z+9,R5
    1229 C0EF      RJMP	0x1319
(0475) 		while(1)
(0476) 		{
(0477) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
    122A E042      LDI	R20,2
    122B E050      LDI	R21,0
    122C E060      LDI	R22,0
    122D E070      LDI	R23,0
    122E 01FE      MOVW	R30,R28
    122F 8026      LDD	R2,Z+6
    1230 8037      LDD	R3,Z+7
    1231 8440      LDD	R4,Z+8
    1232 8451      LDD	R5,Z+9
    1233 1A24      SUB	R2,R20
    1234 0A35      SBC	R3,R21
    1235 0A46      SBC	R4,R22
    1236 0A57      SBC	R5,R23
    1237 90600F0D  LDS	R6,SectorsPerClust
    1239 90700F0E  LDS	R7,SectorsPerClust+1
    123B 2488      CLR	R8
    123C 2499      CLR	R9
    123D 929A      ST	R9,-Y
    123E 928A      ST	R8,-Y
    123F 927A      ST	R7,-Y
    1240 926A      ST	R6,-Y
    1241 0181      MOVW	R16,R2
    1242 0192      MOVW	R18,R4
    1243 940E2396  CALL	empy32s
    1245 90400F15  LDS	R4,FirstDataSector+2
    1247 90500F16  LDS	R5,FirstDataSector+3
    1249 90200F13  LDS	R2,FirstDataSector
    124B 90300F14  LDS	R3,FirstDataSector+1
    124D 0E20      ADD	R2,R16
    124E 1E31      ADC	R3,R17
    124F 1E42      ADC	R4,R18
    1250 1E53      ADC	R5,R19
    1251 01FE      MOVW	R30,R28
    1252 8222      STD	Z+2,R2
    1253 8233      STD	Z+3,R3
    1254 8244      STD	Z+4,R4
    1255 8255      STD	Z+5,R5
(0478) 			buffer=malloc(512);//apply memory
    1256 E000      LDI	R16,0
    1257 E012      LDI	R17,2
    1258 940E24AF  CALL	_malloc
    125A 0168      MOVW	R12,R16
(0479) 			if(buffer==0)return 1;//if failed
    125B 3000      CPI	R16,0
    125C 0701      CPC	R16,R17
    125D F411      BNE	0x1260
    125E E001      LDI	R16,1
    125F C0BB      RJMP	0x131B
(0480) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
    1260 24AA      CLR	R10
    1261 C070      RJMP	0x12D2
(0481) 			{
(0482) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
    1262 82D9      STD	Y+1,R13
    1263 82C8      STD	Y+0,R12
    1264 2C2A      MOV	R2,R10
    1265 2433      CLR	R3
    1266 2444      CLR	R4
    1267 2455      CLR	R5
    1268 01FE      MOVW	R30,R28
    1269 8062      LDD	R6,Z+2
    126A 8073      LDD	R7,Z+3
    126B 8084      LDD	R8,Z+4
    126C 8095      LDD	R9,Z+5
    126D 0C62      ADD	R6,R2
    126E 1C73      ADC	R7,R3
    126F 1C84      ADC	R8,R4
    1270 1C95      ADC	R9,R5
    1271 0183      MOVW	R16,R6
    1272 0194      MOVW	R18,R8
    1273 91E00198  LDS	R30,FAT_ReadSector
    1275 91F00199  LDS	R31,FAT_ReadSector+1
    1277 940E23F1  CALL	xicall
    1279 2300      TST	R16
    127A F029      BEQ	0x1280
    127B 0186      MOVW	R16,R12
    127C 940E2601  CALL	_free
    127E E001      LDI	R16,1
    127F C09B      RJMP	0x131B
(0483) 				for(offset=0;offset<512;offset+=32)
    1280 24EE      CLR	R14
    1281 24FF      CLR	R15
    1282 C048      RJMP	0x12CB
(0484) 				{
(0485) 					item=(struct direntry *)(&buffer[offset]);
    1283 0117      MOVW	R2,R14
    1284 0C2C      ADD	R2,R12
    1285 1C3D      ADC	R3,R13
    1286 863B      STD	Y+11,R3
    1287 862A      STD	Y+10,R2
(0486) 					if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5))
    1288 01F1      MOVW	R30,R2
    1289 8020      LDD	R2,Z+0
    128A 2433      CLR	R3
    128B 2D82      MOV	R24,R2
    128C 328E      CPI	R24,0x2E
    128D F409      BNE	0x128F
    128E C039      RJMP	0x12C8
    128F 2388      TST	R24
    1290 F409      BNE	0x1292
    1291 C036      RJMP	0x12C8
    1292 3E85      CPI	R24,0xE5
    1293 F409      BNE	0x1295
    1294 C033      RJMP	0x12C8
(0487) 					{				
(0488) 						if(item->deAttributes & ATTR_DIRECTORY )
    1295 8423      LDD	R2,Z+11
    1296 FE24      SBRS	R2,4
    1297 C030      RJMP	0x12C8
(0489) 						{
(0490) 							#if FAT_DEBUG
(0491) 								printf("\r\nFound a folder!");
    1298 E504      LDI	R16,0x54
    1299 E012      LDI	R17,2
    129A 940E2859  CALL	_printf
(0492) 							#endif
(0493) 							if(*addr==RECORD_ADDR_END)return 0;
    129C 8DEA      LDD	R30,Y+26
    129D 8DFB      LDD	R31,Y+27
    129E 8180      LDD	R24,Z+0
    129F 8191      LDD	R25,Z+1
    12A0 3080      CPI	R24,0
    12A1 E0E2      LDI	R30,2
    12A2 079E      CPC	R25,R30
    12A3 F411      BNE	0x12A6
    12A4 2700      CLR	R16
    12A5 C075      RJMP	0x131B
(0494) 							else
(0495) 							{
(0496) 								WriteFolderCluster(*addr,item->deStartCluster+(((unsigned long)item->deHighClust)<<16));
    12A6 85EA      LDD	R30,Y+10
    12A7 85FB      LDD	R31,Y+11
    12A8 8824      LDD	R2,Z+20
    12A9 8835      LDD	R3,Z+21
    12AA 2444      CLR	R4
    12AB 2455      CLR	R5
    12AC 0121      MOVW	R4,R2
    12AD 2422      CLR	R2
    12AE 2433      CLR	R3
    12AF 85EA      LDD	R30,Y+10
    12B0 85FB      LDD	R31,Y+11
    12B1 8C62      LDD	R6,Z+26
    12B2 8C73      LDD	R7,Z+27
    12B3 2488      CLR	R8
    12B4 2499      CLR	R9
    12B5 0C62      ADD	R6,R2
    12B6 1C73      ADC	R7,R3
    12B7 1C84      ADC	R8,R4
    12B8 1C95      ADC	R9,R5
    12B9 8288      STD	Y+0,R8
    12BA 8299      STD	Y+1,R9
    12BB 0193      MOVW	R18,R6
    12BC 8DEA      LDD	R30,Y+26
    12BD 8DFB      LDD	R31,Y+27
    12BE 8100      LDD	R16,Z+0
    12BF 8111      LDD	R17,Z+1
    12C0 DDA9      RCALL	_WriteFolderCluster
(0497) 								*addr+=4;
    12C1 8DEA      LDD	R30,Y+26
    12C2 8DFB      LDD	R31,Y+27
    12C3 8180      LDD	R24,Z+0
    12C4 8191      LDD	R25,Z+1
    12C5 9604      ADIW	R24,4
    12C6 8391      STD	Z+1,R25
    12C7 8380      STD	Z+0,R24
    12C8 01C7      MOVW	R24,R14
    12C9 9680      ADIW	R24,0x20
    12CA 017C      MOVW	R14,R24
    12CB 01C7      MOVW	R24,R14
    12CC 3080      CPI	R24,0
    12CD E0E2      LDI	R30,2
    12CE 079E      CPC	R25,R30
    12CF F408      BCC	0x12D1
    12D0 CFB2      RJMP	0x1283
    12D1 94A3      INC	R10
    12D2 90200F0D  LDS	R2,SectorsPerClust
    12D4 90300F0E  LDS	R3,SectorsPerClust+1
    12D6 2C4A      MOV	R4,R10
    12D7 2455      CLR	R5
    12D8 1442      CP	R4,R2
    12D9 0453      CPC	R5,R3
    12DA F408      BCC	0x12DC
    12DB CF86      RJMP	0x1262
(0498) 							}
(0499) 						}
(0500) 					}
(0501) 				}
(0502) 			}
(0503) 			free(buffer);//release
    12DC 0186      MOVW	R16,R12
    12DD 940E2601  CALL	_free
(0504) 			tempclust=FAT_NextCluster(tempclust);//next cluster
    12DF 01FE      MOVW	R30,R28
    12E0 8106      LDD	R16,Z+6
    12E1 8117      LDD	R17,Z+7
    12E2 8520      LDD	R18,Z+8
    12E3 8531      LDD	R19,Z+9
    12E4 DBE6      RCALL	_FAT_NextCluster
    12E5 01FE      MOVW	R30,R28
    12E6 8306      STD	Z+6,R16
    12E7 8317      STD	Z+7,R17
    12E8 8720      STD	Z+8,R18
    12E9 8731      STD	Z+9,R19
(0505) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
    12EA EF4F      LDI	R20,0xFF
    12EB EF5F      LDI	R21,0xFF
    12EC EF6F      LDI	R22,0xFF
    12ED E07F      LDI	R23,0xF
    12EE 01FE      MOVW	R30,R28
    12EF 8026      LDD	R2,Z+6
    12F0 8037      LDD	R3,Z+7
    12F1 8440      LDD	R4,Z+8
    12F2 8451      LDD	R5,Z+9
    12F3 1624      CP	R2,R20
    12F4 0635      CPC	R3,R21
    12F5 0646      CPC	R4,R22
    12F6 0657      CPC	R5,R23
    12F7 F101      BEQ	0x1318
    12F8 EF48      LDI	R20,0xF8
    12F9 EF5F      LDI	R21,0xFF
    12FA EF6F      LDI	R22,0xFF
    12FB E07F      LDI	R23,0xF
    12FC 01FE      MOVW	R30,R28
    12FD 8026      LDD	R2,Z+6
    12FE 8037      LDD	R3,Z+7
    12FF 8440      LDD	R4,Z+8
    1300 8451      LDD	R5,Z+9
    1301 1624      CP	R2,R20
    1302 0635      CPC	R3,R21
    1303 0646      CPC	R4,R22
    1304 0657      CPC	R5,R23
    1305 F091      BEQ	0x1318
    1306 90200EFC  LDS	R2,FAT32_Enable
    1308 2022      TST	R2
    1309 F479      BNE	0x1319
    130A EF4F      LDI	R20,0xFF
    130B EF5F      LDI	R21,0xFF
    130C E060      LDI	R22,0
    130D E070      LDI	R23,0
    130E 01FE      MOVW	R30,R28
    130F 8026      LDD	R2,Z+6
    1310 8037      LDD	R3,Z+7
    1311 8440      LDD	R4,Z+8
    1312 8451      LDD	R5,Z+9
    1313 1624      CP	R2,R20
    1314 0635      CPC	R3,R21
    1315 0646      CPC	R4,R22
    1316 0657      CPC	R5,R23
    1317 F409      BNE	0x1319
    1318 C001      RJMP	0x131A
    1319 CF10      RJMP	0x122A
(0506) 		}
(0507) 	}
(0508) 	return 0;		
    131A 2700      CLR	R16
    131B 962C      ADIW	R28,0xC
    131C 940E23CF  CALL	pop_gset5
    131E 9624      ADIW	R28,4
    131F 9508      RET
_SearchInit:
  temp_addr            --> Y+6
  cluster              --> Y+2
  addr                 --> R10
    1320 940E23D6  CALL	push_gset3
    1322 9728      SBIW	R28,0x8
(0509) }
(0510) 
(0511) 
(0512) 
(0513) BYTE SearchInit()
(0514) {	
(0515) 	WORD addr = RECORD_ADDR_START;
    1323 24AA      CLR	R10
    1324 24BB      CLR	R11
(0516) 	WORD temp_addr;
(0517) 	DWORD cluster;
(0518) 	
(0519) #if FAT_DEBUG
(0520) 	printf("\r\nSearchInit");
    1325 E407      LDI	R16,0x47
    1326 E012      LDI	R17,2
    1327 940E2859  CALL	_printf
(0521) #endif
(0522) 
(0523) 	if(FAT32_Enable)
    1329 90200EFC  LDS	R2,FAT32_Enable
    132B 2022      TST	R2
    132C F071      BEQ	0x133B
(0524) 		WriteFolderCluster(addr,FirstDirClust);
    132D 90400F19  LDS	R4,FirstDirClust+2
    132F 90500F1A  LDS	R5,FirstDirClust+3
    1331 90200F17  LDS	R2,FirstDirClust
    1333 90300F18  LDS	R3,FirstDirClust+1
    1335 8248      STD	Y+0,R4
    1336 8259      STD	Y+1,R5
    1337 0191      MOVW	R18,R2
    1338 0185      MOVW	R16,R10
    1339 DD30      RCALL	_WriteFolderCluster
    133A C00A      RJMP	0x1345
(0525) 	else 
(0526) 		WriteFolderCluster(RECORD_ADDR_START,0);
    133B E040      LDI	R20,0
    133C E050      LDI	R21,0
    133D E060      LDI	R22,0
    133E E070      LDI	R23,0
    133F 8368      STD	Y+0,R22
    1340 8379      STD	Y+1,R23
    1341 019A      MOVW	R18,R20
    1342 2700      CLR	R16
    1343 2711      CLR	R17
    1344 DD25      RCALL	_WriteFolderCluster
(0527) 	
(0528) 	addr += 4;
    1345 01C5      MOVW	R24,R10
    1346 9604      ADIW	R24,4
    1347 015C      MOVW	R10,R24
(0529) 	
(0530) 	WriteFolderCluster(addr, 0xffffffff);
    1348 EF4F      LDI	R20,0xFF
    1349 EF5F      LDI	R21,0xFF
    134A EF6F      LDI	R22,0xFF
    134B EF7F      LDI	R23,0xFF
    134C 8368      STD	Y+0,R22
    134D 8379      STD	Y+1,R23
    134E 019A      MOVW	R18,R20
    134F 018C      MOVW	R16,R24
    1350 DD19      RCALL	_WriteFolderCluster
(0531) 	temp_addr = addr;
    1351 82BF      STD	Y+7,R11
    1352 82AE      STD	Y+6,R10
(0532) 	addr = RECORD_ADDR_START;
    1353 24AA      CLR	R10
    1354 24BB      CLR	R11
    1355 C05B      RJMP	0x13B1
(0533) 	while(1)
(0534) 	{
(0535) 		cluster = GetFolderCluster(addr);
    1356 0185      MOVW	R16,R10
    1357 DD66      RCALL	_GetFolderCluster
    1358 01FE      MOVW	R30,R28
    1359 8302      STD	Z+2,R16
    135A 8313      STD	Z+3,R17
    135B 8324      STD	Z+4,R18
    135C 8335      STD	Z+5,R19
(0536) 		if(cluster == 0xffffffff)return 0;
    135D EF4F      LDI	R20,0xFF
    135E EF5F      LDI	R21,0xFF
    135F EF6F      LDI	R22,0xFF
    1360 EF7F      LDI	R23,0xFF
    1361 01FE      MOVW	R30,R28
    1362 8022      LDD	R2,Z+2
    1363 8033      LDD	R3,Z+3
    1364 8044      LDD	R4,Z+4
    1365 8055      LDD	R5,Z+5
    1366 1624      CP	R2,R20
    1367 0635      CPC	R3,R21
    1368 0646      CPC	R4,R22
    1369 0657      CPC	R5,R23
    136A F411      BNE	0x136D
    136B 2700      CLR	R16
    136C C04A      RJMP	0x13B7
(0537) 		else
(0538) 		{
(0539) 			if(SearchFolder(cluster,&temp_addr))
    136D 01CE      MOVW	R24,R28
    136E 9606      ADIW	R24,6
    136F 8399      STD	Y+1,R25
    1370 8388      STD	Y+0,R24
    1371 01FE      MOVW	R30,R28
    1372 8102      LDD	R16,Z+2
    1373 8113      LDD	R17,Z+3
    1374 8124      LDD	R18,Z+4
    1375 8135      LDD	R19,Z+5
    1376 DDF2      RCALL	_SearchFolder
    1377 2300      TST	R16
    1378 F021      BEQ	0x137D
(0540) 			{
(0541) 				#if FAT_DEBUG
(0542) 					printf("\r\nERROR: search folder error");
    1379 E20A      LDI	R16,0x2A
    137A E012      LDI	R17,2
    137B 940E2859  CALL	_printf
(0543) 				#endif
(0544) 			}
(0545) 			#if FAT_DEBUG
(0546) 				printf("\r\nSearch one folder, write the end flag if the the value is not the right value");
    137D ED0A      LDI	R16,0xDA
    137E E011      LDI	R17,1
    137F 940E2859  CALL	_printf
(0547) 			#endif
(0548) 			if(GetFolderCluster(temp_addr) != 0xffffffff)
    1381 810E      LDD	R16,Y+6
    1382 811F      LDD	R17,Y+7
    1383 DD3A      RCALL	_GetFolderCluster
    1384 EF4F      LDI	R20,0xFF
    1385 EF5F      LDI	R21,0xFF
    1386 EF6F      LDI	R22,0xFF
    1387 EF7F      LDI	R23,0xFF
    1388 1704      CP	R16,R20
    1389 0715      CPC	R17,R21
    138A 0726      CPC	R18,R22
    138B 0737      CPC	R19,R23
    138C F051      BEQ	0x1397
(0549) 				WriteFolderCluster(temp_addr,0XFFFFFFFF);
    138D EF4F      LDI	R20,0xFF
    138E EF5F      LDI	R21,0xFF
    138F EF6F      LDI	R22,0xFF
    1390 EF7F      LDI	R23,0xFF
    1391 8368      STD	Y+0,R22
    1392 8379      STD	Y+1,R23
    1393 019A      MOVW	R18,R20
    1394 810E      LDD	R16,Y+6
    1395 811F      LDD	R17,Y+7
    1396 DCD3      RCALL	_WriteFolderCluster
(0550) 			if(temp_addr == RECORD_ADDR_END)
    1397 818E      LDD	R24,Y+6
    1398 819F      LDD	R25,Y+7
    1399 3080      CPI	R24,0
    139A E0E2      LDI	R30,2
    139B 079E      CPC	R25,R30
    139C F489      BNE	0x13AE
(0551) 			{
(0552) 				#if FAT_DEBUG
(0553) 					printf("\r\nWARNING: EEPROM is full, no more space!");
    139D EB00      LDI	R16,0xB0
    139E E011      LDI	R17,1
    139F 940E2859  CALL	_printf
(0554) 				#endif
(0555) 				WriteFolderCluster(temp_addr - 4,0XFFFFFFFF);
    13A1 EF4F      LDI	R20,0xFF
    13A2 EF5F      LDI	R21,0xFF
    13A3 EF6F      LDI	R22,0xFF
    13A4 EF7F      LDI	R23,0xFF
    13A5 8368      STD	Y+0,R22
    13A6 8379      STD	Y+1,R23
    13A7 019A      MOVW	R18,R20
    13A8 810E      LDD	R16,Y+6
    13A9 811F      LDD	R17,Y+7
    13AA 5004      SUBI	R16,4
    13AB 4010      SBCI	R17,0
    13AC DCBD      RCALL	_WriteFolderCluster
(0556) 				break;
    13AD C004      RJMP	0x13B2
(0557) 			}
(0558) 		}
(0559) 		addr+=4;
    13AE 01C5      MOVW	R24,R10
    13AF 9604      ADIW	R24,4
    13B0 015C      MOVW	R10,R24
    13B1 CFA4      RJMP	0x1356
(0560) 	}
(0561) 	#if FAT_DEBUG
(0562) 		printf("\r\nSearch Completed!");
    13B2 E90C      LDI	R16,0x9C
    13B3 E011      LDI	R17,1
    13B4 940E2859  CALL	_printf
(0563) 	#endif
(0564) return 1;
    13B6 E001      LDI	R16,1
    13B7 9628      ADIW	R28,0x8
    13B8 940E23C9  CALL	pop_gset3
    13BA 9508      RET
_Search:
  addr                 --> Y+21
  cluster              --> Y+13
  tempclust            --> Y+9
  sector               --> Y+5
  cnt                  --> R10
  i                    --> Y+19
  buffer               --> R12
  file_type            --> Y+2
  offset               --> R14
  item                 --> Y+17
  type                 --> Y+37
  Count                --> Y+35
  MusicInfo            --> Y+33
    13BB 940E22CF  CALL	push_arg4
    13BD 940E23D2  CALL	push_gset5
    13BF 9767      SBIW	R28,0x17
(0565) }
(0566) 
(0567) 
(0568) 
(0569) BYTE Search(/*BYTE *dirWORD *music_record_addr,*/struct direntry *MusicInfo,WORD *Count,BYTE *type)//当COUNT为零时，有它带回这个目录下总共有多少图片
(0570) {                                                            //不为零时有MusicInfo带回第Count图片的详细文件信息
(0571) 	BYTE *buffer;
(0572) 	DWORD sector;
(0573) 	DWORD cluster;
(0574) 	DWORD tempclust;
(0575) 	unsigned char cnt;
(0576) 	unsigned int offset;
(0577) 	unsigned int i=0;
    13C0 2400      CLR	R0
    13C1 2411      CLR	R1
    13C2 8A1C      STD	Y+20,R1
    13C3 8A0B      STD	Y+19,R0
(0578) 	//unsigned char j;//long name buffer offset;
(0579) 	//unsigned char *p;//long name buffer pointer
(0580) 	struct direntry *item = 0;
    13C4 8A1A      STD	Y+18,R1
    13C5 8A09      STD	Y+17,R0
(0581) 	//struct winentry *we =0;
(0582) 	//cluster = FAT_OpenDir(dir);
(0583) 	//if(cluster == 1)return 1;
(0584) 	
(0585) 	BYTE file_type[3] ;
(0586) 	WORD addr =RECORD_ADDR_START;
    13C6 8A1E      STD	Y+22,R1
    13C7 8A0D      STD	Y+21,R0
(0587) 	
(0588) 	switch(*type)
    13C8 A1ED      LDD	R30,Y+37
    13C9 A1FE      LDD	R31,Y+38
    13CA 80A0      LDD	R10,Z+0
    13CB 24BB      CLR	R11
    13CC 01C5      MOVW	R24,R10
    13CD 3081      CPI	R24,1
    13CE E0E0      LDI	R30,0
    13CF 079E      CPC	R25,R30
    13D0 F029      BEQ	0x13D6
    13D1 3082      CPI	R24,2
    13D2 E0E0      LDI	R30,0
    13D3 079E      CPC	R25,R30
    13D4 F041      BEQ	0x13DD
    13D5 C1C0      RJMP	0x1596
(0589) 	  {
(0590) 	    case  1 : file_type[0] = 'B' ;
    13D6 E482      LDI	R24,0x42
    13D7 838A      STD	Y+2,R24
(0591)                   file_type[1] = 'M' ; 
    13D8 E48D      LDI	R24,0x4D
    13D9 838B      STD	Y+3,R24
(0592) 				  file_type[2] = 'P' ;
    13DA E580      LDI	R24,0x50
    13DB 838C      STD	Y+4,R24
(0593) 				  
(0594) 				  break ;
    13DC C1B9      RJMP	0x1596
(0595) 				  
(0596) 		case  2 : file_type[0] = 'B' ;
    13DD E482      LDI	R24,0x42
    13DE 838A      STD	Y+2,R24
(0597) 		          file_type[1] = 'I' ;
    13DF E489      LDI	R24,0x49
    13E0 838B      STD	Y+3,R24
(0598) 				  file_type[2] = 'N' ;
    13E1 E48E      LDI	R24,0x4E
    13E2 838C      STD	Y+4,R24
(0599) 				  
(0600) 				  break;
    13E3 C1B2      RJMP	0x1596
(0601) 				  
(0602) 	  
(0603) 	  }
(0604) 	
(0605) 	
(0606) 	
(0607) 	while(1)
(0608) 	{
(0609) 		cluster = GetFolderCluster(addr);
    13E4 890D      LDD	R16,Y+21
    13E5 891E      LDD	R17,Y+22
    13E6 DCD7      RCALL	_GetFolderCluster
    13E7 01FE      MOVW	R30,R28
    13E8 8705      STD	Z+13,R16
    13E9 8716      STD	Z+14,R17
    13EA 8727      STD	Z+15,R18
    13EB 8B30      STD	Z+16,R19
(0610) 		addr += 4;
    13EC 898D      LDD	R24,Y+21
    13ED 899E      LDD	R25,Y+22
    13EE 9604      ADIW	R24,4
    13EF 8B9E      STD	Y+22,R25
    13F0 8B8D      STD	Y+21,R24
(0611) 		if(cluster == 0xffffffff) break;
    13F1 EF4F      LDI	R20,0xFF
    13F2 EF5F      LDI	R21,0xFF
    13F3 EF6F      LDI	R22,0xFF
    13F4 EF7F      LDI	R23,0xFF
    13F5 01FE      MOVW	R30,R28
    13F6 8425      LDD	R2,Z+13
    13F7 8436      LDD	R3,Z+14
    13F8 8447      LDD	R4,Z+15
    13F9 8850      LDD	R5,Z+16
    13FA 1624      CP	R2,R20
    13FB 0635      CPC	R3,R21
    13FC 0646      CPC	R4,R22
    13FD 0657      CPC	R5,R23
    13FE F409      BNE	0x1400
    13FF C197      RJMP	0x1597
(0612) 		
(0613) 		else
(0614) 		{
(0615) 			//*music_record_addr = addr - 4;	/* record in which record found the right file */
(0616) 			if(cluster==0 && FAT32_Enable==0)// 根目录，FAT16文件系统
    1400 E040      LDI	R20,0
    1401 E050      LDI	R21,0
    1402 E060      LDI	R22,0
    1403 E070      LDI	R23,0
    1404 01FE      MOVW	R30,R28
    1405 8425      LDD	R2,Z+13
    1406 8436      LDD	R3,Z+14
    1407 8447      LDD	R4,Z+15
    1408 8850      LDD	R5,Z+16
    1409 1624      CP	R2,R20
    140A 0635      CPC	R3,R21
    140B 0646      CPC	R4,R22
    140C 0657      CPC	R5,R23
    140D F009      BEQ	0x140F
    140E C093      RJMP	0x14A2
    140F 90200EFC  LDS	R2,FAT32_Enable
    1411 2022      TST	R2
    1412 F009      BEQ	0x1414
    1413 C08E      RJMP	0x14A2
(0617) 			{
(0618) 			
(0619) 			
(0620) 				buffer=malloc(512);//动态分配空间512字节
    1414 E000      LDI	R16,0
    1415 E012      LDI	R17,2
    1416 940E24AF  CALL	_malloc
    1418 0168      MOVW	R12,R16
(0621) 				if(buffer==0)return 1;//if failed
    1419 3000      CPI	R16,0
    141A 0701      CPC	R16,R17
    141B F411      BNE	0x141E
    141C E001      LDI	R16,1
    141D C188      RJMP	0x15A6
(0622) 				
(0623) 				
(0624) 				for(cnt=0;cnt<RootDirSectors;cnt++)
    141E 24AA      CLR	R10
    141F C06C      RJMP	0x148C
(0625) 				{
(0626) 					if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
    1420 82D9      STD	Y+1,R13
    1421 82C8      STD	Y+0,R12
    1422 2C2A      MOV	R2,R10
    1423 2433      CLR	R3
    1424 2444      CLR	R4
    1425 2455      CLR	R5
    1426 90800F07  LDS	R8,FirstDirSector+2
    1428 90900F08  LDS	R9,FirstDirSector+3
    142A 90600F05  LDS	R6,FirstDirSector
    142C 90700F06  LDS	R7,FirstDirSector+1
    142E 0C62      ADD	R6,R2
    142F 1C73      ADC	R7,R3
    1430 1C84      ADC	R8,R4
    1431 1C95      ADC	R9,R5
    1432 0183      MOVW	R16,R6
    1433 0194      MOVW	R18,R8
    1434 91E00198  LDS	R30,FAT_ReadSector
    1436 91F00199  LDS	R31,FAT_ReadSector+1
    1438 940E23F1  CALL	xicall
    143A 2300      TST	R16
    143B F029      BEQ	0x1441
    143C 0186      MOVW	R16,R12
    143D 940E2601  CALL	_free
    143F E001      LDI	R16,1
    1440 C165      RJMP	0x15A6
(0627) 					for(offset=0;offset<512;offset+=32)
    1441 24EE      CLR	R14
    1442 24FF      CLR	R15
    1443 C041      RJMP	0x1485
(0628) 					{
(0629) 						item=(struct direntry *)(&buffer[offset]);//pointer convert
    1444 0117      MOVW	R2,R14
    1445 0C2C      ADD	R2,R12
    1446 1C3D      ADC	R3,R13
    1447 8A3A      STD	Y+18,R3
    1448 8A29      STD	Y+17,R2
(0630) 						//find a valid item and display it
(0631) 						if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
    1449 01F1      MOVW	R30,R2
    144A 8020      LDD	R2,Z+0
    144B 2433      CLR	R3
    144C 2D82      MOV	R24,R2
    144D 328E      CPI	R24,0x2E
    144E F409      BNE	0x1450
    144F C032      RJMP	0x1482
    1450 2388      TST	R24
    1451 F409      BNE	0x1453
    1452 C02F      RJMP	0x1482
    1453 3E85      CPI	R24,0xE5
    1454 F409      BNE	0x1456
    1455 C02C      RJMP	0x1482
    1456 8583      LDD	R24,Z+11
    1457 308F      CPI	R24,0xF
    1458 F149      BEQ	0x1482
(0632) 						{
(0633) 						
(0634) 							if((item->deExtension[0] == file_type[0])&&(item->deExtension[1] == file_type[1])&&(item->deExtension[2] == file_type[2]))
    1459 802A      LDD	R2,Y+2
    145A 89E9      LDD	R30,Y+17
    145B 89FA      LDD	R31,Y+18
    145C 8430      LDD	R3,Z+8
    145D 1432      CP	R3,R2
    145E F519      BNE	0x1482
    145F 802B      LDD	R2,Y+3
    1460 89E9      LDD	R30,Y+17
    1461 89FA      LDD	R31,Y+18
    1462 8431      LDD	R3,Z+9
    1463 1432      CP	R3,R2
    1464 F4E9      BNE	0x1482
    1465 802C      LDD	R2,Y+4
    1466 89E9      LDD	R30,Y+17
    1467 89FA      LDD	R31,Y+18
    1468 8432      LDD	R3,Z+10
    1469 1432      CP	R3,R2
    146A F4B9      BNE	0x1482
(0635) 							{
(0636) 								
(0637) 								CopyDirentruyItem(MusicInfo,item);
    146B 8929      LDD	R18,Y+17
    146C 893A      LDD	R19,Y+18
    146D A109      LDD	R16,Y+33
    146E A11A      LDD	R17,Y+34
    146F DB52      RCALL	_CopyDirentruyItem
(0638) 								
(0639) 								i++;
    1470 898B      LDD	R24,Y+19
    1471 899C      LDD	R25,Y+20
    1472 9601      ADIW	R24,1
    1473 8B9C      STD	Y+20,R25
    1474 8B8B      STD	Y+19,R24
(0640) 								if(i==*Count){free(buffer);return 0;}
    1475 A1EB      LDD	R30,Y+35
    1476 A1FC      LDD	R31,Y+36
    1477 8020      LDD	R2,Z+0
    1478 8031      LDD	R3,Z+1
    1479 010C      MOVW	R0,R24
    147A 1582      CP	R24,R2
    147B 0593      CPC	R25,R3
    147C F429      BNE	0x1482
    147D 0186      MOVW	R16,R12
    147E 940E2601  CALL	_free
    1480 2700      CLR	R16
    1481 C124      RJMP	0x15A6
    1482 01C7      MOVW	R24,R14
    1483 9680      ADIW	R24,0x20
    1484 017C      MOVW	R14,R24
    1485 01C7      MOVW	R24,R14
    1486 3080      CPI	R24,0
    1487 E0E2      LDI	R30,2
    1488 079E      CPC	R25,R30
    1489 F408      BCC	0x148B
    148A CFB9      RJMP	0x1444
    148B 94A3      INC	R10
    148C 90400F03  LDS	R4,RootDirSectors+2
    148E 90500F04  LDS	R5,RootDirSectors+3
    1490 90200F01  LDS	R2,RootDirSectors
    1492 90300F02  LDS	R3,RootDirSectors+1
    1494 2C6A      MOV	R6,R10
    1495 2477      CLR	R7
    1496 2488      CLR	R8
    1497 2499      CLR	R9
    1498 1462      CP	R6,R2
    1499 0473      CPC	R7,R3
    149A 0484      CPC	R8,R4
    149B 0495      CPC	R9,R5
    149C F408      BCC	0x149E
    149D CF82      RJMP	0x1420
(0641) 							}							 
(0642) 						}
(0643) 					}
(0644) 				}
(0645) 				free(buffer);//release释放空间
    149E 0186      MOVW	R16,R12
    149F 940E2601  CALL	_free
(0646) 			}
    14A1 C0F4      RJMP	0x1596
(0647) 			else//other folders
(0648) 			{
(0649) 				tempclust=cluster;
    14A2 01FE      MOVW	R30,R28
    14A3 8425      LDD	R2,Z+13
    14A4 8436      LDD	R3,Z+14
    14A5 8447      LDD	R4,Z+15
    14A6 8850      LDD	R5,Z+16
    14A7 01FE      MOVW	R30,R28
    14A8 8621      STD	Z+9,R2
    14A9 8632      STD	Z+10,R3
    14AA 8643      STD	Z+11,R4
    14AB 8654      STD	Z+12,R5
    14AC C0E8      RJMP	0x1595
(0650) 				while(1)
(0651) 				{
(0652) 					sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
    14AD E042      LDI	R20,2
    14AE E050      LDI	R21,0
    14AF E060      LDI	R22,0
    14B0 E070      LDI	R23,0
    14B1 01FE      MOVW	R30,R28
    14B2 8421      LDD	R2,Z+9
    14B3 8432      LDD	R3,Z+10
    14B4 8443      LDD	R4,Z+11
    14B5 8454      LDD	R5,Z+12
    14B6 1A24      SUB	R2,R20
    14B7 0A35      SBC	R3,R21
    14B8 0A46      SBC	R4,R22
    14B9 0A57      SBC	R5,R23
    14BA 90600F0D  LDS	R6,SectorsPerClust
    14BC 90700F0E  LDS	R7,SectorsPerClust+1
    14BE 2488      CLR	R8
    14BF 2499      CLR	R9
    14C0 929A      ST	R9,-Y
    14C1 928A      ST	R8,-Y
    14C2 927A      ST	R7,-Y
    14C3 926A      ST	R6,-Y
    14C4 0181      MOVW	R16,R2
    14C5 0192      MOVW	R18,R4
    14C6 940E2396  CALL	empy32s
    14C8 90400F15  LDS	R4,FirstDataSector+2
    14CA 90500F16  LDS	R5,FirstDataSector+3
    14CC 90200F13  LDS	R2,FirstDataSector
    14CE 90300F14  LDS	R3,FirstDataSector+1
    14D0 0E20      ADD	R2,R16
    14D1 1E31      ADC	R3,R17
    14D2 1E42      ADC	R4,R18
    14D3 1E53      ADC	R5,R19
    14D4 01FE      MOVW	R30,R28
    14D5 8225      STD	Z+5,R2
    14D6 8236      STD	Z+6,R3
    14D7 8247      STD	Z+7,R4
    14D8 8650      STD	Z+8,R5
(0653) 					buffer=malloc(512);//apply memory
    14D9 E000      LDI	R16,0
    14DA E012      LDI	R17,2
    14DB 940E24AF  CALL	_malloc
    14DD 0168      MOVW	R12,R16
(0654) 					if(buffer==0)return 1;//if failed
    14DE 3000      CPI	R16,0
    14DF 0701      CPC	R16,R17
    14E0 F411      BNE	0x14E3
    14E1 E001      LDI	R16,1
    14E2 C0C3      RJMP	0x15A6
(0655) 					for(cnt=0;cnt<SectorsPerClust;cnt++)
    14E3 24AA      CLR	R10
    14E4 C069      RJMP	0x154E
(0656) 					{
(0657) 						if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
    14E5 82D9      STD	Y+1,R13
    14E6 82C8      STD	Y+0,R12
    14E7 2C2A      MOV	R2,R10
    14E8 2433      CLR	R3
    14E9 2444      CLR	R4
    14EA 2455      CLR	R5
    14EB 01FE      MOVW	R30,R28
    14EC 8065      LDD	R6,Z+5
    14ED 8076      LDD	R7,Z+6
    14EE 8087      LDD	R8,Z+7
    14EF 8490      LDD	R9,Z+8
    14F0 0C62      ADD	R6,R2
    14F1 1C73      ADC	R7,R3
    14F2 1C84      ADC	R8,R4
    14F3 1C95      ADC	R9,R5
    14F4 0183      MOVW	R16,R6
    14F5 0194      MOVW	R18,R8
    14F6 91E00198  LDS	R30,FAT_ReadSector
    14F8 91F00199  LDS	R31,FAT_ReadSector+1
    14FA 940E23F1  CALL	xicall
    14FC 2300      TST	R16
    14FD F029      BEQ	0x1503
    14FE 0186      MOVW	R16,R12
    14FF 940E2601  CALL	_free
    1501 E001      LDI	R16,1
    1502 C0A3      RJMP	0x15A6
(0658) 						for(offset=0;offset<512;offset+=32)
    1503 24EE      CLR	R14
    1504 24FF      CLR	R15
    1505 C041      RJMP	0x1547
(0659) 						{
(0660) 							item=(struct direntry *)(&buffer[offset]);
    1506 0117      MOVW	R2,R14
    1507 0C2C      ADD	R2,R12
    1508 1C3D      ADC	R3,R13
    1509 8A3A      STD	Y+18,R3
    150A 8A29      STD	Y+17,R2
(0661) 							if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
    150B 01F1      MOVW	R30,R2
    150C 8020      LDD	R2,Z+0
    150D 2433      CLR	R3
    150E 2D82      MOV	R24,R2
    150F 328E      CPI	R24,0x2E
    1510 F409      BNE	0x1512
    1511 C032      RJMP	0x1544
    1512 2388      TST	R24
    1513 F409      BNE	0x1515
    1514 C02F      RJMP	0x1544
    1515 3E85      CPI	R24,0xE5
    1516 F409      BNE	0x1518
    1517 C02C      RJMP	0x1544
    1518 8583      LDD	R24,Z+11
    1519 308F      CPI	R24,0xF
    151A F149      BEQ	0x1544
(0662) 							{		
(0663)                                		
(0664) 								if((item->deExtension[0] == file_type[0])&&(item->deExtension[1] == file_type[1])&&(item->deExtension[2] == file_type[2]))
    151B 802A      LDD	R2,Y+2
    151C 89E9      LDD	R30,Y+17
    151D 89FA      LDD	R31,Y+18
    151E 8430      LDD	R3,Z+8
    151F 1432      CP	R3,R2
    1520 F519      BNE	0x1544
    1521 802B      LDD	R2,Y+3
    1522 89E9      LDD	R30,Y+17
    1523 89FA      LDD	R31,Y+18
    1524 8431      LDD	R3,Z+9
    1525 1432      CP	R3,R2
    1526 F4E9      BNE	0x1544
    1527 802C      LDD	R2,Y+4
    1528 89E9      LDD	R30,Y+17
    1529 89FA      LDD	R31,Y+18
    152A 8432      LDD	R3,Z+10
    152B 1432      CP	R3,R2
    152C F4B9      BNE	0x1544
(0665) 								{
(0666) 								    
(0667) 									CopyDirentruyItem(MusicInfo,item);
    152D 8929      LDD	R18,Y+17
    152E 893A      LDD	R19,Y+18
    152F A109      LDD	R16,Y+33
    1530 A11A      LDD	R17,Y+34
    1531 DA90      RCALL	_CopyDirentruyItem
(0668) 									
(0669) 									i++;
    1532 898B      LDD	R24,Y+19
    1533 899C      LDD	R25,Y+20
    1534 9601      ADIW	R24,1
    1535 8B9C      STD	Y+20,R25
    1536 8B8B      STD	Y+19,R24
(0670) 									if(i==*Count){free(buffer);return 0;}
    1537 A1EB      LDD	R30,Y+35
    1538 A1FC      LDD	R31,Y+36
    1539 8020      LDD	R2,Z+0
    153A 8031      LDD	R3,Z+1
    153B 010C      MOVW	R0,R24
    153C 1582      CP	R24,R2
    153D 0593      CPC	R25,R3
    153E F429      BNE	0x1544
    153F 0186      MOVW	R16,R12
    1540 940E2601  CALL	_free
    1542 2700      CLR	R16
    1543 C062      RJMP	0x15A6
    1544 01C7      MOVW	R24,R14
    1545 9680      ADIW	R24,0x20
    1546 017C      MOVW	R14,R24
    1547 01C7      MOVW	R24,R14
    1548 3080      CPI	R24,0
    1549 E0E2      LDI	R30,2
    154A 079E      CPC	R25,R30
    154B F408      BCC	0x154D
    154C CFB9      RJMP	0x1506
    154D 94A3      INC	R10
    154E 90200F0D  LDS	R2,SectorsPerClust
    1550 90300F0E  LDS	R3,SectorsPerClust+1
    1552 2C4A      MOV	R4,R10
    1553 2455      CLR	R5
    1554 1442      CP	R4,R2
    1555 0453      CPC	R5,R3
    1556 F408      BCC	0x1558
    1557 CF8D      RJMP	0x14E5
(0671) 								}
(0672) 							}
(0673) 						}
(0674) 					}
(0675) 					free(buffer);//release
    1558 0186      MOVW	R16,R12
    1559 940E2601  CALL	_free
(0676) 					tempclust=FAT_NextCluster(tempclust);//next cluster
    155B 01FE      MOVW	R30,R28
    155C 8501      LDD	R16,Z+9
    155D 8512      LDD	R17,Z+10
    155E 8523      LDD	R18,Z+11
    155F 8534      LDD	R19,Z+12
    1560 D96A      RCALL	_FAT_NextCluster
    1561 01FE      MOVW	R30,R28
    1562 8701      STD	Z+9,R16
    1563 8712      STD	Z+10,R17
    1564 8723      STD	Z+11,R18
    1565 8734      STD	Z+12,R19
(0677) 					if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
    1566 EF4F      LDI	R20,0xFF
    1567 EF5F      LDI	R21,0xFF
    1568 EF6F      LDI	R22,0xFF
    1569 E07F      LDI	R23,0xF
    156A 01FE      MOVW	R30,R28
    156B 8421      LDD	R2,Z+9
    156C 8432      LDD	R3,Z+10
    156D 8443      LDD	R4,Z+11
    156E 8454      LDD	R5,Z+12
    156F 1624      CP	R2,R20
    1570 0635      CPC	R3,R21
    1571 0646      CPC	R4,R22
    1572 0657      CPC	R5,R23
    1573 F101      BEQ	0x1594
    1574 EF48      LDI	R20,0xF8
    1575 EF5F      LDI	R21,0xFF
    1576 EF6F      LDI	R22,0xFF
    1577 E07F      LDI	R23,0xF
    1578 01FE      MOVW	R30,R28
    1579 8421      LDD	R2,Z+9
    157A 8432      LDD	R3,Z+10
    157B 8443      LDD	R4,Z+11
    157C 8454      LDD	R5,Z+12
    157D 1624      CP	R2,R20
    157E 0635      CPC	R3,R21
    157F 0646      CPC	R4,R22
    1580 0657      CPC	R5,R23
    1581 F091      BEQ	0x1594
    1582 90200EFC  LDS	R2,FAT32_Enable
    1584 2022      TST	R2
    1585 F479      BNE	0x1595
    1586 EF4F      LDI	R20,0xFF
    1587 EF5F      LDI	R21,0xFF
    1588 E060      LDI	R22,0
    1589 E070      LDI	R23,0
    158A 01FE      MOVW	R30,R28
    158B 8421      LDD	R2,Z+9
    158C 8432      LDD	R3,Z+10
    158D 8443      LDD	R4,Z+11
    158E 8454      LDD	R5,Z+12
    158F 1624      CP	R2,R20
    1590 0635      CPC	R3,R21
    1591 0646      CPC	R4,R22
    1592 0657      CPC	R5,R23
    1593 F409      BNE	0x1595
    1594 C001      RJMP	0x1596
    1595 CF17      RJMP	0x14AD
    1596 CE4D      RJMP	0x13E4
(0678) 				}
(0679) 			}
(0680) 		}
(0681) 	}
(0682) 	if(*Count==0)*Count=i;
    1597 A1EB      LDD	R30,Y+35
    1598 A1FC      LDD	R31,Y+36
    1599 8020      LDD	R2,Z+0
    159A 8031      LDD	R3,Z+1
    159B 2022      TST	R2
    159C F441      BNE	0x15A5
    159D 2033      TST	R3
    159E F431      BNE	0x15A5
    159F A1EB      LDD	R30,Y+35
    15A0 A1FC      LDD	R31,Y+36
    15A1 880B      LDD	R0,Y+19
    15A2 881C      LDD	R1,Y+20
    15A3 8211      STD	Z+1,R1
    15A4 8200      STD	Z+0,R0
(0683) 	/*
(0684) 	GUI_sprintf_chartohex(130,300,*type,0xffff,0x0000) ;
(0685) 	GUI_sprintf_chartohex(160,300,i,0xffff,0x0000) ;
(0686) 	GUI_sprintf_chartohex(190,300,*Count,0xffff,0x0000) ;
(0687) 	while(1) ;*/
(0688) 	return 0;	
    15A5 2700      CLR	R16
    15A6 9667      ADIW	R28,0x17
    15A7 940E23CF  CALL	pop_gset5
    15A9 9624      ADIW	R28,4
    15AA 9508      RET
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\mmc.c
(0001) //SD卡驱动函数，采取网络上开源的第三方库文件
(0002) //欣世纪电子略作修改，由于部分SD卡并非标准SD卡命令，因此可能存在兼容性问题，建议使用金士顿SD卡
(0003) //SD卡片选信号SD_CS在mmcconf.h文件中修改，DMAVR-M128为PG3脚控制SD_CS
(0004) //由于DMAVR-128板载SPI接口同时连接在TLC5615芯片上，因此，初始化时要先将SS管脚拉高，禁止TLC5615芯片
(0005) 
(0006) //***********************************************************************
(0007) //			包含文件
(0008) //***********************************************************************
(0009) #include "libtypes.h"		// include our global settings
(0010) #include "DM_spi.h"			// include spi bus support
(0011) #include "mmc.h"
(0012) #include "mmcconf.h"	   // include project-specific hardware configuration
(0013) #include <stdio.h>
(0014) //#include <delay.h>
(0015) #include <iom128v.h>
(0016) 
(0017) #define   set(x)                (1<<(x))
(0018) #define   sbi(temp,x)    		temp|=(1<<(x))     //置位
(0019) #define   clr(x)                (~(1<<(x)))
(0020) #define   cbi(temp,x)     		temp&=~(1<<(x))    //清零
(0021) //***********************************************************************
(0022) //			IO口初始化
(0023) //***********************************************************************
(0024) //void McuInit()
(0025) //{
(0026) 	//PORTB=0XFF;
(0027) 	//DDRB=0XFF;
(0028) //}
(0029) 
(0030) //***********************************************************************
(0031) //			SD卡初始化
(0032) //***********************************************************************
(0033) void mmcInit(void)
(0034) {
(0035) 	// initialize SPI interface
(0036) 	spiInit();
_mmcInit:
    15AB 940E17F3  CALL	_spiInit
(0037) 	// release chip select
(0038) 	sbi(MMC_CS_DDR, MMC_CS_PIN);
    15AD 91800064  LDS	R24,0x64
    15AF 6088      ORI	R24,0x8
    15B0 93800064  STS	0x64,R24
(0039) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    15B2 91800065  LDS	R24,0x65
    15B4 6088      ORI	R24,0x8
    15B5 93800065  STS	0x65,R24
    15B7 9508      RET
_mmcReset:
  retry                --> R10
  r1                   --> R12
  i                    --> R14
    15B8 940E23D2  CALL	push_gset5
    15BA 9722      SBIW	R28,2
(0040) }
(0041) 
(0042) //***********************************************************************
(0043) //			识别SD卡是否存在
(0044) //***********************************************************************
(0045) 
(0046) u08 mmcReset(void)
(0047) {
(0048) 	u08 i;
(0049) 	u08 retry;
(0050) 	u08 r1=0;
    15BB 24CC      CLR	R12
(0051) 
(0052) 	retry = 0;
    15BC 24AA      CLR	R10
(0053) 	do
(0054) 	{
(0055) 		// send dummy bytes with CS high before accessing
(0056) 		for(i=0;i<10;i++) spiTransferByte(0xFF);
    15BD 24EE      CLR	R14
    15BE C004      RJMP	0x15C3
    15BF EF0F      LDI	R16,0xFF
    15C0 940E1807  CALL	_spiTransferByte
    15C2 94E3      INC	R14
    15C3 2D8E      MOV	R24,R14
    15C4 308A      CPI	R24,0xA
    15C5 F3C8      BCS	0x15BF
(0057) 		// resetting card, go to SPI mode
(0058) 		r1 = mmcSendCommand(MMC_GO_IDLE_STATE, 0);
    15C6 E040      LDI	R20,0
    15C7 E050      LDI	R21,0
    15C8 E060      LDI	R22,0
    15C9 E070      LDI	R23,0
    15CA 8368      STD	Y+0,R22
    15CB 8379      STD	Y+1,R23
    15CC 019A      MOVW	R18,R20
    15CD 2700      CLR	R16
    15CE D035      RCALL	_mmcSendCommand
    15CF 2EC0      MOV	R12,R16
(0059) 		#ifdef MMC_DEBUG
(0060) 		//rprintf("MMC_GO_IDLE_STATE: R1=0x%x\r\n", r1);
(0061) 		#endif
(0062) 		// do retry counter
(0063) 		retry++;
    15D0 94A3      INC	R10
(0064) 		if(retry>10) return -1;
    15D1 E08A      LDI	R24,0xA
    15D2 158A      CP	R24,R10
    15D3 F410      BCC	0x15D6
    15D4 EF0F      LDI	R16,0xFF
    15D5 C02A      RJMP	0x1600
(0065) 	} while(r1 != 0x01);
    15D6 2D8C      MOV	R24,R12
    15D7 3081      CPI	R24,1
    15D8 F721      BNE	0x15BD
(0066) 
(0067) 	// TODO: check card parameters for voltage compliance
(0068) 	// before issuing initialize command
(0069) 
(0070) 	retry = 0;
    15D9 24AA      CLR	R10
(0071) 	do
(0072) 	{
(0073) 		// initializing card for operation
(0074) 		r1 = mmcSendCommand(MMC_SEND_OP_COND, 0);
    15DA E040      LDI	R20,0
    15DB E050      LDI	R21,0
    15DC E060      LDI	R22,0
    15DD E070      LDI	R23,0
    15DE 8368      STD	Y+0,R22
    15DF 8379      STD	Y+1,R23
    15E0 019A      MOVW	R18,R20
    15E1 E001      LDI	R16,1
    15E2 D021      RCALL	_mmcSendCommand
    15E3 2EC0      MOV	R12,R16
(0075) 		#ifdef MMC_DEBUG
(0076) 		//rprintf("MMC_SEND_OP_COND: R1=0x%x\r\n", r1);
(0077) 		#endif
(0078) 		// do retry counter
(0079) 		retry++;
    15E4 94A3      INC	R10
(0080) 		if(retry>100) return -1;
    15E5 E684      LDI	R24,0x64
    15E6 158A      CP	R24,R10
    15E7 F410      BCC	0x15EA
    15E8 EF0F      LDI	R16,0xFF
    15E9 C016      RJMP	0x1600
(0081) 	} while(r1);
    15EA 20CC      TST	R12
    15EB F771      BNE	0x15DA
(0082) 		
(0083) 	// turn off CRC checking to simplify communication
(0084) 	r1 = mmcSendCommand(MMC_CRC_ON_OFF, 0);
    15EC E040      LDI	R20,0
    15ED E050      LDI	R21,0
    15EE E060      LDI	R22,0
    15EF E070      LDI	R23,0
    15F0 8368      STD	Y+0,R22
    15F1 8379      STD	Y+1,R23
    15F2 019A      MOVW	R18,R20
    15F3 E30B      LDI	R16,0x3B
    15F4 D00F      RCALL	_mmcSendCommand
(0085) 	#ifdef MMC_DEBUG
(0086) 	//rprintf("MMC_CRC_ON_OFF: R1=0x%x\r\n", r1);
(0087) 	#endif
(0088) 
(0089) 	// set block length to 512 bytes
(0090) 	r1 = mmcSendCommand(MMC_SET_BLOCKLEN, 512);
    15F5 E040      LDI	R20,0
    15F6 E052      LDI	R21,2
    15F7 E060      LDI	R22,0
    15F8 E070      LDI	R23,0
    15F9 8368      STD	Y+0,R22
    15FA 8379      STD	Y+1,R23
    15FB 019A      MOVW	R18,R20
    15FC E100      LDI	R16,0x10
    15FD D006      RCALL	_mmcSendCommand
    15FE 2EC0      MOV	R12,R16
(0091) 	#ifdef MMC_DEBUG
(0092) 	//rprintf("MMC_SET_BLOCKLEN: R1=0x%x\r\n", r1);
(0093) 	#endif
(0094) 
(0095) 	// return success
(0096) 	return 0;
    15FF 2700      CLR	R16
    1600 9622      ADIW	R28,2
    1601 940E23CF  CALL	pop_gset5
    1603 9508      RET
_mmcSendCommand:
  r1                   --> R20
  arg                  --> Y+4
  cmd                  --> R20
    1604 933A      ST	R19,-Y
    1605 932A      ST	R18,-Y
    1606 940E23DA  CALL	push_gset1
    1608 2F40      MOV	R20,R16
    1609 9722      SBIW	R28,2
(0097) }
(0098) 
(0099) //***********************************************************************
(0100) //			发送SD卡命令函数
(0101) //***********************************************************************
(0102) 
(0103) u08 mmcSendCommand(u08 cmd, u32 arg)
(0104) {
(0105) 	u08 r1;
(0106) 
(0107) 	// assert chip select
(0108) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    160A 91800065  LDS	R24,0x65
    160C 7F87      ANDI	R24,0xF7
    160D 93800065  STS	0x65,R24
(0109) 	// issue the command
(0110) 	r1 = mmcCommand(cmd, arg);
    160F 01FE      MOVW	R30,R28
    1610 8024      LDD	R2,Z+4
    1611 8035      LDD	R3,Z+5
    1612 8046      LDD	R4,Z+6
    1613 8057      LDD	R5,Z+7
    1614 8248      STD	Y+0,R4
    1615 8259      STD	Y+1,R5
    1616 0191      MOVW	R18,R2
    1617 2F04      MOV	R16,R20
    1618 D0B0      RCALL	_mmcCommand
    1619 2F40      MOV	R20,R16
(0111) 	// release chip select
(0112) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    161A 91800065  LDS	R24,0x65
    161C 6088      ORI	R24,0x8
    161D 93800065  STS	0x65,R24
(0113) 
(0114) 	return r1;
    161F 9622      ADIW	R28,2
    1620 940E23DD  CALL	pop_gset1
    1622 9622      ADIW	R28,2
    1623 9508      RET
_mmcRead:
  r1                   --> R10
  i                    --> R20
  buffer               --> R22
  sector               --> Y+8
    1624 940E22CF  CALL	push_arg4
    1626 940E23D6  CALL	push_gset3
    1628 9722      SBIW	R28,2
    1629 856C      LDD	R22,Y+12
    162A 857D      LDD	R23,Y+13
(0115) }
(0116) 
(0117) //***********************************************************************
(0118) //			读SD卡数据函数，扇区读，一次512个字节
(0119) //***********************************************************************
(0120) u08 mmcRead(u32 sector, u08* buffer)
(0121) {
(0122) 	u08 r1;
(0123) 	u16 i;
(0124) 
(0125) 	// assert chip select
(0126) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    162B 91800065  LDS	R24,0x65
    162D 7F87      ANDI	R24,0xF7
    162E 93800065  STS	0x65,R24
(0127) 	for(i=0;i<10;i++) spiTransferByte(0xFF);
    1630 2744      CLR	R20
    1631 2755      CLR	R21
    1632 C005      RJMP	0x1638
    1633 EF0F      LDI	R16,0xFF
    1634 940E1807  CALL	_spiTransferByte
    1636 5F4F      SUBI	R20,0xFF
    1637 4F5F      SBCI	R21,0xFF
    1638 304A      CPI	R20,0xA
    1639 E0E0      LDI	R30,0
    163A 075E      CPC	R21,R30
    163B F3B8      BCS	0x1633
(0128) 	// issue command
(0129) 	r1 = mmcCommand(MMC_READ_SINGLE_BLOCK, sector<<9);
    163C E089      LDI	R24,0x9
    163D E090      LDI	R25,0
    163E 01FE      MOVW	R30,R28
    163F 8420      LDD	R2,Z+8
    1640 8431      LDD	R3,Z+9
    1641 8442      LDD	R4,Z+10
    1642 8453      LDD	R5,Z+11
    1643 938A      ST	R24,-Y
    1644 0181      MOVW	R16,R2
    1645 0192      MOVW	R18,R4
    1646 940E242F  CALL	lsl32
    1648 8328      STD	Y+0,R18
    1649 8339      STD	Y+1,R19
    164A 0198      MOVW	R18,R16
    164B E101      LDI	R16,0x11
    164C D07C      RCALL	_mmcCommand
    164D 2EA0      MOV	R10,R16
(0130) 	#ifdef MMC_DEBUG
(0131) 	//rprintf("MMC Read Block R1=0x%x\r\n", r1);
(0132) 	#endif
(0133) 	// check for valid response
(0134) 	if(r1 != 0x00)
    164E 2300      TST	R16
    164F F009      BEQ	0x1651
(0135) 		return r1;
    1650 C020      RJMP	0x1671
(0136) 	// wait for block start
(0137) 	while(spiTransferByte(0xFF) != MMC_STARTBLOCK_READ);
    1651 EF0F      LDI	R16,0xFF
    1652 940E1807  CALL	_spiTransferByte
    1654 3F0E      CPI	R16,0xFE
    1655 F7D9      BNE	0x1651
(0138) 	// read in data
(0139) 	for(i=0; i<0x200; i++)
    1656 2744      CLR	R20
    1657 2755      CLR	R21
    1658 C008      RJMP	0x1661
(0140) 	{
(0141) 		*buffer++ =spiTransferByte(0xFF);
    1659 EF0F      LDI	R16,0xFF
    165A 940E1807  CALL	_spiTransferByte
    165C 01FB      MOVW	R30,R22
    165D 9301      ST	R16,Z+
    165E 01BF      MOVW	R22,R30
    165F 5F4F      SUBI	R20,0xFF
    1660 4F5F      SBCI	R21,0xFF
    1661 3040      CPI	R20,0
    1662 E0E2      LDI	R30,2
    1663 075E      CPC	R21,R30
    1664 F3A0      BCS	0x1659
(0142) 	}
(0143) 	// read 16-bit CRC
(0144) 	spiTransferByte(0xFF);
    1665 EF0F      LDI	R16,0xFF
    1666 940E1807  CALL	_spiTransferByte
(0145) 	spiTransferByte(0xFF);
    1668 EF0F      LDI	R16,0xFF
    1669 940E1807  CALL	_spiTransferByte
(0146) 	// release chip select
(0147) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    166B 91800065  LDS	R24,0x65
    166D 6088      ORI	R24,0x8
    166E 93800065  STS	0x65,R24
(0148) 	// return success
(0149) 	return 0;
    1670 2700      CLR	R16
    1671 9622      ADIW	R28,2
    1672 940E23C9  CALL	pop_gset3
    1674 9624      ADIW	R28,4
    1675 9508      RET
_mmcWrite:
  r1                   --> R20
  i                    --> R22
  buffer               --> R10
  sector               --> Y+8
    1676 940E22CF  CALL	push_arg4
    1678 940E23D6  CALL	push_gset3
    167A 9722      SBIW	R28,2
    167B 84AC      LDD	R10,Y+12
    167C 84BD      LDD	R11,Y+13
(0150) }
(0151) 
(0152) //***********************************************************************
(0153) //			向SD卡中指定地址写数据，扇区写，一次512个字节
(0154) //***********************************************************************
(0155) u08 mmcWrite(u32 sector, u08* buffer)
(0156) {
(0157) 	u08 r1;
(0158) 	u16 i;
(0159) 
(0160) 	// assert chip select
(0161) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    167D 91800065  LDS	R24,0x65
    167F 7F87      ANDI	R24,0xF7
    1680 93800065  STS	0x65,R24
(0162) 	// issue command
(0163) 	r1 = mmcCommand(MMC_WRITE_BLOCK, sector<<9);
    1682 E089      LDI	R24,0x9
    1683 E090      LDI	R25,0
    1684 01FE      MOVW	R30,R28
    1685 8420      LDD	R2,Z+8
    1686 8431      LDD	R3,Z+9
    1687 8442      LDD	R4,Z+10
    1688 8453      LDD	R5,Z+11
    1689 938A      ST	R24,-Y
    168A 0181      MOVW	R16,R2
    168B 0192      MOVW	R18,R4
    168C 940E242F  CALL	lsl32
    168E 8328      STD	Y+0,R18
    168F 8339      STD	Y+1,R19
    1690 0198      MOVW	R18,R16
    1691 E108      LDI	R16,0x18
    1692 D036      RCALL	_mmcCommand
    1693 2F40      MOV	R20,R16
(0164) 	#ifdef MMC_DEBUG
(0165) 	//rprintf("MMC Write Block R1=0x%x\r\n", r1);
(0166) 	#endif
(0167) 	// check for valid response
(0168) 	if(r1 != 0x00)
    1694 2300      TST	R16
    1695 F009      BEQ	0x1697
(0169) 		return r1;
    1696 C02D      RJMP	0x16C4
(0170) 	// send dummy
(0171) 	spiTransferByte(0xFF);
    1697 EF0F      LDI	R16,0xFF
    1698 940E1807  CALL	_spiTransferByte
(0172) 	// send data start token
(0173) 	spiTransferByte(MMC_STARTBLOCK_WRITE);
    169A EF0E      LDI	R16,0xFE
    169B 940E1807  CALL	_spiTransferByte
(0174) 	// write data
(0175) 	for(i=0; i<0x200; i++)
    169D 2766      CLR	R22
    169E 2777      CLR	R23
    169F C006      RJMP	0x16A6
(0176) 	{
(0177) 		spiTransferByte(*buffer);   //为了节省空间，只写入buffer[0]的数据，若写入512个不同数据，改为*buffer++
    16A0 01F5      MOVW	R30,R10
    16A1 8100      LDD	R16,Z+0
    16A2 940E1807  CALL	_spiTransferByte
    16A4 5F6F      SUBI	R22,0xFF
    16A5 4F7F      SBCI	R23,0xFF
    16A6 3060      CPI	R22,0
    16A7 E0E2      LDI	R30,2
    16A8 077E      CPC	R23,R30
    16A9 F3B0      BCS	0x16A0
(0178) 	}
(0179) 	// write 16-bit CRC (dummy values)
(0180) 	spiTransferByte(0xFF);
    16AA EF0F      LDI	R16,0xFF
    16AB 940E1807  CALL	_spiTransferByte
(0181) 	spiTransferByte(0xFF);
    16AD EF0F      LDI	R16,0xFF
    16AE 940E1807  CALL	_spiTransferByte
(0182) 	// read data response token
(0183) 	r1 = spiTransferByte(0xFF);
    16B0 EF0F      LDI	R16,0xFF
    16B1 940E1807  CALL	_spiTransferByte
    16B3 2F40      MOV	R20,R16
(0184) 	if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
    16B4 2F84      MOV	R24,R20
    16B5 718F      ANDI	R24,0x1F
    16B6 3085      CPI	R24,5
    16B7 F009      BEQ	0x16B9
(0185) 		return r1;
    16B8 C00B      RJMP	0x16C4
(0186) 	#ifdef MMC_DEBUG
(0187) 	//rprintf("Data Response Token=0x%x\r\n", r1);
(0188) 	#endif
(0189) 	// wait until card not busy
(0190) 	while(!spiTransferByte(0xFF));
    16B9 EF0F      LDI	R16,0xFF
    16BA 940E1807  CALL	_spiTransferByte
    16BC 2300      TST	R16
    16BD F3D9      BEQ	0x16B9
(0191) 	// release chip select
(0192) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    16BE 91800065  LDS	R24,0x65
    16C0 6088      ORI	R24,0x8
    16C1 93800065  STS	0x65,R24
(0193) 	// return success
(0194) 	return 0;
    16C3 2700      CLR	R16
    16C4 9622      ADIW	R28,2
    16C5 940E23C9  CALL	pop_gset3
    16C7 9624      ADIW	R28,4
    16C8 9508      RET
_mmcCommand:
  retry                --> R20
  r1                   --> R22
  arg                  --> Y+6
  cmd                  --> R10
    16C9 933A      ST	R19,-Y
    16CA 932A      ST	R18,-Y
    16CB 940E23D6  CALL	push_gset3
    16CD 2EA0      MOV	R10,R16
(0195) }
(0196) 
(0197) //***********************************************************************
(0198) //			单命令传送函数
(0199) //***********************************************************************
(0200) u08 mmcCommand(u08 cmd, u32 arg)
(0201) {
(0202) 	u08 r1;
(0203) 	u08 retry=0;
    16CE 2744      CLR	R20
(0204) 	// send command
(0205) 	spiTransferByte(cmd | 0x40);
    16CF 2D0A      MOV	R16,R10
    16D0 6400      ORI	R16,0x40
    16D1 940E1807  CALL	_spiTransferByte
(0206) 	spiTransferByte(arg>>24);
    16D3 E188      LDI	R24,0x18
    16D4 E090      LDI	R25,0
    16D5 01FE      MOVW	R30,R28
    16D6 8026      LDD	R2,Z+6
    16D7 8037      LDD	R3,Z+7
    16D8 8440      LDD	R4,Z+8
    16D9 8451      LDD	R5,Z+9
    16DA 938A      ST	R24,-Y
    16DB 0181      MOVW	R16,R2
    16DC 0192      MOVW	R18,R4
    16DD 940E243B  CALL	lsr32
    16DF 940E1807  CALL	_spiTransferByte
(0207) 	spiTransferByte(arg>>16);
    16E1 01FE      MOVW	R30,R28
    16E2 8026      LDD	R2,Z+6
    16E3 8037      LDD	R3,Z+7
    16E4 8440      LDD	R4,Z+8
    16E5 8451      LDD	R5,Z+9
    16E6 0112      MOVW	R2,R4
    16E7 2444      CLR	R4
    16E8 2455      CLR	R5
    16E9 2D02      MOV	R16,R2
    16EA 940E1807  CALL	_spiTransferByte
(0208) 	spiTransferByte(arg>>8);
    16EC E088      LDI	R24,0x8
    16ED E090      LDI	R25,0
    16EE 01FE      MOVW	R30,R28
    16EF 8026      LDD	R2,Z+6
    16F0 8037      LDD	R3,Z+7
    16F1 8440      LDD	R4,Z+8
    16F2 8451      LDD	R5,Z+9
    16F3 938A      ST	R24,-Y
    16F4 0181      MOVW	R16,R2
    16F5 0192      MOVW	R18,R4
    16F6 940E243B  CALL	lsr32
    16F8 940E1807  CALL	_spiTransferByte
(0209) 	spiTransferByte(arg);
    16FA 01FE      MOVW	R30,R28
    16FB 8106      LDD	R16,Z+6
    16FC 940E1807  CALL	_spiTransferByte
(0210) 	spiTransferByte(0x95);	// crc valid only for MMC_GO_IDLE_STATE
    16FE E905      LDI	R16,0x95
    16FF 940E1807  CALL	_spiTransferByte
    1701 C007      RJMP	0x1709
(0211) 	// end command
(0212) 	// wait for response
(0213) 	// if more than 8 retries, card has timed-out
(0214) 	// return the received 0xFF
(0215) 	while((r1 = spiTransferByte(0xFF)) == 0xFF)
(0216) 		if(retry++ > 8) break;
    1702 2E24      MOV	R2,R20
    1703 2433      CLR	R3
    1704 5F4F      SUBI	R20,0xFF
    1705 E088      LDI	R24,0x8
    1706 1582      CP	R24,R2
    1707 F408      BCC	0x1709
    1708 C006      RJMP	0x170F
    1709 EF0F      LDI	R16,0xFF
    170A 940E1807  CALL	_spiTransferByte
    170C 2F60      MOV	R22,R16
    170D 3F6F      CPI	R22,0xFF
    170E F399      BEQ	0x1702
(0217) 	// return response
(0218) 	return r1;
    170F 2F06      MOV	R16,R22
    1710 940E23C9  CALL	pop_gset3
    1712 9622      ADIW	R28,2
    1713 9508      RET
_mmcCapacity:
  Capacity             --> Y+18
  retry                --> Y+22
  buffer               --> Y+2
  temp                 --> R12
  r1                   --> R14
  i                    --> R10
    1714 940E23D2  CALL	push_gset5
    1716 9768      SBIW	R28,0x18
(0219) }
(0220) 
(0221) //***********************************************************************
(0222) //			SD卡容量读取函数，返回容量数
(0223) //***********************************************************************
(0224) 
(0225) u32 mmcCapacity()
(0226) {
(0227) 	u08 r1;
(0228) 	u16 i;
(0229) 	u16 temp;
(0230) 	u08 buffer[16];
(0231) 	u32 Capacity;
(0232) 	u16 retry =0;
    1717 2400      CLR	R0
    1718 2411      CLR	R1
    1719 8A1F      STD	Y+23,R1
    171A 8A0E      STD	Y+22,R0
(0233) 
(0234) 	r1 = mmcSendCommand(9, 0);						//写命令	
    171B E040      LDI	R20,0
    171C E050      LDI	R21,0
    171D E060      LDI	R22,0
    171E E070      LDI	R23,0
    171F 8368      STD	Y+0,R22
    1720 8379      STD	Y+1,R23
    1721 019A      MOVW	R18,R20
    1722 E009      LDI	R16,0x9
    1723 DEE0      RCALL	_mmcSendCommand
    1724 2EE0      MOV	R14,R16
(0235) 	if(r1 != 0x00)
    1725 2300      TST	R16
    1726 F039      BEQ	0x172E
(0236) 		return r1;
    1727 2C2E      MOV	R2,R14
    1728 2433      CLR	R3
    1729 2444      CLR	R4
    172A 2455      CLR	R5
    172B 0181      MOVW	R16,R2
    172C 0192      MOVW	R18,R4
    172D C0C1      RJMP	0x17EF
(0237) 
(0238) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    172E 91800065  LDS	R24,0x65
    1730 7F87      ANDI	R24,0xF7
    1731 93800065  STS	0x65,R24
    1733 C015      RJMP	0x1749
(0239) 	while(spiTransferByte(0xff) != 0xfe)if(retry++ > 0xfffe){sbi(MMC_CS_PORT,MMC_CS_PIN);return 1;}
    1734 882E      LDD	R2,Y+22
    1735 883F      LDD	R3,Y+23
    1736 01C1      MOVW	R24,R2
    1737 9601      ADIW	R24,1
    1738 8B9F      STD	Y+23,R25
    1739 8B8E      STD	Y+22,R24
    173A EF8E      LDI	R24,0xFE
    173B EF9F      LDI	R25,0xFF
    173C 1582      CP	R24,R2
    173D 0593      CPC	R25,R3
    173E F450      BCC	0x1749
    173F 91800065  LDS	R24,0x65
    1741 6088      ORI	R24,0x8
    1742 93800065  STS	0x65,R24
    1744 E001      LDI	R16,1
    1745 E010      LDI	R17,0
    1746 E020      LDI	R18,0
    1747 E030      LDI	R19,0
    1748 C0A6      RJMP	0x17EF
    1749 EF0F      LDI	R16,0xFF
    174A 940E1807  CALL	_spiTransferByte
    174C 3F0E      CPI	R16,0xFE
    174D F731      BNE	0x1734
(0240) 
(0241) 	
(0242) 	for(i=0;i<16;i++)
    174E 24AA      CLR	R10
    174F 24BB      CLR	R11
    1750 C00C      RJMP	0x175D
(0243) 	{
(0244) 		buffer[i]=spiTransferByte(0xff);
    1751 EF0F      LDI	R16,0xFF
    1752 940E1807  CALL	_spiTransferByte
    1754 01CE      MOVW	R24,R28
    1755 9602      ADIW	R24,2
    1756 01F5      MOVW	R30,R10
    1757 0FE8      ADD	R30,R24
    1758 1FF9      ADC	R31,R25
    1759 8300      STD	Z+0,R16
    175A 01C5      MOVW	R24,R10
    175B 9601      ADIW	R24,1
    175C 015C      MOVW	R10,R24
    175D 01C5      MOVW	R24,R10
    175E 3180      CPI	R24,0x10
    175F E0E0      LDI	R30,0
    1760 079E      CPC	R25,R30
    1761 F378      BCS	0x1751
(0245) 	}	
(0246) 
(0247) 	spiTransferByte(0xff);
    1762 EF0F      LDI	R16,0xFF
    1763 940E1807  CALL	_spiTransferByte
(0248) 	spiTransferByte(0xff);
    1765 EF0F      LDI	R16,0xFF
    1766 940E1807  CALL	_spiTransferByte
(0249) 	
(0250) 	spiTransferByte(0xff);
    1768 EF0F      LDI	R16,0xFF
    1769 940E1807  CALL	_spiTransferByte
(0251) 	
(0252) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    176B 91800065  LDS	R24,0x65
    176D 6088      ORI	R24,0x8
    176E 93800065  STS	0x65,R24
(0253) 
(0254) 	spiTransferByte(0xff);// extra 8 CLK
    1770 EF0F      LDI	R16,0xFF
    1771 940E1807  CALL	_spiTransferByte
(0255) 
(0256) /*********************************/
(0257) //	C_SIZE
(0258) 	i = buffer[6]&0x03;
    1773 8588      LDD	R24,Y+8
    1774 2799      CLR	R25
    1775 7083      ANDI	R24,3
    1776 7090      ANDI	R25,0
    1777 015C      MOVW	R10,R24
(0259) 	i<<=8;
    1778 2CBA      MOV	R11,R10
    1779 24AA      CLR	R10
(0260) 	i += buffer[7];
    177A 8429      LDD	R2,Y+9
    177B 2433      CLR	R3
    177C 0CA2      ADD	R10,R2
    177D 1CB3      ADC	R11,R3
(0261) 	i<<=2;
    177E 0CAA      LSL	R10
    177F 1CBB      ROL	R11
    1780 0CAA      LSL	R10
    1781 1CBB      ROL	R11
(0262) 	i += ((buffer[8]&0xc0)>>6);
    1782 E026      LDI	R18,6
    1783 E030      LDI	R19,0
    1784 850A      LDD	R16,Y+10
    1785 2711      CLR	R17
    1786 7C00      ANDI	R16,0xC0
    1787 7010      ANDI	R17,0
    1788 940E22D4  CALL	asr16
    178A 0EA0      ADD	R10,R16
    178B 1EB1      ADC	R11,R17
(0263) 
(0264) /**********************************/
(0265) //  C_SIZE_MULT
(0266) 
(0267) 	r1 = buffer[9]&0x03;
    178C 858B      LDD	R24,Y+11
    178D 7083      ANDI	R24,3
    178E 2EE8      MOV	R14,R24
(0268) 	r1<<=1;
    178F 0CEE      LSL	R14
(0269) 	r1 += ((buffer[10]&0x80)>>7);
    1790 858C      LDD	R24,Y+12
    1791 7880      ANDI	R24,0x80
    1792 9586      LSR	R24
    1793 9586      LSR	R24
    1794 9586      LSR	R24
    1795 9586      LSR	R24
    1796 9586      LSR	R24
    1797 9586      LSR	R24
    1798 9586      LSR	R24
    1799 0EE8      ADD	R14,R24
(0270) 
(0271) 
(0272) /**********************************/
(0273) // BLOCKNR
(0274) 
(0275) 	r1+=2;
    179A 2D8E      MOV	R24,R14
    179B 5F8E      SUBI	R24,0xFE
    179C 2EE8      MOV	R14,R24
(0276) 
(0277) 	temp = 1;
    179D E081      LDI	R24,1
    179E E090      LDI	R25,0
    179F 016C      MOVW	R12,R24
    17A0 C007      RJMP	0x17A8
(0278) 	while(r1)
(0279) 	{
(0280) 		temp*=2;
    17A1 E002      LDI	R16,2
    17A2 E010      LDI	R17,0
    17A3 0196      MOVW	R18,R12
    17A4 940E2386  CALL	empy16s
    17A6 0168      MOVW	R12,R16
(0281) 		r1--;
    17A7 94EA      DEC	R14
    17A8 20EE      TST	R14
    17A9 F7B9      BNE	0x17A1
(0282) 	}
(0283) 	
(0284) 	Capacity = ((u32)(i+1))*((u32)temp);
    17AA 0116      MOVW	R2,R12
    17AB 2444      CLR	R4
    17AC 2455      CLR	R5
    17AD 01C5      MOVW	R24,R10
    17AE 9601      ADIW	R24,1
    17AF 013C      MOVW	R6,R24
    17B0 2488      CLR	R8
    17B1 2499      CLR	R9
    17B2 925A      ST	R5,-Y
    17B3 924A      ST	R4,-Y
    17B4 923A      ST	R3,-Y
    17B5 922A      ST	R2,-Y
    17B6 0183      MOVW	R16,R6
    17B7 0194      MOVW	R18,R8
    17B8 940E2396  CALL	empy32s
    17BA 01FE      MOVW	R30,R28
    17BB 8B02      STD	Z+18,R16
    17BC 8B13      STD	Z+19,R17
    17BD 8B24      STD	Z+20,R18
    17BE 8B35      STD	Z+21,R19
(0285) 
(0286) 
(0287) // READ_BL_LEN
(0288) 
(0289) 	i = buffer[5]&0x0f;
    17BF 818F      LDD	R24,Y+7
    17C0 2799      CLR	R25
    17C1 708F      ANDI	R24,0xF
    17C2 7090      ANDI	R25,0
    17C3 015C      MOVW	R10,R24
(0290) 
(0291) 
(0292) //BLOCK_LEN
(0293) 
(0294) 	temp = 1;
    17C4 E081      LDI	R24,1
    17C5 E090      LDI	R25,0
    17C6 016C      MOVW	R12,R24
    17C7 C009      RJMP	0x17D1
(0295) 	while(i)
(0296) 	{
(0297) 		temp*=2;
    17C8 E002      LDI	R16,2
    17C9 E010      LDI	R17,0
    17CA 0196      MOVW	R18,R12
    17CB 940E2386  CALL	empy16s
    17CD 0168      MOVW	R12,R16
(0298) 		i--;
    17CE 01C5      MOVW	R24,R10
    17CF 9701      SBIW	R24,1
    17D0 015C      MOVW	R10,R24
    17D1 20AA      TST	R10
    17D2 F7A9      BNE	0x17C8
    17D3 20BB      TST	R11
    17D4 F799      BNE	0x17C8
(0299) 	}
(0300) 
(0301) 
(0302) //The final result
(0303) 	
(0304) 	Capacity *= (u32)temp;	 
    17D5 0116      MOVW	R2,R12
    17D6 2444      CLR	R4
    17D7 2455      CLR	R5
    17D8 01FE      MOVW	R30,R28
    17D9 8862      LDD	R6,Z+18
    17DA 8873      LDD	R7,Z+19
    17DB 8884      LDD	R8,Z+20
    17DC 8895      LDD	R9,Z+21
    17DD 925A      ST	R5,-Y
    17DE 924A      ST	R4,-Y
    17DF 923A      ST	R3,-Y
    17E0 922A      ST	R2,-Y
    17E1 0183      MOVW	R16,R6
    17E2 0194      MOVW	R18,R8
    17E3 940E2396  CALL	empy32s
    17E5 01FE      MOVW	R30,R28
    17E6 8B02      STD	Z+18,R16
    17E7 8B13      STD	Z+19,R17
    17E8 8B24      STD	Z+20,R18
    17E9 8B35      STD	Z+21,R19
(0305) 	return Capacity;		
    17EA 01FE      MOVW	R30,R28
    17EB 8902      LDD	R16,Z+18
    17EC 8913      LDD	R17,Z+19
    17ED 8924      LDD	R18,Z+20
    17EE 8935      LDD	R19,Z+21
    17EF 9668      ADIW	R28,0x18
    17F0 940E23CF  CALL	pop_gset5
    17F2 9508      RET
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\spi.c
(0001) //SPI接口驱动程序，采用开源的第三方库函数
(0002) //欣世纪电子略作修改
(0003) 
(0004) //#include <avr/io.h>
(0005) //#include <avr/interrupt.h>
(0006) 
(0007) #include "DM_spi.h"
(0008) #include <string.h>
(0009) #include <stdio.h>
(0010) //#include <delay.h>
(0011) #include <iom128v.h>
(0012) 
(0013) #define   set(x)                (1<<(x))
(0014) #define   sbi(temp,x)    		temp|=(1<<(x))
(0015) #define   clr(x)                (~(1<<(x)))
(0016) #define   cbi(temp,x)     		temp&=~(1<<(x))
(0017) 
(0018) #define	outb(addr, data)	addr = (data)
(0019) #define	inb(addr)			(addr)
(0020) #define	outw(addr, data)	addr = (data)
(0021) #define	inw(addr)			(addr)
(0022) 
(0023) 
(0024) volatile u08 spiTransferComplete;
(0025) 
(0026) // SPI interrupt service handler
(0027) #ifdef SPI_USEINT
(0028) SIGNAL(SIG_SPI)
(0029) {
(0030) 	spiTransferComplete = TRUE;
(0031) }
(0032) #endif
(0033) 
(0034) // access routines
(0035) void spiInit()
(0036) {
(0037) 	// setup SPI I/O pins
(0038) 	sbi(PORTB, 1);	// set SCK hi
_spiInit:
    17F3 9AC1      SBI	0x18,1
(0039) 	sbi(DDRB, 1);	// set SCK as output
    17F4 9AB9      SBI	0x17,1
(0040) 	cbi(DDRB, 3);	// set MISO as input
    17F5 98BB      CBI	0x17,3
(0041) 	sbi(DDRB, 2);	// set MOSI as output
    17F6 9ABA      SBI	0x17,2
(0042) 	sbi(DDRB, 0);	// SS must be output for Master mode to work
    17F7 9AB8      SBI	0x17,0
(0043) 	sbi(PORTB,0);   // set SS hi
    17F8 9AC0      SBI	0x18,0
(0044) 	
(0045) 	// setup SPI interface :
(0046) 	// master mode
(0047) 	sbi(SPCR, MSTR);
    17F9 9A6C      SBI	0x0D,4
(0048) 	// clock = f/4
(0049) //	cbi(SPCR, SPR0);
(0050) //	cbi(SPCR, SPR1);
(0051) 	// clock = f/16
(0052) 	cbi(SPCR, SPR0);
    17FA 9868      CBI	0x0D,0
(0053) 	sbi(SPCR, SPR1);
    17FB 9A69      SBI	0x0D,1
(0054) 	// select clock phase positive-going in middle of data
(0055) 	cbi(SPCR, CPOL);
    17FC 986B      CBI	0x0D,3
(0056) 	// Data order MSB first
(0057) 	cbi(SPCR,DORD);
    17FD 986D      CBI	0x0D,5
(0058) 	// enable SPI
(0059) 	sbi(SPCR, SPE);
    17FE 9A6E      SBI	0x0D,6
(0060) 		
(0061) 	
(0062) 	// some other possible configs
(0063) 	//outp((1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
(0064) 	//outp((1<<CPHA)|(1<<CPOL)|(1<<MSTR)|(1<<SPE)|(1<<SPR0)|(1<<SPR1), SPCR );
(0065) 	//outp((1<<CPHA)|(1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
(0066) 	
(0067) 	// clear status
(0068) 	inb(SPSR);
(0069) 	spiTransferComplete = TRUE;
    17FF EF8F      LDI	R24,0xFF
    1800 93800F1B  STS	spiTransferComplete,R24
    1802 9508      RET
(0070) 
(0071) 	// enable SPI interrupt
(0072) 	#ifdef SPI_USEINT
(0073) 	sbi(SPCR, SPIE);
(0074) 	#endif
(0075) }
(0076) /*
(0077) void spiSetBitrate(u08 spr)
(0078) {
(0079) 	outb(SPCR, (inb(SPCR) & ((1<<SPR0)|(1<<SPR1))) | (spr&((1<<SPR0)|(1<<SPR1)))));
(0080) }
(0081) */
(0082) void spiSendByte(u08 data)
(0083) {
(0084) 	// send a byte over SPI and ignore reply
(0085) 	#ifdef SPI_USEINT
(0086) 		while(!spiTransferComplete);
(0087) 		spiTransferComplete = FALSE;
(0088) 	#else
(0089) 		while(!(inb(SPSR) & (1<<SPIF)));
_spiSendByte:
  data                 --> R16
    1803 9B77      SBIS	0x0E,7
    1804 CFFE      RJMP	_spiSendByte
(0090) 	#endif
(0091) 
(0092) 	outb(SPDR, data);
    1805 B90F      OUT	0x0F,R16
    1806 9508      RET
(0093) }
(0094) 
(0095) u08 spiTransferByte(u08 data)
(0096) {
(0097) 	#ifdef SPI_USEINT
(0098) 	// send the given data
(0099) 	spiTransferComplete = FALSE;
(0100) 	outb(SPDR, data);
(0101) 	// wait for transfer to complete
(0102) 	while(!spiTransferComplete);
(0103) 	#else
(0104) 	// send the given data
(0105) 	outb(SPDR, data);
_spiTransferByte:
  data                 --> R16
    1807 B90F      OUT	0x0F,R16
(0106) 	// wait for transfer to complete
(0107) 	while(!(inb(SPSR) & (1<<SPIF)));
    1808 9B77      SBIS	0x0E,7
    1809 CFFE      RJMP	0x1808
(0108) 	#endif
(0109) 	// return the received data
(0110) 	return inb(SPDR);
    180A B10F      IN	R16,0x0F
    180B 9508      RET
_spiTransferWord:
  rxData               --> R20
  data                 --> R22
    180C 940E23D8  CALL	push_gset2
    180E 01B8      MOVW	R22,R16
(0111) }
(0112) 
(0113) u16 spiTransferWord(u16 data)
(0114) {
(0115) 	u16 rxData = 0;
    180F 2744      CLR	R20
    1810 2755      CLR	R21
(0116) 
(0117) 	// send MS byte of given data
(0118) 	rxData = (spiTransferByte((data>>8) & 0x00FF))<<8;
    1811 018B      MOVW	R16,R22
    1812 2F01      MOV	R16,R17
    1813 2711      CLR	R17
    1814 7010      ANDI	R17,0
    1815 DFF1      RCALL	_spiTransferByte
    1816 2F40      MOV	R20,R16
    1817 2755      CLR	R21
    1818 2F54      MOV	R21,R20
    1819 2744      CLR	R20
(0119) 	// send LS byte of given data
(0120) 	rxData |= (spiTransferByte(data & 0x00FF));
    181A 2F06      MOV	R16,R22
    181B 7010      ANDI	R17,0
    181C DFEA      RCALL	_spiTransferByte
    181D 2E20      MOV	R2,R16
    181E 2433      CLR	R3
    181F 2942      OR	R20,R2
    1820 2953      OR	R21,R3
(0121) 
(0122) 	// return the received data
(0123) 	return rxData;
    1821 018A      MOVW	R16,R20
    1822 940E23C6  CALL	pop_gset2
    1824 9508      RET
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\TFT.c
(0001) //TFT液晶读写相关函数及初始化函数等
(0002) //相关头文件 TFT.h
(0003) 
(0004) 
(0005) #include  <BMP_TFT.h>
(0006) 
(0007) 
(0008) uint color[]={0xf800,0x07e0,0x001f,0xffe0,0x0000,0xffff,0x07ff,0xf81f}; //八种颜色代码
(0009) //unsigned char RamVar_1[512];            				//定义无符号整型变量(Ram变量)
(0010) 
(0011) //***********************************************************************
(0012) //	  IO口初始化
(0013) //***********************************************************************
(0014) 
(0015) void McuInit()
(0016) {
(0017) 	LCD_Data=0xFF;                     //各相关IO口初始化
_McuInit:
    1825 EF8F      LDI	R24,0xFF
    1826 BB8B      OUT	0x1B,R24
(0018) 	DDR_Data=0xFF;
    1827 BB8A      OUT	0x1A,R24
(0019) 
(0020) 	PORTF=0xFF;
    1828 93800062  STS	0x62,R24
(0021) 	DDRF=0xFF;
    182A 93800061  STS	0x61,R24
(0022) 
(0023) 	PORTG=0x0F;                        
    182C E08F      LDI	R24,0xF
    182D 93800065  STS	0x65,R24
(0024) 	DDRG=0x0F;
    182F 93800064  STS	0x64,R24
(0025) 
(0026) 	PORTD=0xFF;
    1831 EF8F      LDI	R24,0xFF
    1832 BB82      OUT	0x12,R24
(0027) 	DDRD=0xFF;
    1833 BB81      OUT	0x11,R24
(0028)   	
(0029) 	D_LE1;                             //关掉数码管，以免显示乱码，因为共用PA口                   
    1834 9A94      SBI	0x12,4
(0030)     W_LE1;                     
    1835 9A95      SBI	0x12,5
(0031)     LCD_Data=0xFF;                      //关所有数码管            
    1836 BB8B      OUT	0x1B,R24
(0032)     W_LE0; 
    1837 9895      CBI	0x12,5
(0033) 
(0034)     PORTB=0xFF;
    1838 BB88      OUT	0x18,R24
(0035) 	DDRB=0xFF;
    1839 BB87      OUT	0x17,R24
(0036) 
(0037) 	LCD_BL0;
    183A 91800065  LDS	R24,0x65
    183C 7F8B      ANDI	R24,0xFB
    183D 93800065  STS	0x65,R24
    183F 9508      RET
(0038) 
(0039) 
(0040) }
(0041) 
(0042) 
(0043) //***********************************************************************
(0044) //	   写寻址寄存器地址，厂家规定0x22
(0045) //***********************************************************************
(0046) 
(0047) void LCD_WR_REG(uchar index)           
(0048) {
(0049) 	LCD_RS0;                            //根据控制器datasheet，RS为0时，为写寄存器地址
_LCD_WR_REG:
  index                --> R16
    1840 91800062  LDS	R24,0x62
    1842 7F8D      ANDI	R24,0xFD
    1843 93800062  STS	0x62,R24
(0050) 	LCD_EC0;
    1845 91800062  LDS	R24,0x62
    1847 7F87      ANDI	R24,0xF7
    1848 93800062  STS	0x62,R24
(0051) 	LCD_Data = 0x00;
    184A 2422      CLR	R2
    184B BA2B      OUT	0x1B,R2
(0052) 	LCD_WR0;
    184C 91800062  LDS	R24,0x62
    184E 7F8B      ANDI	R24,0xFB
    184F 93800062  STS	0x62,R24
(0053) 	LCD_WR1;
    1851 91800062  LDS	R24,0x62
    1853 6084      ORI	R24,4
    1854 93800062  STS	0x62,R24
(0054) 	LCD_Data = index;
    1856 BB0B      OUT	0x1B,R16
(0055) 	LCD_WR0;
    1857 91800062  LDS	R24,0x62
    1859 7F8B      ANDI	R24,0xFB
    185A 93800062  STS	0x62,R24
(0056) 	LCD_WR1;
    185C 91800062  LDS	R24,0x62
    185E 6084      ORI	R24,4
    185F 93800062  STS	0x62,R24
(0057) 	LCD_EC1;
    1861 91800062  LDS	R24,0x62
    1863 6088      ORI	R24,0x8
    1864 93800062  STS	0x62,R24
(0058) 	LCD_RS0;
    1866 91800062  LDS	R24,0x62
    1868 7F8D      ANDI	R24,0xFD
    1869 93800062  STS	0x62,R24
    186B 9508      RET
_LCD_RD_REG16:
  pd                   --> R20
  index                --> R20
    186C 940E23DA  CALL	push_gset1
    186E 2F40      MOV	R20,R16
(0059) }
(0060) 
(0061) //***********************************************************************
(0062) //	   读数据，从GRAM中读取，第一个字节无效，从第二个字节开始读取
(0063) //***********************************************************************
(0064) 
(0065) unsigned int LCD_RD_REG16(uchar index)
(0066) {
(0067) 	unsigned int pd;
(0068) 
(0069) 	LCD_RS0;
    186F 91800062  LDS	R24,0x62
    1871 7F8D      ANDI	R24,0xFD
    1872 93800062  STS	0x62,R24
(0070) 	LCD_EC0;
    1874 91800062  LDS	R24,0x62
    1876 7F87      ANDI	R24,0xF7
    1877 93800062  STS	0x62,R24
(0071) 	
(0072) 	delay_3us();
    1879 940E07E3  CALL	_delay_3us
(0073) 	
(0074) 	LCD_Data = 0x00;
    187B 2422      CLR	R2
    187C BA2B      OUT	0x1B,R2
(0075) 	delay_3us();
    187D 940E07E3  CALL	_delay_3us
(0076) 
(0077) 	LCD_WR0;
    187F 91800062  LDS	R24,0x62
    1881 7F8B      ANDI	R24,0xFB
    1882 93800062  STS	0x62,R24
(0078) 	delay_3us();
    1884 940E07E3  CALL	_delay_3us
(0079) 
(0080) 	LCD_WR1;
    1886 91800062  LDS	R24,0x62
    1888 6084      ORI	R24,4
    1889 93800062  STS	0x62,R24
(0081) 	delay_3us();
    188B 940E07E3  CALL	_delay_3us
(0082) 
(0083) 	LCD_Data = index;
    188D BB4B      OUT	0x1B,R20
(0084) 	delay_3us();
    188E 940E07E3  CALL	_delay_3us
(0085) 
(0086) 	LCD_WR0;
    1890 91800062  LDS	R24,0x62
    1892 7F8B      ANDI	R24,0xFB
    1893 93800062  STS	0x62,R24
(0087) 	delay_3us();
    1895 940E07E3  CALL	_delay_3us
(0088) 
(0089) 	LCD_WR1;
    1897 91800062  LDS	R24,0x62
    1899 6084      ORI	R24,4
    189A 93800062  STS	0x62,R24
(0090) 	delay_3us();
    189C 940E07E3  CALL	_delay_3us
(0091) 
(0092) 	LCD_RS1;
    189E 91800062  LDS	R24,0x62
    18A0 6082      ORI	R24,2
    18A1 93800062  STS	0x62,R24
(0093) 	delay_3us();
    18A3 940E07E3  CALL	_delay_3us
(0094) 
(0095) 	LCD_Data = 0xFF;
    18A5 EF8F      LDI	R24,0xFF
    18A6 BB8B      OUT	0x1B,R24
(0096) 	delay_3us();
    18A7 940E07E3  CALL	_delay_3us
(0097) 
(0098) 	LCD_RD0;
    18A9 91800065  LDS	R24,0x65
    18AB 7E8F      ANDI	R24,0xEF
    18AC 93800065  STS	0x65,R24
(0099) 	delay_3us();
    18AE 940E07E3  CALL	_delay_3us
(0100) 
(0101)     //DDR_IN;  //数据输入
(0102) 	delay_3us();
    18B0 940E07E3  CALL	_delay_3us
(0103) 
(0104) 	LCD_RD1;
    18B2 91800065  LDS	R24,0x65
    18B4 6180      ORI	R24,0x10
    18B5 93800065  STS	0x65,R24
(0105) 	pd = LCD_Data;
    18B7 B34B      IN	R20,0x1B
    18B8 2755      CLR	R21
(0106) 	delay_3us();
    18B9 940E07E3  CALL	_delay_3us
(0107) 
(0108) 	LCD_Data = 0xFF;
    18BB EF8F      LDI	R24,0xFF
    18BC BB8B      OUT	0x1B,R24
(0109) 	LCD_RD0;
    18BD 91800065  LDS	R24,0x65
    18BF 7E8F      ANDI	R24,0xEF
    18C0 93800065  STS	0x65,R24
(0110) 	delay_3us();
    18C2 940E07E3  CALL	_delay_3us
(0111) 
(0112) 	LCD_RD1;
    18C4 91800065  LDS	R24,0x65
    18C6 6180      ORI	R24,0x10
    18C7 93800065  STS	0x65,R24
(0113) 	pd = pd + LCD_Data*256;
    18C9 B32B      IN	R18,0x1B
    18CA 2733      CLR	R19
    18CB E000      LDI	R16,0
    18CC E011      LDI	R17,1
    18CD 940E2386  CALL	empy16s
    18CF 0F40      ADD	R20,R16
    18D0 1F51      ADC	R21,R17
(0114) 	LCD_EC1;
    18D1 91800062  LDS	R24,0x62
    18D3 6088      ORI	R24,0x8
    18D4 93800062  STS	0x62,R24
(0115) 	LCD_RS0;
    18D6 91800062  LDS	R24,0x62
    18D8 7F8D      ANDI	R24,0xFD
    18D9 93800062  STS	0x62,R24
(0116) 	return pd;
    18DB 018A      MOVW	R16,R20
    18DC 940E23DD  CALL	pop_gset1
    18DE 9508      RET
(0117) }
(0118) 
(0119) //***********************************************************************
(0120) //	   写控制命令，index为寄存器地址，val为控制命令，16位长度
(0121) //***********************************************************************
(0122) 
(0123) void LCD_WR_CMD(uchar index,uint val)
(0124) {
(0125) 	LCD_RS0;
_LCD_WR_CMD:
  val                  --> R18
  index                --> R16
    18DF 91800062  LDS	R24,0x62
    18E1 7F8D      ANDI	R24,0xFD
    18E2 93800062  STS	0x62,R24
(0126) 	LCD_EC0;
    18E4 91800062  LDS	R24,0x62
    18E6 7F87      ANDI	R24,0xF7
    18E7 93800062  STS	0x62,R24
(0127) 	LCD_Data = 0x00;
    18E9 2422      CLR	R2
    18EA BA2B      OUT	0x1B,R2
(0128) 	LCD_WR0;
    18EB 91800062  LDS	R24,0x62
    18ED 7F8B      ANDI	R24,0xFB
    18EE 93800062  STS	0x62,R24
(0129) 	LCD_WR1;
    18F0 91800062  LDS	R24,0x62
    18F2 6084      ORI	R24,4
    18F3 93800062  STS	0x62,R24
(0130) 	LCD_Data = index;
    18F5 BB0B      OUT	0x1B,R16
(0131) 	LCD_WR0;
    18F6 91800062  LDS	R24,0x62
    18F8 7F8B      ANDI	R24,0xFB
    18F9 93800062  STS	0x62,R24
(0132) 	LCD_WR1;
    18FB 91800062  LDS	R24,0x62
    18FD 6084      ORI	R24,4
    18FE 93800062  STS	0x62,R24
(0133) 	LCD_EC1;
    1900 91800062  LDS	R24,0x62
    1902 6088      ORI	R24,0x8
    1903 93800062  STS	0x62,R24
(0134) 	LCD_RS0;
    1905 91800062  LDS	R24,0x62
    1907 7F8D      ANDI	R24,0xFD
    1908 93800062  STS	0x62,R24
(0135) 
(0136) 	LCD_RS1;                             //根据控制器datasheet，RS为1时，为写控制命令或者数据到GRAM
    190A 91800062  LDS	R24,0x62
    190C 6082      ORI	R24,2
    190D 93800062  STS	0x62,R24
(0137) 	LCD_EC0;
    190F 91800062  LDS	R24,0x62
    1911 7F87      ANDI	R24,0xF7
    1912 93800062  STS	0x62,R24
(0138) 	LCD_Data = (uchar)(val>>8);
    1914 0119      MOVW	R2,R18
    1915 2C23      MOV	R2,R3
    1916 2433      CLR	R3
    1917 BA2B      OUT	0x1B,R2
(0139) 	LCD_WR0;
    1918 91800062  LDS	R24,0x62
    191A 7F8B      ANDI	R24,0xFB
    191B 93800062  STS	0x62,R24
(0140) 	LCD_WR1;
    191D 91800062  LDS	R24,0x62
    191F 6084      ORI	R24,4
    1920 93800062  STS	0x62,R24
(0141) 	LCD_EC1;
    1922 91800062  LDS	R24,0x62
    1924 6088      ORI	R24,0x8
    1925 93800062  STS	0x62,R24
(0142) 	LCD_RS0;
    1927 91800062  LDS	R24,0x62
    1929 7F8D      ANDI	R24,0xFD
    192A 93800062  STS	0x62,R24
(0143) 	LCD_RS1;
    192C 91800062  LDS	R24,0x62
    192E 6082      ORI	R24,2
    192F 93800062  STS	0x62,R24
(0144) 	LCD_EC0;
    1931 91800062  LDS	R24,0x62
    1933 7F87      ANDI	R24,0xF7
    1934 93800062  STS	0x62,R24
(0145) 	LCD_Data = (uchar)val;
    1936 BB2B      OUT	0x1B,R18
(0146) 	LCD_WR0;
    1937 91800062  LDS	R24,0x62
    1939 7F8B      ANDI	R24,0xFB
    193A 93800062  STS	0x62,R24
(0147) 	LCD_WR1;
    193C 91800062  LDS	R24,0x62
    193E 6084      ORI	R24,4
    193F 93800062  STS	0x62,R24
(0148) 	LCD_EC1;
    1941 91800062  LDS	R24,0x62
    1943 6088      ORI	R24,0x8
    1944 93800062  STS	0x62,R24
(0149) 	LCD_RS0;
    1946 91800062  LDS	R24,0x62
    1948 7F8D      ANDI	R24,0xFD
    1949 93800062  STS	0x62,R24
    194B 9508      RET
(0150) }
(0151) 
(0152) //***********************************************************************
(0153) //	   向GRAM存储器写数据，用来显示，定义为16位指针调用
(0154) //***********************************************************************
(0155) 
(0156) void LCD_WR_Data(uint val)
(0157) {
(0158) 
(0159) 
(0160) 	LCD_Data = (uchar)(val>>8);
_LCD_WR_Data:
  val                  --> R16
    194C 0118      MOVW	R2,R16
    194D 2C23      MOV	R2,R3
    194E 2433      CLR	R3
    194F BA2B      OUT	0x1B,R2
(0161) 	LCD_WR0;
    1950 91800062  LDS	R24,0x62
    1952 7F8B      ANDI	R24,0xFB
    1953 93800062  STS	0x62,R24
(0162) 	LCD_WR1;
    1955 91800062  LDS	R24,0x62
    1957 6084      ORI	R24,4
    1958 93800062  STS	0x62,R24
(0163) 	//LCD_RS1;
(0164) 	LCD_Data = (uchar)val;
    195A BB0B      OUT	0x1B,R16
(0165) 	LCD_WR0;
    195B 91800062  LDS	R24,0x62
    195D 7F8B      ANDI	R24,0xFB
    195E 93800062  STS	0x62,R24
(0166) 	LCD_WR1;
    1960 91800062  LDS	R24,0x62
    1962 6084      ORI	R24,4
    1963 93800062  STS	0x62,R24
    1965 9508      RET
(0167) 
(0168) }
(0169) 
(0170) //***********************************************************************
(0171) //	   向GRAM存储器写数据，用来显示，定义为8位指针调用
(0172) //***********************************************************************
(0173) void LCD_WR_DataP(uint val)
(0174) {
(0175) 
(0176) 	LCD_Data = (uchar)val;
_LCD_WR_DataP:
  val                  --> R16
    1966 BB0B      OUT	0x1B,R16
(0177) 	LCD_WR0;
    1967 91800062  LDS	R24,0x62
    1969 7F8B      ANDI	R24,0xFB
    196A 93800062  STS	0x62,R24
(0178) 	LCD_WR1;
    196C 91800062  LDS	R24,0x62
    196E 6084      ORI	R24,4
    196F 93800062  STS	0x62,R24
    1971 9508      RET
(0179) }
(0180) 
(0181) 
(0182) void LCD_Init()
(0183) {
(0184) 	LCD_RST0;                      //复位有效，至少2ms
_LCD_Init:
    1972 9897      CBI	0x12,7
(0185) 	delay_nms(10);
    1973 E00A      LDI	R16,0xA
    1974 E010      LDI	R17,0
    1975 940E081D  CALL	_delay_nms
(0186) 	LCD_RST1;                      //复位结束
    1977 9A97      SBI	0x12,7
(0187) 	delay_nms(10);
    1978 E00A      LDI	R16,0xA
    1979 E010      LDI	R17,0
    197A 940E081D  CALL	_delay_nms
(0188) 
(0189)     LCD_WR_CMD(0x00,0x0001);		//启动晶振，必须有至少10ms的延时，保证稳定
    197C E021      LDI	R18,1
    197D E030      LDI	R19,0
    197E 2700      CLR	R16
    197F DF5F      RCALL	_LCD_WR_CMD
(0190)     delay_nms(10);
    1980 E00A      LDI	R16,0xA
    1981 E010      LDI	R17,0
    1982 940E081D  CALL	_delay_nms
(0191)     LCD_WR_CMD(0x03,0x0030);        //设置数据扫描方向，由左至右，水平扫描
    1984 E320      LDI	R18,0x30
    1985 E030      LDI	R19,0
    1986 E003      LDI	R16,3
    1987 DF57      RCALL	_LCD_WR_CMD
(0192)     //LCD_WR_CMD(0x03,0x0230);      //HWM=1为高速数据模式
(0193)     LCD_WR_CMD(0x01,0x011D);
    1988 E12D      LDI	R18,0x1D
    1989 E031      LDI	R19,1
    198A E001      LDI	R16,1
    198B DF53      RCALL	_LCD_WR_CMD
(0194)     //delay_us(1000);
(0195)     LCD_WR_CMD(0x0a,0x0106); 
    198C E026      LDI	R18,6
    198D E031      LDI	R19,1
    198E E00A      LDI	R16,0xA
    198F DF4F      RCALL	_LCD_WR_CMD
(0196)     //delay_us(1000);
(0197)     LCD_WR_CMD(0x07,0x0037);        //非8位模式,开显示
    1990 E327      LDI	R18,0x37
    1991 E030      LDI	R19,0
    1992 E007      LDI	R16,7
    1993 DF4B      RCALL	_LCD_WR_CMD
(0198) 
(0199)     LCD_WR_CMD(0x08,0x0707);        //光栅周期数为7，若为0，则无显示，是为了保证足够的时间让光栅回到行左边
    1994 E027      LDI	R18,7
    1995 E037      LDI	R19,7
    1996 E008      LDI	R16,0x8
    1997 DF47      RCALL	_LCD_WR_CMD
(0200)     LCD_WR_CMD(0x0c,0x01);
    1998 E021      LDI	R18,1
    1999 E030      LDI	R19,0
    199A E00C      LDI	R16,0xC
    199B DF43      RCALL	_LCD_WR_CMD
(0201)     LCD_WR_CMD(0x02,0x0400);        //驱动波形控制指令
    199C E020      LDI	R18,0
    199D E034      LDI	R19,4
    199E E002      LDI	R16,2
    199F DF3F      RCALL	_LCD_WR_CMD
(0202)     //delay_us(1000);
(0203)     LCD_WR_CMD(0x0a,0x0107);        //门驱动和电源控制IC指令，后面要紧跟需要的指令
    19A0 E027      LDI	R18,7
    19A1 E031      LDI	R19,1
    19A2 E00A      LDI	R16,0xA
    19A3 DF3B      RCALL	_LCD_WR_CMD
(0204)  //   delay_us(1000);
(0205) 
(0206)     LCD_WR_CMD(0x12,0x0001);        //VciOUT = 3V × 0.83 = 2.49V
    19A4 E021      LDI	R18,1
    19A5 E030      LDI	R19,0
    19A6 E102      LDI	R16,0x12
    19A7 DF37      RCALL	_LCD_WR_CMD
(0207)     // only 100(=VCI), 000(.92 VCI),001(.83),010(.73VCI) is valid. other is inhibited
(0208)   //  delay_us(1000);
(0209)     LCD_WR_CMD(0x0a,0x0101); 
    19A8 E021      LDI	R18,1
    19A9 E031      LDI	R19,1
    19AA E00A      LDI	R16,0xA
    19AB DF33      RCALL	_LCD_WR_CMD
(0210)    // delay_us(1000);
(0211)    
(0212)    // LCD_WR_CMD(0x13,0x404);
(0213)    // delay_us(1);LCD_WR_CMD(0x0a,0x0101); delay_us(1);
(0214) 
(0215)     LCD_WR_CMD(0x11,0x0505);   //CAD=0
    19AC E025      LDI	R18,5
    19AD E035      LDI	R19,5
    19AE E101      LDI	R16,0x11
    19AF DF2F      RCALL	_LCD_WR_CMD
(0216)    // delay_us(1);LCD_WR_CMD(0x0a,0x0101); delay_us(1);
(0217) 
(0218) 
(0219) 
(0220)     LCD_WR_CMD(0x14,0x2c0f); // last 4 bit must be 1!!! vcomg = 1, 
    19B0 E02F      LDI	R18,0xF
    19B1 E23C      LDI	R19,0x2C
    19B2 E104      LDI	R16,0x14
    19B3 DF2B      RCALL	_LCD_WR_CMD
(0221)     // VDV4-0 == 09-0e,10-12 // other is inhibited.!!! 
(0222)     delay_3us();
    19B4 940E07E3  CALL	_delay_3us
(0223)     LCD_WR_CMD(0x0a,0x0102); 
    19B6 E022      LDI	R18,2
    19B7 E031      LDI	R19,1
    19B8 E00A      LDI	R16,0xA
    19B9 DF25      RCALL	_LCD_WR_CMD
(0224)    // delay_us(1);
(0225) 
(0226)     LCD_WR_CMD(0x10,0x1a10);// if Vci > 3.0V, use 0x1a10.
    19BA E120      LDI	R18,0x10
    19BB E13A      LDI	R19,0x1A
    19BC E100      LDI	R16,0x10
    19BD DF21      RCALL	_LCD_WR_CMD
(0227)     delay_3us();
    19BE 940E07E3  CALL	_delay_3us
(0228)     LCD_WR_CMD(0x0a,0x0100); 
    19C0 E020      LDI	R18,0
    19C1 E031      LDI	R19,1
    19C2 E00A      LDI	R16,0xA
    19C3 DF1B      RCALL	_LCD_WR_CMD
(0229)   //  delay_3us();
(0230) 
(0231)     LCD_WR_CMD(0x13,0x0616); //////////!!!!!!!!!!!!! VERY IMPORTANT!!!
    19C4 E126      LDI	R18,0x16
    19C5 E036      LDI	R19,6
    19C6 E103      LDI	R16,0x13
    19C7 DF17      RCALL	_LCD_WR_CMD
(0232)     //set VRH3-0 to fit REG1out= 3 to DDVDH-0.5
(0233)     delay_3us();
    19C8 940E07E3  CALL	_delay_3us
(0234)     LCD_WR_CMD(0x0a,0x0101); 
    19CA E021      LDI	R18,1
    19CB E031      LDI	R19,1
    19CC E00A      LDI	R16,0xA
    19CD DF11      RCALL	_LCD_WR_CMD
(0235)   //  delay_nms(1);
(0236) 
(0237)     LCD_WR_CMD(0x30,0x0003);
    19CE E023      LDI	R18,3
    19CF E030      LDI	R19,0
    19D0 E300      LDI	R16,0x30
    19D1 DF0D      RCALL	_LCD_WR_CMD
(0238)     LCD_WR_CMD(0x31,0x0404);
    19D2 E024      LDI	R18,4
    19D3 E034      LDI	R19,4
    19D4 E301      LDI	R16,0x31
    19D5 DF09      RCALL	_LCD_WR_CMD
(0239)     LCD_WR_CMD(0x32,0x0303);
    19D6 E023      LDI	R18,3
    19D7 E033      LDI	R19,3
    19D8 E302      LDI	R16,0x32
    19D9 DF05      RCALL	_LCD_WR_CMD
(0240)     LCD_WR_CMD(0x33,0x0406);
    19DA E026      LDI	R18,6
    19DB E034      LDI	R19,4
    19DC E303      LDI	R16,0x33
    19DD DF01      RCALL	_LCD_WR_CMD
(0241)     LCD_WR_CMD(0x34,0x0404);
    19DE E024      LDI	R18,4
    19DF E034      LDI	R19,4
    19E0 E304      LDI	R16,0x34
    19E1 DEFD      RCALL	_LCD_WR_CMD
(0242)     LCD_WR_CMD(0x35,0x0303);
    19E2 E023      LDI	R18,3
    19E3 E033      LDI	R19,3
    19E4 E305      LDI	R16,0x35
    19E5 DEF9      RCALL	_LCD_WR_CMD
(0243)     LCD_WR_CMD(0x36,0x0407);
    19E6 E027      LDI	R18,7
    19E7 E034      LDI	R19,4
    19E8 E306      LDI	R16,0x36
    19E9 DEF5      RCALL	_LCD_WR_CMD
(0244)     LCD_WR_CMD(0x37,0x0604);
    19EA E024      LDI	R18,4
    19EB E036      LDI	R19,6
    19EC E307      LDI	R16,0x37
    19ED DEF1      RCALL	_LCD_WR_CMD
(0245)     
(0246)     delay_3us();
    19EE 940E07E3  CALL	_delay_3us
(0247)   //  LCD_WR_CMD(0x0a,0x0100);
(0248)    // delay_nms(1); 
(0249)     
(0250)     //*********** SAP, AP set****************	
(0251)     LCD_WR_CMD(0x10,0x1a10);//BT2-0 Ok,and...
    19F0 E120      LDI	R18,0x10
    19F1 E13A      LDI	R19,0x1A
    19F2 E100      LDI	R16,0x10
    19F3 DEEB      RCALL	_LCD_WR_CMD
(0252)     delay_3us();
    19F4 940E07E3  CALL	_delay_3us
(0253)     LCD_WR_CMD(0x0a,0x0100); 
    19F6 E020      LDI	R18,0
    19F7 E031      LDI	R19,1
    19F8 E00A      LDI	R16,0xA
    19F9 DEE5      RCALL	_LCD_WR_CMD
(0254)   //  delay_us(100);	
(0255) 	//*********** PON  set********************
(0256) 	LCD_WR_CMD(0x13,0x0616); //////////
    19FA E126      LDI	R18,0x16
    19FB E036      LDI	R19,6
    19FC E103      LDI	R16,0x13
    19FD DEE1      RCALL	_LCD_WR_CMD
(0257)     
(0258)  //   delay_3us();
(0259)   //  LCD_WR_CMD(0x0a,0x0101); 
(0260)    // delay_us(100);
(0261)     
(0262)     //***********Display ON set*****************
(0263)    // LCD_WR_CMD(0x07,0x0037);
(0264)  //   delay_3us();
(0265)   // LCD_WR_CMD(0x0a,0x0100); 
(0266)     delay_n100us(1); 
    19FE E001      LDI	R16,1
    19FF E010      LDI	R17,0
    1A00 940E0805  CALL	_delay_n100us
    1A02 9508      RET
_LCD_clear:
  num                  --> R20
  p                    --> R22
    1A03 940E23D8  CALL	push_gset2
    1A05 01B8      MOVW	R22,R16
(0267)      
(0268) }
(0269) 
(0270) 
(0271) 
(0272) 
(0273) 
(0274) 
(0275) //***********************************************************************
(0276) //	   清屏子程序
(0277) //***********************************************************************
(0278) 
(0279) 
(0280) void LCD_clear(uint p)
(0281) {
(0282) 	uint num;
(0283) 	
(0284) 	LCD_WR_CMD(0x44,127*256+0);
    1A06 E020      LDI	R18,0
    1A07 E73F      LDI	R19,0x7F
    1A08 E404      LDI	R16,0x44
    1A09 DED5      RCALL	_LCD_WR_CMD
(0285) 	LCD_WR_CMD(0x45,239*256+80);
    1A0A E520      LDI	R18,0x50
    1A0B EE3F      LDI	R19,0xEF
    1A0C E405      LDI	R16,0x45
    1A0D DED1      RCALL	_LCD_WR_CMD
(0286) 	LCD_WR_CMD(0x21,80*256+0);	
    1A0E E020      LDI	R18,0
    1A0F E530      LDI	R19,0x50
    1A10 E201      LDI	R16,0x21
    1A11 DECD      RCALL	_LCD_WR_CMD
(0287) 	LCD_WR_REG(0x22);
    1A12 E202      LDI	R16,0x22
    1A13 DE2C      RCALL	_LCD_WR_REG
(0288) 	LCD_EC0;
    1A14 91800062  LDS	R24,0x62
    1A16 7F87      ANDI	R24,0xF7
    1A17 93800062  STS	0x62,R24
(0289) 	LCD_RS1;
    1A19 91800062  LDS	R24,0x62
    1A1B 6082      ORI	R24,2
    1A1C 93800062  STS	0x62,R24
(0290) 	for(num=160*128;num>0;num--)
    1A1E E040      LDI	R20,0
    1A1F E550      LDI	R21,0x50
    1A20 C004      RJMP	0x1A25
(0291) 	{
(0292) 		LCD_WR_Data(p);
    1A21 018B      MOVW	R16,R22
    1A22 DF29      RCALL	_LCD_WR_Data
    1A23 5041      SUBI	R20,1
    1A24 4050      SBCI	R21,0
    1A25 3040      CPI	R20,0
    1A26 0745      CPC	R20,R21
    1A27 F7C9      BNE	0x1A21
(0293) 	}
(0294) 	LCD_WR_CMD(0x44,95*256+0);
    1A28 E020      LDI	R18,0
    1A29 E53F      LDI	R19,0x5F
    1A2A E404      LDI	R16,0x44
    1A2B DEB3      RCALL	_LCD_WR_CMD
(0295) 	LCD_WR_CMD(0x45,79*256+16);
    1A2C E120      LDI	R18,0x10
    1A2D E43F      LDI	R19,0x4F
    1A2E E405      LDI	R16,0x45
    1A2F DEAF      RCALL	_LCD_WR_CMD
(0296) 	LCD_WR_CMD(0x21,16*256+0);	
    1A30 E020      LDI	R18,0
    1A31 E130      LDI	R19,0x10
    1A32 E201      LDI	R16,0x21
    1A33 DEAB      RCALL	_LCD_WR_CMD
(0297) 	LCD_WR_REG(0x22);
    1A34 E202      LDI	R16,0x22
    1A35 DE0A      RCALL	_LCD_WR_REG
(0298) 	LCD_EC0;
    1A36 91800062  LDS	R24,0x62
    1A38 7F87      ANDI	R24,0xF7
    1A39 93800062  STS	0x62,R24
(0299) 	LCD_RS1;
    1A3B 91800062  LDS	R24,0x62
    1A3D 6082      ORI	R24,2
    1A3E 93800062  STS	0x62,R24
(0300) 	for(num=64*96;num>0;num--)
    1A40 E040      LDI	R20,0
    1A41 E158      LDI	R21,0x18
    1A42 C004      RJMP	0x1A47
(0301) 	{
(0302) 		LCD_WR_Data(p);
    1A43 018B      MOVW	R16,R22
    1A44 DF07      RCALL	_LCD_WR_Data
    1A45 5041      SUBI	R20,1
    1A46 4050      SBCI	R21,0
    1A47 3040      CPI	R20,0
    1A48 0745      CPC	R20,R21
    1A49 F7C9      BNE	0x1A43
(0303) 	}
(0304) 	LCD_EC1;
    1A4A 91800062  LDS	R24,0x62
    1A4C 6088      ORI	R24,0x8
    1A4D 93800062  STS	0x62,R24
    1A4F 940E23C6  CALL	pop_gset2
    1A51 9508      RET
_DisplayChar:
  p                    --> R20
  j                    --> R22
  i                    --> R12
  b                    --> R14
  char_color           --> R10
  postion_y            --> Y+10
  postion_x            --> R20
  casc                 --> R22
    1A52 940E23D2  CALL	push_gset5
    1A54 2F42      MOV	R20,R18
    1A55 2F60      MOV	R22,R16
    1A56 84AC      LDD	R10,Y+12
    1A57 84BD      LDD	R11,Y+13
(0305) }
(0306) 
(0307) //***********************************************************************
(0308) //	   8X16点阵的字符显示函数
(0309) //	   casc:字符对应字模中的位置
(0310) //     x:显示位置第几列,每行是128/8 ==16列
(0311) //     y:显示位置第几行,整屏是160/16==10行
(0312) //     char_color:字体颜色
(0313) //***********************************************************************
(0314) 
(0315) void DisplayChar(uchar casc,uchar postion_x,uchar postion_y,uint char_color)
(0316) {
(0317) 
(0318) 	uchar i,j,b;
(0319) 	 
(0320) 	 uchar *p;
(0321) 	
(0322) 	
(0323) 	LCD_WR_CMD(0x44,(postion_x*8+7)*256+(postion_x*8));	            //x end point
    1A58 E088      LDI	R24,0x8
    1A59 9F84      MUL	R24,R20
    1A5A 0110      MOVW	R2,R0
    1A5B E000      LDI	R16,0
    1A5C E011      LDI	R17,1
    1A5D 0191      MOVW	R18,R2
    1A5E 940E2386  CALL	empy16s
    1A60 0198      MOVW	R18,R16
    1A61 5020      SUBI	R18,0
    1A62 4F39      SBCI	R19,0xF9
    1A63 0D22      ADD	R18,R2
    1A64 1D33      ADC	R19,R3
    1A65 E404      LDI	R16,0x44
    1A66 DE78      RCALL	_LCD_WR_CMD
(0324) 	LCD_WR_CMD(0x45,(postion_y*16+15+80)*256+(postion_y*16+80));	//y end point
    1A67 E180      LDI	R24,0x10
    1A68 840A      LDD	R0,Y+10
    1A69 9D80      MUL	R24,R0
    1A6A 0110      MOVW	R2,R0
    1A6B E000      LDI	R16,0
    1A6C E011      LDI	R17,1
    1A6D 0191      MOVW	R18,R2
    1A6E 940E2386  CALL	empy16s
    1A70 0198      MOVW	R18,R16
    1A71 5020      SUBI	R18,0
    1A72 4A31      SBCI	R19,0xA1
    1A73 01C1      MOVW	R24,R2
    1A74 5B80      SUBI	R24,0xB0
    1A75 4F9F      SBCI	R25,0xFF
    1A76 0F28      ADD	R18,R24
    1A77 1F39      ADC	R19,R25
    1A78 E405      LDI	R16,0x45
    1A79 DE65      RCALL	_LCD_WR_CMD
(0325) 	LCD_WR_CMD(0x21,(postion_y*16+80)*256+(postion_x*8));	
    1A7A E180      LDI	R24,0x10
    1A7B 840A      LDD	R0,Y+10
    1A7C 9D80      MUL	R24,R0
    1A7D 0190      MOVW	R18,R0
    1A7E E000      LDI	R16,0
    1A7F E011      LDI	R17,1
    1A80 940E2386  CALL	empy16s
    1A82 0198      MOVW	R18,R16
    1A83 5020      SUBI	R18,0
    1A84 4B30      SBCI	R19,0xB0
    1A85 E088      LDI	R24,0x8
    1A86 9F84      MUL	R24,R20
    1A87 0D20      ADD	R18,R0
    1A88 1D31      ADC	R19,R1
    1A89 E201      LDI	R16,0x21
    1A8A DE54      RCALL	_LCD_WR_CMD
(0326) 	LCD_WR_REG(0x22);
    1A8B E202      LDI	R16,0x22
    1A8C DDB3      RCALL	_LCD_WR_REG
(0327) 	LCD_EC0;
    1A8D 91800062  LDS	R24,0x62
    1A8F 7F87      ANDI	R24,0xF7
    1A90 93800062  STS	0x62,R24
(0328) 	LCD_RS1;
    1A92 91800062  LDS	R24,0x62
    1A94 6082      ORI	R24,2
    1A95 93800062  STS	0x62,R24
(0329) 	p=ascii;
    1A97 EE4A      LDI	R20,0xEA
    1A98 E052      LDI	R21,2
(0330) 	p+=casc*16;
    1A99 E180      LDI	R24,0x10
    1A9A 9F86      MUL	R24,R22
    1A9B 0D40      ADD	R20,R0
    1A9C 1D51      ADC	R21,R1
(0331) 	for(j=0;j<16;j++)
    1A9D 2766      CLR	R22
    1A9E C015      RJMP	0x1AB4
(0332) 	{
(0333) 		b=*(p+j);
    1A9F 2FE6      MOV	R30,R22
    1AA0 27FF      CLR	R31
    1AA1 0FE4      ADD	R30,R20
    1AA2 1FF5      ADC	R31,R21
    1AA3 80E0      LDD	R14,Z+0
(0334) 		for(i=0;i<8;i++)
    1AA4 24CC      CLR	R12
    1AA5 C00A      RJMP	0x1AB0
(0335) 		{
(0336) 			if(b&0x80)
    1AA6 FEE7      SBRS	R14,7
    1AA7 C003      RJMP	0x1AAB
(0337) 			{
(0338) 				LCD_WR_Data(char_color);                //字体颜色
    1AA8 0185      MOVW	R16,R10
    1AA9 DEA2      RCALL	_LCD_WR_Data
(0339) 			}
    1AAA C003      RJMP	0x1AAE
(0340) 			else
(0341) 			{
(0342) 				LCD_WR_Data(0x0000);       				//背景颜色
    1AAB 2700      CLR	R16
    1AAC 2711      CLR	R17
    1AAD DE9E      RCALL	_LCD_WR_Data
(0343) 			}
(0344) 			b=b<<1;
    1AAE 0CEE      LSL	R14
    1AAF 94C3      INC	R12
    1AB0 2D8C      MOV	R24,R12
    1AB1 3088      CPI	R24,0x8
    1AB2 F398      BCS	0x1AA6
    1AB3 9563      INC	R22
    1AB4 3160      CPI	R22,0x10
    1AB5 F348      BCS	0x1A9F
(0345) 			
(0346) 		}	
(0347) 	}
(0348) 	LCD_EC1;
    1AB6 91800062  LDS	R24,0x62
    1AB8 6088      ORI	R24,0x8
    1AB9 93800062  STS	0x62,R24
    1ABB 940E23CF  CALL	pop_gset5
    1ABD 9508      RET
_DisplayGB2312:
  p                    --> R20
  j                    --> R22
  i                    --> R12
  b                    --> R14
  gb_color             --> R10
  postion_y            --> Y+10
  postion_x            --> R20
  gb                   --> R22
    1ABE 940E23D2  CALL	push_gset5
    1AC0 2F42      MOV	R20,R18
    1AC1 2F60      MOV	R22,R16
    1AC2 84AC      LDD	R10,Y+12
    1AC3 84BD      LDD	R11,Y+13
(0349) }
(0350) //***********************************************************************
(0351) //        16X16点阵的汉字显示函数，字库可以自己提取
(0352) //		  gb:汉字对应字模中的位置
(0353) //         x:显示位置第几列
(0354) //         y:显示位置第几行
(0355) //		  color:字体颜色
(0356) //***********************************************************************
(0357) 
(0358) void DisplayGB2312(uchar gb,uchar postion_x,uchar postion_y,uint gb_color)
(0359) {
(0360) 
(0361) 	uchar i,j,b;
(0362) 	uchar *p;
(0363) 	
(0364) 	LCD_WR_CMD(0x44,(postion_x*16+15)*256+(postion_x*16));	        //x end point
    1AC4 E180      LDI	R24,0x10
    1AC5 9F84      MUL	R24,R20
    1AC6 0110      MOVW	R2,R0
    1AC7 E000      LDI	R16,0
    1AC8 E011      LDI	R17,1
    1AC9 0191      MOVW	R18,R2
    1ACA 940E2386  CALL	empy16s
    1ACC 0198      MOVW	R18,R16
    1ACD 5020      SUBI	R18,0
    1ACE 4F31      SBCI	R19,0xF1
    1ACF 0D22      ADD	R18,R2
    1AD0 1D33      ADC	R19,R3
    1AD1 E404      LDI	R16,0x44
    1AD2 DE0C      RCALL	_LCD_WR_CMD
(0365) 	LCD_WR_CMD(0x45,(postion_y*16+15+80)*256+(postion_y*16+80));	//y end point
    1AD3 E180      LDI	R24,0x10
    1AD4 840A      LDD	R0,Y+10
    1AD5 9D80      MUL	R24,R0
    1AD6 0110      MOVW	R2,R0
    1AD7 E000      LDI	R16,0
    1AD8 E011      LDI	R17,1
    1AD9 0191      MOVW	R18,R2
    1ADA 940E2386  CALL	empy16s
    1ADC 0198      MOVW	R18,R16
    1ADD 5020      SUBI	R18,0
    1ADE 4A31      SBCI	R19,0xA1
    1ADF 01C1      MOVW	R24,R2
    1AE0 5B80      SUBI	R24,0xB0
    1AE1 4F9F      SBCI	R25,0xFF
    1AE2 0F28      ADD	R18,R24
    1AE3 1F39      ADC	R19,R25
    1AE4 E405      LDI	R16,0x45
    1AE5 DDF9      RCALL	_LCD_WR_CMD
(0366) 	LCD_WR_CMD(0x21,(postion_y*16+80)*256+(postion_x*16));	
    1AE6 E180      LDI	R24,0x10
    1AE7 840A      LDD	R0,Y+10
    1AE8 9D80      MUL	R24,R0
    1AE9 0190      MOVW	R18,R0
    1AEA E000      LDI	R16,0
    1AEB E011      LDI	R17,1
    1AEC 940E2386  CALL	empy16s
    1AEE 0198      MOVW	R18,R16
    1AEF 5020      SUBI	R18,0
    1AF0 4B30      SBCI	R19,0xB0
    1AF1 E180      LDI	R24,0x10
    1AF2 9F84      MUL	R24,R20
    1AF3 0D20      ADD	R18,R0
    1AF4 1D31      ADC	R19,R1
    1AF5 E201      LDI	R16,0x21
    1AF6 DDE8      RCALL	_LCD_WR_CMD
(0367) 	LCD_WR_REG(0x22);
    1AF7 E202      LDI	R16,0x22
    1AF8 DD47      RCALL	_LCD_WR_REG
(0368) 	LCD_EC0;
    1AF9 91800062  LDS	R24,0x62
    1AFB 7F87      ANDI	R24,0xF7
    1AFC 93800062  STS	0x62,R24
(0369) 	LCD_RS1;
    1AFE 91800062  LDS	R24,0x62
    1B00 6082      ORI	R24,2
    1B01 93800062  STS	0x62,R24
(0370) 	p=GB2312;
    1B03 EE4A      LDI	R20,0xEA
    1B04 E05A      LDI	R21,0xA
(0371) 	p+=gb*32;
    1B05 E280      LDI	R24,0x20
    1B06 9F86      MUL	R24,R22
    1B07 0D40      ADD	R20,R0
    1B08 1D51      ADC	R21,R1
(0372) 	for(j=0;j<32;j++)
    1B09 2766      CLR	R22
    1B0A C015      RJMP	0x1B20
(0373) 	{
(0374) 		b=*(p+j);
    1B0B 2FE6      MOV	R30,R22
    1B0C 27FF      CLR	R31
    1B0D 0FE4      ADD	R30,R20
    1B0E 1FF5      ADC	R31,R21
    1B0F 80E0      LDD	R14,Z+0
(0375) 		for(i=0;i<8;i++)
    1B10 24CC      CLR	R12
    1B11 C00A      RJMP	0x1B1C
(0376) 		{
(0377) 			if(b&0x80)
    1B12 FEE7      SBRS	R14,7
    1B13 C003      RJMP	0x1B17
(0378) 			{
(0379) 				LCD_WR_Data(gb_color);          //字体颜色
    1B14 0185      MOVW	R16,R10
    1B15 DE36      RCALL	_LCD_WR_Data
(0380) 			}
    1B16 C003      RJMP	0x1B1A
(0381) 			else
(0382) 			{
(0383) 				LCD_WR_Data(0x0000);         //背景颜色
    1B17 2700      CLR	R16
    1B18 2711      CLR	R17
    1B19 DE32      RCALL	_LCD_WR_Data
(0384) 			}
(0385) 			b=b<<1;
    1B1A 0CEE      LSL	R14
    1B1B 94C3      INC	R12
    1B1C 2D8C      MOV	R24,R12
    1B1D 3088      CPI	R24,0x8
    1B1E F398      BCS	0x1B12
    1B1F 9563      INC	R22
    1B20 3260      CPI	R22,0x20
    1B21 F348      BCS	0x1B0B
(0386) 			
(0387) 		}	
(0388) 	}
(0389) 	LCD_EC1;
    1B22 91800062  LDS	R24,0x62
    1B24 6088      ORI	R24,0x8
    1B25 93800062  STS	0x62,R24
    1B27 940E23CF  CALL	pop_gset5
    1B29 9508      RET
_DisplayString:
  s_color              --> R20
  y                    --> R22
  x                    --> R10
  s                    --> R12
    1B2A 940E23D4  CALL	push_gset4
    1B2C 2EA2      MOV	R10,R18
    1B2D 0168      MOVW	R12,R16
    1B2E 9724      SBIW	R28,4
    1B2F 856C      LDD	R22,Y+12
    1B30 854E      LDD	R20,Y+14
    1B31 855F      LDD	R21,Y+15
(0390) }
(0391) 
(0392) //***********************************************************************
(0393) //         英文字符显示函数
(0394) //		   s:ASCII码对应字模中的位置
(0395) //         x:显示位置第几列
(0396) //         y:显示位置第几行
(0397) //***********************************************************************
(0398) 
(0399) void DisplayString(uchar *s,uchar x,uchar y,uint s_color)                      //英文字符串显示.
(0400) {
    1B32 C016      RJMP	0x1B49
(0401) 	while (*s) 
(0402) 	{ 
(0403) 		DisplayChar(*s,x,y,s_color);
    1B33 835B      STD	Y+3,R21
    1B34 834A      STD	Y+2,R20
    1B35 8368      STD	Y+0,R22
    1B36 2D2A      MOV	R18,R10
    1B37 01F6      MOVW	R30,R12
    1B38 8100      LDD	R16,Z+0
    1B39 DF18      RCALL	_DisplayChar
(0404) 		if(++x>=16)
    1B3A 2D8A      MOV	R24,R10
    1B3B 5F8F      SUBI	R24,0xFF
    1B3C 2EA8      MOV	R10,R24
    1B3D 3180      CPI	R24,0x10
    1B3E F038      BCS	0x1B46
(0405) 		{
(0406) 			x=0;
    1B3F 24AA      CLR	R10
(0407) 			if(++y>=10)
    1B40 2F86      MOV	R24,R22
    1B41 5F8F      SUBI	R24,0xFF
    1B42 2F68      MOV	R22,R24
    1B43 306A      CPI	R22,0xA
    1B44 F008      BCS	0x1B46
(0408) 			{
(0409) 				y=0;
    1B45 2766      CLR	R22
(0410) 			}
(0411) 		}
(0412) 		s++;
    1B46 01C6      MOVW	R24,R12
    1B47 9601      ADIW	R24,1
    1B48 016C      MOVW	R12,R24
    1B49 01F6      MOVW	R30,R12
    1B4A 8020      LDD	R2,Z+0
    1B4B 2022      TST	R2
    1B4C F731      BNE	0x1B33
    1B4D 9624      ADIW	R28,4
    1B4E 940E23CC  CALL	pop_gset4
    1B50 9508      RET
_GUIback:
  num                  --> R20
  back_color           --> R22
    1B51 940E23D8  CALL	push_gset2
    1B53 01B8      MOVW	R22,R16
(0413)     }
(0414) }
(0415) 
(0416) //***********************************************************************
(0417) //          打点绘图背景颜色函数，可先调用,相当于清屏函数
(0418) //***********************************************************************
(0419) 
(0420) void GUIback(uint back_color)                 //背景函数
(0421)   {
(0422)   	uint num;
(0423) 	LCD_WR_CMD(0x44,127*256+0);              //水平显示区域
    1B54 E020      LDI	R18,0
    1B55 E73F      LDI	R19,0x7F
    1B56 E404      LDI	R16,0x44
    1B57 DD87      RCALL	_LCD_WR_CMD
(0424) 	LCD_WR_CMD(0x45,239*256+80);			 //垂直显示区域
    1B58 E520      LDI	R18,0x50
    1B59 EE3F      LDI	R19,0xEF
    1B5A E405      LDI	R16,0x45
    1B5B DD83      RCALL	_LCD_WR_CMD
(0425) 	LCD_WR_CMD(0x21,80*256);				 //显示RAM起始位置，大屏起始点为0x5000
    1B5C E020      LDI	R18,0
    1B5D E530      LDI	R19,0x50
    1B5E E201      LDI	R16,0x21
    1B5F DD7F      RCALL	_LCD_WR_CMD
(0426) 	LCD_WR_REG(0x22);                     	 //执行写数据到GRAM操作
    1B60 E202      LDI	R16,0x22
    1B61 DCDE      RCALL	_LCD_WR_REG
(0427)     LCD_EC0;
    1B62 91800062  LDS	R24,0x62
    1B64 7F87      ANDI	R24,0xF7
    1B65 93800062  STS	0x62,R24
(0428) 	LCD_RS1;
    1B67 91800062  LDS	R24,0x62
    1B69 6082      ORI	R24,2
    1B6A 93800062  STS	0x62,R24
(0429) 	for(num=160*128;num>0;num--)
    1B6C E040      LDI	R20,0
    1B6D E550      LDI	R21,0x50
    1B6E C004      RJMP	0x1B73
(0430) 	{
(0431) 		LCD_WR_Data(back_color);
    1B6F 018B      MOVW	R16,R22
    1B70 DDDB      RCALL	_LCD_WR_Data
    1B71 5041      SUBI	R20,1
    1B72 4050      SBCI	R21,0
    1B73 3040      CPI	R20,0
    1B74 0745      CPC	R20,R21
    1B75 F7C9      BNE	0x1B6F
(0432) 	}
(0433) 	LCD_EC1;
    1B76 91800062  LDS	R24,0x62
    1B78 6088      ORI	R24,0x8
    1B79 93800062  STS	0x62,R24
    1B7B 940E23C6  CALL	pop_gset2
    1B7D 9508      RET
_GUIpoint:
  point_color          --> Y+4
  y                    --> R22
  x                    --> R20
    1B7E 940E23D8  CALL	push_gset2
    1B80 2F62      MOV	R22,R18
    1B81 2F40      MOV	R20,R16
(0434)   }
(0435) 
(0436) //***********************************************************************
(0437) //         大屏GUI打点函数，（x,y）为坐标
(0438) //***********************************************************************
(0439) 
(0440) void GUIpoint(uchar x,uchar y,uint point_color)                      //打点函数
(0441) {
(0442) 	
(0443) 	LCD_WR_CMD(0x44,127*256+0);              //水平显示区域
    1B82 E020      LDI	R18,0
    1B83 E73F      LDI	R19,0x7F
    1B84 E404      LDI	R16,0x44
    1B85 DD59      RCALL	_LCD_WR_CMD
(0444) 	LCD_WR_CMD(0x45,239*256+80);			 //垂直显示区域
    1B86 E520      LDI	R18,0x50
    1B87 EE3F      LDI	R19,0xEF
    1B88 E405      LDI	R16,0x45
    1B89 DD55      RCALL	_LCD_WR_CMD
(0445) 	LCD_WR_CMD(0x21,(y+80)*256+x);			 //显示RAM起始位置，大屏起始点为0x5000
    1B8A 2F26      MOV	R18,R22
    1B8B 2733      CLR	R19
    1B8C E000      LDI	R16,0
    1B8D E011      LDI	R17,1
    1B8E 940E2386  CALL	empy16s
    1B90 0198      MOVW	R18,R16
    1B91 5020      SUBI	R18,0
    1B92 4B30      SBCI	R19,0xB0
    1B93 2E24      MOV	R2,R20
    1B94 2433      CLR	R3
    1B95 0D22      ADD	R18,R2
    1B96 1D33      ADC	R19,R3
    1B97 E201      LDI	R16,0x21
    1B98 DD46      RCALL	_LCD_WR_CMD
(0446) 	LCD_WR_REG(0x22);                     	 //执行写数据到GRAM操作
    1B99 E202      LDI	R16,0x22
    1B9A DCA5      RCALL	_LCD_WR_REG
(0447) 	LCD_EC0;
    1B9B 91800062  LDS	R24,0x62
    1B9D 7F87      ANDI	R24,0xF7
    1B9E 93800062  STS	0x62,R24
(0448) 	LCD_RS1;
    1BA0 91800062  LDS	R24,0x62
    1BA2 6082      ORI	R24,2
    1BA3 93800062  STS	0x62,R24
(0449) 	
(0450) 	LCD_WR_Data(point_color);               //打点颜色	
    1BA5 810C      LDD	R16,Y+4
    1BA6 811D      LDD	R17,Y+5
    1BA7 DDA4      RCALL	_LCD_WR_Data
(0451) 	
(0452) 	LCD_EC1;	
    1BA8 91800062  LDS	R24,0x62
    1BAA 6088      ORI	R24,0x8
    1BAB 93800062  STS	0x62,R24
    1BAD 940E23C6  CALL	pop_gset2
    1BAF 9508      RET
_GUIline:
  temp                 --> Y+10
  dy                   --> Y+8
  dx                   --> Y+6
  s2                   --> Y+4
  s1                   --> Y+2
  status               --> R20
  i                    --> R22
  Dx                   --> R10
  Dy                   --> R12
  sub                  --> R14
  line_color           --> Y+30
  y1                   --> Y+28
  x1                   --> Y+26
  y0                   --> Y+24
  x0                   --> Y+22
    1BB0 940E22CF  CALL	push_arg4
    1BB2 940E23D2  CALL	push_gset5
    1BB4 972C      SBIW	R28,0xC
(0453) }
(0454) 
(0455) 
(0456) 
(0457) //***********************************************************************
(0458) //         大屏GUI画线函数，（x0,y0）为起始坐标,（x1,y1）为终点坐标
(0459) //		   line_color 线的颜色
(0460) //***********************************************************************
(0461) 
(0462) void GUIline(uchar x0,uchar y0,uchar x1,uchar y1,uint line_color)   //画线函数
(0463) {
(0464)   	int temp; 
(0465)     int dx,dy;               	//定义起点到终点的横、纵坐标增加值 
(0466)     int s1,s2,status,i; 
(0467)     int Dx,Dy,sub; 
(0468) 	
(0469) 	dx = x1 - x0; 
    1BB5 882E      LDD	R2,Y+22
    1BB6 2433      CLR	R3
    1BB7 8C4A      LDD	R4,Y+26
    1BB8 2455      CLR	R5
    1BB9 1842      SUB	R4,R2
    1BBA 0853      SBC	R5,R3
    1BBB 825F      STD	Y+7,R5
    1BBC 824E      STD	Y+6,R4
(0470)     if(dx >= 0)                 //X的方向是增加的 
    1BBD 01C2      MOVW	R24,R4
    1BBE 3080      CPI	R24,0
    1BBF E0E0      LDI	R30,0
    1BC0 079E      CPC	R25,R30
    1BC1 F02C      BLT	0x1BC7
(0471)         s1 = 1; 
    1BC2 E081      LDI	R24,1
    1BC3 E090      LDI	R25,0
    1BC4 839B      STD	Y+3,R25
    1BC5 838A      STD	Y+2,R24
    1BC6 C004      RJMP	0x1BCB
(0472)     else                     	//X的方向是降低的 
(0473)         s1 = -1;      
    1BC7 EF8F      LDI	R24,0xFF
    1BC8 EF9F      LDI	R25,0xFF
    1BC9 839B      STD	Y+3,R25
    1BCA 838A      STD	Y+2,R24
(0474)     dy = y1 - y0;                 //判断Y的方向是增加还是降到的 
    1BCB 8C28      LDD	R2,Y+24
    1BCC 2433      CLR	R3
    1BCD 8C4C      LDD	R4,Y+28
    1BCE 2455      CLR	R5
    1BCF 1842      SUB	R4,R2
    1BD0 0853      SBC	R5,R3
    1BD1 8659      STD	Y+9,R5
    1BD2 8648      STD	Y+8,R4
(0475)     if(dy >= 0) 
    1BD3 01C2      MOVW	R24,R4
    1BD4 3080      CPI	R24,0
    1BD5 E0E0      LDI	R30,0
    1BD6 079E      CPC	R25,R30
    1BD7 F02C      BLT	0x1BDD
(0476)         s2 = 1; 
    1BD8 E081      LDI	R24,1
    1BD9 E090      LDI	R25,0
    1BDA 839D      STD	Y+5,R25
    1BDB 838C      STD	Y+4,R24
    1BDC C004      RJMP	0x1BE1
(0477)     else 
(0478)         s2 =- 1; 
    1BDD EF8F      LDI	R24,0xFF
    1BDE EF9F      LDI	R25,0xFF
    1BDF 839D      STD	Y+5,R25
    1BE0 838C      STD	Y+4,R24
(0479)    
(0480)     Dx = abs(x1-x0);             //计算横、纵标志增加值的绝对值 
    1BE1 882E      LDD	R2,Y+22
    1BE2 2433      CLR	R3
    1BE3 8D0A      LDD	R16,Y+26
    1BE4 2711      CLR	R17
    1BE5 1902      SUB	R16,R2
    1BE6 0913      SBC	R17,R3
    1BE7 940E229B  CALL	_abs
    1BE9 0158      MOVW	R10,R16
(0481)     Dy = abs(y1-y0); 
    1BEA 8C28      LDD	R2,Y+24
    1BEB 2433      CLR	R3
    1BEC 8D0C      LDD	R16,Y+28
    1BED 2711      CLR	R17
    1BEE 1902      SUB	R16,R2
    1BEF 0913      SBC	R17,R3
    1BF0 940E229B  CALL	_abs
    1BF2 0168      MOVW	R12,R16
(0482)         
(0483)     if(Dy > Dx)                               
    1BF3 16A0      CP	R10,R16
    1BF4 06B1      CPC	R11,R17
    1BF5 F444      BGE	0x1BFE
(0484)     {                     		//以45度角为分界线，靠进Y轴是status=1,靠近X轴是status=0  
(0485)         temp = Dx; 
    1BF6 86BB      STD	Y+11,R11
    1BF7 86AA      STD	Y+10,R10
(0486)         Dx = Dy; 
    1BF8 0156      MOVW	R10,R12
(0487)         Dy = temp; 
    1BF9 84CA      LDD	R12,Y+10
    1BFA 84DB      LDD	R13,Y+11
(0488)     status = 1; 
    1BFB E041      LDI	R20,1
    1BFC E050      LDI	R21,0
(0489)     }  
    1BFD C002      RJMP	0x1C00
(0490)     else 
(0491)         status = 0; 
    1BFE 2744      CLR	R20
    1BFF 2755      CLR	R21
(0492) 
(0493) /*********Bresenham算法画任意两点间的直线********/  
(0494)     sub = Dy + Dy - Dx;                 //第1次判断下个点的位置 
    1C00 0176      MOVW	R14,R12
    1C01 0CEC      ADD	R14,R12
    1C02 1CFD      ADC	R15,R13
    1C03 18EA      SUB	R14,R10
    1C04 08FB      SBC	R15,R11
(0495)     for(i = 0;i < Dx;i ++) 
    1C05 2766      CLR	R22
    1C06 2777      CLR	R23
    1C07 C03E      RJMP	0x1C46
(0496)     {  
(0497)         GUIpoint(x0,y0,line_color);           //画点  
    1C08 8C0E      LDD	R0,Y+30
    1C09 8C1F      LDD	R1,Y+31
    1C0A 8219      STD	Y+1,R1
    1C0B 8208      STD	Y+0,R0
    1C0C 8D28      LDD	R18,Y+24
    1C0D 890E      LDD	R16,Y+22
    1C0E DF6F      RCALL	_GUIpoint
(0498)         if(sub >= 0)                                
    1C0F 01C7      MOVW	R24,R14
    1C10 3080      CPI	R24,0
    1C11 E0E0      LDI	R30,0
    1C12 079E      CPC	R25,R30
    1C13 F0C4      BLT	0x1C2C
(0499)         {  
(0500)             if(status == 1)               //在靠近Y轴区，x值加1 
    1C14 3041      CPI	R20,1
    1C15 E0E0      LDI	R30,0
    1C16 075E      CPC	R21,R30
    1C17 F441      BNE	0x1C20
(0501)                 x0 += s1;  
    1C18 802A      LDD	R2,Y+2
    1C19 803B      LDD	R3,Y+3
    1C1A 884E      LDD	R4,Y+22
    1C1B 2455      CLR	R5
    1C1C 0C42      ADD	R4,R2
    1C1D 1C53      ADC	R5,R3
    1C1E 8A4E      STD	Y+22,R4
    1C1F C007      RJMP	0x1C27
(0502)             else                     //在靠近X轴区，y值加1                
(0503)                 y0 += s2;  
    1C20 802C      LDD	R2,Y+4
    1C21 803D      LDD	R3,Y+5
    1C22 8C48      LDD	R4,Y+24
    1C23 2455      CLR	R5
    1C24 0C42      ADD	R4,R2
    1C25 1C53      ADC	R5,R3
    1C26 8E48      STD	Y+24,R4
(0504)             sub -= (Dx + Dx);                 //判断下下个点的位置  
    1C27 0115      MOVW	R2,R10
    1C28 0C2A      ADD	R2,R10
    1C29 1C3B      ADC	R3,R11
    1C2A 18E2      SUB	R14,R2
    1C2B 08F3      SBC	R15,R3
(0505)         }  
(0506)         if(status == 1) 
    1C2C 3041      CPI	R20,1
    1C2D E0E0      LDI	R30,0
    1C2E 075E      CPC	R21,R30
    1C2F F441      BNE	0x1C38
(0507)             y0 += s2;  
    1C30 802C      LDD	R2,Y+4
    1C31 803D      LDD	R3,Y+5
    1C32 8C48      LDD	R4,Y+24
    1C33 2455      CLR	R5
    1C34 0C42      ADD	R4,R2
    1C35 1C53      ADC	R5,R3
    1C36 8E48      STD	Y+24,R4
    1C37 C007      RJMP	0x1C3F
(0508)         else        
(0509)             x0 += s1;  
    1C38 802A      LDD	R2,Y+2
    1C39 803B      LDD	R3,Y+3
    1C3A 884E      LDD	R4,Y+22
    1C3B 2455      CLR	R5
    1C3C 0C42      ADD	R4,R2
    1C3D 1C53      ADC	R5,R3
    1C3E 8A4E      STD	Y+22,R4
(0510)         sub += Dy + Dy;  
    1C3F 0116      MOVW	R2,R12
    1C40 0C2C      ADD	R2,R12
    1C41 1C3D      ADC	R3,R13
    1C42 0CE2      ADD	R14,R2
    1C43 1CF3      ADC	R15,R3
    1C44 5F6F      SUBI	R22,0xFF
    1C45 4F7F      SBCI	R23,0xFF
    1C46 156A      CP	R22,R10
    1C47 057B      CPC	R23,R11
    1C48 F40C      BGE	0x1C4A
    1C49 CFBE      RJMP	0x1C08
    1C4A 962C      ADIW	R28,0xC
    1C4B 940E23CF  CALL	pop_gset5
    1C4D 9624      ADIW	R28,4
    1C4E 9508      RET
_GUIfull:
  j                    --> R20
  i                    --> R14
  full_colour          --> R22
  y1                   --> R10
  x1                   --> R12
  y0                   --> R14
  x0                   --> Y+12
    1C4F 940E22CF  CALL	push_arg4
    1C51 940E23D2  CALL	push_gset5
    1C53 2EE2      MOV	R14,R18
    1C54 9722      SBIW	R28,2
    1C55 88C8      LDD	R12,Y+16
    1C56 88AA      LDD	R10,Y+18
    1C57 896C      LDD	R22,Y+20
    1C58 897D      LDD	R23,Y+21
(0511)          
(0512)     }  
(0513) } 
(0514) 
(0515) /**************************************************************************** 
(0516) * 名称：GUI_Full(unsigned char x0,unsigned char y0,unsigned char x1,unsigned char y1,unsigned char full_colour) 
(0517) * 功能：用绘图的方法填充一个矩形 
(0518) * 入口参数：x0 			起始点横坐标 
(0519) *           y0    		起始点纵坐标 
(0520) *           x1 			终止点横坐标 
(0521) *           y1      	终止点纵坐标 
(0522) *          full_color      	显示颜色 
(0523) * 出口参数：无 
(0524) ****************************************************************************/ 
(0525) void GUIfull(uchar x0,uchar y0,uchar x1,uchar y1,uint full_colour) 
(0526) { 
(0527)     unsigned char i,j; 
(0528) for(j = y0;j <= y1;j ++) 
    1C59 2D4E      MOV	R20,R14
    1C5A C00B      RJMP	0x1C66
(0529)     for(i = x0;i <= x1;i ++) 
    1C5B 84EC      LDD	R14,Y+12
    1C5C C006      RJMP	0x1C63
(0530)     GUIpoint(i,j,full_colour); 
    1C5D 8379      STD	Y+1,R23
    1C5E 8368      STD	Y+0,R22
    1C5F 2F24      MOV	R18,R20
    1C60 2D0E      MOV	R16,R14
    1C61 DF1C      RCALL	_GUIpoint
    1C62 94E3      INC	R14
    1C63 14CE      CP	R12,R14
    1C64 F7C0      BCC	0x1C5D
    1C65 9543      INC	R20
    1C66 16A4      CP	R10,R20
    1C67 F798      BCC	0x1C5B
    1C68 9622      ADIW	R28,2
    1C69 940E23CF  CALL	pop_gset5
    1C6B 9624      ADIW	R28,4
    1C6C 9508      RET
_plotC:
  yc_colour            --> R14
  yc                   --> R10
  xc                   --> R22
  y                    --> R20
  x                    --> R12
    1C6D 940E23D2  CALL	push_gset5
    1C6F 2F42      MOV	R20,R18
    1C70 2EC0      MOV	R12,R16
    1C71 9722      SBIW	R28,2
    1C72 856C      LDD	R22,Y+12
    1C73 84AE      LDD	R10,Y+14
    1C74 84BF      LDD	R11,Y+15
    1C75 88E8      LDD	R14,Y+16
    1C76 88F9      LDD	R15,Y+17
(0531) } 
(0532) 
(0533) 
(0534) /**************************************************************************** 
(0535) * 名称：plotC(int x,int y,int xc,int yc,unsigned char yc_colour) 
(0536) * 功能：八分点画圆函数 
(0537) * 入口参数：x    		指定线起点所在行的位置 
(0538) *           y    		指定线起点所在列的位置 
(0539) *          yc_color 	显示颜色,根据彩色代码设定 
(0540) * 出口参数：无 
(0541) ****************************************************************************/ 
(0542) void plotC(uchar x,uchar y,uchar xc,int yc,uint yc_colour) 
(0543) { 
(0544)     GUIpoint(xc+x,yc+y,yc_colour); 
    1C77 82F9      STD	Y+1,R15
    1C78 82E8      STD	Y+0,R14
    1C79 2E24      MOV	R2,R20
    1C7A 2433      CLR	R3
    1C7B 2D2A      MOV	R18,R10
    1C7C 0D22      ADD	R18,R2
    1C7D 1D33      ADC	R19,R3
    1C7E 2F06      MOV	R16,R22
    1C7F 0D0C      ADD	R16,R12
    1C80 DEFD      RCALL	_GUIpoint
(0545)     GUIpoint(xc+x,yc-y,yc_colour); 
    1C81 82F9      STD	Y+1,R15
    1C82 82E8      STD	Y+0,R14
    1C83 2E24      MOV	R2,R20
    1C84 2433      CLR	R3
    1C85 2D2A      MOV	R18,R10
    1C86 1922      SUB	R18,R2
    1C87 0933      SBC	R19,R3
    1C88 2F06      MOV	R16,R22
    1C89 0D0C      ADD	R16,R12
    1C8A DEF3      RCALL	_GUIpoint
(0546)     GUIpoint(xc-x,yc+y,yc_colour); 
    1C8B 82F9      STD	Y+1,R15
    1C8C 82E8      STD	Y+0,R14
    1C8D 2E24      MOV	R2,R20
    1C8E 2433      CLR	R3
    1C8F 2D2A      MOV	R18,R10
    1C90 0D22      ADD	R18,R2
    1C91 1D33      ADC	R19,R3
    1C92 2F06      MOV	R16,R22
    1C93 190C      SUB	R16,R12
    1C94 DEE9      RCALL	_GUIpoint
(0547)     GUIpoint(xc-x,yc-y,yc_colour); 
    1C95 82F9      STD	Y+1,R15
    1C96 82E8      STD	Y+0,R14
    1C97 2E24      MOV	R2,R20
    1C98 2433      CLR	R3
    1C99 2D2A      MOV	R18,R10
    1C9A 1922      SUB	R18,R2
    1C9B 0933      SBC	R19,R3
    1C9C 2F06      MOV	R16,R22
    1C9D 190C      SUB	R16,R12
    1C9E DEDF      RCALL	_GUIpoint
(0548)     GUIpoint(xc+y,yc+x,yc_colour); 
    1C9F 82F9      STD	Y+1,R15
    1CA0 82E8      STD	Y+0,R14
    1CA1 2C2C      MOV	R2,R12
    1CA2 2433      CLR	R3
    1CA3 2D2A      MOV	R18,R10
    1CA4 0D22      ADD	R18,R2
    1CA5 1D33      ADC	R19,R3
    1CA6 2F06      MOV	R16,R22
    1CA7 0F04      ADD	R16,R20
    1CA8 DED5      RCALL	_GUIpoint
(0549)     GUIpoint(xc+y,yc-x,yc_colour); 
    1CA9 82F9      STD	Y+1,R15
    1CAA 82E8      STD	Y+0,R14
    1CAB 2C2C      MOV	R2,R12
    1CAC 2433      CLR	R3
    1CAD 2D2A      MOV	R18,R10
    1CAE 1922      SUB	R18,R2
    1CAF 0933      SBC	R19,R3
    1CB0 2F06      MOV	R16,R22
    1CB1 0F04      ADD	R16,R20
    1CB2 DECB      RCALL	_GUIpoint
(0550)     GUIpoint(xc-y,yc+x,yc_colour); 
    1CB3 82F9      STD	Y+1,R15
    1CB4 82E8      STD	Y+0,R14
    1CB5 2C2C      MOV	R2,R12
    1CB6 2433      CLR	R3
    1CB7 2D2A      MOV	R18,R10
    1CB8 0D22      ADD	R18,R2
    1CB9 1D33      ADC	R19,R3
    1CBA 2F06      MOV	R16,R22
    1CBB 1B04      SUB	R16,R20
    1CBC DEC1      RCALL	_GUIpoint
(0551)     GUIpoint(xc-y,yc-x,yc_colour); 
    1CBD 82F9      STD	Y+1,R15
    1CBE 82E8      STD	Y+0,R14
    1CBF 2C2C      MOV	R2,R12
    1CC0 2433      CLR	R3
    1CC1 2D2A      MOV	R18,R10
    1CC2 1922      SUB	R18,R2
    1CC3 0933      SBC	R19,R3
    1CC4 2F06      MOV	R16,R22
    1CC5 1B04      SUB	R16,R20
    1CC6 DEB7      RCALL	_GUIpoint
    1CC7 9622      ADIW	R28,2
    1CC8 940E23CF  CALL	pop_gset5
    1CCA 9508      RET
_GUIcircle:
  d                    --> R20
  y                    --> R22
  x                    --> R10
  circle_colour        --> R12
  r                    --> Y+20
  yc                   --> R14
  xc                   --> Y+16
    1CCB 940E22CF  CALL	push_arg4
    1CCD 940E23D2  CALL	push_gset5
    1CCF 2EE2      MOV	R14,R18
    1CD0 9726      SBIW	R28,6
    1CD1 88CE      LDD	R12,Y+22
    1CD2 88DF      LDD	R13,Y+23
(0552) } 
(0553) 
(0554) /**************************************************************************** 
(0555) * 名称：GUI_Circle(int xc,int yc,int r,unsigned char circle_colour) 
(0556) * 功能：画圆 
(0557) * 入口参数：xc 				圆心的行坐标 
(0558) *           yc    			圆心的列坐标 
(0559) *           r 				半径 
(0560) *          circle_color     显示颜色 
(0561) * 出口参数：无 
(0562) ****************************************************************************/ 
(0563) void GUIcircle(uchar xc,uchar yc,uchar r,uint circle_colour) 
(0564) { 
(0565)     int x,y,d; 
(0566)     y = r; 
    1CD3 896C      LDD	R22,Y+20
    1CD4 2777      CLR	R23
(0567)     d = 3 - (r + r); 
    1CD5 2E26      MOV	R2,R22
    1CD6 2433      CLR	R3
    1CD7 2C42      MOV	R4,R2
    1CD8 2455      CLR	R5
    1CD9 0C42      ADD	R4,R2
    1CDA 1C53      ADC	R5,R3
    1CDB E043      LDI	R20,3
    1CDC E050      LDI	R21,0
    1CDD 1944      SUB	R20,R4
    1CDE 0955      SBC	R21,R5
(0568)     x = 0; 
    1CDF 24AA      CLR	R10
    1CE0 24BB      CLR	R11
    1CE1 C02C      RJMP	0x1D0E
(0569)     while(x <= y) 
(0570)     { 
(0571)         plotC(x,y,xc,yc,circle_colour); 
    1CE2 82DD      STD	Y+5,R13
    1CE3 82CC      STD	Y+4,R12
    1CE4 2C2E      MOV	R2,R14
    1CE5 2433      CLR	R3
    1CE6 823B      STD	Y+3,R3
    1CE7 822A      STD	Y+2,R2
    1CE8 8808      LDD	R0,Y+16
    1CE9 8208      STD	Y+0,R0
    1CEA 2F26      MOV	R18,R22
    1CEB 2D0A      MOV	R16,R10
    1CEC DF80      RCALL	_plotC
(0572)         if(d < 0) 
    1CED 3040      CPI	R20,0
    1CEE E0E0      LDI	R30,0
    1CEF 075E      CPC	R21,R30
    1CF0 F45C      BGE	0x1CFC
(0573)             d += (x + x + x + x) + 6; 
    1CF1 01C5      MOVW	R24,R10
    1CF2 0D8A      ADD	R24,R10
    1CF3 1D9B      ADC	R25,R11
    1CF4 0D8A      ADD	R24,R10
    1CF5 1D9B      ADC	R25,R11
    1CF6 0D8A      ADD	R24,R10
    1CF7 1D9B      ADC	R25,R11
    1CF8 9606      ADIW	R24,6
    1CF9 0F48      ADD	R20,R24
    1CFA 1F59      ADC	R21,R25
    1CFB C00F      RJMP	0x1D0B
(0574)         else 
(0575)         { 
(0576)             d+=((x - y) + (x - y) + (x - y) + (x - y)) + 10; 
    1CFC 0115      MOVW	R2,R10
    1CFD 1A26      SUB	R2,R22
    1CFE 0A37      SBC	R3,R23
    1CFF 01C1      MOVW	R24,R2
    1D00 0D82      ADD	R24,R2
    1D01 1D93      ADC	R25,R3
    1D02 0D82      ADD	R24,R2
    1D03 1D93      ADC	R25,R3
    1D04 0D82      ADD	R24,R2
    1D05 1D93      ADC	R25,R3
    1D06 960A      ADIW	R24,0xA
    1D07 0F48      ADD	R20,R24
    1D08 1F59      ADC	R21,R25
(0577)             y = y - 1; 
    1D09 5061      SUBI	R22,1
    1D0A 4070      SBCI	R23,0
(0578)         } 
(0579)         x = x + 1; 
    1D0B 01C5      MOVW	R24,R10
    1D0C 9601      ADIW	R24,1
    1D0D 015C      MOVW	R10,R24
    1D0E 156A      CP	R22,R10
    1D0F 057B      CPC	R23,R11
    1D10 F68C      BGE	0x1CE2
    1D11 9626      ADIW	R28,6
    1D12 940E23CF  CALL	pop_gset5
    1D14 9624      ADIW	R28,4
    1D15 9508      RET
_GUI_sprintf_nu:
  color                --> Y+10
  nu                   --> Y+8
  y                    --> R22
  x                    --> R20
    1D16 940E23D8  CALL	push_gset2
    1D18 01B9      MOVW	R22,R18
    1D19 01A8      MOVW	R20,R16
    1D1A 9724      SBIW	R28,4
(0580)     } 
(0581) }
(0582) 
(0583) /*********************************************
(0584) //显示数字函数
(0585) //(x，y)点的坐标量，nu数字值,color颜色,b_color背景颜色
(0586) **********************************************/
(0587) void  GUI_sprintf_nu(uint x, uint y,uint nu, uint color)
(0588) {  
(0589)   DisplayChar(nu+'0',x,y,color);
    1D1B 840A      LDD	R0,Y+10
    1D1C 841B      LDD	R1,Y+11
    1D1D 821B      STD	Y+3,R1
    1D1E 820A      STD	Y+2,R0
    1D1F 8368      STD	Y+0,R22
    1D20 2F24      MOV	R18,R20
    1D21 8508      LDD	R16,Y+8
    1D22 8519      LDD	R17,Y+9
    1D23 5D00      SUBI	R16,0xD0
    1D24 4F1F      SBCI	R17,0xFF
    1D25 DD2C      RCALL	_DisplayChar
    1D26 9624      ADIW	R28,4
    1D27 940E23C6  CALL	pop_gset2
    1D29 9508      RET
_GUI_sprintf_chartobit:
  i                    --> R20
  color                --> R22
  bin_data             --> R10
  y                    --> R12
  x                    --> R14
    1D2A 940E23D2  CALL	push_gset5
    1D2C 0169      MOVW	R12,R18
    1D2D 0178      MOVW	R14,R16
    1D2E 9724      SBIW	R28,4
    1D2F 84AE      LDD	R10,Y+14
    1D30 84BF      LDD	R11,Y+15
    1D31 8968      LDD	R22,Y+16
    1D32 8979      LDD	R23,Y+17
(0590) }
(0591) 
(0592) /**********************************************************
(0593) //写入二进制字符
(0594) //(x，y)开始点的坐标量，color 线的颜色，
(0595) ************************************************************/
(0596) void  GUI_sprintf_chartobit(uint x, uint y,uint bin_data, uint color)
(0597) {  
(0598)   uint i ;
(0599)   for(i=0;i<8;i++)
    1D33 2744      CLR	R20
    1D34 2755      CLR	R21
    1D35 C023      RJMP	0x1D59
(0600)     {
(0601) 	  if((bin_data&(0x80>>i))==(0x80>>i))
    1D36 E800      LDI	R16,0x80
    1D37 E010      LDI	R17,0
    1D38 019A      MOVW	R18,R20
    1D39 940E22D4  CALL	asr16
    1D3B 0115      MOVW	R2,R10
    1D3C 2220      AND	R2,R16
    1D3D 2231      AND	R3,R17
    1D3E 1620      CP	R2,R16
    1D3F 0631      CPC	R3,R17
    1D40 F451      BNE	0x1D4B
(0602) 	    {
(0603) 		  GUI_sprintf_nu(x,y,1,color) ;
    1D41 837B      STD	Y+3,R23
    1D42 836A      STD	Y+2,R22
    1D43 E081      LDI	R24,1
    1D44 E090      LDI	R25,0
    1D45 8399      STD	Y+1,R25
    1D46 8388      STD	Y+0,R24
    1D47 0196      MOVW	R18,R12
    1D48 0187      MOVW	R16,R14
    1D49 DFCC      RCALL	_GUI_sprintf_nu
(0604) 		}
    1D4A C009      RJMP	0x1D54
(0605) 	  else 
(0606) 	    {
(0607) 		  GUI_sprintf_nu(x,y,0,color) ;
    1D4B 837B      STD	Y+3,R23
    1D4C 836A      STD	Y+2,R22
    1D4D 2422      CLR	R2
    1D4E 2433      CLR	R3
    1D4F 8239      STD	Y+1,R3
    1D50 8228      STD	Y+0,R2
    1D51 0196      MOVW	R18,R12
    1D52 0187      MOVW	R16,R14
    1D53 DFC2      RCALL	_GUI_sprintf_nu
(0608) 		}
(0609) 		
(0610) 	  x+=1 ;
    1D54 01C7      MOVW	R24,R14
    1D55 9601      ADIW	R24,1
    1D56 017C      MOVW	R14,R24
    1D57 5F4F      SUBI	R20,0xFF
    1D58 4F5F      SBCI	R21,0xFF
    1D59 3048      CPI	R20,0x8
    1D5A E0E0      LDI	R30,0
    1D5B 075E      CPC	R21,R30
    1D5C F2C8      BCS	0x1D36
    1D5D 9624      ADIW	R28,4
    1D5E 940E23CF  CALL	pop_gset5
    1D60 9508      RET
_GUI_sprintf_chartohex:
  i                    --> Y+5
  color                --> Y+10
  hex_data             --> Y+8
  y                    --> R22
  x                    --> R20
    1D61 940E23D8  CALL	push_gset2
    1D63 01B9      MOVW	R22,R18
    1D64 01A8      MOVW	R20,R16
    1D65 9724      SBIW	R28,4
(0611) 	}
(0612)  
(0613) }
(0614) 
(0615) 
(0616) /**********************************************************
(0617) //写入十六进制字符
(0618) //(x，y)开始点的坐标量，color 线的颜色，
(0619) ************************************************************/
(0620) void  GUI_sprintf_chartohex(uint x, uint y,uint hex_data, uint color)
(0621) {  
(0622)   uint i ;
(0623) 
(0624) 		  GUI_sprintf_nu(x,y,hex_data>>4,color) ;
    1D66 840A      LDD	R0,Y+10
    1D67 841B      LDD	R1,Y+11
    1D68 821B      STD	Y+3,R1
    1D69 820A      STD	Y+2,R0
    1D6A 8428      LDD	R2,Y+8
    1D6B 8439      LDD	R3,Y+9
    1D6C 9436      LSR	R3
    1D6D 9427      ROR	R2
    1D6E 9436      LSR	R3
    1D6F 9427      ROR	R2
    1D70 9436      LSR	R3
    1D71 9427      ROR	R2
    1D72 9436      LSR	R3
    1D73 9427      ROR	R2
    1D74 8239      STD	Y+1,R3
    1D75 8228      STD	Y+0,R2
    1D76 019B      MOVW	R18,R22
    1D77 018A      MOVW	R16,R20
    1D78 DF9D      RCALL	_GUI_sprintf_nu
(0625) 		  x+=1 ;
    1D79 5F4F      SUBI	R20,0xFF
    1D7A 4F5F      SBCI	R21,0xFF
(0626) 		  GUI_sprintf_nu(x,y,hex_data&0x0f,color) ;
    1D7B 840A      LDD	R0,Y+10
    1D7C 841B      LDD	R1,Y+11
    1D7D 821B      STD	Y+3,R1
    1D7E 820A      STD	Y+2,R0
    1D7F 8588      LDD	R24,Y+8
    1D80 8599      LDD	R25,Y+9
    1D81 708F      ANDI	R24,0xF
    1D82 7090      ANDI	R25,0
    1D83 8399      STD	Y+1,R25
    1D84 8388      STD	Y+0,R24
    1D85 019B      MOVW	R18,R22
    1D86 018A      MOVW	R16,R20
    1D87 DF8E      RCALL	_GUI_sprintf_nu
    1D88 9624      ADIW	R28,4
    1D89 940E23C6  CALL	pop_gset2
    1D8B 9508      RET
_eeprom_read_byte:
  readtemp             --> R20
  addr                 --> R16
    1D8C 940E23DA  CALL	push_gset1
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\EEPROM.C
(0001) //DMAVR-128的读写EEPROM示例程序，记录CPU启动的次数到EEPROM中
(0002) //在LED数码管上显示读出的数据,可用复位键刷新显示
(0003) //编译环境 ICCAVR
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //忠兴电子元件店编辑
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <string.h>
(0012) #include <stdio.h>
(0013) #define	 F_CPU	7372800							// 单片机主频为7.3728MHz,用于延时子程序
(0014) //#include <delay.h>
(0015) #include <iom128v.h>
(0016) 
(0017) 
(0018) //***********************************************************************
(0019) //			定义变量区
(0020) //***********************************************************************
(0021) 
(0022) #define uchar           unsigned char
(0023) #define uint            unsigned int
(0024) 
(0025) 
(0026) 
(0027) //***********************************************************************
(0028) //                EEPROM读取函数*/
(0029) //            addr：地址；number：长度；p_buff：读出数据存放指针
(0030) //***********************************************************************
(0031)  eeprom_read_byte(unsigned int addr) 
(0032) {
(0033)    unsigned char readtemp;
(0034) 	while(EECR & (1 << EEWE));               //等待前面的写完成
    1D8E 99E1      SBIC	0x1C,1
    1D8F CFFE      RJMP	0x1D8E
(0035) 
(0036) 	EEARH = 0x00;                           //写高字节地址
    1D90 2422      CLR	R2
    1D91 BA2F      OUT	0x1F,R2
(0037) 	
(0038) 		EEARL = addr;                 	//写地址低字节
    1D92 BB0E      OUT	0x1E,R16
(0039) 		EECR |= (1 << EERE);            	//读允许位置1
    1D93 9AE0      SBI	0x1C,0
(0040) 		readtemp = EEDR;               	//读出EEDR中的数据
    1D94 B34D      IN	R20,0x1D
(0041)    return readtemp;	
    1D95 2F04      MOV	R16,R20
    1D96 2711      CLR	R17
    1D97 940E23DD  CALL	pop_gset1
    1D99 9508      RET
(0042) }
(0043) 
(0044) //***********************************************************************
(0045) //              EEPROM写入函数
(0046) //          addr：地址；number：长度；p_buff：写入数据存放指针
(0047) //***********************************************************************
(0048) void eeprom_write_byte(unsigned int addr, unsigned char p_buff) 
(0049) {
(0050) 
(0051) 	EEARH = 0x00;
_eeprom_write_byte:
  p_buff               --> R18
  addr                 --> R16
    1D9A 2422      CLR	R2
    1D9B BA2F      OUT	0x1F,R2
(0052) 	
(0053) 	
(0054) 		while(EECR & (1 << EEWE));       //等待前面的写完成
    1D9C 99E1      SBIC	0x1C,1
    1D9D CFFE      RJMP	0x1D9C
(0055) 		EEARL = addr;                 //写地址
    1D9E BB0E      OUT	0x1E,R16
(0056) 		EEDR = p_buff;               //写数据到EEDR
    1D9F BB2D      OUT	0x1D,R18
(0057) 		EECR |= (1 << EEMWE);            //主机写入允许位
    1DA0 9AE2      SBI	0x1C,2
(0058) 		EECR&=~(1<<EEWE);
    1DA1 98E1      CBI	0x1C,1
(0059) 		EECR |= (1 << EEWE);             //EEWE为1，执行写操作
    1DA2 9AE1      SBI	0x1C,1
    1DA3 9508      RET
_putchar:
  c                    --> R20
    1DA4 940E23DA  CALL	push_gset1
    1DA6 2F40      MOV	R20,R16
FILE: E:\ATMEGA128开发板\我的ATMEGA128最小系统板\M128_ZZX_1配套资料\27.读取SD卡中BMP图片实验\ReadBmp\uart.c
(0001) //串口发送接收驱动程序
(0002) //采用标准输入输出格式进行打印，UART1输出，通过串口调试助手可以查看调试信息
(0003) //编译环境 ICCAVR 7.16A
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //忠兴电子元件店编辑
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <stdio.h>
(0012) #include <string.h>
(0013) #include <iom128v.h>
(0014) 
(0015) #define uchar           unsigned char
(0016) #define uint            unsigned int
(0017) #define ulong           unsigned long
(0018) #define	F_CPU		   7372800		 						    //单片机主频为7.3728MHz
(0019) #define baud           9600                                     //设置波特率的大小
(0020) #define baud_setting   (uint)((ulong)F_CPU/(16*(ulong)baud)-1)  //波特率计算公式
(0021) #define baud_h         (uchar)(baud_setting>>8)                 //提取高位
(0022) #define baud_l         (uchar)(baud_setting)                    //低位
(0023) 
(0024) //***********************************************************************
(0025) // 用于输出的标准格式函数，用printf输出到UART1
(0026) //***********************************************************************
(0027) 
(0028) extern int _textmode;
(0029) 
(0030) int putchar(char c)
(0031)     {
(0032)     if (_textmode && c == '\n')
    1DA7 90200F37  LDS	R2,_textmode
    1DA9 90300F38  LDS	R3,_textmode+1
    1DAB 2022      TST	R2
    1DAC F411      BNE	0x1DAF
    1DAD 2033      TST	R3
    1DAE F021      BEQ	0x1DB3
    1DAF 304A      CPI	R20,0xA
    1DB0 F411      BNE	0x1DB3
(0033)         putchar('\r');
    1DB1 E00D      LDI	R16,0xD
    1DB2 DFF1      RCALL	_putchar
(0034)     while ( !(UCSR1A & (1<<UDRE1)) )   // UDRE, data register empty
    1DB3 9020009B  LDS	R2,0x9B
    1DB5 FE25      SBRS	R2,5
    1DB6 CFFC      RJMP	0x1DB3
(0035)         ;
(0036)     UDR1 = c;
    1DB7 9340009C  STS	0x9C,R20
(0037)     return c;
    1DB9 2F04      MOV	R16,R20
    1DBA 2711      CLR	R17
    1DBB 940E23DD  CALL	pop_gset1
    1DBD 9508      RET
(0038)     }
(0039) //***********************************************************************
(0040) // 用于输入的标准格式函数，用getchar通过UART1输入到单片机，代替C中的scanf
(0041) //***********************************************************************
(0042) 
(0043) int getchar(void)
(0044)     {
(0045)     while ((UCSR1A & 0x80) == 0)
_getchar:
    1DBE 9020009B  LDS	R2,0x9B
    1DC0 FE27      SBRS	R2,7
    1DC1 CFFC      RJMP	_getchar
(0046)         ;
(0047)     return UDR1;
    1DC2 9100009C  LDS	R16,0x9C
    1DC4 2711      CLR	R17
    1DC5 9508      RET
(0048)     } 
(0049) //***********************************************************************
(0050) // 串口1初始化接口函数
(0051) // 初始化uart,查询方式读写
(0052) //***********************************************************************
(0053) void UART_Init(void)
(0054) {
(0055)  
(0056)   UCSR1B =(1<<RXEN1)|(1<<TXEN1);             		//发送接收使能
_UART_Init:
    1DC6 E188      LDI	R24,0x18
    1DC7 9380009A  STS	0x9A,R24
(0057)   UBRR1H=baud_h;                                	//写波特率的值
    1DC9 2422      CLR	R2
    1DCA 92200098  STS	0x98,R2
(0058)   UBRR1L=baud_l; 
FILE: <library>
    1DCC E28F      LDI	R24,0x2F
    1DCD 93800099  STS	0x99,R24
    1DCF 9508      RET
__print:
    1DD0 940E22CF  CALL	push_arg4
    1DD2 940E23D2  CALL	push_gset5
    1DD4 9769      SBIW	R28,0x19
    1DD5 2400      CLR	R0
    1DD6 2411      CLR	R1
    1DD7 8A1D      STD	Y+21,R1
    1DD8 8A0C      STD	Y+20,R0
    1DD9 C4B4      RJMP	0x228E
    1DDA A1ED      LDD	R30,Y+37
    1DDB A1FE      LDD	R31,Y+38
    1DDC 8180      LDD	R24,Z+0
    1DDD 3285      CPI	R24,0x25
    1DDE F059      BEQ	0x1DEA
    1DDF 8100      LDD	R16,Z+0
    1DE0 A1EB      LDD	R30,Y+35
    1DE1 A1FC      LDD	R31,Y+36
    1DE2 940E23F1  CALL	xicall
    1DE4 898C      LDD	R24,Y+20
    1DE5 899D      LDD	R25,Y+21
    1DE6 9601      ADIW	R24,1
    1DE7 8B9D      STD	Y+21,R25
    1DE8 8B8C      STD	Y+20,R24
    1DE9 C49F      RJMP	0x2289
    1DEA 2400      CLR	R0
    1DEB 2411      CLR	R1
    1DEC 8A1B      STD	Y+19,R1
    1DED 8A0A      STD	Y+18,R0
    1DEE EF8F      LDI	R24,0xFF
    1DEF EF9F      LDI	R25,0xFF
    1DF0 8B9F      STD	Y+23,R25
    1DF1 8B8E      STD	Y+22,R24
    1DF2 8A19      STD	Y+17,R1
    1DF3 8A08      STD	Y+16,R0
    1DF4 E18C      LDI	R24,0x1C
    1DF5 E09F      LDI	R25,0xF
    1DF6 839D      STD	Y+5,R25
    1DF7 838C      STD	Y+4,R24
    1DF8 E280      LDI	R24,0x20
    1DF9 8F88      STD	Y+24,R24
    1DFA A18D      LDD	R24,Y+37
    1DFB A19E      LDD	R25,Y+38
    1DFC 9601      ADIW	R24,1
    1DFD A39E      STD	Y+38,R25
    1DFE A38D      STD	Y+37,R24
    1DFF 24CC      CLR	R12
    1E00 24DD      CLR	R13
    1E01 A1ED      LDD	R30,Y+37
    1E02 A1FE      LDD	R31,Y+38
    1E03 8020      LDD	R2,Z+0
    1E04 2433      CLR	R3
    1E05 863F      STD	Y+15,R3
    1E06 862E      STD	Y+14,R2
    1E07 2D82      MOV	R24,R2
    1E08 2D93      MOV	R25,R3
    1E09 3280      CPI	R24,0x20
    1E0A E0E0      LDI	R30,0
    1E0B 079E      CPC	R25,R30
    1E0C F159      BEQ	0x1E38
    1E0D 3283      CPI	R24,0x23
    1E0E E0E0      LDI	R30,0
    1E0F 079E      CPC	R25,R30
    1E10 F099      BEQ	0x1E24
    1E11 3280      CPI	R24,0x20
    1E12 E0E0      LDI	R30,0
    1E13 079E      CPC	R25,R30
    1E14 F18C      BLT	0x1E46
    1E15 858E      LDD	R24,Y+14
    1E16 859F      LDD	R25,Y+15
    1E17 328B      CPI	R24,0x2B
    1E18 E0E0      LDI	R30,0
    1E19 079E      CPC	R25,R30
    1E1A F0A9      BEQ	0x1E30
    1E1B 328D      CPI	R24,0x2D
    1E1C E0E0      LDI	R30,0
    1E1D 079E      CPC	R25,R30
    1E1E F059      BEQ	0x1E2A
    1E1F 3380      CPI	R24,0x30
    1E20 E0E0      LDI	R30,0
    1E21 079E      CPC	R25,R30
    1E22 F0E9      BEQ	0x1E40
    1E23 C022      RJMP	0x1E46
    1E24 8988      LDD	R24,Y+16
    1E25 8999      LDD	R25,Y+17
    1E26 6081      ORI	R24,1
    1E27 8B99      STD	Y+17,R25
    1E28 8B88      STD	Y+16,R24
    1E29 C020      RJMP	0x1E4A
    1E2A 8988      LDD	R24,Y+16
    1E2B 8999      LDD	R25,Y+17
    1E2C 6084      ORI	R24,4
    1E2D 8B99      STD	Y+17,R25
    1E2E 8B88      STD	Y+16,R24
    1E2F C01A      RJMP	0x1E4A
    1E30 8988      LDD	R24,Y+16
    1E31 8999      LDD	R25,Y+17
    1E32 6088      ORI	R24,0x8
    1E33 8B99      STD	Y+17,R25
    1E34 8B88      STD	Y+16,R24
    1E35 E28B      LDI	R24,0x2B
    1E36 8F88      STD	Y+24,R24
    1E37 C012      RJMP	0x1E4A
    1E38 8988      LDD	R24,Y+16
    1E39 8999      LDD	R25,Y+17
    1E3A 6088      ORI	R24,0x8
    1E3B 8B99      STD	Y+17,R25
    1E3C 8B88      STD	Y+16,R24
    1E3D E280      LDI	R24,0x20
    1E3E 8F88      STD	Y+24,R24
    1E3F C00A      RJMP	0x1E4A
    1E40 8988      LDD	R24,Y+16
    1E41 8999      LDD	R25,Y+17
    1E42 6180      ORI	R24,0x10
    1E43 8B99      STD	Y+17,R25
    1E44 8B88      STD	Y+16,R24
    1E45 C004      RJMP	0x1E4A
    1E46 E081      LDI	R24,1
    1E47 E090      LDI	R25,0
    1E48 2EC8      MOV	R12,R24
    1E49 2ED9      MOV	R13,R25
    1E4A 20CC      TST	R12
    1E4B F411      BNE	0x1E4E
    1E4C 20DD      TST	R13
    1E4D F009      BEQ	0x1E4F
    1E4E C006      RJMP	0x1E55
    1E4F A18D      LDD	R24,Y+37
    1E50 A19E      LDD	R25,Y+38
    1E51 9601      ADIW	R24,1
    1E52 A39E      STD	Y+38,R25
    1E53 A38D      STD	Y+37,R24
    1E54 CFAC      RJMP	0x1E01
    1E55 A1ED      LDD	R30,Y+37
    1E56 A1FE      LDD	R31,Y+38
    1E57 8100      LDD	R16,Z+0
    1E58 2711      CLR	R17
    1E59 940E2818  CALL	_isdigit
    1E5B 3000      CPI	R16,0
    1E5C 0701      CPC	R16,R17
    1E5D F0B1      BEQ	0x1E74
    1E5E A10D      LDD	R16,Y+37
    1E5F A11E      LDD	R17,Y+38
    1E60 940E2620  CALL	_atoi
    1E62 8B1B      STD	Y+19,R17
    1E63 8B0A      STD	Y+18,R16
    1E64 C005      RJMP	0x1E6A
    1E65 A18D      LDD	R24,Y+37
    1E66 A19E      LDD	R25,Y+38
    1E67 9601      ADIW	R24,1
    1E68 A39E      STD	Y+38,R25
    1E69 A38D      STD	Y+37,R24
    1E6A A1ED      LDD	R30,Y+37
    1E6B A1FE      LDD	R31,Y+38
    1E6C 8100      LDD	R16,Z+0
    1E6D 2711      CLR	R17
    1E6E 940E2818  CALL	_isdigit
    1E70 3000      CPI	R16,0
    1E71 0701      CPC	R16,R17
    1E72 F791      BNE	0x1E65
    1E73 C016      RJMP	0x1E8A
    1E74 A1ED      LDD	R30,Y+37
    1E75 A1FE      LDD	R31,Y+38
    1E76 8180      LDD	R24,Z+0
    1E77 328A      CPI	R24,0x2A
    1E78 F489      BNE	0x1E8A
    1E79 A18F      LDD	R24,Y+39
    1E7A A598      LDD	R25,Y+40
    1E7B 9602      ADIW	R24,2
    1E7C A798      STD	Y+40,R25
    1E7D A38F      STD	Y+39,R24
    1E7E 2FE8      MOV	R30,R24
    1E7F 2FF9      MOV	R31,R25
    1E80 9732      SBIW	R30,2
    1E81 8020      LDD	R2,Z+0
    1E82 8031      LDD	R3,Z+1
    1E83 8A3B      STD	Y+19,R3
    1E84 8A2A      STD	Y+18,R2
    1E85 A18D      LDD	R24,Y+37
    1E86 A19E      LDD	R25,Y+38
    1E87 9601      ADIW	R24,1
    1E88 A39E      STD	Y+38,R25
    1E89 A38D      STD	Y+37,R24
    1E8A A1ED      LDD	R30,Y+37
    1E8B A1FE      LDD	R31,Y+38
    1E8C 8180      LDD	R24,Z+0
    1E8D 328E      CPI	R24,0x2E
    1E8E F009      BEQ	0x1E90
    1E8F C03A      RJMP	0x1ECA
    1E90 2F8E      MOV	R24,R30
    1E91 2F9F      MOV	R25,R31
    1E92 9601      ADIW	R24,1
    1E93 A39E      STD	Y+38,R25
    1E94 A38D      STD	Y+37,R24
    1E95 2FE8      MOV	R30,R24
    1E96 2FF9      MOV	R31,R25
    1E97 8100      LDD	R16,Z+0
    1E98 2711      CLR	R17
    1E99 940E2818  CALL	_isdigit
    1E9B 3000      CPI	R16,0
    1E9C 0701      CPC	R16,R17
    1E9D F0B1      BEQ	0x1EB4
    1E9E A10D      LDD	R16,Y+37
    1E9F A11E      LDD	R17,Y+38
    1EA0 940E2620  CALL	_atoi
    1EA2 8B1F      STD	Y+23,R17
    1EA3 8B0E      STD	Y+22,R16
    1EA4 C005      RJMP	0x1EAA
    1EA5 A18D      LDD	R24,Y+37
    1EA6 A19E      LDD	R25,Y+38
    1EA7 9601      ADIW	R24,1
    1EA8 A39E      STD	Y+38,R25
    1EA9 A38D      STD	Y+37,R24
    1EAA A1ED      LDD	R30,Y+37
    1EAB A1FE      LDD	R31,Y+38
    1EAC 8100      LDD	R16,Z+0
    1EAD 2711      CLR	R17
    1EAE 940E2818  CALL	_isdigit
    1EB0 3000      CPI	R16,0
    1EB1 0701      CPC	R16,R17
    1EB2 F791      BNE	0x1EA5
    1EB3 C016      RJMP	0x1ECA
    1EB4 A1ED      LDD	R30,Y+37
    1EB5 A1FE      LDD	R31,Y+38
    1EB6 8180      LDD	R24,Z+0
    1EB7 328A      CPI	R24,0x2A
    1EB8 F489      BNE	0x1ECA
    1EB9 A18F      LDD	R24,Y+39
    1EBA A598      LDD	R25,Y+40
    1EBB 9602      ADIW	R24,2
    1EBC A798      STD	Y+40,R25
    1EBD A38F      STD	Y+39,R24
    1EBE 2FE8      MOV	R30,R24
    1EBF 2FF9      MOV	R31,R25
    1EC0 9732      SBIW	R30,2
    1EC1 8020      LDD	R2,Z+0
    1EC2 8031      LDD	R3,Z+1
    1EC3 8A3F      STD	Y+23,R3
    1EC4 8A2E      STD	Y+22,R2
    1EC5 A18D      LDD	R24,Y+37
    1EC6 A19E      LDD	R25,Y+38
    1EC7 9601      ADIW	R24,1
    1EC8 A39E      STD	Y+38,R25
    1EC9 A38D      STD	Y+37,R24
    1ECA A1ED      LDD	R30,Y+37
    1ECB A1FE      LDD	R31,Y+38
    1ECC 8180      LDD	R24,Z+0
    1ECD 368C      CPI	R24,0x6C
    1ECE F451      BNE	0x1ED9
    1ECF 2F8E      MOV	R24,R30
    1ED0 2F9F      MOV	R25,R31
    1ED1 9601      ADIW	R24,1
    1ED2 A39E      STD	Y+38,R25
    1ED3 A38D      STD	Y+37,R24
    1ED4 8988      LDD	R24,Y+16
    1ED5 8999      LDD	R25,Y+17
    1ED6 6082      ORI	R24,2
    1ED7 8B99      STD	Y+17,R25
    1ED8 8B88      STD	Y+16,R24
    1ED9 A1ED      LDD	R30,Y+37
    1EDA A1FE      LDD	R31,Y+38
    1EDB 8020      LDD	R2,Z+0
    1EDC 2433      CLR	R3
    1EDD 863F      STD	Y+15,R3
    1EDE 862E      STD	Y+14,R2
    1EDF 2D82      MOV	R24,R2
    1EE0 2D93      MOV	R25,R3
    1EE1 3588      CPI	R24,0x58
    1EE2 E0E0      LDI	R30,0
    1EE3 079E      CPC	R25,R30
    1EE4 F409      BNE	0x1EE6
    1EE5 C0D9      RJMP	0x1FBF
    1EE6 E588      LDI	R24,0x58
    1EE7 1582      CP	R24,R2
    1EE8 0593      CPC	R25,R3
    1EE9 F0A4      BLT	0x1EFE
    1EEA 858E      LDD	R24,Y+14
    1EEB 859F      LDD	R25,Y+15
    1EEC 3485      CPI	R24,0x45
    1EED E0E0      LDI	R30,0
    1EEE 079E      CPC	R25,R30
    1EEF F409      BNE	0x1EF1
    1EF0 C393      RJMP	0x2284
    1EF1 3485      CPI	R24,0x45
    1EF2 E0E0      LDI	R30,0
    1EF3 079E      CPC	R25,R30
    1EF4 F40C      BGE	0x1EF6
    1EF5 C043      RJMP	0x1F39
    1EF6 858E      LDD	R24,Y+14
    1EF7 859F      LDD	R25,Y+15
    1EF8 3583      CPI	R24,0x53
    1EF9 E0E0      LDI	R30,0
    1EFA 079E      CPC	R25,R30
    1EFB F409      BNE	0x1EFD
    1EFC C1DA      RJMP	0x20D7
    1EFD C03B      RJMP	0x1F39
    1EFE 858E      LDD	R24,Y+14
    1EFF 859F      LDD	R25,Y+15
    1F00 368F      CPI	R24,0x6F
    1F01 E0E0      LDI	R30,0
    1F02 079E      CPC	R25,R30
    1F03 F409      BNE	0x1F05
    1F04 C0BA      RJMP	0x1FBF
    1F05 E68F      LDI	R24,0x6F
    1F06 E090      LDI	R25,0
    1F07 842E      LDD	R2,Y+14
    1F08 843F      LDD	R3,Y+15
    1F09 1582      CP	R24,R2
    1F0A 0593      CPC	R25,R3
    1F0B F0DC      BLT	0x1F27
    1F0C 858E      LDD	R24,Y+14
    1F0D 859F      LDD	R25,Y+15
    1F0E 3683      CPI	R24,0x63
    1F0F E0E0      LDI	R30,0
    1F10 079E      CPC	R25,R30
    1F11 F409      BNE	0x1F13
    1F12 C19D      RJMP	0x20B0
    1F13 3684      CPI	R24,0x64
    1F14 E0E0      LDI	R30,0
    1F15 079E      CPC	R25,R30
    1F16 F409      BNE	0x1F18
    1F17 C02E      RJMP	0x1F46
    1F18 3685      CPI	R24,0x65
    1F19 E0E0      LDI	R30,0
    1F1A 079E      CPC	R25,R30
    1F1B F409      BNE	0x1F1D
    1F1C C367      RJMP	0x2284
    1F1D 3686      CPI	R24,0x66
    1F1E E0E0      LDI	R30,0
    1F1F 079E      CPC	R25,R30
    1F20 F409      BNE	0x1F22
    1F21 C362      RJMP	0x2284
    1F22 3689      CPI	R24,0x69
    1F23 E0E0      LDI	R30,0
    1F24 079E      CPC	R25,R30
    1F25 F101      BEQ	0x1F46
    1F26 C012      RJMP	0x1F39
    1F27 858E      LDD	R24,Y+14
    1F28 859F      LDD	R25,Y+15
    1F29 3783      CPI	R24,0x73
    1F2A E0E0      LDI	R30,0
    1F2B 079E      CPC	R25,R30
    1F2C F409      BNE	0x1F2E
    1F2D C27C      RJMP	0x21AA
    1F2E 3785      CPI	R24,0x75
    1F2F E0E0      LDI	R30,0
    1F30 079E      CPC	R25,R30
    1F31 F409      BNE	0x1F33
    1F32 C08C      RJMP	0x1FBF
    1F33 3788      CPI	R24,0x78
    1F34 E0E0      LDI	R30,0
    1F35 079E      CPC	R25,R30
    1F36 F409      BNE	0x1F38
    1F37 C087      RJMP	0x1FBF
    1F38 C000      RJMP	0x1F39
    1F39 A1ED      LDD	R30,Y+37
    1F3A A1FE      LDD	R31,Y+38
    1F3B 8100      LDD	R16,Z+0
    1F3C A1EB      LDD	R30,Y+35
    1F3D A1FC      LDD	R31,Y+36
    1F3E 940E23F1  CALL	xicall
    1F40 898C      LDD	R24,Y+20
    1F41 899D      LDD	R25,Y+21
    1F42 9601      ADIW	R24,1
    1F43 8B9D      STD	Y+21,R25
    1F44 8B8C      STD	Y+20,R24
    1F45 C343      RJMP	0x2289
    1F46 8808      LDD	R0,Y+16
    1F47 8819      LDD	R1,Y+17
    1F48 FE01      SBRS	R0,1
    1F49 C049      RJMP	0x1F93
    1F4A A18F      LDD	R24,Y+39
    1F4B A598      LDD	R25,Y+40
    1F4C 9604      ADIW	R24,4
    1F4D A798      STD	Y+40,R25
    1F4E A38F      STD	Y+39,R24
    1F4F 2FE8      MOV	R30,R24
    1F50 2FF9      MOV	R31,R25
    1F51 9734      SBIW	R30,4
    1F52 8020      LDD	R2,Z+0
    1F53 8031      LDD	R3,Z+1
    1F54 8042      LDD	R4,Z+2
    1F55 8053      LDD	R5,Z+3
    1F56 2FEC      MOV	R30,R28
    1F57 2FFD      MOV	R31,R29
    1F58 8620      STD	Z+8,R2
    1F59 8631      STD	Z+9,R3
    1F5A 8642      STD	Z+10,R4
    1F5B 8653      STD	Z+11,R5
    1F5C E040      LDI	R20,0
    1F5D E050      LDI	R21,0
    1F5E E060      LDI	R22,0
    1F5F E070      LDI	R23,0
    1F60 2FEC      MOV	R30,R28
    1F61 2FFD      MOV	R31,R29
    1F62 8420      LDD	R2,Z+8
    1F63 8431      LDD	R3,Z+9
    1F64 8442      LDD	R4,Z+10
    1F65 8453      LDD	R5,Z+11
    1F66 1624      CP	R2,R20
    1F67 0635      CPC	R3,R21
    1F68 0646      CPC	R4,R22
    1F69 0657      CPC	R5,R23
    1F6A F4AC      BGE	0x1F80
    1F6B 8988      LDD	R24,Y+16
    1F6C 8999      LDD	R25,Y+17
    1F6D 6088      ORI	R24,0x8
    1F6E 8B99      STD	Y+17,R25
    1F6F 8B88      STD	Y+16,R24
    1F70 E28D      LDI	R24,0x2D
    1F71 8F88      STD	Y+24,R24
    1F72 2FEC      MOV	R30,R28
    1F73 2FFD      MOV	R31,R29
    1F74 8500      LDD	R16,Z+8
    1F75 8511      LDD	R17,Z+9
    1F76 8522      LDD	R18,Z+10
    1F77 8533      LDD	R19,Z+11
    1F78 940E23FA  CALL	neg32
    1F7A 2FEC      MOV	R30,R28
    1F7B 2FFD      MOV	R31,R29
    1F7C 8700      STD	Z+8,R16
    1F7D 8711      STD	Z+9,R17
    1F7E 8722      STD	Z+10,R18
    1F7F 8733      STD	Z+11,R19
    1F80 E08A      LDI	R24,0xA
    1F81 E090      LDI	R25,0
    1F82 839B      STD	Y+3,R25
    1F83 838A      STD	Y+2,R24
    1F84 2FEC      MOV	R30,R28
    1F85 2FFD      MOV	R31,R29
    1F86 8420      LDD	R2,Z+8
    1F87 8431      LDD	R3,Z+9
    1F88 8442      LDD	R4,Z+10
    1F89 8453      LDD	R5,Z+11
    1F8A 8248      STD	Y+0,R4
    1F8B 8259      STD	Y+1,R5
    1F8C 2D22      MOV	R18,R2
    1F8D 2D33      MOV	R19,R3
    1F8E 810C      LDD	R16,Y+4
    1F8F 811D      LDD	R17,Y+5
    1F90 940E26CC  CALL	_ltoa
    1F92 C0F7      RJMP	0x208A
    1F93 A18F      LDD	R24,Y+39
    1F94 A598      LDD	R25,Y+40
    1F95 9602      ADIW	R24,2
    1F96 A798      STD	Y+40,R25
    1F97 A38F      STD	Y+39,R24
    1F98 2FE8      MOV	R30,R24
    1F99 2FF9      MOV	R31,R25
    1F9A 9732      SBIW	R30,2
    1F9B 8020      LDD	R2,Z+0
    1F9C 8031      LDD	R3,Z+1
    1F9D 823F      STD	Y+7,R3
    1F9E 822E      STD	Y+6,R2
    1F9F 2D82      MOV	R24,R2
    1FA0 2D93      MOV	R25,R3
    1FA1 3080      CPI	R24,0
    1FA2 E0E0      LDI	R30,0
    1FA3 079E      CPC	R25,R30
    1FA4 F47C      BGE	0x1FB4
    1FA5 8988      LDD	R24,Y+16
    1FA6 8999      LDD	R25,Y+17
    1FA7 6088      ORI	R24,0x8
    1FA8 8B99      STD	Y+17,R25
    1FA9 8B88      STD	Y+16,R24
    1FAA E28D      LDI	R24,0x2D
    1FAB 8F88      STD	Y+24,R24
    1FAC 818E      LDD	R24,Y+6
    1FAD 819F      LDD	R25,Y+7
    1FAE 9580      COM	R24
    1FAF 9590      COM	R25
    1FB0 5F8F      SUBI	R24,0xFF
    1FB1 4F9F      SBCI	R25,0xFF
    1FB2 839F      STD	Y+7,R25
    1FB3 838E      STD	Y+6,R24
    1FB4 E08A      LDI	R24,0xA
    1FB5 E090      LDI	R25,0
    1FB6 8399      STD	Y+1,R25
    1FB7 8388      STD	Y+0,R24
    1FB8 812E      LDD	R18,Y+6
    1FB9 813F      LDD	R19,Y+7
    1FBA 810C      LDD	R16,Y+4
    1FBB 811D      LDD	R17,Y+5
    1FBC 940E2673  CALL	_itoa
    1FBE C0CB      RJMP	0x208A
    1FBF 8808      LDD	R0,Y+16
    1FC0 8819      LDD	R1,Y+17
    1FC1 FE01      SBRS	R0,1
    1FC2 C013      RJMP	0x1FD6
    1FC3 A18F      LDD	R24,Y+39
    1FC4 A598      LDD	R25,Y+40
    1FC5 9604      ADIW	R24,4
    1FC6 A798      STD	Y+40,R25
    1FC7 A38F      STD	Y+39,R24
    1FC8 2FE8      MOV	R30,R24
    1FC9 2FF9      MOV	R31,R25
    1FCA 9734      SBIW	R30,4
    1FCB 8020      LDD	R2,Z+0
    1FCC 8031      LDD	R3,Z+1
    1FCD 8042      LDD	R4,Z+2
    1FCE 8053      LDD	R5,Z+3
    1FCF 2FEC      MOV	R30,R28
    1FD0 2FFD      MOV	R31,R29
    1FD1 8620      STD	Z+8,R2
    1FD2 8631      STD	Z+9,R3
    1FD3 8642      STD	Z+10,R4
    1FD4 8653      STD	Z+11,R5
    1FD5 C00C      RJMP	0x1FE2
    1FD6 A18F      LDD	R24,Y+39
    1FD7 A598      LDD	R25,Y+40
    1FD8 9602      ADIW	R24,2
    1FD9 A798      STD	Y+40,R25
    1FDA A38F      STD	Y+39,R24
    1FDB 2FE8      MOV	R30,R24
    1FDC 2FF9      MOV	R31,R25
    1FDD 9732      SBIW	R30,2
    1FDE 8020      LDD	R2,Z+0
    1FDF 8031      LDD	R3,Z+1
    1FE0 823F      STD	Y+7,R3
    1FE1 822E      STD	Y+6,R2
    1FE2 A1ED      LDD	R30,Y+37
    1FE3 A1FE      LDD	R31,Y+38
    1FE4 8180      LDD	R24,Z+0
    1FE5 3785      CPI	R24,0x75
    1FE6 F511      BNE	0x2009
    1FE7 8808      LDD	R0,Y+16
    1FE8 8819      LDD	R1,Y+17
    1FE9 FE01      SBRS	R0,1
    1FEA C013      RJMP	0x1FFE
    1FEB E08A      LDI	R24,0xA
    1FEC E090      LDI	R25,0
    1FED 839B      STD	Y+3,R25
    1FEE 838A      STD	Y+2,R24
    1FEF 2FEC      MOV	R30,R28
    1FF0 2FFD      MOV	R31,R29
    1FF1 8420      LDD	R2,Z+8
    1FF2 8431      LDD	R3,Z+9
    1FF3 8442      LDD	R4,Z+10
    1FF4 8453      LDD	R5,Z+11
    1FF5 8248      STD	Y+0,R4
    1FF6 8259      STD	Y+1,R5
    1FF7 2D22      MOV	R18,R2
    1FF8 2D33      MOV	R19,R3
    1FF9 810C      LDD	R16,Y+4
    1FFA 811D      LDD	R17,Y+5
    1FFB 940E276A  CALL	_ultoa
    1FFD C08C      RJMP	0x208A
    1FFE E08A      LDI	R24,0xA
    1FFF E090      LDI	R25,0
    2000 8399      STD	Y+1,R25
    2001 8388      STD	Y+0,R24
    2002 812E      LDD	R18,Y+6
    2003 813F      LDD	R19,Y+7
    2004 810C      LDD	R16,Y+4
    2005 811D      LDD	R17,Y+5
    2006 940E27DC  CALL	_utoa
    2008 C081      RJMP	0x208A
    2009 A1ED      LDD	R30,Y+37
    200A A1FE      LDD	R31,Y+38
    200B 8180      LDD	R24,Z+0
    200C 368F      CPI	R24,0x6F
    200D F561      BNE	0x203A
    200E 8808      LDD	R0,Y+16
    200F 8819      LDD	R1,Y+17
    2010 FE00      SBRS	R0,0
    2011 C006      RJMP	0x2018
    2012 E380      LDI	R24,0x30
    2013 81EC      LDD	R30,Y+4
    2014 81FD      LDD	R31,Y+5
    2015 9381      ST	R24,Z+
    2016 83FD      STD	Y+5,R31
    2017 83EC      STD	Y+4,R30
    2018 8808      LDD	R0,Y+16
    2019 8819      LDD	R1,Y+17
    201A FE01      SBRS	R0,1
    201B C013      RJMP	0x202F
    201C E088      LDI	R24,0x8
    201D E090      LDI	R25,0
    201E 839B      STD	Y+3,R25
    201F 838A      STD	Y+2,R24
    2020 2FEC      MOV	R30,R28
    2021 2FFD      MOV	R31,R29
    2022 8420      LDD	R2,Z+8
    2023 8431      LDD	R3,Z+9
    2024 8442      LDD	R4,Z+10
    2025 8453      LDD	R5,Z+11
    2026 8248      STD	Y+0,R4
    2027 8259      STD	Y+1,R5
    2028 2D22      MOV	R18,R2
    2029 2D33      MOV	R19,R3
    202A 810C      LDD	R16,Y+4
    202B 811D      LDD	R17,Y+5
    202C 940E276A  CALL	_ultoa
    202E C05B      RJMP	0x208A
    202F E088      LDI	R24,0x8
    2030 E090      LDI	R25,0
    2031 8399      STD	Y+1,R25
    2032 8388      STD	Y+0,R24
    2033 812E      LDD	R18,Y+6
    2034 813F      LDD	R19,Y+7
    2035 810C      LDD	R16,Y+4
    2036 811D      LDD	R17,Y+5
    2037 940E27DC  CALL	_utoa
    2039 C050      RJMP	0x208A
    203A 8808      LDD	R0,Y+16
    203B 8819      LDD	R1,Y+17
    203C FE00      SBRS	R0,0
    203D C00E      RJMP	0x204C
    203E E380      LDI	R24,0x30
    203F 81EC      LDD	R30,Y+4
    2040 81FD      LDD	R31,Y+5
    2041 9381      ST	R24,Z+
    2042 83FD      STD	Y+5,R31
    2043 83EC      STD	Y+4,R30
    2044 A1ED      LDD	R30,Y+37
    2045 A1FE      LDD	R31,Y+38
    2046 8020      LDD	R2,Z+0
    2047 81EC      LDD	R30,Y+4
    2048 81FD      LDD	R31,Y+5
    2049 9221      ST	R2,Z+
    204A 83FD      STD	Y+5,R31
    204B 83EC      STD	Y+4,R30
    204C 8808      LDD	R0,Y+16
    204D 8819      LDD	R1,Y+17
    204E FE01      SBRS	R0,1
    204F C013      RJMP	0x2063
    2050 E180      LDI	R24,0x10
    2051 E090      LDI	R25,0
    2052 839B      STD	Y+3,R25
    2053 838A      STD	Y+2,R24
    2054 2FEC      MOV	R30,R28
    2055 2FFD      MOV	R31,R29
    2056 8420      LDD	R2,Z+8
    2057 8431      LDD	R3,Z+9
    2058 8442      LDD	R4,Z+10
    2059 8453      LDD	R5,Z+11
    205A 8248      STD	Y+0,R4
    205B 8259      STD	Y+1,R5
    205C 2D22      MOV	R18,R2
    205D 2D33      MOV	R19,R3
    205E 810C      LDD	R16,Y+4
    205F 811D      LDD	R17,Y+5
    2060 940E276A  CALL	_ultoa
    2062 C00A      RJMP	0x206D
    2063 E180      LDI	R24,0x10
    2064 E090      LDI	R25,0
    2065 8399      STD	Y+1,R25
    2066 8388      STD	Y+0,R24
    2067 812E      LDD	R18,Y+6
    2068 813F      LDD	R19,Y+7
    2069 810C      LDD	R16,Y+4
    206A 811D      LDD	R17,Y+5
    206B 940E27DC  CALL	_utoa
    206D A1ED      LDD	R30,Y+37
    206E A1FE      LDD	R31,Y+38
    206F 8180      LDD	R24,Z+0
    2070 3588      CPI	R24,0x58
    2071 F4C1      BNE	0x208A
    2072 E18C      LDI	R24,0x1C
    2073 E09F      LDI	R25,0xF
    2074 2EE8      MOV	R14,R24
    2075 2EF9      MOV	R15,R25
    2076 C00E      RJMP	0x2085
    2077 2DEE      MOV	R30,R14
    2078 2DFF      MOV	R31,R15
    2079 8100      LDD	R16,Z+0
    207A 2711      CLR	R17
    207B 940E2842  CALL	_toupper
    207D 2DEE      MOV	R30,R14
    207E 2DFF      MOV	R31,R15
    207F 8300      STD	Z+0,R16
    2080 2D8E      MOV	R24,R14
    2081 2D9F      MOV	R25,R15
    2082 9601      ADIW	R24,1
    2083 2EE8      MOV	R14,R24
    2084 2EF9      MOV	R15,R25
    2085 2DEE      MOV	R30,R14
    2086 2DFF      MOV	R31,R15
    2087 8020      LDD	R2,Z+0
    2088 2022      TST	R2
    2089 F769      BNE	0x2077
    208A E18C      LDI	R24,0x1C
    208B E09F      LDI	R25,0xF
    208C 2EE8      MOV	R14,R24
    208D 2EF9      MOV	R15,R25
    208E 898E      LDD	R24,Y+22
    208F 899F      LDD	R25,Y+23
    2090 3F8F      CPI	R24,0xFF
    2091 EFEF      LDI	R30,0xFF
    2092 079E      CPC	R25,R30
    2093 F421      BNE	0x2098
    2094 2400      CLR	R0
    2095 2411      CLR	R1
    2096 8A1F      STD	Y+23,R1
    2097 8A0E      STD	Y+22,R0
    2098 880E      LDD	R0,Y+22
    2099 881F      LDD	R1,Y+23
    209A 2000      TST	R0
    209B F419      BNE	0x209F
    209C 2011      TST	R1
    209D F409      BNE	0x209F
    209E C11D      RJMP	0x21BC
    209F E10C      LDI	R16,0x1C
    20A0 E01F      LDI	R17,0xF
    20A1 940E22C3  CALL	_strlen
    20A3 831F      STD	Y+7,R17
    20A4 830E      STD	Y+6,R16
    20A5 2E20      MOV	R2,R16
    20A6 2E31      MOV	R3,R17
    20A7 880E      LDD	R0,Y+22
    20A8 881F      LDD	R1,Y+23
    20A9 1600      CP	R0,R16
    20AA 0611      CPC	R1,R17
    20AB F00C      BLT	0x20AD
    20AC C10F      RJMP	0x21BC
    20AD 8A3F      STD	Y+23,R3
    20AE 8A2E      STD	Y+22,R2
    20AF C10C      RJMP	0x21BC
    20B0 A18F      LDD	R24,Y+39
    20B1 A598      LDD	R25,Y+40
    20B2 9602      ADIW	R24,2
    20B3 A798      STD	Y+40,R25
    20B4 A38F      STD	Y+39,R24
    20B5 2FE8      MOV	R30,R24
    20B6 2FF9      MOV	R31,R25
    20B7 9732      SBIW	R30,2
    20B8 8020      LDD	R2,Z+0
    20B9 8031      LDD	R3,Z+1
    20BA 862C      STD	Y+12,R2
    20BB E081      LDI	R24,1
    20BC E090      LDI	R25,0
    20BD 880A      LDD	R0,Y+18
    20BE 881B      LDD	R1,Y+19
    20BF 1580      CP	R24,R0
    20C0 0591      CPC	R25,R1
    20C1 F454      BGE	0x20CC
    20C2 8A1F      STD	Y+23,R1
    20C3 8A0E      STD	Y+22,R0
    20C4 2422      CLR	R2
    20C5 862D      STD	Y+13,R2
    20C6 2F8C      MOV	R24,R28
    20C7 2F9D      MOV	R25,R29
    20C8 960C      ADIW	R24,0xC
    20C9 2EE8      MOV	R14,R24
    20CA 2EF9      MOV	R15,R25
    20CB C0F0      RJMP	0x21BC
    20CC 850C      LDD	R16,Y+12
    20CD A1EB      LDD	R30,Y+35
    20CE A1FC      LDD	R31,Y+36
    20CF 940E23F1  CALL	xicall
    20D1 898C      LDD	R24,Y+20
    20D2 899D      LDD	R25,Y+21
    20D3 9601      ADIW	R24,1
    20D4 8B9D      STD	Y+21,R25
    20D5 8B8C      STD	Y+20,R24
    20D6 C1B2      RJMP	0x2289
    20D7 A18F      LDD	R24,Y+39
    20D8 A598      LDD	R25,Y+40
    20D9 9602      ADIW	R24,2
    20DA A798      STD	Y+40,R25
    20DB A38F      STD	Y+39,R24
    20DC 2FE8      MOV	R30,R24
    20DD 2FF9      MOV	R31,R25
    20DE 9732      SBIW	R30,2
    20DF 80A0      LDD	R10,Z+0
    20E0 80B1      LDD	R11,Z+1
    20E1 898E      LDD	R24,Y+22
    20E2 899F      LDD	R25,Y+23
    20E3 3F8F      CPI	R24,0xFF
    20E4 EFEF      LDI	R30,0xFF
    20E5 079E      CPC	R25,R30
    20E6 F421      BNE	0x20EB
    20E7 2400      CLR	R0
    20E8 2411      CLR	R1
    20E9 8A1F      STD	Y+23,R1
    20EA 8A0E      STD	Y+22,R0
    20EB 880A      LDD	R0,Y+18
    20EC 881B      LDD	R1,Y+19
    20ED 2000      TST	R0
    20EE F411      BNE	0x20F1
    20EF 2011      TST	R1
    20F0 F051      BEQ	0x20FB
    20F1 2D0A      MOV	R16,R10
    20F2 2D1B      MOV	R17,R11
    20F3 940E2464  CALL	_cstrlen
    20F5 884A      LDD	R4,Y+18
    20F6 885B      LDD	R5,Y+19
    20F7 1A40      SUB	R4,R16
    20F8 0A51      SBC	R5,R17
    20F9 8A5B      STD	Y+19,R5
    20FA 8A4A      STD	Y+18,R4
    20FB 880E      LDD	R0,Y+22
    20FC 881F      LDD	R1,Y+23
    20FD 2000      TST	R0
    20FE F441      BNE	0x2107
    20FF 2011      TST	R1
    2100 F431      BNE	0x2107
    2101 2D0A      MOV	R16,R10
    2102 2D1B      MOV	R17,R11
    2103 940E2464  CALL	_cstrlen
    2105 8B1F      STD	Y+23,R17
    2106 8B0E      STD	Y+22,R16
    2107 880A      LDD	R0,Y+18
    2108 881B      LDD	R1,Y+19
    2109 2000      TST	R0
    210A F411      BNE	0x210D
    210B 2011      TST	R1
    210C F049      BEQ	0x2116
    210D 8808      LDD	R0,Y+16
    210E 8819      LDD	R1,Y+17
    210F FE03      SBRS	R0,3
    2110 C005      RJMP	0x2116
    2111 898A      LDD	R24,Y+18
    2112 899B      LDD	R25,Y+19
    2113 9701      SBIW	R24,1
    2114 8B9B      STD	Y+19,R25
    2115 8B8A      STD	Y+18,R24
    2116 8808      LDD	R0,Y+16
    2117 8819      LDD	R1,Y+17
    2118 FE04      SBRS	R0,4
    2119 C028      RJMP	0x2142
    211A FE03      SBRS	R0,3
    211B C00A      RJMP	0x2126
    211C 8D08      LDD	R16,Y+24
    211D A1EB      LDD	R30,Y+35
    211E A1FC      LDD	R31,Y+36
    211F 940E23F1  CALL	xicall
    2121 898C      LDD	R24,Y+20
    2122 899D      LDD	R25,Y+21
    2123 9601      ADIW	R24,1
    2124 8B9D      STD	Y+21,R25
    2125 8B8C      STD	Y+20,R24
    2126 8808      LDD	R0,Y+16
    2127 8819      LDD	R1,Y+17
    2128 FC02      SBRC	R0,2
    2129 C054      RJMP	0x217E
    212A C00F      RJMP	0x213A
    212B E300      LDI	R16,0x30
    212C A1EB      LDD	R30,Y+35
    212D A1FC      LDD	R31,Y+36
    212E 940E23F1  CALL	xicall
    2130 898C      LDD	R24,Y+20
    2131 899D      LDD	R25,Y+21
    2132 9601      ADIW	R24,1
    2133 8B9D      STD	Y+21,R25
    2134 8B8C      STD	Y+20,R24
    2135 898A      LDD	R24,Y+18
    2136 899B      LDD	R25,Y+19
    2137 9701      SBIW	R24,1
    2138 8B9B      STD	Y+19,R25
    2139 8B8A      STD	Y+18,R24
    213A 2422      CLR	R2
    213B 2433      CLR	R3
    213C 880A      LDD	R0,Y+18
    213D 881B      LDD	R1,Y+19
    213E 1420      CP	R2,R0
    213F 0431      CPC	R3,R1
    2140 F354      BLT	0x212B
    2141 C03C      RJMP	0x217E
    2142 8808      LDD	R0,Y+16
    2143 8819      LDD	R1,Y+17
    2144 FC02      SBRC	R0,2
    2145 C017      RJMP	0x215D
    2146 C00F      RJMP	0x2156
    2147 E200      LDI	R16,0x20
    2148 A1EB      LDD	R30,Y+35
    2149 A1FC      LDD	R31,Y+36
    214A 940E23F1  CALL	xicall
    214C 898C      LDD	R24,Y+20
    214D 899D      LDD	R25,Y+21
    214E 9601      ADIW	R24,1
    214F 8B9D      STD	Y+21,R25
    2150 8B8C      STD	Y+20,R24
    2151 898A      LDD	R24,Y+18
    2152 899B      LDD	R25,Y+19
    2153 9701      SBIW	R24,1
    2154 8B9B      STD	Y+19,R25
    2155 8B8A      STD	Y+18,R24
    2156 2422      CLR	R2
    2157 2433      CLR	R3
    2158 880A      LDD	R0,Y+18
    2159 881B      LDD	R1,Y+19
    215A 1420      CP	R2,R0
    215B 0431      CPC	R3,R1
    215C F354      BLT	0x2147
    215D 8808      LDD	R0,Y+16
    215E 8819      LDD	R1,Y+17
    215F FE03      SBRS	R0,3
    2160 C01D      RJMP	0x217E
    2161 8D08      LDD	R16,Y+24
    2162 A1EB      LDD	R30,Y+35
    2163 A1FC      LDD	R31,Y+36
    2164 940E23F1  CALL	xicall
    2166 898C      LDD	R24,Y+20
    2167 899D      LDD	R25,Y+21
    2168 9601      ADIW	R24,1
    2169 8B9D      STD	Y+21,R25
    216A 8B8C      STD	Y+20,R24
    216B C012      RJMP	0x217E
    216C 2DEA      MOV	R30,R10
    216D 2DFB      MOV	R31,R11
    216E 95C8      LPM
    216F 2D00      MOV	R16,R0
    2170 A1EB      LDD	R30,Y+35
    2171 A1FC      LDD	R31,Y+36
    2172 940E23F1  CALL	xicall
    2174 898C      LDD	R24,Y+20
    2175 899D      LDD	R25,Y+21
    2176 9601      ADIW	R24,1
    2177 8B9D      STD	Y+21,R25
    2178 8B8C      STD	Y+20,R24
    2179 2D8A      MOV	R24,R10
    217A 2D9B      MOV	R25,R11
    217B 9601      ADIW	R24,1
    217C 2EA8      MOV	R10,R24
    217D 2EB9      MOV	R11,R25
    217E 2DEA      MOV	R30,R10
    217F 2DFB      MOV	R31,R11
    2180 95C8      LPM
    2181 2000      TST	R0
    2182 F059      BEQ	0x218E
    2183 882E      LDD	R2,Y+22
    2184 883F      LDD	R3,Y+23
    2185 2D82      MOV	R24,R2
    2186 2D93      MOV	R25,R3
    2187 9701      SBIW	R24,1
    2188 8B9F      STD	Y+23,R25
    2189 8B8E      STD	Y+22,R24
    218A 2022      TST	R2
    218B F701      BNE	0x216C
    218C 2033      TST	R3
    218D F6F1      BNE	0x216C
    218E 8808      LDD	R0,Y+16
    218F 8819      LDD	R1,Y+17
    2190 FE02      SBRS	R0,2
    2191 C0F7      RJMP	0x2289
    2192 C00F      RJMP	0x21A2
    2193 E200      LDI	R16,0x20
    2194 A1EB      LDD	R30,Y+35
    2195 A1FC      LDD	R31,Y+36
    2196 940E23F1  CALL	xicall
    2198 898C      LDD	R24,Y+20
    2199 899D      LDD	R25,Y+21
    219A 9601      ADIW	R24,1
    219B 8B9D      STD	Y+21,R25
    219C 8B8C      STD	Y+20,R24
    219D 898A      LDD	R24,Y+18
    219E 899B      LDD	R25,Y+19
    219F 9701      SBIW	R24,1
    21A0 8B9B      STD	Y+19,R25
    21A1 8B8A      STD	Y+18,R24
    21A2 2422      CLR	R2
    21A3 2433      CLR	R3
    21A4 880A      LDD	R0,Y+18
    21A5 881B      LDD	R1,Y+19
    21A6 1420      CP	R2,R0
    21A7 0431      CPC	R3,R1
    21A8 F354      BLT	0x2193
    21A9 C0DF      RJMP	0x2289
    21AA A18F      LDD	R24,Y+39
    21AB A598      LDD	R25,Y+40
    21AC 9602      ADIW	R24,2
    21AD A798      STD	Y+40,R25
    21AE A38F      STD	Y+39,R24
    21AF 2FE8      MOV	R30,R24
    21B0 2FF9      MOV	R31,R25
    21B1 9732      SBIW	R30,2
    21B2 80E0      LDD	R14,Z+0
    21B3 80F1      LDD	R15,Z+1
    21B4 20EE      TST	R14
    21B5 F431      BNE	0x21BC
    21B6 20FF      TST	R15
    21B7 F421      BNE	0x21BC
    21B8 E38D      LDI	R24,0x3D
    21B9 E09E      LDI	R25,0xE
    21BA 2EE8      MOV	R14,R24
    21BB 2EF9      MOV	R15,R25
    21BC 898E      LDD	R24,Y+22
    21BD 899F      LDD	R25,Y+23
    21BE 3F8F      CPI	R24,0xFF
    21BF EFEF      LDI	R30,0xFF
    21C0 079E      CPC	R25,R30
    21C1 F421      BNE	0x21C6
    21C2 2400      CLR	R0
    21C3 2411      CLR	R1
    21C4 8A1F      STD	Y+23,R1
    21C5 8A0E      STD	Y+22,R0
    21C6 880A      LDD	R0,Y+18
    21C7 881B      LDD	R1,Y+19
    21C8 2000      TST	R0
    21C9 F411      BNE	0x21CC
    21CA 2011      TST	R1
    21CB F051      BEQ	0x21D6
    21CC 2D0E      MOV	R16,R14
    21CD 2D1F      MOV	R17,R15
    21CE 940E22C3  CALL	_strlen
    21D0 884A      LDD	R4,Y+18
    21D1 885B      LDD	R5,Y+19
    21D2 1A40      SUB	R4,R16
    21D3 0A51      SBC	R5,R17
    21D4 8A5B      STD	Y+19,R5
    21D5 8A4A      STD	Y+18,R4
    21D6 880E      LDD	R0,Y+22
    21D7 881F      LDD	R1,Y+23
    21D8 2000      TST	R0
    21D9 F441      BNE	0x21E2
    21DA 2011      TST	R1
    21DB F431      BNE	0x21E2
    21DC 2D0E      MOV	R16,R14
    21DD 2D1F      MOV	R17,R15
    21DE 940E22C3  CALL	_strlen
    21E0 8B1F      STD	Y+23,R17
    21E1 8B0E      STD	Y+22,R16
    21E2 880A      LDD	R0,Y+18
    21E3 881B      LDD	R1,Y+19
    21E4 2000      TST	R0
    21E5 F411      BNE	0x21E8
    21E6 2011      TST	R1
    21E7 F049      BEQ	0x21F1
    21E8 8808      LDD	R0,Y+16
    21E9 8819      LDD	R1,Y+17
    21EA FE03      SBRS	R0,3
    21EB C005      RJMP	0x21F1
    21EC 898A      LDD	R24,Y+18
    21ED 899B      LDD	R25,Y+19
    21EE 9701      SBIW	R24,1
    21EF 8B9B      STD	Y+19,R25
    21F0 8B8A      STD	Y+18,R24
    21F1 8808      LDD	R0,Y+16
    21F2 8819      LDD	R1,Y+17
    21F3 FE04      SBRS	R0,4
    21F4 C028      RJMP	0x221D
    21F5 FE03      SBRS	R0,3
    21F6 C00A      RJMP	0x2201
    21F7 8D08      LDD	R16,Y+24
    21F8 A1EB      LDD	R30,Y+35
    21F9 A1FC      LDD	R31,Y+36
    21FA 940E23F1  CALL	xicall
    21FC 898C      LDD	R24,Y+20
    21FD 899D      LDD	R25,Y+21
    21FE 9601      ADIW	R24,1
    21FF 8B9D      STD	Y+21,R25
    2200 8B8C      STD	Y+20,R24
    2201 8808      LDD	R0,Y+16
    2202 8819      LDD	R1,Y+17
    2203 FC02      SBRC	R0,2
    2204 C053      RJMP	0x2258
    2205 C00F      RJMP	0x2215
    2206 E300      LDI	R16,0x30
    2207 A1EB      LDD	R30,Y+35
    2208 A1FC      LDD	R31,Y+36
    2209 940E23F1  CALL	xicall
    220B 898C      LDD	R24,Y+20
    220C 899D      LDD	R25,Y+21
    220D 9601      ADIW	R24,1
    220E 8B9D      STD	Y+21,R25
    220F 8B8C      STD	Y+20,R24
    2210 898A      LDD	R24,Y+18
    2211 899B      LDD	R25,Y+19
    2212 9701      SBIW	R24,1
    2213 8B9B      STD	Y+19,R25
    2214 8B8A      STD	Y+18,R24
    2215 2422      CLR	R2
    2216 2433      CLR	R3
    2217 880A      LDD	R0,Y+18
    2218 881B      LDD	R1,Y+19
    2219 1420      CP	R2,R0
    221A 0431      CPC	R3,R1
    221B F354      BLT	0x2206
    221C C03B      RJMP	0x2258
    221D 8808      LDD	R0,Y+16
    221E 8819      LDD	R1,Y+17
    221F FC02      SBRC	R0,2
    2220 C017      RJMP	0x2238
    2221 C00F      RJMP	0x2231
    2222 E200      LDI	R16,0x20
    2223 A1EB      LDD	R30,Y+35
    2224 A1FC      LDD	R31,Y+36
    2225 940E23F1  CALL	xicall
    2227 898C      LDD	R24,Y+20
    2228 899D      LDD	R25,Y+21
    2229 9601      ADIW	R24,1
    222A 8B9D      STD	Y+21,R25
    222B 8B8C      STD	Y+20,R24
    222C 898A      LDD	R24,Y+18
    222D 899B      LDD	R25,Y+19
    222E 9701      SBIW	R24,1
    222F 8B9B      STD	Y+19,R25
    2230 8B8A      STD	Y+18,R24
    2231 2422      CLR	R2
    2232 2433      CLR	R3
    2233 880A      LDD	R0,Y+18
    2234 881B      LDD	R1,Y+19
    2235 1420      CP	R2,R0
    2236 0431      CPC	R3,R1
    2237 F354      BLT	0x2222
    2238 8808      LDD	R0,Y+16
    2239 8819      LDD	R1,Y+17
    223A FE03      SBRS	R0,3
    223B C01C      RJMP	0x2258
    223C 8D08      LDD	R16,Y+24
    223D A1EB      LDD	R30,Y+35
    223E A1FC      LDD	R31,Y+36
    223F 940E23F1  CALL	xicall
    2241 898C      LDD	R24,Y+20
    2242 899D      LDD	R25,Y+21
    2243 9601      ADIW	R24,1
    2244 8B9D      STD	Y+21,R25
    2245 8B8C      STD	Y+20,R24
    2246 C011      RJMP	0x2258
    2247 2DEE      MOV	R30,R14
    2248 2DFF      MOV	R31,R15
    2249 8100      LDD	R16,Z+0
    224A A1EB      LDD	R30,Y+35
    224B A1FC      LDD	R31,Y+36
    224C 940E23F1  CALL	xicall
    224E 898C      LDD	R24,Y+20
    224F 899D      LDD	R25,Y+21
    2250 9601      ADIW	R24,1
    2251 8B9D      STD	Y+21,R25
    2252 8B8C      STD	Y+20,R24
    2253 2D8E      MOV	R24,R14
    2254 2D9F      MOV	R25,R15
    2255 9601      ADIW	R24,1
    2256 2EE8      MOV	R14,R24
    2257 2EF9      MOV	R15,R25
    2258 2DEE      MOV	R30,R14
    2259 2DFF      MOV	R31,R15
    225A 8020      LDD	R2,Z+0
    225B 2022      TST	R2
    225C F059      BEQ	0x2268
    225D 882E      LDD	R2,Y+22
    225E 883F      LDD	R3,Y+23
    225F 2D82      MOV	R24,R2
    2260 2D93      MOV	R25,R3
    2261 9701      SBIW	R24,1
    2262 8B9F      STD	Y+23,R25
    2263 8B8E      STD	Y+22,R24
    2264 2022      TST	R2
    2265 F709      BNE	0x2247
    2266 2033      TST	R3
    2267 F6F9      BNE	0x2247
    2268 8808      LDD	R0,Y+16
    2269 8819      LDD	R1,Y+17
    226A FE02      SBRS	R0,2
    226B C01D      RJMP	0x2289
    226C C00F      RJMP	0x227C
    226D E200      LDI	R16,0x20
    226E A1EB      LDD	R30,Y+35
    226F A1FC      LDD	R31,Y+36
    2270 940E23F1  CALL	xicall
    2272 898C      LDD	R24,Y+20
    2273 899D      LDD	R25,Y+21
    2274 9601      ADIW	R24,1
    2275 8B9D      STD	Y+21,R25
    2276 8B8C      STD	Y+20,R24
    2277 898A      LDD	R24,Y+18
    2278 899B      LDD	R25,Y+19
    2279 9701      SBIW	R24,1
    227A 8B9B      STD	Y+19,R25
    227B 8B8A      STD	Y+18,R24
    227C 2422      CLR	R2
    227D 2433      CLR	R3
    227E 880A      LDD	R0,Y+18
    227F 881B      LDD	R1,Y+19
    2280 1420      CP	R2,R0
    2281 0431      CPC	R3,R1
    2282 F354      BLT	0x226D
    2283 C005      RJMP	0x2289
    2284 ED8A      LDI	R24,0xDA
    2285 E09D      LDI	R25,0xD
    2286 2EE8      MOV	R14,R24
    2287 2EF9      MOV	R15,R25
    2288 CF33      RJMP	0x21BC
    2289 A18D      LDD	R24,Y+37
    228A A19E      LDD	R25,Y+38
    228B 9601      ADIW	R24,1
    228C A39E      STD	Y+38,R25
    228D A38D      STD	Y+37,R24
    228E A1ED      LDD	R30,Y+37
    228F A1FE      LDD	R31,Y+38
    2290 8020      LDD	R2,Z+0
    2291 2022      TST	R2
    2292 F009      BEQ	0x2294
    2293 CB46      RJMP	0x1DDA
    2294 890C      LDD	R16,Y+20
    2295 891D      LDD	R17,Y+21
    2296 9669      ADIW	R28,0x19
    2297 940E23CF  CALL	pop_gset5
    2299 9624      ADIW	R28,4
    229A 9508      RET
_abs:
    229B FF17      SBRS	R17,7
    229C 9508      RET
    229D 9510      COM	R17
    229E 9501      NEG	R16
    229F 4F1F      SBCI	R17,0xFF
    22A0 9508      RET
_memcpy:
    22A1 2FA0      MOV	R26,R16
    22A2 2FB1      MOV	R27,R17
    22A3 2FE2      MOV	R30,R18
    22A4 2FF3      MOV	R31,R19
    22A5 8188      LDD	R24,Y+0
    22A6 8199      LDD	R25,Y+1
    22A7 3080      CPI	R24,0
    22A8 0798      CPC	R25,R24
    22A9 C003      RJMP	0x22AD
    22AA 9001      LD	R0,Z+
    22AB 920D      ST	R0,X+
    22AC 9701      SBIW	R24,1
    22AD F7E1      BNE	0x22AA
    22AE 9508      RET
_memset:
    22AF 8188      LDD	R24,Y+0
    22B0 8199      LDD	R25,Y+1
    22B1 3080      CPI	R24,0
    22B2 0789      CPC	R24,R25
    22B3 F029      BEQ	0x22B9
    22B4 2FE0      MOV	R30,R16
    22B5 2FF1      MOV	R31,R17
    22B6 9321      ST	R18,Z+
    22B7 9701      SBIW	R24,1
    22B8 F7E9      BNE	0x22B6
    22B9 9508      RET
_strcpy:
    22BA 2FA0      MOV	R26,R16
    22BB 2FB1      MOV	R27,R17
    22BC 2FE2      MOV	R30,R18
    22BD 2FF3      MOV	R31,R19
    22BE 9001      LD	R0,Z+
    22BF 920D      ST	R0,X+
    22C0 2000      TST	R0
    22C1 F7E1      BNE	0x22BE
    22C2 9508      RET
_strlen:
    22C3 2FE0      MOV	R30,R16
    22C4 2FF1      MOV	R31,R17
    22C5 27AA      CLR	R26
    22C6 27BB      CLR	R27
    22C7 9001      LD	R0,Z+
    22C8 2000      TST	R0
    22C9 F011      BEQ	0x22CC
    22CA 9611      ADIW	R26,1
    22CB CFFB      RJMP	0x22C7
    22CC 2F0A      MOV	R16,R26
    22CD 2F1B      MOV	R17,R27
    22CE 9508      RET
push_arg4:
    22CF 933A      ST	R19,-Y
    22D0 932A      ST	R18,-Y
push_arg2:
    22D1 931A      ST	R17,-Y
    22D2 930A      ST	R16,-Y
    22D3 9508      RET
asr16:
    22D4 2322      TST	R18
    22D5 F021      BEQ	0x22DA
    22D6 9515      ASR	R17
    22D7 9507      ROR	R16
    22D8 952A      DEC	R18
    22D9 CFFA      RJMP	asr16
    22DA 9508      RET
mod16s:
    22DB 9468      BSET	6
    22DC 92DA      ST	R13,-Y
    22DD 2ED1      MOV	R13,R17
    22DE C004      RJMP	0x22E3
div16s:
    22DF 94E8      BCLR	6
    22E0 92DA      ST	R13,-Y
    22E1 2ED1      MOV	R13,R17
    22E2 26D3      EOR	R13,R19
    22E3 FF17      SBRS	R17,7
    22E4 C004      RJMP	0x22E9
    22E5 9510      COM	R17
    22E6 9500      COM	R16
    22E7 5F0F      SUBI	R16,0xFF
    22E8 4F1F      SBCI	R17,0xFF
    22E9 FF37      SBRS	R19,7
    22EA C004      RJMP	0x22EF
    22EB 9530      COM	R19
    22EC 9520      COM	R18
    22ED 5F2F      SUBI	R18,0xFF
    22EE 4F3F      SBCI	R19,0xFF
    22EF 940E22FC  CALL	xdiv16u
    22F1 FED7      SBRS	R13,7
    22F2 C004      RJMP	0x22F7
    22F3 9510      COM	R17
    22F4 9500      COM	R16
    22F5 5F0F      SUBI	R16,0xFF
    22F6 4F1F      SBCI	R17,0xFF
    22F7 90D9      LD	R13,Y+
    22F8 9508      RET
mod16u:
    22F9 9468      BSET	6
    22FA C001      RJMP	xdiv16u
div16u:
    22FB 94E8      BCLR	6
xdiv16u:
    22FC 92EA      ST	R14,-Y
    22FD 92FA      ST	R15,-Y
    22FE 938A      ST	R24,-Y
    22FF 24EE      CLR	R14
    2300 24FF      CLR	R15
    2301 E180      LDI	R24,0x10
    2302 0F00      LSL	R16
    2303 1F11      ROL	R17
    2304 1CEE      ROL	R14
    2305 1CFF      ROL	R15
    2306 16E2      CP	R14,R18
    2307 06F3      CPC	R15,R19
    2308 F018      BCS	0x230C
    2309 1AE2      SUB	R14,R18
    230A 0AF3      SBC	R15,R19
    230B 9503      INC	R16
    230C 958A      DEC	R24
    230D F7A1      BNE	0x2302
    230E F416      BRTC	0x2311
    230F 2D0E      MOV	R16,R14
    2310 2D1F      MOV	R17,R15
    2311 9189      LD	R24,Y+
    2312 90F9      LD	R15,Y+
    2313 90E9      LD	R14,Y+
    2314 9508      RET
div32u:
    2315 94E8      BCLR	6
    2316 C001      RJMP	0x2318
mod32u:
    2317 9468      BSET	6
    2318 D02F      RCALL	long_div_prolog
    2319 24CC      CLR	R12
    231A C008      RJMP	0x2323
div32s:
    231B 94E8      BCLR	6
    231C C001      RJMP	0x231E
mod32s:
    231D 9468      BSET	6
    231E D029      RCALL	long_div_prolog
    231F FD37      SBRC	R19,7
    2320 D053      RCALL	neg_R16_R19
    2321 FDB7      SBRC	R27,7
    2322 D05A      RCALL	neg_R24_R27
    2323 2477      CLR	R7
    2324 2488      CLR	R8
    2325 2499      CLR	R9
    2326 24AA      CLR	R10
    2327 24BB      CLR	R11
    2328 D041      RCALL	tst_R16_R19
    2329 F0C1      BEQ	0x2342
    232A D044      RCALL	tst_R24_R27
    232B F0B1      BEQ	0x2342
    232C E2E8      LDI	R30,0x28
    232D 0F00      LSL	R16
    232E 1F11      ROL	R17
    232F 1F22      ROL	R18
    2330 1F33      ROL	R19
    2331 1C77      ROL	R7
    2332 1C88      ROL	R8
    2333 1C99      ROL	R9
    2334 1CAA      ROL	R10
    2335 1CBB      ROL	R11
    2336 1688      CP	R8,R24
    2337 0699      CPC	R9,R25
    2338 06AA      CPC	R10,R26
    2339 06BB      CPC	R11,R27
    233A F028      BCS	0x2340
    233B 1A88      SUB	R8,R24
    233C 0A99      SBC	R9,R25
    233D 0AAA      SBC	R10,R26
    233E 0ABB      SBC	R11,R27
    233F 9503      INC	R16
    2340 95EA      DEC	R30
    2341 F759      BNE	0x232D
    2342 F426      BRTC	0x2347
    2343 2D08      MOV	R16,R8
    2344 2D19      MOV	R17,R9
    2345 2D2A      MOV	R18,R10
    2346 2D3B      MOV	R19,R11
    2347 C013      RJMP	long_div_epilog
long_div_prolog:
    2348 927A      ST	R7,-Y
    2349 928A      ST	R8,-Y
    234A 929A      ST	R9,-Y
    234B 92AA      ST	R10,-Y
    234C 92BA      ST	R11,-Y
    234D 92CA      ST	R12,-Y
    234E 93EA      ST	R30,-Y
    234F 938A      ST	R24,-Y
    2350 939A      ST	R25,-Y
    2351 93AA      ST	R26,-Y
    2352 93BA      ST	R27,-Y
    2353 858B      LDD	R24,Y+11
    2354 859C      LDD	R25,Y+12
    2355 85AD      LDD	R26,Y+13
    2356 85BE      LDD	R27,Y+14
    2357 2EC3      MOV	R12,R19
    2358 F00E      BRTS	0x235A
    2359 26CB      EOR	R12,R27
    235A 9508      RET
long_div_epilog:
    235B FCC7      SBRC	R12,7
    235C D017      RCALL	neg_R16_R19
    235D 91B9      LD	R27,Y+
    235E 91A9      LD	R26,Y+
    235F 9199      LD	R25,Y+
    2360 9189      LD	R24,Y+
    2361 91E9      LD	R30,Y+
    2362 90C9      LD	R12,Y+
    2363 90B9      LD	R11,Y+
    2364 90A9      LD	R10,Y+
    2365 9099      LD	R9,Y+
    2366 9089      LD	R8,Y+
    2367 9079      LD	R7,Y+
    2368 9624      ADIW	R28,4
    2369 9508      RET
tst_R16_R19:
    236A 2FE0      MOV	R30,R16
    236B 2BE1      OR	R30,R17
    236C 2BE2      OR	R30,R18
    236D 2BE3      OR	R30,R19
    236E 9508      RET
tst_R24_R27:
    236F 2FE8      MOV	R30,R24
    2370 2BE9      OR	R30,R25
    2371 2BEA      OR	R30,R26
    2372 2BEB      OR	R30,R27
    2373 9508      RET
neg_R16_R19:
    2374 9500      COM	R16
    2375 9510      COM	R17
    2376 9520      COM	R18
    2377 9530      COM	R19
    2378 5F0F      SUBI	R16,0xFF
    2379 4F1F      SBCI	R17,0xFF
    237A 4F2F      SBCI	R18,0xFF
    237B 4F3F      SBCI	R19,0xFF
    237C 9508      RET
neg_R24_R27:
    237D 9580      COM	R24
    237E 9590      COM	R25
    237F 95A0      COM	R26
    2380 95B0      COM	R27
    2381 5F8F      SUBI	R24,0xFF
    2382 4F9F      SBCI	R25,0xFF
    2383 4FAF      SBCI	R26,0xFF
    2384 4FBF      SBCI	R27,0xFF
    2385 9508      RET
empy16s:
    2386 920A      ST	R0,-Y
    2387 921A      ST	R1,-Y
    2388 938A      ST	R24,-Y
    2389 939A      ST	R25,-Y
    238A 9F02      MUL	R16,R18
    238B 01C0      MOVW	R24,R0
    238C 9F12      MUL	R17,R18
    238D 0D90      ADD	R25,R0
    238E 9F03      MUL	R16,R19
    238F 0D90      ADD	R25,R0
    2390 018C      MOVW	R16,R24
    2391 9199      LD	R25,Y+
    2392 9189      LD	R24,Y+
    2393 9019      LD	R1,Y+
    2394 9009      LD	R0,Y+
    2395 9508      RET
empy32s:
empy32u:
    2396 940E2403  CALL	long_prolog
    2398 927F      PUSH	R7
    2399 940E241C  CALL	tstzero1
    239B F139      BEQ	0x23C3
    239C 2477      CLR	R7
    239D 940E2422  CALL	tstzero2
    239F F419      BNE	0x23A3
    23A0 018C      MOVW	R16,R24
    23A1 019D      MOVW	R18,R26
    23A2 C020      RJMP	0x23C3
    23A3 9F08      MUL	R16,R24
    23A4 2CB0      MOV	R11,R0
    23A5 2CA1      MOV	R10,R1
    23A6 9F28      MUL	R18,R24
    23A7 2C90      MOV	R9,R0
    23A8 2C81      MOV	R8,R1
    23A9 9F18      MUL	R17,R24
    23AA 0CA0      ADD	R10,R0
    23AB 1C91      ADC	R9,R1
    23AC 1C87      ADC	R8,R7
    23AD 9F09      MUL	R16,R25
    23AE 0CA0      ADD	R10,R0
    23AF 1C91      ADC	R9,R1
    23B0 1C87      ADC	R8,R7
    23B1 9F19      MUL	R17,R25
    23B2 0C90      ADD	R9,R0
    23B3 1C81      ADC	R8,R1
    23B4 9F0A      MUL	R16,R26
    23B5 0C90      ADD	R9,R0
    23B6 1C81      ADC	R8,R1
    23B7 9F38      MUL	R19,R24
    23B8 0C80      ADD	R8,R0
    23B9 9F29      MUL	R18,R25
    23BA 0C80      ADD	R8,R0
    23BB 9F1A      MUL	R17,R26
    23BC 0C80      ADD	R8,R0
    23BD 9F0B      MUL	R16,R27
    23BE 0C80      ADD	R8,R0
    23BF 2D0B      MOV	R16,R11
    23C0 2D1A      MOV	R17,R10
    23C1 2D29      MOV	R18,R9
    23C2 2D38      MOV	R19,R8
    23C3 907F      POP	R7
    23C4 940C2411  JMP	long_epilog
pop_gset2:
    23C6 E0E2      LDI	R30,2
    23C7 940C23DE  JMP	pop
pop_gset3:
    23C9 E0E4      LDI	R30,4
    23CA 940C23DE  JMP	pop
pop_gset4:
    23CC E0E8      LDI	R30,0x8
    23CD 940C23DE  JMP	pop
pop_gset5:
    23CF 27EE      CLR	R30
    23D0 940C23DE  JMP	pop
push_gset5:
    23D2 92FA      ST	R15,-Y
    23D3 92EA      ST	R14,-Y
push_gset4:
    23D4 92DA      ST	R13,-Y
    23D5 92CA      ST	R12,-Y
push_gset3:
    23D6 92BA      ST	R11,-Y
    23D7 92AA      ST	R10,-Y
push_gset2:
    23D8 937A      ST	R23,-Y
    23D9 936A      ST	R22,-Y
push_gset1:
    23DA 935A      ST	R21,-Y
    23DB 934A      ST	R20,-Y
    23DC 9508      RET
pop_gset1:
    23DD E0E1      LDI	R30,1
pop:
    23DE 9149      LD	R20,Y+
    23DF 9159      LD	R21,Y+
    23E0 FDE0      SBRC	R30,0
    23E1 9508      RET
    23E2 9169      LD	R22,Y+
    23E3 9179      LD	R23,Y+
    23E4 FDE1      SBRC	R30,1
    23E5 9508      RET
    23E6 90A9      LD	R10,Y+
    23E7 90B9      LD	R11,Y+
    23E8 FDE2      SBRC	R30,2
    23E9 9508      RET
    23EA 90C9      LD	R12,Y+
    23EB 90D9      LD	R13,Y+
    23EC FDE3      SBRC	R30,3
    23ED 9508      RET
    23EE 90E9      LD	R14,Y+
    23EF 90F9      LD	R15,Y+
    23F0 9508      RET
xicall:
    23F1 920A      ST	R0,-Y
    23F2 95C8      LPM
    23F3 920A      ST	R0,-Y
    23F4 9631      ADIW	R30,1
    23F5 95C8      LPM
    23F6 2DF0      MOV	R31,R0
    23F7 91E9      LD	R30,Y+
    23F8 9009      LD	R0,Y+
    23F9 9409      IJMP
neg32:
    23FA 9500      COM	R16
    23FB 9510      COM	R17
    23FC 9520      COM	R18
    23FD 9530      COM	R19
    23FE 5F0F      SUBI	R16,0xFF
    23FF 4F1F      SBCI	R17,0xFF
    2400 4F2F      SBCI	R18,0xFF
    2401 4F3F      SBCI	R19,0xFF
    2402 9508      RET
long_prolog:
    2403 928A      ST	R8,-Y
    2404 929A      ST	R9,-Y
    2405 92AA      ST	R10,-Y
    2406 92BA      ST	R11,-Y
    2407 93EA      ST	R30,-Y
    2408 938A      ST	R24,-Y
    2409 939A      ST	R25,-Y
    240A 93AA      ST	R26,-Y
    240B 93BA      ST	R27,-Y
    240C 8589      LDD	R24,Y+9
    240D 859A      LDD	R25,Y+10
    240E 85AB      LDD	R26,Y+11
    240F 85BC      LDD	R27,Y+12
    2410 9508      RET
long_epilog:
    2411 91B9      LD	R27,Y+
    2412 91A9      LD	R26,Y+
    2413 9199      LD	R25,Y+
    2414 9189      LD	R24,Y+
    2415 91E9      LD	R30,Y+
    2416 90B9      LD	R11,Y+
    2417 90A9      LD	R10,Y+
    2418 9099      LD	R9,Y+
    2419 9089      LD	R8,Y+
    241A 9624      ADIW	R28,4
    241B 9508      RET
tstzero1:
    241C 27EE      CLR	R30
    241D 2BE0      OR	R30,R16
    241E 2BE1      OR	R30,R17
    241F 2BE2      OR	R30,R18
    2420 2BE3      OR	R30,R19
    2421 9508      RET
tstzero2:
    2422 27EE      CLR	R30
    2423 2BE8      OR	R30,R24
    2424 2BE9      OR	R30,R25
    2425 2BEA      OR	R30,R26
    2426 2BEB      OR	R30,R27
    2427 9508      RET
lsl16:
    2428 2322      TST	R18
    2429 F021      BEQ	0x242E
    242A 0F00      LSL	R16
    242B 1F11      ROL	R17
    242C 952A      DEC	R18
    242D CFFA      RJMP	lsl16
    242E 9508      RET
lsl32:
    242F 920F      PUSH	R0
    2430 9009      LD	R0,Y+
    2431 2000      TST	R0
    2432 F031      BEQ	0x2439
    2433 0F00      LSL	R16
    2434 1F11      ROL	R17
    2435 1F22      ROL	R18
    2436 1F33      ROL	R19
    2437 940A      DEC	R0
    2438 CFF8      RJMP	0x2431
    2439 900F      POP	R0
    243A 9508      RET
lsr32:
    243B 920F      PUSH	R0
    243C 9009      LD	R0,Y+
    243D 2000      TST	R0
    243E F031      BEQ	0x2445
    243F 9536      LSR	R19
    2440 9527      ROR	R18
    2441 9517      ROR	R17
    2442 9507      ROR	R16
    2443 940A      DEC	R0
    2444 CFF8      RJMP	0x243D
    2445 900F      POP	R0
    2446 9508      RET
mpy16s:
    2447 920A      ST	R0,-Y
    2448 921A      ST	R1,-Y
    2449 2400      CLR	R0
    244A 2411      CLR	R1
    244B 3000      CPI	R16,0
    244C 0701      CPC	R16,R17
    244D F041      BEQ	0x2456
    244E 9516      LSR	R17
    244F 9507      ROR	R16
    2450 F410      BCC	0x2453
    2451 0E02      ADD	R0,R18
    2452 1E13      ADC	R1,R19
    2453 0F22      LSL	R18
    2454 1F33      ROL	R19
    2455 CFF5      RJMP	0x244B
    2456 2D00      MOV	R16,R0
    2457 2D11      MOV	R17,R1
    2458 9019      LD	R1,Y+
    2459 9009      LD	R0,Y+
    245A 9508      RET
__va_start:
    245B 2F82      MOV	R24,R18
    245C 2F93      MOV	R25,R19
    245D 9601      ADIW	R24,1
    245E 7F8E      ANDI	R24,0xFE
    245F 0F80      ADD	R24,R16
    2460 1F91      ADC	R25,R17
    2461 2F08      MOV	R16,R24
    2462 2F19      MOV	R17,R25
    2463 9508      RET
_cstrlen:
    2464 2FE0      MOV	R30,R16
    2465 2FF1      MOV	R31,R17
    2466 27AA      CLR	R26
    2467 27BB      CLR	R27
    2468 95C8      LPM
    2469 2000      TST	R0
    246A F019      BEQ	0x246E
    246B 9631      ADIW	R30,1
    246C 9611      ADIW	R26,1
    246D CFFA      RJMP	0x2468
    246E 2F0A      MOV	R16,R26
    246F 2F1B      MOV	R17,R27
    2470 9508      RET
__NewHeap:
    2471 940E23DA  CALL	push_gset1
    2473 2F40      MOV	R20,R16
    2474 2F51      MOV	R21,R17
    2475 90200F35  LDS	R2,__FreeList
    2477 90300F36  LDS	R3,__FreeList+1
    2479 2FE4      MOV	R30,R20
    247A 2FF5      MOV	R31,R21
    247B 8231      STD	Z+1,R3
    247C 8220      STD	Z+0,R2
    247D 93500F36  STS	__FreeList+1,R21
    247F 93400F35  STS	__FreeList,R20
    2481 2F8E      MOV	R24,R30
    2482 2F9F      MOV	R25,R31
    2483 9606      ADIW	R24,6
    2484 2E22      MOV	R2,R18
    2485 2E33      MOV	R3,R19
    2486 1A28      SUB	R2,R24
    2487 0A39      SBC	R3,R25
    2488 8235      STD	Z+5,R3
    2489 8224      STD	Z+4,R2
    248A 2FE4      MOV	R30,R20
    248B 2FF5      MOV	R31,R21
    248C 8333      STD	Z+3,R19
    248D 8322      STD	Z+2,R18
    248E 940E23DD  CALL	pop_gset1
    2490 9508      RET
_calloc:
    2491 940E23D8  CALL	push_gset2
    2493 2F62      MOV	R22,R18
    2494 2F73      MOV	R23,R19
    2495 2F40      MOV	R20,R16
    2496 2F51      MOV	R21,R17
    2497 9722      SBIW	R28,2
    2498 2F24      MOV	R18,R20
    2499 2F35      MOV	R19,R21
    249A 2F06      MOV	R16,R22
    249B 2F17      MOV	R17,R23
    249C 940E2447  CALL	mpy16s
    249E 2F60      MOV	R22,R16
    249F 2F71      MOV	R23,R17
    24A0 D00E      RCALL	_malloc
    24A1 2F40      MOV	R20,R16
    24A2 2F51      MOV	R21,R17
    24A3 8379      STD	Y+1,R23
    24A4 8368      STD	Y+0,R22
    24A5 2722      CLR	R18
    24A6 2733      CLR	R19
    24A7 940E22AF  CALL	_memset
    24A9 2F04      MOV	R16,R20
    24AA 2F15      MOV	R17,R21
    24AB 9622      ADIW	R28,2
    24AC 940E23C6  CALL	pop_gset2
    24AE 9508      RET
_malloc:
    24AF 940E23D4  CALL	push_gset4
    24B1 2F80      MOV	R24,R16
    24B2 2F91      MOV	R25,R17
    24B3 9601      ADIW	R24,1
    24B4 7F8E      ANDI	R24,0xFE
    24B5 2F08      MOV	R16,R24
    24B6 2F19      MOV	R17,R25
    24B7 E345      LDI	R20,0x35
    24B8 E05F      LDI	R21,0xF
    24B9 C071      RJMP	0x252B
    24BA 2DEA      MOV	R30,R10
    24BB 2DFB      MOV	R31,R11
    24BC 8024      LDD	R2,Z+4
    24BD 8035      LDD	R3,Z+5
    24BE 1620      CP	R2,R16
    24BF 0631      CPC	R3,R17
    24C0 F408      BCC	0x24C2
    24C1 C065      RJMP	0x2527
    24C2 2DEA      MOV	R30,R10
    24C3 2DFB      MOV	R31,R11
    24C4 8024      LDD	R2,Z+4
    24C5 8035      LDD	R3,Z+5
    24C6 1A20      SUB	R2,R16
    24C7 0A31      SBC	R3,R17
    24C8 E08E      LDI	R24,0xE
    24C9 E090      LDI	R25,0
    24CA 1582      CP	R24,R2
    24CB 0593      CPC	R25,R3
    24CC F008      BCS	0x24CE
    24CD C044      RJMP	0x2512
    24CE 2F80      MOV	R24,R16
    24CF 2F91      MOV	R25,R17
    24D0 9606      ADIW	R24,6
    24D1 2EC8      MOV	R12,R24
    24D2 2ED9      MOV	R13,R25
    24D3 0CCA      ADD	R12,R10
    24D4 1CDB      ADC	R13,R11
    24D5 2DEA      MOV	R30,R10
    24D6 2DFB      MOV	R31,R11
    24D7 8020      LDD	R2,Z+0
    24D8 8031      LDD	R3,Z+1
    24D9 2DEC      MOV	R30,R12
    24DA 2DFD      MOV	R31,R13
    24DB 8231      STD	Z+1,R3
    24DC 8220      STD	Z+0,R2
    24DD 2F80      MOV	R24,R16
    24DE 2F91      MOV	R25,R17
    24DF 9606      ADIW	R24,6
    24E0 2DEA      MOV	R30,R10
    24E1 2DFB      MOV	R31,R11
    24E2 8024      LDD	R2,Z+4
    24E3 8035      LDD	R3,Z+5
    24E4 1A28      SUB	R2,R24
    24E5 0A39      SBC	R3,R25
    24E6 2DEC      MOV	R30,R12
    24E7 2DFD      MOV	R31,R13
    24E8 8235      STD	Z+5,R3
    24E9 8224      STD	Z+4,R2
    24EA 2D8C      MOV	R24,R12
    24EB 2D9D      MOV	R25,R13
    24EC 9604      ADIW	R24,4
    24ED 2FE8      MOV	R30,R24
    24EE 2FF9      MOV	R31,R25
    24EF 8180      LDD	R24,Z+0
    24F0 8191      LDD	R25,Z+1
    24F1 7F8E      ANDI	R24,0xFE
    24F2 8391      STD	Z+1,R25
    24F3 8380      STD	Z+0,R24
    24F4 2DEA      MOV	R30,R10
    24F5 2DFB      MOV	R31,R11
    24F6 8022      LDD	R2,Z+2
    24F7 8033      LDD	R3,Z+3
    24F8 2DEC      MOV	R30,R12
    24F9 2DFD      MOV	R31,R13
    24FA 8233      STD	Z+3,R3
    24FB 8222      STD	Z+2,R2
    24FC 2DEA      MOV	R30,R10
    24FD 2DFB      MOV	R31,R11
    24FE 82D3      STD	Z+3,R13
    24FF 82C2      STD	Z+2,R12
    2500 2D8A      MOV	R24,R10
    2501 2D9B      MOV	R25,R11
    2502 9606      ADIW	R24,6
    2503 2DEA      MOV	R30,R10
    2504 2DFB      MOV	R31,R11
    2505 8022      LDD	R2,Z+2
    2506 8033      LDD	R3,Z+3
    2507 1A28      SUB	R2,R24
    2508 0A39      SBC	R3,R25
    2509 2DEA      MOV	R30,R10
    250A 2DFB      MOV	R31,R11
    250B 8235      STD	Z+5,R3
    250C 8224      STD	Z+4,R2
    250D 2FE4      MOV	R30,R20
    250E 2FF5      MOV	R31,R21
    250F 82D1      STD	Z+1,R13
    2510 82C0      STD	Z+0,R12
    2511 C008      RJMP	0x251A
    2512 2DEA      MOV	R30,R10
    2513 2DFB      MOV	R31,R11
    2514 8020      LDD	R2,Z+0
    2515 8031      LDD	R3,Z+1
    2516 2FE4      MOV	R30,R20
    2517 2FF5      MOV	R31,R21
    2518 8231      STD	Z+1,R3
    2519 8220      STD	Z+0,R2
    251A 2422      CLR	R2
    251B 2433      CLR	R3
    251C 2DEA      MOV	R30,R10
    251D 2DFB      MOV	R31,R11
    251E 8231      STD	Z+1,R3
    251F 8220      STD	Z+0,R2
    2520 2F6E      MOV	R22,R30
    2521 2F7F      MOV	R23,R31
    2522 5F6A      SUBI	R22,0xFA
    2523 4F7F      SBCI	R23,0xFF
    2524 2F06      MOV	R16,R22
    2525 2F17      MOV	R17,R23
    2526 C012      RJMP	0x2539
    2527 2FE4      MOV	R30,R20
    2528 2FF5      MOV	R31,R21
    2529 8140      LDD	R20,Z+0
    252A 8151      LDD	R21,Z+1
    252B 2FE4      MOV	R30,R20
    252C 2FF5      MOV	R31,R21
    252D 8020      LDD	R2,Z+0
    252E 8031      LDD	R3,Z+1
    252F 2CA2      MOV	R10,R2
    2530 2CB3      MOV	R11,R3
    2531 20AA      TST	R10
    2532 F009      BEQ	0x2534
    2533 CF86      RJMP	0x24BA
    2534 20BB      TST	R11
    2535 F009      BEQ	0x2537
    2536 CF83      RJMP	0x24BA
    2537 2700      CLR	R16
    2538 2711      CLR	R17
    2539 940E23CC  CALL	pop_gset4
    253B 9508      RET
_realloc:
    253C 940E23D4  CALL	push_gset4
    253E 2EA2      MOV	R10,R18
    253F 2EB3      MOV	R11,R19
    2540 2F60      MOV	R22,R16
    2541 2F71      MOV	R23,R17
    2542 9722      SBIW	R28,2
    2543 2F86      MOV	R24,R22
    2544 2F97      MOV	R25,R23
    2545 9706      SBIW	R24,6
    2546 2EC8      MOV	R12,R24
    2547 2ED9      MOV	R13,R25
    2548 2C2A      MOV	R2,R10
    2549 2C3B      MOV	R3,R11
    254A 0E26      ADD	R2,R22
    254B 1E37      ADC	R3,R23
    254C 2FE8      MOV	R30,R24
    254D 2FF9      MOV	R31,R25
    254E 8042      LDD	R4,Z+2
    254F 8053      LDD	R5,Z+3
    2550 1442      CP	R4,R2
    2551 0453      CPC	R5,R3
    2552 F038      BCS	0x255A
    2553 2FE8      MOV	R30,R24
    2554 2FF9      MOV	R31,R25
    2555 82B5      STD	Z+5,R11
    2556 82A4      STD	Z+4,R10
    2557 2F06      MOV	R16,R22
    2558 2F17      MOV	R17,R23
    2559 C01D      RJMP	0x2577
    255A 2D0A      MOV	R16,R10
    255B 2D1B      MOV	R17,R11
    255C DF52      RCALL	_malloc
    255D 2F40      MOV	R20,R16
    255E 2F51      MOV	R21,R17
    255F 2DEC      MOV	R30,R12
    2560 2DFD      MOV	R31,R13
    2561 8024      LDD	R2,Z+4
    2562 8035      LDD	R3,Z+5
    2563 142A      CP	R2,R10
    2564 043B      CPC	R3,R11
    2565 F420      BCC	0x256A
    2566 2DEC      MOV	R30,R12
    2567 2DFD      MOV	R31,R13
    2568 80A4      LDD	R10,Z+4
    2569 80B5      LDD	R11,Z+5
    256A 82B9      STD	Y+1,R11
    256B 82A8      STD	Y+0,R10
    256C 2F26      MOV	R18,R22
    256D 2F37      MOV	R19,R23
    256E 2F04      MOV	R16,R20
    256F 2F15      MOV	R17,R21
    2570 940E22A1  CALL	_memcpy
    2572 2F06      MOV	R16,R22
    2573 2F17      MOV	R17,R23
    2574 D08C      RCALL	_free
    2575 2F04      MOV	R16,R20
    2576 2F15      MOV	R17,R21
    2577 9622      ADIW	R28,2
    2578 940E23CC  CALL	pop_gset4
    257A 9508      RET
    257B 940E23D6  CALL	push_gset3
    257D 2F40      MOV	R20,R16
    257E 2F51      MOV	R21,R17
    257F E365      LDI	R22,0x35
    2580 E07F      LDI	R23,0xF
    2581 C060      RJMP	0x25E2
    2582 2FE4      MOV	R30,R20
    2583 2FF5      MOV	R31,R21
    2584 8022      LDD	R2,Z+2
    2585 8033      LDD	R3,Z+3
    2586 14A2      CP	R10,R2
    2587 04B3      CPC	R11,R3
    2588 F009      BEQ	0x258A
    2589 C026      RJMP	0x25B0
    258A 2DEA      MOV	R30,R10
    258B 2DFB      MOV	R31,R11
    258C 8020      LDD	R2,Z+0
    258D 8031      LDD	R3,Z+1
    258E 2FE6      MOV	R30,R22
    258F 2FF7      MOV	R31,R23
    2590 8231      STD	Z+1,R3
    2591 8220      STD	Z+0,R2
    2592 2F84      MOV	R24,R20
    2593 2F95      MOV	R25,R21
    2594 9604      ADIW	R24,4
    2595 2E28      MOV	R2,R24
    2596 2E39      MOV	R3,R25
    2597 2DEA      MOV	R30,R10
    2598 2DFB      MOV	R31,R11
    2599 8184      LDD	R24,Z+4
    259A 8195      LDD	R25,Z+5
    259B 9606      ADIW	R24,6
    259C 2DE2      MOV	R30,R2
    259D 2DF3      MOV	R31,R3
    259E 8040      LDD	R4,Z+0
    259F 8051      LDD	R5,Z+1
    25A0 0E48      ADD	R4,R24
    25A1 1E59      ADC	R5,R25
    25A2 8251      STD	Z+1,R5
    25A3 8240      STD	Z+0,R4
    25A4 2DEA      MOV	R30,R10
    25A5 2DFB      MOV	R31,R11
    25A6 8022      LDD	R2,Z+2
    25A7 8033      LDD	R3,Z+3
    25A8 2FE4      MOV	R30,R20
    25A9 2FF5      MOV	R31,R21
    25AA 8233      STD	Z+3,R3
    25AB 8222      STD	Z+2,R2
    25AC 2F04      MOV	R16,R20
    25AD 2F15      MOV	R17,R21
    25AE DFCC      RCALL	0x257B
    25AF C03E      RJMP	0x25EE
    25B0 2DEA      MOV	R30,R10
    25B1 2DFB      MOV	R31,R11
    25B2 8022      LDD	R2,Z+2
    25B3 8033      LDD	R3,Z+3
    25B4 1542      CP	R20,R2
    25B5 0553      CPC	R21,R3
    25B6 F009      BEQ	0x25B8
    25B7 C026      RJMP	0x25DE
    25B8 2DEA      MOV	R30,R10
    25B9 2DFB      MOV	R31,R11
    25BA 8020      LDD	R2,Z+0
    25BB 8031      LDD	R3,Z+1
    25BC 2FE6      MOV	R30,R22
    25BD 2FF7      MOV	R31,R23
    25BE 8231      STD	Z+1,R3
    25BF 8220      STD	Z+0,R2
    25C0 2D8A      MOV	R24,R10
    25C1 2D9B      MOV	R25,R11
    25C2 9604      ADIW	R24,4
    25C3 2E28      MOV	R2,R24
    25C4 2E39      MOV	R3,R25
    25C5 2FE4      MOV	R30,R20
    25C6 2FF5      MOV	R31,R21
    25C7 8184      LDD	R24,Z+4
    25C8 8195      LDD	R25,Z+5
    25C9 9606      ADIW	R24,6
    25CA 2DE2      MOV	R30,R2
    25CB 2DF3      MOV	R31,R3
    25CC 8040      LDD	R4,Z+0
    25CD 8051      LDD	R5,Z+1
    25CE 0E48      ADD	R4,R24
    25CF 1E59      ADC	R5,R25
    25D0 8251      STD	Z+1,R5
    25D1 8240      STD	Z+0,R4
    25D2 2FE4      MOV	R30,R20
    25D3 2FF5      MOV	R31,R21
    25D4 8022      LDD	R2,Z+2
    25D5 8033      LDD	R3,Z+3
    25D6 2DEA      MOV	R30,R10
    25D7 2DFB      MOV	R31,R11
    25D8 8233      STD	Z+3,R3
    25D9 8222      STD	Z+2,R2
    25DA 2D0A      MOV	R16,R10
    25DB 2D1B      MOV	R17,R11
    25DC DF9E      RCALL	0x257B
    25DD C010      RJMP	0x25EE
    25DE 2FE6      MOV	R30,R22
    25DF 2FF7      MOV	R31,R23
    25E0 8160      LDD	R22,Z+0
    25E1 8171      LDD	R23,Z+1
    25E2 2FE6      MOV	R30,R22
    25E3 2FF7      MOV	R31,R23
    25E4 8020      LDD	R2,Z+0
    25E5 8031      LDD	R3,Z+1
    25E6 2CA2      MOV	R10,R2
    25E7 2CB3      MOV	R11,R3
    25E8 20AA      TST	R10
    25E9 F009      BEQ	0x25EB
    25EA CF97      RJMP	0x2582
    25EB 20BB      TST	R11
    25EC F009      BEQ	0x25EE
    25ED CF94      RJMP	0x2582
    25EE 20AA      TST	R10
    25EF F471      BNE	0x25FE
    25F0 20BB      TST	R11
    25F1 F461      BNE	0x25FE
    25F2 90200F35  LDS	R2,__FreeList
    25F4 90300F36  LDS	R3,__FreeList+1
    25F6 2FE4      MOV	R30,R20
    25F7 2FF5      MOV	R31,R21
    25F8 8231      STD	Z+1,R3
    25F9 8220      STD	Z+0,R2
    25FA 93500F36  STS	__FreeList+1,R21
    25FC 93400F35  STS	__FreeList,R20
    25FE 940E23C9  CALL	pop_gset3
    2600 9508      RET
_free:
    2601 940E23DA  CALL	push_gset1
    2603 2F40      MOV	R20,R16
    2604 2F51      MOV	R21,R17
    2605 3040      CPI	R20,0
    2606 0745      CPC	R20,R21
    2607 F409      BNE	0x2609
    2608 C014      RJMP	0x261D
    2609 5046      SUBI	R20,6
    260A 4050      SBCI	R21,0
    260B 2FE4      MOV	R30,R20
    260C 2FF5      MOV	R31,R21
    260D 8184      LDD	R24,Z+4
    260E 8195      LDD	R25,Z+5
    260F 9606      ADIW	R24,6
    2610 0F84      ADD	R24,R20
    2611 1F95      ADC	R25,R21
    2612 2FE4      MOV	R30,R20
    2613 2FF5      MOV	R31,R21
    2614 8022      LDD	R2,Z+2
    2615 8033      LDD	R3,Z+3
    2616 1628      CP	R2,R24
    2617 0639      CPC	R3,R25
    2618 F408      BCC	0x261A
    2619 C003      RJMP	0x261D
    261A 2F04      MOV	R16,R20
    261B 2F15      MOV	R17,R21
    261C DF5E      RCALL	0x257B
    261D 940E23DD  CALL	pop_gset1
    261F 9508      RET
_atoi:
    2620 940E23D6  CALL	push_gset3
    2622 2F60      MOV	R22,R16
    2623 2F71      MOV	R23,R17
    2624 C002      RJMP	0x2627
    2625 5F6F      SUBI	R22,0xFF
    2626 4F7F      SBCI	R23,0xFF
    2627 2FE6      MOV	R30,R22
    2628 2FF7      MOV	R31,R23
    2629 8100      LDD	R16,Z+0
    262A 2711      CLR	R17
    262B 940E2834  CALL	_isspace
    262D 3000      CPI	R16,0
    262E 0701      CPC	R16,R17
    262F F7A9      BNE	0x2625
    2630 24AA      CLR	R10
    2631 24BB      CLR	R11
    2632 2FE6      MOV	R30,R22
    2633 2FF7      MOV	R31,R23
    2634 8180      LDD	R24,Z+0
    2635 328D      CPI	R24,0x2D
    2636 F439      BNE	0x263E
    2637 E081      LDI	R24,1
    2638 E090      LDI	R25,0
    2639 2EA8      MOV	R10,R24
    263A 2EB9      MOV	R11,R25
    263B 5F6F      SUBI	R22,0xFF
    263C 4F7F      SBCI	R23,0xFF
    263D C007      RJMP	0x2645
    263E 2FE6      MOV	R30,R22
    263F 2FF7      MOV	R31,R23
    2640 8180      LDD	R24,Z+0
    2641 328B      CPI	R24,0x2B
    2642 F411      BNE	0x2645
    2643 5F6F      SUBI	R22,0xFF
    2644 4F7F      SBCI	R23,0xFF
    2645 2744      CLR	R20
    2646 2755      CLR	R21
    2647 C012      RJMP	0x265A
    2648 E00A      LDI	R16,0xA
    2649 E010      LDI	R17,0
    264A 2F24      MOV	R18,R20
    264B 2F35      MOV	R19,R21
    264C 940E2447  CALL	mpy16s
    264E 2F40      MOV	R20,R16
    264F 2F51      MOV	R21,R17
    2650 2FE6      MOV	R30,R22
    2651 2FF7      MOV	R31,R23
    2652 9021      LD	R2,Z+
    2653 2F6E      MOV	R22,R30
    2654 2F7F      MOV	R23,R31
    2655 2433      CLR	R3
    2656 0D42      ADD	R20,R2
    2657 1D53      ADC	R21,R3
    2658 5340      SUBI	R20,0x30
    2659 4050      SBCI	R21,0
    265A 2FE6      MOV	R30,R22
    265B 2FF7      MOV	R31,R23
    265C 8100      LDD	R16,Z+0
    265D 2711      CLR	R17
    265E 940E2818  CALL	_isdigit
    2660 3000      CPI	R16,0
    2661 0701      CPC	R16,R17
    2662 F729      BNE	0x2648
    2663 20AA      TST	R10
    2664 F411      BNE	0x2667
    2665 20BB      TST	R11
    2666 F039      BEQ	0x266E
    2667 2F04      MOV	R16,R20
    2668 2F15      MOV	R17,R21
    2669 9500      COM	R16
    266A 9510      COM	R17
    266B 5F0F      SUBI	R16,0xFF
    266C 4F1F      SBCI	R17,0xFF
    266D C002      RJMP	0x2670
    266E 2F04      MOV	R16,R20
    266F 2F15      MOV	R17,R21
    2670 940E23C9  CALL	pop_gset3
    2672 9508      RET
_itoa:
    2673 940E23D2  CALL	push_gset5
    2675 2EC2      MOV	R12,R18
    2676 2ED3      MOV	R13,R19
    2677 2F40      MOV	R20,R16
    2678 2F51      MOV	R21,R17
    2679 97A2      SBIW	R28,0x22
    267A A4AC      LDD	R10,Y+44
    267B A4BD      LDD	R11,Y+45
    267C 2D8C      MOV	R24,R12
    267D 2D9D      MOV	R25,R13
    267E 3080      CPI	R24,0
    267F E0E0      LDI	R30,0
    2680 079E      CPC	R25,R30
    2681 F444      BGE	0x268A
    2682 E061      LDI	R22,1
    2683 9580      COM	R24
    2684 9590      COM	R25
    2685 5F8F      SUBI	R24,0xFF
    2686 4F9F      SBCI	R25,0xFF
    2687 2EC8      MOV	R12,R24
    2688 2ED9      MOV	R13,R25
    2689 C001      RJMP	0x268B
    268A 2766      CLR	R22
    268B 2422      CLR	R2
    268C A229      STD	Y+33,R2
    268D 2F8C      MOV	R24,R28
    268E 2F9D      MOV	R25,R29
    268F 9681      ADIW	R24,0x21
    2690 2EE8      MOV	R14,R24
    2691 2EF9      MOV	R15,R25
    2692 2D8E      MOV	R24,R14
    2693 2D9F      MOV	R25,R15
    2694 9701      SBIW	R24,1
    2695 2E28      MOV	R2,R24
    2696 2E39      MOV	R3,R25
    2697 2EE8      MOV	R14,R24
    2698 2EF9      MOV	R15,R25
    2699 2D2A      MOV	R18,R10
    269A 2D3B      MOV	R19,R11
    269B 2D0C      MOV	R16,R12
    269C 2D1D      MOV	R17,R13
    269D 940E22DB  CALL	mod16s
    269F 2FE0      MOV	R30,R16
    26A0 2FF1      MOV	R31,R17
    26A1 E48F      LDI	R24,0x4F
    26A2 E09E      LDI	R25,0xE
    26A3 0FE8      ADD	R30,R24
    26A4 1FF9      ADC	R31,R25
    26A5 8040      LDD	R4,Z+0
    26A6 2DE2      MOV	R30,R2
    26A7 2DF3      MOV	R31,R3
    26A8 8240      STD	Z+0,R4
    26A9 2D2A      MOV	R18,R10
    26AA 2D3B      MOV	R19,R11
    26AB 2D0C      MOV	R16,R12
    26AC 2D1D      MOV	R17,R13
    26AD 940E22DF  CALL	div16s
    26AF 2EC0      MOV	R12,R16
    26B0 2ED1      MOV	R13,R17
    26B1 20CC      TST	R12
    26B2 F6F9      BNE	0x2692
    26B3 20DD      TST	R13
    26B4 F6E9      BNE	0x2692
    26B5 2366      TST	R22
    26B6 F059      BEQ	0x26C2
    26B7 2D8E      MOV	R24,R14
    26B8 2D9F      MOV	R25,R15
    26B9 9701      SBIW	R24,1
    26BA 2E28      MOV	R2,R24
    26BB 2E39      MOV	R3,R25
    26BC 2EE8      MOV	R14,R24
    26BD 2EF9      MOV	R15,R25
    26BE E28D      LDI	R24,0x2D
    26BF 2DE2      MOV	R30,R2
    26C0 2DF3      MOV	R31,R3
    26C1 8380      STD	Z+0,R24
    26C2 2D2E      MOV	R18,R14
    26C3 2D3F      MOV	R19,R15
    26C4 2F04      MOV	R16,R20
    26C5 2F15      MOV	R17,R21
    26C6 940E22BA  CALL	_strcpy
    26C8 96A2      ADIW	R28,0x22
    26C9 940E23CF  CALL	pop_gset5
    26CB 9508      RET
_ltoa:
    26CC 940E22CF  CALL	push_arg4
    26CE 940E23D2  CALL	push_gset5
    26D0 97A2      SBIW	R28,0x22
    26D1 A8EA      LDD	R14,Y+50
    26D2 A8FB      LDD	R15,Y+51
    26D3 E040      LDI	R20,0
    26D4 E050      LDI	R21,0
    26D5 E060      LDI	R22,0
    26D6 E070      LDI	R23,0
    26D7 2FEC      MOV	R30,R28
    26D8 2FFD      MOV	R31,R29
    26D9 A426      LDD	R2,Z+46
    26DA A437      LDD	R3,Z+47
    26DB A840      LDD	R4,Z+48
    26DC A851      LDD	R5,Z+49
    26DD 1624      CP	R2,R20
    26DE 0635      CPC	R3,R21
    26DF 0646      CPC	R4,R22
    26E0 0657      CPC	R5,R23
    26E1 F48C      BGE	0x26F3
    26E2 24AA      CLR	R10
    26E3 94A3      INC	R10
    26E4 2FEC      MOV	R30,R28
    26E5 2FFD      MOV	R31,R29
    26E6 A506      LDD	R16,Z+46
    26E7 A517      LDD	R17,Z+47
    26E8 A920      LDD	R18,Z+48
    26E9 A931      LDD	R19,Z+49
    26EA 940E23FA  CALL	neg32
    26EC 2FEC      MOV	R30,R28
    26ED 2FFD      MOV	R31,R29
    26EE A706      STD	Z+46,R16
    26EF A717      STD	Z+47,R17
    26F0 AB20      STD	Z+48,R18
    26F1 AB31      STD	Z+49,R19
    26F2 C001      RJMP	0x26F4
    26F3 24AA      CLR	R10
    26F4 2422      CLR	R2
    26F5 A229      STD	Y+33,R2
    26F6 2F8C      MOV	R24,R28
    26F7 2F9D      MOV	R25,R29
    26F8 9681      ADIW	R24,0x21
    26F9 2EC8      MOV	R12,R24
    26FA 2ED9      MOV	R13,R25
    26FB 2D8C      MOV	R24,R12
    26FC 2D9D      MOV	R25,R13
    26FD 9701      SBIW	R24,1
    26FE 2E28      MOV	R2,R24
    26FF 2E39      MOV	R3,R25
    2700 2EC8      MOV	R12,R24
    2701 2ED9      MOV	R13,R25
    2702 2C4E      MOV	R4,R14
    2703 2C5F      MOV	R5,R15
    2704 2466      CLR	R6
    2705 FC57      SBRC	R5,7
    2706 9460      COM	R6
    2707 2477      CLR	R7
    2708 FC67      SBRC	R6,7
    2709 9470      COM	R7
    270A 2FEC      MOV	R30,R28
    270B 2FFD      MOV	R31,R29
    270C A546      LDD	R20,Z+46
    270D A557      LDD	R21,Z+47
    270E A960      LDD	R22,Z+48
    270F A971      LDD	R23,Z+49
    2710 927A      ST	R7,-Y
    2711 926A      ST	R6,-Y
    2712 925A      ST	R5,-Y
    2713 924A      ST	R4,-Y
    2714 2F04      MOV	R16,R20
    2715 2F15      MOV	R17,R21
    2716 2F26      MOV	R18,R22
    2717 2F37      MOV	R19,R23
    2718 940E231D  CALL	mod32s
    271A 2FE0      MOV	R30,R16
    271B 2FF1      MOV	R31,R17
    271C E784      LDI	R24,0x74
    271D E09E      LDI	R25,0xE
    271E 0FE8      ADD	R30,R24
    271F 1FF9      ADC	R31,R25
    2720 8040      LDD	R4,Z+0
    2721 2DE2      MOV	R30,R2
    2722 2DF3      MOV	R31,R3
    2723 8240      STD	Z+0,R4
    2724 2C2E      MOV	R2,R14
    2725 2C3F      MOV	R3,R15
    2726 2444      CLR	R4
    2727 FC37      SBRC	R3,7
    2728 9440      COM	R4
    2729 2455      CLR	R5
    272A FC47      SBRC	R4,7
    272B 9450      COM	R5
    272C 2FEC      MOV	R30,R28
    272D 2FFD      MOV	R31,R29
    272E A466      LDD	R6,Z+46
    272F A477      LDD	R7,Z+47
    2730 A880      LDD	R8,Z+48
    2731 A891      LDD	R9,Z+49
    2732 925A      ST	R5,-Y
    2733 924A      ST	R4,-Y
    2734 923A      ST	R3,-Y
    2735 922A      ST	R2,-Y
    2736 2D06      MOV	R16,R6
    2737 2D17      MOV	R17,R7
    2738 2D28      MOV	R18,R8
    2739 2D39      MOV	R19,R9
    273A 940E231B  CALL	div32s
    273C 2FEC      MOV	R30,R28
    273D 2FFD      MOV	R31,R29
    273E A706      STD	Z+46,R16
    273F A717      STD	Z+47,R17
    2740 AB20      STD	Z+48,R18
    2741 AB31      STD	Z+49,R19
    2742 E040      LDI	R20,0
    2743 E050      LDI	R21,0
    2744 E060      LDI	R22,0
    2745 E070      LDI	R23,0
    2746 2FEC      MOV	R30,R28
    2747 2FFD      MOV	R31,R29
    2748 A426      LDD	R2,Z+46
    2749 A437      LDD	R3,Z+47
    274A A840      LDD	R4,Z+48
    274B A851      LDD	R5,Z+49
    274C 1624      CP	R2,R20
    274D 0635      CPC	R3,R21
    274E 0646      CPC	R4,R22
    274F 0657      CPC	R5,R23
    2750 F009      BEQ	0x2752
    2751 CFA9      RJMP	0x26FB
    2752 20AA      TST	R10
    2753 F059      BEQ	0x275F
    2754 2D8C      MOV	R24,R12
    2755 2D9D      MOV	R25,R13
    2756 9701      SBIW	R24,1
    2757 2E28      MOV	R2,R24
    2758 2E39      MOV	R3,R25
    2759 2EC8      MOV	R12,R24
    275A 2ED9      MOV	R13,R25
    275B E28D      LDI	R24,0x2D
    275C 2DE2      MOV	R30,R2
    275D 2DF3      MOV	R31,R3
    275E 8380      STD	Z+0,R24
    275F 2D2C      MOV	R18,R12
    2760 2D3D      MOV	R19,R13
    2761 A50C      LDD	R16,Y+44
    2762 A51D      LDD	R17,Y+45
    2763 940E22BA  CALL	_strcpy
    2765 96A2      ADIW	R28,0x22
    2766 940E23CF  CALL	pop_gset5
    2768 9624      ADIW	R28,4
    2769 9508      RET
_ultoa:
    276A 933A      ST	R19,-Y
    276B 932A      ST	R18,-Y
    276C 940E23D2  CALL	push_gset5
    276E 2EE0      MOV	R14,R16
    276F 2EF1      MOV	R15,R17
    2770 97A2      SBIW	R28,0x22
    2771 A8C8      LDD	R12,Y+48
    2772 A8D9      LDD	R13,Y+49
    2773 2422      CLR	R2
    2774 A229      STD	Y+33,R2
    2775 2F8C      MOV	R24,R28
    2776 2F9D      MOV	R25,R29
    2777 9681      ADIW	R24,0x21
    2778 2EA8      MOV	R10,R24
    2779 2EB9      MOV	R11,R25
    277A 2D8A      MOV	R24,R10
    277B 2D9B      MOV	R25,R11
    277C 9701      SBIW	R24,1
    277D 2E28      MOV	R2,R24
    277E 2E39      MOV	R3,R25
    277F 2EA8      MOV	R10,R24
    2780 2EB9      MOV	R11,R25
    2781 2C4C      MOV	R4,R12
    2782 2C5D      MOV	R5,R13
    2783 2466      CLR	R6
    2784 FC57      SBRC	R5,7
    2785 9460      COM	R6
    2786 2477      CLR	R7
    2787 FC67      SBRC	R6,7
    2788 9470      COM	R7
    2789 2FEC      MOV	R30,R28
    278A 2FFD      MOV	R31,R29
    278B A544      LDD	R20,Z+44
    278C A555      LDD	R21,Z+45
    278D A566      LDD	R22,Z+46
    278E A577      LDD	R23,Z+47
    278F 927A      ST	R7,-Y
    2790 926A      ST	R6,-Y
    2791 925A      ST	R5,-Y
    2792 924A      ST	R4,-Y
    2793 2F04      MOV	R16,R20
    2794 2F15      MOV	R17,R21
    2795 2F26      MOV	R18,R22
    2796 2F37      MOV	R19,R23
    2797 940E2317  CALL	mod32u
    2799 2FE0      MOV	R30,R16
    279A 2FF1      MOV	R31,R17
    279B E989      LDI	R24,0x99
    279C E09E      LDI	R25,0xE
    279D 0FE8      ADD	R30,R24
    279E 1FF9      ADC	R31,R25
    279F 8040      LDD	R4,Z+0
    27A0 2DE2      MOV	R30,R2
    27A1 2DF3      MOV	R31,R3
    27A2 8240      STD	Z+0,R4
    27A3 2C2C      MOV	R2,R12
    27A4 2C3D      MOV	R3,R13
    27A5 2444      CLR	R4
    27A6 FC37      SBRC	R3,7
    27A7 9440      COM	R4
    27A8 2455      CLR	R5
    27A9 FC47      SBRC	R4,7
    27AA 9450      COM	R5
    27AB 2FEC      MOV	R30,R28
    27AC 2FFD      MOV	R31,R29
    27AD A464      LDD	R6,Z+44
    27AE A475      LDD	R7,Z+45
    27AF A486      LDD	R8,Z+46
    27B0 A497      LDD	R9,Z+47
    27B1 925A      ST	R5,-Y
    27B2 924A      ST	R4,-Y
    27B3 923A      ST	R3,-Y
    27B4 922A      ST	R2,-Y
    27B5 2D06      MOV	R16,R6
    27B6 2D17      MOV	R17,R7
    27B7 2D28      MOV	R18,R8
    27B8 2D39      MOV	R19,R9
    27B9 940E2315  CALL	div32u
    27BB 2FEC      MOV	R30,R28
    27BC 2FFD      MOV	R31,R29
    27BD A704      STD	Z+44,R16
    27BE A715      STD	Z+45,R17
    27BF A726      STD	Z+46,R18
    27C0 A737      STD	Z+47,R19
    27C1 E040      LDI	R20,0
    27C2 E050      LDI	R21,0
    27C3 E060      LDI	R22,0
    27C4 E070      LDI	R23,0
    27C5 2FEC      MOV	R30,R28
    27C6 2FFD      MOV	R31,R29
    27C7 A424      LDD	R2,Z+44
    27C8 A435      LDD	R3,Z+45
    27C9 A446      LDD	R4,Z+46
    27CA A457      LDD	R5,Z+47
    27CB 1624      CP	R2,R20
    27CC 0635      CPC	R3,R21
    27CD 0646      CPC	R4,R22
    27CE 0657      CPC	R5,R23
    27CF F009      BEQ	0x27D1
    27D0 CFA9      RJMP	0x277A
    27D1 2D2A      MOV	R18,R10
    27D2 2D3B      MOV	R19,R11
    27D3 2D0E      MOV	R16,R14
    27D4 2D1F      MOV	R17,R15
    27D5 940E22BA  CALL	_strcpy
    27D7 96A2      ADIW	R28,0x22
    27D8 940E23CF  CALL	pop_gset5
    27DA 9622      ADIW	R28,2
    27DB 9508      RET
_utoa:
    27DC 940E23D4  CALL	push_gset4
    27DE 2EA2      MOV	R10,R18
    27DF 2EB3      MOV	R11,R19
    27E0 2EC0      MOV	R12,R16
    27E1 2ED1      MOV	R13,R17
    27E2 97A2      SBIW	R28,0x22
    27E3 A56A      LDD	R22,Y+42
    27E4 A57B      LDD	R23,Y+43
    27E5 2422      CLR	R2
    27E6 A229      STD	Y+33,R2
    27E7 2F4C      MOV	R20,R28
    27E8 2F5D      MOV	R21,R29
    27E9 5D4F      SUBI	R20,0xDF
    27EA 4F5F      SBCI	R21,0xFF
    27EB 2F84      MOV	R24,R20
    27EC 2F95      MOV	R25,R21
    27ED 9701      SBIW	R24,1
    27EE 2E28      MOV	R2,R24
    27EF 2E39      MOV	R3,R25
    27F0 2F48      MOV	R20,R24
    27F1 2F59      MOV	R21,R25
    27F2 2F26      MOV	R18,R22
    27F3 2F37      MOV	R19,R23
    27F4 2D0A      MOV	R16,R10
    27F5 2D1B      MOV	R17,R11
    27F6 940E22F9  CALL	mod16u
    27F8 2FE0      MOV	R30,R16
    27F9 2FF1      MOV	R31,R17
    27FA EB8E      LDI	R24,0xBE
    27FB E09E      LDI	R25,0xE
    27FC 0FE8      ADD	R30,R24
    27FD 1FF9      ADC	R31,R25
    27FE 8040      LDD	R4,Z+0
    27FF 2DE2      MOV	R30,R2
    2800 2DF3      MOV	R31,R3
    2801 8240      STD	Z+0,R4
    2802 2F26      MOV	R18,R22
    2803 2F37      MOV	R19,R23
    2804 2D0A      MOV	R16,R10
    2805 2D1B      MOV	R17,R11
    2806 940E22FB  CALL	div16u
    2808 2EA0      MOV	R10,R16
    2809 2EB1      MOV	R11,R17
    280A 20AA      TST	R10
    280B F6F9      BNE	0x27EB
    280C 20BB      TST	R11
    280D F6E9      BNE	0x27EB
    280E 2F24      MOV	R18,R20
    280F 2F35      MOV	R19,R21
    2810 2D0C      MOV	R16,R12
    2811 2D1D      MOV	R17,R13
    2812 940E22BA  CALL	_strcpy
    2814 96A2      ADIW	R28,0x22
    2815 940E23CC  CALL	pop_gset4
    2817 9508      RET
_isdigit:
    2818 E983      LDI	R24,0x93
    2819 E090      LDI	R25,0
    281A 2E20      MOV	R2,R16
    281B 2E31      MOV	R3,R17
    281C 0E28      ADD	R2,R24
    281D 1E39      ADC	R3,R25
    281E 2DE2      MOV	R30,R2
    281F 2DF3      MOV	R31,R3
    2820 95C8      LPM
    2821 2D00      MOV	R16,R0
    2822 2711      CLR	R17
    2823 7004      ANDI	R16,4
    2824 7010      ANDI	R17,0
    2825 9508      RET
_islower:
    2826 E983      LDI	R24,0x93
    2827 E090      LDI	R25,0
    2828 2E20      MOV	R2,R16
    2829 2E31      MOV	R3,R17
    282A 0E28      ADD	R2,R24
    282B 1E39      ADC	R3,R25
    282C 2DE2      MOV	R30,R2
    282D 2DF3      MOV	R31,R3
    282E 95C8      LPM
    282F 2D00      MOV	R16,R0
    2830 2711      CLR	R17
    2831 7002      ANDI	R16,2
    2832 7010      ANDI	R17,0
    2833 9508      RET
_isspace:
    2834 E983      LDI	R24,0x93
    2835 E090      LDI	R25,0
    2836 2E20      MOV	R2,R16
    2837 2E31      MOV	R3,R17
    2838 0E28      ADD	R2,R24
    2839 1E39      ADC	R3,R25
    283A 2DE2      MOV	R30,R2
    283B 2DF3      MOV	R31,R3
    283C 95C8      LPM
    283D 2D00      MOV	R16,R0
    283E 2711      CLR	R17
    283F 7100      ANDI	R16,0x10
    2840 7010      ANDI	R17,0
    2841 9508      RET
_toupper:
    2842 940E23DA  CALL	push_gset1
    2844 2F40      MOV	R20,R16
    2845 2F51      MOV	R21,R17
    2846 2F04      MOV	R16,R20
    2847 2F15      MOV	R17,R21
    2848 940E2826  CALL	_islower
    284A 3000      CPI	R16,0
    284B 0701      CPC	R16,R17
    284C F039      BEQ	0x2854
    284D 2F04      MOV	R16,R20
    284E 2F15      MOV	R17,R21
    284F 5601      SUBI	R16,0x61
    2850 4010      SBCI	R17,0
    2851 5B0F      SUBI	R16,0xBF
    2852 4F1F      SBCI	R17,0xFF
    2853 C002      RJMP	0x2856
    2854 2F04      MOV	R16,R20
    2855 2F15      MOV	R17,R21
    2856 940E23DD  CALL	pop_gset1
    2858 9508      RET
_printf:
    2859 940E22CF  CALL	push_arg4
    285B 940E23DA  CALL	push_gset1
    285D 9722      SBIW	R28,2
    285E E022      LDI	R18,2
    285F E030      LDI	R19,0
    2860 2F0C      MOV	R16,R28
    2861 2F1D      MOV	R17,R29
    2862 5F0C      SUBI	R16,0xFC
    2863 4F1F      SBCI	R17,0xFF
    2864 940E245B  CALL	__va_start
    2866 2F40      MOV	R20,R16
    2867 2F51      MOV	R21,R17
    2868 8359      STD	Y+1,R21
    2869 8348      STD	Y+0,R20
    286A 812C      LDD	R18,Y+4
    286B 813D      LDD	R19,Y+5
    286C E900      LDI	R16,0x90
    286D E010      LDI	R17,0
    286E 940E1DD0  CALL	__print
    2870 2F40      MOV	R20,R16
    2871 2F51      MOV	R21,R17
    2872 9622      ADIW	R28,2
    2873 940E23DD  CALL	pop_gset1
    2875 9624      ADIW	R28,4
    2876 9508      RET
