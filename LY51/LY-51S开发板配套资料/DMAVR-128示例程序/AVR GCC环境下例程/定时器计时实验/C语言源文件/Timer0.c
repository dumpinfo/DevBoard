//DMAVR-128的利用定时器0实现999s加1计数功能，每1s加1
//定时器用普通模式，溢出中断，加1计数
//定时器初值计算，定时10ms，1024分频为例，(FF-X+1)/F_CPU/1024=0.01s
//秒表在数码管上显示
//编译环境 AVR Studio 4.17/AVR GCC，优化度-0s
//系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
//作者：阿迪 www.avrgcc.com
//日期：2010.01.14
//***********************************************************************
//			包含文件
//***********************************************************************

#include <string.h>
#include <stdio.h>
#define	 F_CPU	7372800						// 单片机主频为7.3728MHz,用于延时子程序和计算定时器初始值
#include <util/delay.h>
#include <avr/io.h>
#include <avr/iom128.h>
#include <avr/interrupt.h>     				//中断信号头文件

//***********************************************************************
//			定义变量区
//***********************************************************************
#define f_count         182              	//定时器初值，定时器加一计数
#define timer_clk       0x07				//时钟1024分频
#define delay_us(x)     _delay_us(x)    	//AVR GCC延时函数 x(us)
#define delay_ms(x)     _delay_ms(x)    	//AVR GCC延时函数 x(ms)

#define uchar           unsigned char
#define uint            unsigned int
#define ulong           unsigned long


#define Data_IO	        PORTA                //数码管数据口
#define Data_DDR        DDRA                 //数码管数据口方向寄存器
#define D_LE0	        PORTD &= ~(1 << PD4) //数码管段控制位为0，锁存端口数据
#define D_LE1           PORTD |= (1 << PD4)  //数码管段控制位为1，锁存器输出与端口一致
#define W_LE0	        PORTD &= ~(1 << PD5) //数码管位控制位为0
#define W_LE1           PORTD |= (1 << PD5)  //数码管位控制位为1

//***********************************************************************
//			共阴数码管显示的断码表0～F
//***********************************************************************

uchar table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


uchar time_1s_count=0;
//volatile uchar time_1s_flag;
uint  second;
uint  A1,A2,A3;


//***********************************************************************
//			IO端口初始化
//***********************************************************************

void system_init()
{
    Data_IO=0xFF;             						//数据口为输出
    Data_DDR=0xFF;

    PORTD=0xFF;               						//74HC573的控制口，设置为输出
    DDRD=0xFF;
	PORTB=0XFF;
	DDRB=0XFF;
}


//*************************************************************************
//			定时器0初始化子程序
//*************************************************************************

void timer0_init()                                 //定时器初始化
{
  TCCR0=0x07;                                      //普通模式，OC0不输出，1024分频
  TCNT0=f_count;                                    //初值，定时为10ms
  TIFR=0x01;                                       //清中断标志位
  TIMSK=0x01;                                      //使能定时器0溢出中断
}

//*************************************************************************
//		数据处理函数
//*************************************************************************
 void data_do(uint temp_d)
 {
     uchar A2t;
     A1=temp_d/100;                       		  //分出百，十，和个位
     A2t=temp_d%100;
     A2=A2t/10;
     A3=A2t%10;
}

//*************************************************************************
//			74HC573控制数码管动态扫描显示函数，显示采集到的温度
//*************************************************************************

void Display_Timer0(void)
{
	 uchar i,j;
	 system_init();
     j=0x01;                    			//此数据用来控制位选
 for(i=0;i<5;i++)               			//用后3位数码管来显示
  {
     D_LE1;                     
     W_LE1;                     
     Data_IO=~j;                
     W_LE0;                      
	 j=(j<<1);
     Data_IO=0x00;           
     D_LE0;                      
     delay_ms(1);                
  }
     D_LE1;                    
     W_LE1;                    
     Data_IO=~j;               
     W_LE0;                    
	 j=(j<<1);
     Data_IO=table[A1];         
     D_LE0;                    
     delay_ms(1);              

     D_LE1;                     
     W_LE1;                     
     Data_IO=~j;                
     W_LE0;                      
	 j=(j<<1);
     Data_IO=table[A2];             
     D_LE0;                      
     delay_ms(1);                

	 D_LE1;                     
     W_LE1;                     
     Data_IO=~j;                
     W_LE0;                      
	 j=(j<<1);
     Data_IO=table[A3];           
     D_LE0;                      
     delay_ms(1);                

	 D_LE1;                     
     W_LE1;                     
     Data_IO=0xff;                
     W_LE0;                      

}


//*************************************************************************
//		定时器0中断服务子程序
//*************************************************************************
ISR(SIG_OVERFLOW0)                           	//中断服务程序
{
    
	TCNT0=f_count;                              //定时器赋初值，非自动重装模式
   if(time_1s_count!=100)
      {
	  time_1s_count++;                          //定时器定时10ms，计数100次为1s
//	  time_1s_flag=0;                           //未到1s，标志位为0
	  }
   else
      {
	  if(second!=999)                           //最大计时999s
	     {
		 second++;
		 }
      else
	     second=0;                              //到999s则清0
	  time_1s_count=0;
//	  time_1s_flag=1;
	  data_do(second);                         //将秒转化为BCD码，供显示
	  }
}


//*************************************************************************
//		主程序
//*************************************************************************

int main(void)
{
  system_init();                             //系统初始化
  timer0_init();                             //定时器0初始化，完成定时器相关配置 
  time_1s_count=0;                           //计数值清0
  SREG|=0x80;                                //开启全局中断
  while(1)
  {

	   Display_Timer0();             		//显示计数值

  }
}
