__start:
__text_start:
     771 EFCF      LDI	R28,0xFF
     772 E1D0      LDI	R29,0x10
     773 BFCD      OUT	0x3D,R28
     774 BFDE      OUT	0x3E,R29
     775 51CE      SUBI	R28,0x1E
     776 40D0      SBCI	R29,0
     777 EA0A      LDI	R16,0xAA
     778 8308      STD	Y+0,R16
     779 2400      CLR	R0
     77A EDEA      LDI	R30,0xDA
     77B E0FD      LDI	R31,0xD
     77C E01E      LDI	R17,0xE
     77D 33E0      CPI	R30,0x30
     77E 07F1      CPC	R31,R17
     77F F011      BEQ	0x0782
     780 9201      ST	R0,Z+
     781 CFFB      RJMP	0x077D
     782 8300      STD	Z+0,R16
     783 E0E7      LDI	R30,7
     784 E0F2      LDI	R31,2
     785 E0A0      LDI	R26,0
     786 E0B1      LDI	R27,1
     787 E01E      LDI	R17,0xE
     788 E000      LDI	R16,0
     789 BF0B      OUT	0x3B,R16
     78A 3EE1      CPI	R30,0xE1
     78B 07F1      CPC	R31,R17
     78C F021      BEQ	0x0791
     78D 95C8      LPM
     78E 9631      ADIW	R30,1
     78F 920D      ST	R0,X+
     790 CFF9      RJMP	0x078A
     791 940E 0A7A CALL	_main
_exit:
     793 CFFF      RJMP	_exit
FILE: F:\PROGRA~1\iccavr\include\delay.h
(0001) //********************************************************************
(0002) /*函 数 名：delay_us
(0003) 建立日期：2010年1月28日
(0004) 编译环境：ICCAVR7.16A
(0005) 函数作用：微秒级的延时程序
(0006) 说    明：7.3728M晶振下
(0007) ********************************************************************/
(0008) void delay_1us(void);
(0009) void delay_3us(void);
(0010) void delay_10us(void);
(0011) void delay_50us(void);
(0012) void delay_100us(void);
(0013) void delay_n100us(unsigned char n100us);
(0014) void delay_1ms(void);
(0015) void delay_nms(unsigned int nms);
(0016) void delay_ns(unsigned char ns);
(0017) 
(0018) 
(0019) void delay_1us(void)                 //1us延时函数，不能连续调用， 
(0020) { 
(0021)    asm("nop");                       //1时钟周期
_delay_1us:
     794 0000      NOP
(0022)    asm("nop");
     795 0000      NOP
(0023)    asm("nop");
     796 0000      NOP
(0024)    asm("nop");
     797 0000      NOP
(0025)    asm("nop");                       //1T
     798 0000      NOP
(0026)    asm("nop");
     799 0000      NOP
     79A 9508      RET
(0027) 
(0028) }
(0029) void delay_3us(void)                 //3us延时函数,,可重复调用不影响精度
(0030) { 
(0031)    
(0032)    asm("nop");
_delay_3us:
     79B 0000      NOP
(0033)    asm("nop");
     79C 0000      NOP
(0034)    asm("nop");                       
     79D 0000      NOP
(0035)    asm("nop");
     79E 0000      NOP
(0036)    asm("nop");
     79F 0000      NOP
(0037)    asm("nop");
     7A0 0000      NOP
(0038)    asm("nop");                       
     7A1 0000      NOP
(0039)    asm("nop");
     7A2 0000      NOP
(0040)    asm("nop");
     7A3 0000      NOP
(0041)    asm("nop");
     7A4 0000      NOP
(0042)    asm("nop");                       
     7A5 0000      NOP
(0043)    asm("nop");
     7A6 0000      NOP
(0044)    asm("nop");
     7A7 0000      NOP
(0045)    asm("nop");
     7A8 0000      NOP
(0046)    asm("nop");                       
     7A9 0000      NOP
(0047)    asm("nop");
     7AA 0000      NOP
(0048)    asm("nop");
     7AB 0000      NOP
(0049)    asm("nop");
     7AC 0000      NOP
(0050)    asm("nop");
     7AD 0000      NOP
(0051)    asm("nop");
     7AE 0000      NOP
(0052)    asm("nop");                       
     7AF 0000      NOP
     7B0 9508      RET
(0053) } 
(0054) 
(0055) void delay_10us(void)                 //10us延时函数,,可重复调用不影响精度
(0056) {
(0057)    delay_3us();
_delay_10us:
     7B1 DFE9      RCALL	_delay_3us
(0058)    delay_3us(); 
     7B2 DFE8      RCALL	_delay_3us
(0059)    delay_3us();  
     7B3 CFE7      RJMP	_delay_3us
(0060) }
(0061)   
(0062) void delay_50us(void)                 //48us延时函数,,可重复调用不影响精度
(0063) { 
(0064)    delay_10us();
_delay_50us:
     7B4 DFFC      RCALL	_delay_10us
(0065)    delay_10us(); 
     7B5 DFFB      RCALL	_delay_10us
(0066)    delay_10us();
     7B6 DFFA      RCALL	_delay_10us
(0067)    delay_10us();
     7B7 CFF9      RJMP	_delay_10us
(0068) }
(0069) void delay_100us(void)     //exactly 98us延时函数,,可重复调用不影响精度
(0070) {
(0071)  delay_50us();
_delay_100us:
     7B8 DFFB      RCALL	_delay_50us
(0072)  delay_50us();
     7B9 CFFA      RJMP	_delay_50us
_delay_n100us:
  n100us               --> R20
     7BA 934A      ST	R20,-Y
     7BB 2F40      MOV	R20,R16
(0073) }
(0074) void delay_n100us(unsigned char n100us)
(0075) {
     7BC C001      RJMP	0x07BE
(0076)  while(n100us--)                          
(0077)  delay_100us();
     7BD DFFA      RCALL	_delay_100us
     7BE 2E24      MOV	R2,R20
     7BF 2433      CLR	R3
     7C0 5041      SUBI	R20,1
     7C1 2022      TST	R2
     7C2 F7D1      BNE	0x07BD
     7C3 9149      LD	R20,Y+
     7C4 9508      RET
(0078) }
(0079) /*delay_n100us(2)        250us
(0080) delay_n100us(3)          360us
(0081) delay_n100us(4)          470us
(0082) delay_n100us(5)          580us
(0083) delay_n100us(6)          690us
(0084) delay_n100us(7)       800us
(0085) delay_n100us(8)          900us              主要是由于函数声明及while,,,大概6us
(0086) 
(0087) */
(0088) void delay_1ms()
(0089) {
(0090)  delay_100us();
_delay_1ms:
     7C5 DFF2      RCALL	_delay_100us
(0091)  delay_100us();
     7C6 DFF1      RCALL	_delay_100us
(0092)  delay_100us();
     7C7 DFF0      RCALL	_delay_100us
(0093)  delay_100us();
     7C8 DFEF      RCALL	_delay_100us
(0094)  delay_100us();
     7C9 DFEE      RCALL	_delay_100us
(0095)  delay_100us();
     7CA DFED      RCALL	_delay_100us
(0096)  delay_100us();
     7CB DFEC      RCALL	_delay_100us
(0097)  delay_100us();
     7CC DFEB      RCALL	_delay_100us
(0098)  delay_100us();
     7CD DFEA      RCALL	_delay_100us
(0099)  delay_100us();
     7CE CFE9      RJMP	_delay_100us
_delay_nms:
  nms                  --> R20
     7CF 934A      ST	R20,-Y
     7D0 935A      ST	R21,-Y
     7D1 01A8      MOVW	R20,R16
(0100) }
(0101) /********************************************************************
(0102) 函 数 名：Delay_ms
(0103) 建立日期：2010年1月28日
(0104) 修改日期：
(0105) 函数作用：毫秒级的精确延时程序
(0106) 说    明：
(0107) ********************************************************************/
(0108) void delay_nms(unsigned int nms)
(0109) {
     7D2 C001      RJMP	0x07D4
(0110)  while(nms--) 
(0111)  delay_1ms();
     7D3 DFF1      RCALL	_delay_1ms
     7D4 011A      MOVW	R2,R20
     7D5 5041      SUBI	R20,1
     7D6 4050      SBCI	R21,0
     7D7 2022      TST	R2
     7D8 F7D1      BNE	0x07D3
     7D9 2033      TST	R3
     7DA F7C1      BNE	0x07D3
     7DB 9159      LD	R21,Y+
     7DC 9149      LD	R20,Y+
     7DD 9508      RET
_delay_ns:
  ns                   --> R20
     7DE 934A      ST	R20,-Y
     7DF 2F40      MOV	R20,R16
(0112) }
(0113) void delay_ns(unsigned char ns)
(0114) {
     7E0 C003      RJMP	0x07E4
(0115)  while(ns--) 
(0116)  delay_nms(1000);
     7E1 EE08      LDI	R16,0xE8
     7E2 E013      LDI	R17,3
     7E3 DFEB      RCALL	_delay_nms
     7E4 2E24      MOV	R2,R20
     7E5 2433      CLR	R3
     7E6 5041      SUBI	R20,1
     7E7 2022      TST	R2
     7E8 F7C1      BNE	0x07E1
     7E9 9149      LD	R20,Y+
     7EA 9508      RET
_disp_image:
  FileInfo             --> Y,+41
  type                 --> Y,+40
  BMPInfo              --> Y,+8
  byte3                --> Y,+70
  byte2                --> Y,+69
  byte1                --> Y,+68
  p                    --> Y,+4
  first                --> Y,+67
  i                    --> Y,+65
  tmp_color            --> R14
  buffer               --> R10
  y                    --> Y,+63
  color                --> Y,+61
  x                    --> Y,+60
  count                --> Y,+58
  color_byte           --> Y,+57
  rgb                  --> Y,+56
     7EB 940E 21AD CALL	push_xgsetF0FC
     7ED 97EF      SBIW	R28,0x3F
     7EE 9728      SBIW	R28,0x8
FILE: E:\DMAVR-~3\ReadBmp\main.c
(0001) //DMAVR-M128读取SD卡中BMP图片实验，基于FAT16/32文件系统
(0002) //SD卡中图片文件为BMP形式，用Img2LCD将JPG图片转换为24位BMP图形式即可
(0003) //编译环境 ICCAVR 7.16A
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //作者：阿迪 www.avrgcc.com
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <BMP_main.h>
(0012) 
(0013) int i;
(0014) WORD image_count = 0 ,image_all = 0 ;
(0015) 
(0016) extern u16 SectorsPerClust;//每簇扇区数
(0017) 
(0018) extern u08  FAT32_Enable;
(0019)  extern char _bss_end;
(0020) 
(0021) //***********************************************************************
(0022) //			显示图片函数，每张图片轮流显示，文件位于根目录下，24位色
(0023) //***********************************************************************
(0024) void disp_image(void)
(0025)   {
(0026)     WORD count= 1 ,i =0   ;
     7EF E081      LDI	R24,1
     7F0 E090      LDI	R25,0
     7F1 AF9B      STD	Y+59,R25
     7F2 AF8A      STD	Y+58,R24
     7F3 2400      CLR	R0
     7F4 2411      CLR	R1
     7F5 01FE      MOVW	R30,R28
     7F6 5BEF      SUBI	R30,0xBF
     7F7 4FFF      SBCI	R31,0xFF
     7F8 8211      STD	Z+1,R1
     7F9 8200      STD	Z+0,R0
(0027) 	u08 *buffer ;
(0028) 	u08 type ,x , rgb,first ,color_byte,byte1,byte2,byte3 ;
(0029) 	u16 y ,color,tmp_color ;
(0030)     u32 p;							//簇指示值		
(0031) 	struct FileInfoStruct FileInfo;	//文件信息	
(0032) 	struct direntry BMPInfo;		//要显示的BMP文件信息	
(0033) 	type = 1 ;
     7FA A788      STD	Y+40,R24
(0034) 	
(0035) 	
(0036) 	
(0037) 	
(0038) 	if( image_all == 0 )    		//读取总图片数
     7FB 9020 0102 LDS	R2,image_all
     7FD 9030 0103 LDS	R3,image_all+1
     7FF 2022      TST	R2
     800 F009      BEQ	0x0802
     801 C065      RJMP	0x0867
     802 2033      TST	R3
     803 F009      BEQ	0x0805
     804 C062      RJMP	0x0867
(0039) 	  {
(0040)          image_count =  0 ;
     805 2422      CLR	R2
     806 2433      CLR	R3
     807 9230 0101 STS	image_count+1,R3
     809 9220 0100 STS	image_count,R2
(0041) 	     byte1 = Search(&BMPInfo,&image_count,&type) ;
     80B 01CE      MOVW	R24,R28
     80C 9688      ADIW	R24,0x28
     80D 8399      STD	Y+1,R25
     80E 8388      STD	Y+0,R24
     80F E020      LDI	R18,0
     810 E031      LDI	R19,1
     811 018E      MOVW	R16,R28
     812 5F08      SUBI	R16,0xF8
     813 4F1F      SBCI	R17,0xFF
     814 940E 12BF CALL	_Search
     816 01FE      MOVW	R30,R28
     817 5BEC      SUBI	R30,0xBC
     818 4FFF      SBCI	R31,0xFF
     819 8300      STD	Z+0,R16
(0042) 		 image_all = image_count ;
     81A 9020 0100 LDS	R2,image_count
     81C 9030 0101 LDS	R3,image_count+1
     81E 9230 0103 STS	image_all+1,R3
     820 9220 0102 STS	image_all,R2
(0043)  		 DisplayChar(image_all/10+'0',8,9,0xffff);  //BMP图片数量显示
     822 EF8F      LDI	R24,0xFF
     823 EF9F      LDI	R25,0xFF
     824 839B      STD	Y+3,R25
     825 838A      STD	Y+2,R24
     826 E089      LDI	R24,0x9
     827 8388      STD	Y+0,R24
     828 E028      LDI	R18,0x8
     829 E08A      LDI	R24,0xA
     82A E090      LDI	R25,0
     82B 9100 0102 LDS	R16,image_all
     82D 9110 0103 LDS	R17,image_all+1
     82F 932F      PUSH	R18
     830 933F      PUSH	R19
     831 019C      MOVW	R18,R24
     832 940E 20CE CALL	div16u
     834 913F      POP	R19
     835 912F      POP	R18
     836 5D00      SUBI	R16,0xD0
     837 4F1F      SBCI	R17,0xFF
     838 940E 1913 CALL	_DisplayChar
(0044) 		 DisplayChar(image_all%10+'0',9,9,0xffff);  //BMP图片数量显示
     83A EF8F      LDI	R24,0xFF
     83B EF9F      LDI	R25,0xFF
     83C 839B      STD	Y+3,R25
     83D 838A      STD	Y+2,R24
     83E E089      LDI	R24,0x9
     83F 8388      STD	Y+0,R24
     840 E029      LDI	R18,0x9
     841 E08A      LDI	R24,0xA
     842 E090      LDI	R25,0
     843 9100 0102 LDS	R16,image_all
     845 9110 0103 LDS	R17,image_all+1
     847 932F      PUSH	R18
     848 933F      PUSH	R19
     849 019C      MOVW	R18,R24
     84A 940E 20CC CALL	mod16u
     84C 913F      POP	R19
     84D 912F      POP	R18
     84E 5D00      SUBI	R16,0xD0
     84F 4F1F      SBCI	R17,0xFF
     850 940E 1913 CALL	_DisplayChar
(0045) 		 DisplayString("       ",10,9,0xffff);  	//BMP图片数量，最大显示99张，可以更改算法
     852 EF8F      LDI	R24,0xFF
     853 EF9F      LDI	R25,0xFF
     854 839B      STD	Y+3,R25
     855 838A      STD	Y+2,R24
     856 E089      LDI	R24,0x9
     857 8388      STD	Y+0,R24
     858 E02A      LDI	R18,0xA
     859 E900      LDI	R16,0x90
     85A E011      LDI	R17,1
     85B 940E 19F0 CALL	_DisplayString
(0046) 		 delay_nms(1000);
     85D EE08      LDI	R16,0xE8
     85E E013      LDI	R17,3
     85F DF6F      RCALL	_delay_nms
(0047) 		 image_count = 1 ;
     860 E081      LDI	R24,1
     861 E090      LDI	R25,0
     862 9390 0101 STS	image_count+1,R25
     864 9380 0100 STS	image_count,R24
(0048) 		 		 
(0049) 	  }
     866 C00F      RJMP	0x0876
(0050) 	else  
(0051)       {		
(0052)           byte1 = Search(&BMPInfo,&image_count,&type) ;
     867 01CE      MOVW	R24,R28
     868 9688      ADIW	R24,0x28
     869 8399      STD	Y+1,R25
     86A 8388      STD	Y+0,R24
     86B E020      LDI	R18,0
     86C E031      LDI	R19,1
     86D 018E      MOVW	R16,R28
     86E 5F08      SUBI	R16,0xF8
     86F 4F1F      SBCI	R17,0xFF
     870 940E 12BF CALL	_Search
     872 01FE      MOVW	R30,R28
     873 5BEC      SUBI	R30,0xBC
     874 4FFF      SBCI	R31,0xFF
     875 8300      STD	Z+0,R16
(0053)       }	
(0054) 	 
(0055) 	 
(0056) 	 
(0057) 	p = BMPInfo.deStartCluster+(((u32)BMPInfo.deHighClust)<<16);//读文件首簇
     876 8C2C      LDD	R2,Y+28
     877 8C3D      LDD	R3,Y+29
     878 2444      CLR	R4
     879 2455      CLR	R5
     87A 0121      MOVW	R4,R2
     87B 2422      CLR	R2
     87C 2433      CLR	R3
     87D A06A      LDD	R6,Y+34
     87E A07B      LDD	R7,Y+35
     87F 2488      CLR	R8
     880 2499      CLR	R9
     881 0C62      ADD	R6,R2
     882 1C73      ADC	R7,R3
     883 1C84      ADC	R8,R4
     884 1C95      ADC	R9,R5
     885 826C      STD	Y+4,R6
     886 827D      STD	Y+5,R7
     887 828E      STD	Y+6,R8
     888 829F      STD	Y+7,R9
(0058) 	
(0059) 	x = 0 ;
     889 2400      CLR	R0
     88A AE0C      STD	Y+60,R0
(0060) 	y = 159 ;
     88B E98F      LDI	R24,0x9F
     88C E090      LDI	R25,0
     88D 01FE      MOVW	R30,R28
     88E 96FF      ADIW	R30,0x3F
     88F 8391      STD	Z+1,R25
     890 8380      STD	Z+0,R24
(0061) 	rgb = 0 ;
     891 AE08      STD	Y+56,R0
(0062) 	count = 0 ;
     892 2411      CLR	R1
     893 AE1B      STD	Y+59,R1
     894 AE0A      STD	Y+58,R0
(0063) 	first = 0 ;
     895 01FE      MOVW	R30,R28
     896 5BED      SUBI	R30,0xBD
     897 4FFF      SBCI	R31,0xFF
     898 8200      STD	Z+0,R0
(0064) 	buffer=malloc(512);	
     899 E000      LDI	R16,0
     89A E012      LDI	R17,2
     89B 940E 229A CALL	_malloc
     89D 0158      MOVW	R10,R16
     89E C1CE      RJMP	0x0A6D
(0065) 	while(1)
(0066) 	 {
(0067) 		i = 0 ;
     89F 2400      CLR	R0
     8A0 2411      CLR	R1
     8A1 01FE      MOVW	R30,R28
     8A2 5BEF      SUBI	R30,0xBF
     8A3 4FFF      SBCI	R31,0xFF
     8A4 8211      STD	Z+1,R1
     8A5 8200      STD	Z+0,R0
(0068) 	
(0069) 	    for( ; i < SectorsPerClust ; i++ )      //簇
     8A6 C17B      RJMP	0x0A22
(0070) 	     {
(0071) 	 
(0072) 	        FAT_LoadPartCluster(p,i,buffer);	//读一个扇区	
     8A7 82BB      STD	Y+3,R11
     8A8 82AA      STD	Y+2,R10
     8A9 01DE      MOVW	R26,R28
     8AA 5BAF      SUBI	R26,0xBF
     8AB 4FBF      SBCI	R27,0xFF
     8AC 900D      LD	R0,X+
     8AD 901C      LD	R1,255(X)
     8AE 8219      STD	Y+1,R1
     8AF 8208      STD	Y+0,R0
     8B0 810C      LDD	R16,Y+4
     8B1 811D      LDD	R17,Y+5
     8B2 812E      LDD	R18,Y+6
     8B3 813F      LDD	R19,Y+7
     8B4 940E 0DD5 CALL	_FAT_LoadPartCluster
(0073) 	   
(0074) 	        if(i==0 && first==0) { count= buffer[0x0a] ; color_byte = buffer[0x1c] / 8  ;  first = 1 ; } 
     8B6 01FE      MOVW	R30,R28
     8B7 5BEF      SUBI	R30,0xBF
     8B8 4FFF      SBCI	R31,0xFF
     8B9 8000      LDD	R0,Z+0
     8BA 8011      LDD	R1,Z+1
     8BB 2000      TST	R0
     8BC F4C9      BNE	0x08D6
     8BD 2011      TST	R1
     8BE F4B9      BNE	0x08D6
     8BF 01FE      MOVW	R30,R28
     8C0 5BED      SUBI	R30,0xBD
     8C1 4FFF      SBCI	R31,0xFF
     8C2 8000      LDD	R0,Z+0
     8C3 2000      TST	R0
     8C4 F489      BNE	0x08D6
     8C5 01F5      MOVW	R30,R10
     8C6 8422      LDD	R2,Z+10
     8C7 2433      CLR	R3
     8C8 AE3B      STD	Y+59,R3
     8C9 AE2A      STD	Y+58,R2
     8CA 8C24      LDD	R2,Z+28
     8CB 9426      LSR	R2
     8CC 9426      LSR	R2
     8CD 9426      LSR	R2
     8CE AE29      STD	Y+57,R2
     8CF 2400      CLR	R0
     8D0 9403      INC	R0
     8D1 01FE      MOVW	R30,R28
     8D2 5BED      SUBI	R30,0xBD
     8D3 4FFF      SBCI	R31,0xFF
     8D4 8200      STD	Z+0,R0
     8D5 C13A      RJMP	0x0A10
(0075) 	        else { count=0 ; }
     8D6 2400      CLR	R0
     8D7 2411      CLR	R1
     8D8 AE1B      STD	Y+59,R1
     8D9 AE0A      STD	Y+58,R0
     8DA C135      RJMP	0x0A10
(0076) 	   
(0077) 	        
(0078) 			
(0079) 			while(count<512)  //读取一簇512扇区 (SectorsPerClust 每簇扇区数)
(0080) 	          {
(0081) 		   
(0082) 		        if(color_byte == 3)   //24位颜色图
     8DB AD89      LDD	R24,Y+57
     8DC 3083      CPI	R24,3
     8DD F009      BEQ	0x08DF
     8DE C057      RJMP	0x0936
(0083) 		          {
(0084)                       switch ( rgb ) 
     8DF ACC8      LDD	R12,Y+56
     8E0 24DD      CLR	R13
     8E1 20CC      TST	R12
     8E2 F411      BNE	0x08E5
     8E3 20DD      TST	R13
     8E4 F059      BEQ	0x08F0
     8E5 01C6      MOVW	R24,R12
     8E6 3081      CPI	R24,1
     8E7 E0E0      LDI	R30,0
     8E8 079E      CPC	R25,R30
     8E9 F0C9      BEQ	0x0903
     8EA 3082      CPI	R24,2
     8EB E0E0      LDI	R30,0
     8EC 079E      CPC	R25,R30
     8ED F409      BNE	0x08EF
     8EE C02B      RJMP	0x091A
     8EF C042      RJMP	0x0932
(0085)                         {
(0086) 			               case 0 : tmp_color = buffer[count]>>3 ;
     8F0 ADEA      LDD	R30,Y+58
     8F1 ADFB      LDD	R31,Y+59
     8F2 0DEA      ADD	R30,R10
     8F3 1DFB      ADC	R31,R11
     8F4 80E0      LDD	R14,Z+0
     8F5 24FF      CLR	R15
     8F6 94F5      ASR	R15
     8F7 94E7      ROR	R14
     8F8 94F5      ASR	R15
     8F9 94E7      ROR	R14
     8FA 94F5      ASR	R15
     8FB 94E7      ROR	R14
(0087) 			                        color |= tmp_color;
     8FC AC0D      LDD	R0,Y+61
     8FD AC1E      LDD	R1,Y+62
     8FE 280E      OR	R0,R14
     8FF 281F      OR	R1,R15
     900 AE1E      STD	Y+62,R1
     901 AE0D      STD	Y+61,R0
(0088) 					                break ;
     902 C02F      RJMP	0x0932
(0089) 					  
(0090) 			               case 1 : tmp_color = buffer[count]>>2 ;
     903 ADEA      LDD	R30,Y+58
     904 ADFB      LDD	R31,Y+59
     905 0DEA      ADD	R30,R10
     906 1DFB      ADC	R31,R11
     907 80E0      LDD	R14,Z+0
     908 24FF      CLR	R15
     909 94F5      ASR	R15
     90A 94E7      ROR	R14
     90B 94F5      ASR	R15
     90C 94E7      ROR	R14
(0091) 			                        tmp_color <<= 5 ;
     90D E025      LDI	R18,5
     90E E030      LDI	R19,0
     90F 0187      MOVW	R16,R14
     910 940E 2231 CALL	lsl16
     912 0178      MOVW	R14,R16
(0092) 			                        color |= tmp_color ;
     913 AC0D      LDD	R0,Y+61
     914 AC1E      LDD	R1,Y+62
     915 2A00      OR	R0,R16
     916 2A11      OR	R1,R17
     917 AE1E      STD	Y+62,R1
     918 AE0D      STD	Y+61,R0
(0093) 					                break ;
     919 C018      RJMP	0x0932
(0094) 					   
(0095)        			           case 2 : tmp_color = buffer[count]>>3 ;
     91A ADEA      LDD	R30,Y+58
     91B ADFB      LDD	R31,Y+59
     91C 0DEA      ADD	R30,R10
     91D 1DFB      ADC	R31,R11
     91E 80E0      LDD	R14,Z+0
     91F 24FF      CLR	R15
     920 94F5      ASR	R15
     921 94E7      ROR	R14
     922 94F5      ASR	R15
     923 94E7      ROR	R14
     924 94F5      ASR	R15
     925 94E7      ROR	R14
(0096) 			                        tmp_color <<= 11 ;
     926 E02B      LDI	R18,0xB
     927 E030      LDI	R19,0
     928 0187      MOVW	R16,R14
     929 940E 2231 CALL	lsl16
     92B 0178      MOVW	R14,R16
(0097) 			                        color |= tmp_color ;
     92C AC0D      LDD	R0,Y+61
     92D AC1E      LDD	R1,Y+62
     92E 2A00      OR	R0,R16
     92F 2A11      OR	R1,R17
     930 AE1E      STD	Y+62,R1
     931 AE0D      STD	Y+61,R0
(0098) 					                 break ;			
(0099) 			            }
(0100) 			
(0101)                       rgb ++ ;
     932 AC08      LDD	R0,Y+56
     933 9403      INC	R0
     934 AE08      STD	Y+56,R0
(0102) 			      }
     935 C0A9      RJMP	0x09DF
(0103) 		        else
(0104) 		          {
(0105) 			          if(color_byte==2)  //16位颜色图
     936 AD89      LDD	R24,Y+57
     937 3082      CPI	R24,2
     938 F009      BEQ	0x093A
     939 C030      RJMP	0x096A
(0106) 				        {
(0107) 				          switch ( rgb )
     93A ACC8      LDD	R12,Y+56
     93B 24DD      CLR	R13
     93C 20CC      TST	R12
     93D F411      BNE	0x0940
     93E 20DD      TST	R13
     93F F031      BEQ	0x0946
     940 01C6      MOVW	R24,R12
     941 3081      CPI	R24,1
     942 E0E0      LDI	R30,0
     943 079E      CPC	R25,R30
     944 F059      BEQ	0x0950
     945 C020      RJMP	0x0966
(0108) 					        {
(0109) 					          case 0 : byte1 = buffer[count] ;
     946 ADEA      LDD	R30,Y+58
     947 ADFB      LDD	R31,Y+59
     948 0DEA      ADD	R30,R10
     949 1DFB      ADC	R31,R11
     94A 8020      LDD	R2,Z+0
     94B 01FE      MOVW	R30,R28
     94C 5BEC      SUBI	R30,0xBC
     94D 4FFF      SBCI	R31,0xFF
     94E 8220      STD	Z+0,R2
(0110) 								       break ; 
     94F C016      RJMP	0x0966
(0111) 								   
(0112) 						      case 1 :    
(0113) 								       color = buffer[count] ;
     950 ADEA      LDD	R30,Y+58
     951 ADFB      LDD	R31,Y+59
     952 0DEA      ADD	R30,R10
     953 1DFB      ADC	R31,R11
     954 8020      LDD	R2,Z+0
     955 2433      CLR	R3
     956 AE3E      STD	Y+62,R3
     957 AE2D      STD	Y+61,R2
(0114) 								       color<<=8 ;
     958 0101      MOVW	R0,R2
     959 2C10      MOV	R1,R0
     95A 2400      CLR	R0
     95B AE1E      STD	Y+62,R1
     95C AE0D      STD	Y+61,R0
(0115) 								       color |= byte1 ;
     95D 01FE      MOVW	R30,R28
     95E 5BEC      SUBI	R30,0xBC
     95F 4FFF      SBCI	R31,0xFF
     960 8020      LDD	R2,Z+0
     961 2433      CLR	R3
     962 2802      OR	R0,R2
     963 2813      OR	R1,R3
     964 AE1E      STD	Y+62,R1
     965 AE0D      STD	Y+61,R0
(0116) 								       break ;
(0117) 					     
(0118) 					        }
(0119) 					      rgb ++ ;
     966 AC08      LDD	R0,Y+56
     967 9403      INC	R0
     968 AE08      STD	Y+56,R0
(0120) 				    
(0121) 				        }
     969 C075      RJMP	0x09DF
(0122) 				      else 
(0123) 				        {
(0124) 				          if(color_byte==4) //32位颜色图
     96A AD89      LDD	R24,Y+57
     96B 3084      CPI	R24,4
     96C F009      BEQ	0x096E
     96D C071      RJMP	0x09DF
(0125) 				            {
(0126) 				              switch ( rgb )
     96E ACC8      LDD	R12,Y+56
     96F 24DD      CLR	R13
     970 20CC      TST	R12
     971 F411      BNE	0x0974
     972 20DD      TST	R13
     973 F071      BEQ	0x0982
     974 01C6      MOVW	R24,R12
     975 3081      CPI	R24,1
     976 E0E0      LDI	R30,0
     977 079E      CPC	R25,R30
     978 F099      BEQ	0x098C
     979 3082      CPI	R24,2
     97A E0E0      LDI	R30,0
     97B 079E      CPC	R25,R30
     97C F0C9      BEQ	0x0996
     97D 3083      CPI	R24,3
     97E E0E0      LDI	R30,0
     97F 079E      CPC	R25,R30
     980 F0F9      BEQ	0x09A0
     981 C05A      RJMP	0x09DC
(0127) 					            {
(0128) 					              case 0 :  byte1 = buffer[count] ;
     982 ADEA      LDD	R30,Y+58
     983 ADFB      LDD	R31,Y+59
     984 0DEA      ADD	R30,R10
     985 1DFB      ADC	R31,R11
     986 8020      LDD	R2,Z+0
     987 01FE      MOVW	R30,R28
     988 5BEC      SUBI	R30,0xBC
     989 4FFF      SBCI	R31,0xFF
     98A 8220      STD	Z+0,R2
(0129) 								            break ; 
     98B C050      RJMP	0x09DC
(0130) 								   
(0131) 						          case 1 :  byte2 = buffer[count] ;
     98C ADEA      LDD	R30,Y+58
     98D ADFB      LDD	R31,Y+59
     98E 0DEA      ADD	R30,R10
     98F 1DFB      ADC	R31,R11
     990 8020      LDD	R2,Z+0
     991 01FE      MOVW	R30,R28
     992 5BEB      SUBI	R30,0xBB
     993 4FFF      SBCI	R31,0xFF
     994 8220      STD	Z+0,R2
(0132)                                             break ;
     995 C046      RJMP	0x09DC
(0133) 									   
(0134) 							      case 2 :  byte3 = buffer[count] ;
     996 ADEA      LDD	R30,Y+58
     997 ADFB      LDD	R31,Y+59
     998 0DEA      ADD	R30,R10
     999 1DFB      ADC	R31,R11
     99A 8020      LDD	R2,Z+0
     99B 01FE      MOVW	R30,R28
     99C 5BEA      SUBI	R30,0xBA
     99D 4FFF      SBCI	R31,0xFF
     99E 8220      STD	Z+0,R2
(0135) 							                break ;
     99F C03C      RJMP	0x09DC
(0136) 									   
(0137) 							      case 3 :  tmp_color = byte1 >> 3 ;
     9A0 01FE      MOVW	R30,R28
     9A1 5BEC      SUBI	R30,0xBC
     9A2 4FFF      SBCI	R31,0xFF
     9A3 80E0      LDD	R14,Z+0
     9A4 24FF      CLR	R15
     9A5 94F5      ASR	R15
     9A6 94E7      ROR	R14
     9A7 94F5      ASR	R15
     9A8 94E7      ROR	R14
     9A9 94F5      ASR	R15
     9AA 94E7      ROR	R14
(0138) 			                                color |= tmp_color;
     9AB AC0D      LDD	R0,Y+61
     9AC AC1E      LDD	R1,Y+62
     9AD 280E      OR	R0,R14
     9AE 281F      OR	R1,R15
     9AF AE1E      STD	Y+62,R1
     9B0 AE0D      STD	Y+61,R0
(0139) 									        tmp_color = byte2 >>2 ;
     9B1 01FE      MOVW	R30,R28
     9B2 5BEB      SUBI	R30,0xBB
     9B3 4FFF      SBCI	R31,0xFF
     9B4 80E0      LDD	R14,Z+0
     9B5 24FF      CLR	R15
     9B6 94F5      ASR	R15
     9B7 94E7      ROR	R14
     9B8 94F5      ASR	R15
     9B9 94E7      ROR	R14
(0140) 			                                tmp_color <<= 5 ;
     9BA E025      LDI	R18,5
     9BB E030      LDI	R19,0
     9BC 0187      MOVW	R16,R14
     9BD 940E 2231 CALL	lsl16
(0141) 			                                color |= tmp_color ;
     9BF AC0D      LDD	R0,Y+61
     9C0 AC1E      LDD	R1,Y+62
     9C1 2A00      OR	R0,R16
     9C2 2A11      OR	R1,R17
     9C3 AE1E      STD	Y+62,R1
     9C4 AE0D      STD	Y+61,R0
(0142) 									        tmp_color = byte3 >>3 ;
     9C5 01FE      MOVW	R30,R28
     9C6 5BEA      SUBI	R30,0xBA
     9C7 4FFF      SBCI	R31,0xFF
     9C8 80E0      LDD	R14,Z+0
     9C9 24FF      CLR	R15
     9CA 94F5      ASR	R15
     9CB 94E7      ROR	R14
     9CC 94F5      ASR	R15
     9CD 94E7      ROR	R14
     9CE 94F5      ASR	R15
     9CF 94E7      ROR	R14
(0143) 			                                tmp_color <<= 11 ;
     9D0 E02B      LDI	R18,0xB
     9D1 E030      LDI	R19,0
     9D2 0187      MOVW	R16,R14
     9D3 940E 2231 CALL	lsl16
     9D5 0178      MOVW	R14,R16
(0144) 			                                color |= tmp_color ;
     9D6 AC0D      LDD	R0,Y+61
     9D7 AC1E      LDD	R1,Y+62
     9D8 2A00      OR	R0,R16
     9D9 2A11      OR	R1,R17
     9DA AE1E      STD	Y+62,R1
     9DB AE0D      STD	Y+61,R0
(0145) 									        break ;
(0146) 					     
(0147) 					            }
(0148) 					           rgb ++ ;
     9DC AC08      LDD	R0,Y+56
     9DD 9403      INC	R0
     9DE AE08      STD	Y+56,R0
(0149) 				    
(0150) 				            }
(0151) 				     
(0152) 				        }   
(0153) 			 
(0154) 			       }
(0155)            
(0156) 		   count ++ ;
     9DF AD8A      LDD	R24,Y+58
     9E0 AD9B      LDD	R25,Y+59
     9E1 9601      ADIW	R24,1
     9E2 AF9B      STD	Y+59,R25
     9E3 AF8A      STD	Y+58,R24
(0157) 		   
(0158) 		   if(rgb == color_byte)        //读取1像素数数据后显示
     9E4 AC08      LDD	R0,Y+56
     9E5 AD09      LDD	R16,Y+57
     9E6 1600      CP	R0,R16
     9E7 F541      BNE	0x0A10
(0159) 		     {
(0160) 			    GUIpoint(x, y,color) ;
     9E8 AC0D      LDD	R0,Y+61
     9E9 AC1E      LDD	R1,Y+62
     9EA 8219      STD	Y+1,R1
     9EB 8208      STD	Y+0,R0
     9EC 01FE      MOVW	R30,R28
     9ED 96FF      ADIW	R30,0x3F
     9EE 8120      LDD	R18,Z+0
     9EF 8131      LDD	R19,Z+1
     9F0 AD0C      LDD	R16,Y+60
     9F1 940E 1A41 CALL	_GUIpoint
(0161) 				color = 0x00 ;
     9F3 2400      CLR	R0
     9F4 2411      CLR	R1
     9F5 AE1E      STD	Y+62,R1
     9F6 AE0D      STD	Y+61,R0
(0162) 			    x++ ;
     9F7 AC0C      LDD	R0,Y+60
     9F8 9403      INC	R0
     9F9 AE0C      STD	Y+60,R0
(0163) 			    if(x>=128)
     9FA 2D80      MOV	R24,R0
     9FB 3880      CPI	R24,0x80
     9FC F088      BCS	0x0A0E
(0164) 				  {
(0165) 				    y-- ;
     9FD 01FE      MOVW	R30,R28
     9FE 96FF      ADIW	R30,0x3F
     9FF 8180      LDD	R24,Z+0
     A00 8191      LDD	R25,Z+1
     A01 9701      SBIW	R24,1
     A02 01FE      MOVW	R30,R28
     A03 96FF      ADIW	R30,0x3F
     A04 8391      STD	Z+1,R25
     A05 8380      STD	Z+0,R24
(0166) 					
(0167) 					if( (y+1)<=0 )
     A06 9601      ADIW	R24,1
     A07 F421      BNE	0x0A0C
(0168) 		              {
(0169) 					    
(0170) 						free(buffer) ;
     A08 0185      MOVW	R16,R10
     A09 940E 2399 CALL	_free
(0171) 			            return ;
     A0B C062      RJMP	0x0A6E
(0172) 			          }
(0173) 					x = 0 ;
     A0C 2400      CLR	R0
     A0D AE0C      STD	Y+60,R0
(0174) 				  }
(0175) 		        
(0176) 				rgb = 0 ;
     A0E 2400      CLR	R0
     A0F AE08      STD	Y+56,R0
     A10 AD8A      LDD	R24,Y+58
     A11 AD9B      LDD	R25,Y+59
     A12 3080      CPI	R24,0
     A13 E0E2      LDI	R30,2
     A14 079E      CPC	R25,R30
     A15 F408      BCC	0x0A17
     A16 CEC4      RJMP	0x08DB
     A17 01FE      MOVW	R30,R28
     A18 5BEF      SUBI	R30,0xBF
     A19 4FFF      SBCI	R31,0xFF
     A1A 8180      LDD	R24,Z+0
     A1B 8191      LDD	R25,Z+1
     A1C 9601      ADIW	R24,1
     A1D 01FE      MOVW	R30,R28
     A1E 5BEF      SUBI	R30,0xBF
     A1F 4FFF      SBCI	R31,0xFF
     A20 8391      STD	Z+1,R25
     A21 8380      STD	Z+0,R24
     A22 9020 0E04 LDS	R2,SectorsPerClust
     A24 9030 0E05 LDS	R3,SectorsPerClust+1
     A26 01FE      MOVW	R30,R28
     A27 5BEF      SUBI	R30,0xBF
     A28 4FFF      SBCI	R31,0xFF
     A29 8000      LDD	R0,Z+0
     A2A 8011      LDD	R1,Z+1
     A2B 1402      CP	R0,R2
     A2C 0413      CPC	R1,R3
     A2D F408      BCC	0x0A2F
     A2E CE78      RJMP	0x08A7
(0177) 			 }
(0178) 			 
(0179) 			
(0180) 		}
(0181) 	   
(0182) 	 }  // 读取完一簇数据
(0183) 	 
(0184) 	 free(buffer) ;
     A2F 0185      MOVW	R16,R10
     A30 940E 2399 CALL	_free
(0185) 	 p=FAT_NextCluster(p);//读下一簇数据			
     A32 810C      LDD	R16,Y+4
     A33 811D      LDD	R17,Y+5
     A34 812E      LDD	R18,Y+6
     A35 813F      LDD	R19,Y+7
     A36 940E 0E22 CALL	_FAT_NextCluster
     A38 830C      STD	Y+4,R16
     A39 831D      STD	Y+5,R17
     A3A 832E      STD	Y+6,R18
     A3B 833F      STD	Y+7,R19
(0186) 	 buffer=malloc(512);	
     A3C E000      LDI	R16,0
     A3D E012      LDI	R17,2
     A3E 940E 229A CALL	_malloc
     A40 0178      MOVW	R14,R16
     A41 0157      MOVW	R10,R14
(0187) 	
(0188) 	if(p == 0x0fffffff || p == 0x0ffffff8 || (FAT32_Enable == 0 && p == 0xffff))//如果无后续簇则结束
     A42 EF4F      LDI	R20,0xFF
     A43 EF5F      LDI	R21,0xFF
     A44 EF6F      LDI	R22,0xFF
     A45 E07F      LDI	R23,0xF
     A46 802C      LDD	R2,Y+4
     A47 803D      LDD	R3,Y+5
     A48 804E      LDD	R4,Y+6
     A49 805F      LDD	R5,Y+7
     A4A 1624      CP	R2,R20
     A4B 0635      CPC	R3,R21
     A4C 0646      CPC	R4,R22
     A4D 0657      CPC	R5,R23
     A4E F0D1      BEQ	0x0A69
     A4F EF48      LDI	R20,0xF8
     A50 EF5F      LDI	R21,0xFF
     A51 EF6F      LDI	R22,0xFF
     A52 E07F      LDI	R23,0xF
     A53 1624      CP	R2,R20
     A54 0635      CPC	R3,R21
     A55 0646      CPC	R4,R22
     A56 0657      CPC	R5,R23
     A57 F089      BEQ	0x0A69
     A58 9020 0DF3 LDS	R2,FAT32_Enable
     A5A 2022      TST	R2
     A5B F489      BNE	0x0A6D
     A5C EF4F      LDI	R20,0xFF
     A5D EF5F      LDI	R21,0xFF
     A5E E060      LDI	R22,0
     A5F E070      LDI	R23,0
     A60 802C      LDD	R2,Y+4
     A61 803D      LDD	R3,Y+5
     A62 804E      LDD	R4,Y+6
     A63 805F      LDD	R5,Y+7
     A64 1624      CP	R2,R20
     A65 0635      CPC	R3,R21
     A66 0646      CPC	R4,R22
     A67 0657      CPC	R5,R23
     A68 F421      BNE	0x0A6D
(0189) 		{
(0190) 		        free(buffer) ;
     A69 0185      MOVW	R16,R10
     A6A 940E 2399 CALL	_free
(0191) 				return ;
     A6C C001      RJMP	0x0A6E
     A6D CE31      RJMP	0x089F
     A6E 96EF      ADIW	R28,0x3F
     A6F 9628      ADIW	R28,0x8
     A70 940C 21A2 JMP	pop_xgsetF0FC
(0192) 		}
(0193) 	 
(0194)   }
(0195) 		
(0196) 	free(buffer) ;
(0197)   
(0198)  }
(0199) //***********************************************************************
(0200) //			关闭数码管，防止显示乱码
(0201) //***********************************************************************
(0202) void LED_Off()
(0203) {
(0204)     PORTD=0xFF;
_LED_Off:
     A72 EF8F      LDI	R24,0xFF
     A73 BB82      OUT	0x12,R24
(0205) 	DDRD=0xFF;
     A74 BB81      OUT	0x11,R24
(0206) 	D_LE1;                             				//关掉数码管，以免显示乱码                   
     A75 9A94      SBI	0x12,4
(0207)     W_LE1;                     
     A76 9A95      SBI	0x12,5
(0208)     Data_IO=0xFF;                      				//关数码管            
     A77 BB8B      OUT	0x1B,R24
(0209)     W_LE0; 
     A78 9895      CBI	0x12,5
     A79 9508      RET
_main:
  y                    --> R12
  er                   --> R12
  ok                   --> R12
  x                    --> R20
  retry                --> R10
  i                    --> R20
     A7A 9726      SBIW	R28,6
(0210) }
(0211) //***********************************************************************
(0212) //			主函数，初始化及函数调用
(0213) //***********************************************************************
(0214) void main(void)
(0215) {
(0216)   unsigned char i, x,retry=0;
     A7B 24AA      CLR	R10
(0217)   u08 ok,er ;
(0218)   unsigned int y ;
(0219)   delay_nms(10);
     A7C E00A      LDI	R16,0xA
     A7D E010      LDI	R17,0
     A7E DD50      RCALL	_delay_nms
(0220)   McuInit();
     A7F 940E 16E8 CALL	_McuInit
(0221)   UART_Init();
     A81 940E 1C7B CALL	_UART_Init
(0222)   LCD_RD1; 
     A83 9180 0065 LDS	R24,0x0065
     A85 6180      ORI	R24,0x10
     A86 9380 0065 STS	0x0065,R24
(0223)   LCD_Init();     									//LCD初始化
     A88 940E 1835 CALL	_LCD_Init
(0224)   x = 1 ;
(0225)   y = 0 ;
     A8A 24CC      CLR	R12
     A8B 24DD      CLR	R13
(0226)   LCD_clear(0) ;
     A8C 2700      CLR	R16
     A8D 2711      CLR	R17
     A8E 940E 18C5 CALL	_LCD_clear
(0227)   	
(0228)   for(i=0; i<5 ;i++)
     A90 2744      CLR	R20
     A91 C00D      RJMP	0x0A9F
(0229)    {
(0230) 	DisplayGB2312(i+18,i+1,0,0x07E0) ;    			//显示欣世纪电子
     A92 EE80      LDI	R24,0xE0
     A93 E097      LDI	R25,7
     A94 839B      STD	Y+3,R25
     A95 838A      STD	Y+2,R24
     A96 2422      CLR	R2
     A97 8228      STD	Y+0,R2
     A98 2F24      MOV	R18,R20
     A99 5F2F      SUBI	R18,0xFF
     A9A 2F04      MOV	R16,R20
     A9B 5E0E      SUBI	R16,0xEE
     A9C 940E 1987 CALL	_DisplayGB2312
     A9E 9543      INC	R20
     A9F 3045      CPI	R20,5
     AA0 F388      BCS	0x0A92
(0231)    }
(0232) 	DisplayString("DMAVR-128 Board",0,1,0xf800);  	//字符串显示调用
     AA1 E080      LDI	R24,0
     AA2 EF98      LDI	R25,0xF8
     AA3 839B      STD	Y+3,R25
     AA4 838A      STD	Y+2,R24
     AA5 E081      LDI	R24,1
     AA6 8388      STD	Y+0,R24
     AA7 2722      CLR	R18
     AA8 E800      LDI	R16,0x80
     AA9 E011      LDI	R17,1
     AAA 940E 19F0 CALL	_DisplayString
(0233) 	DisplayString("Show BMP from SD",0,2,0xeee);  	//字符串显示调用
     AAC EE8E      LDI	R24,0xEE
     AAD E09E      LDI	R25,0xE
     AAE 839B      STD	Y+3,R25
     AAF 838A      STD	Y+2,R24
     AB0 E082      LDI	R24,2
     AB1 8388      STD	Y+0,R24
     AB2 2722      CLR	R18
     AB3 E60F      LDI	R16,0x6F
     AB4 E011      LDI	R17,1
     AB5 940E 19F0 CALL	_DisplayString
(0234) 	GUIline(0,49,127,49,0xe387);
     AB7 E887      LDI	R24,0x87
     AB8 EE93      LDI	R25,0xE3
     AB9 839D      STD	Y+5,R25
     ABA 838C      STD	Y+4,R24
     ABB E381      LDI	R24,0x31
     ABC 838A      STD	Y+2,R24
     ABD E78F      LDI	R24,0x7F
     ABE 8388      STD	Y+0,R24
     ABF E321      LDI	R18,0x31
     AC0 2700      CLR	R16
     AC1 940E 1A73 CALL	_GUIline
(0235) 	GUIline(0,51,127,51,0xfef);
     AC3 EE8F      LDI	R24,0xEF
     AC4 E09F      LDI	R25,0xF
     AC5 839D      STD	Y+5,R25
     AC6 838C      STD	Y+4,R24
     AC7 E383      LDI	R24,0x33
     AC8 838A      STD	Y+2,R24
     AC9 E78F      LDI	R24,0x7F
     ACA 8388      STD	Y+0,R24
     ACB E323      LDI	R18,0x33
     ACC 2700      CLR	R16
     ACD 940E 1A73 CALL	_GUIline
(0236) 		
(0237)  	ok = 0 ;
(0238)  	er = 0 ;
     ACF 24CC      CLR	R12
(0239) 	DisplayString("Starting Init SD",0,4,0xffff);  //字符串显示调用
     AD0 EF8F      LDI	R24,0xFF
     AD1 EF9F      LDI	R25,0xFF
     AD2 839B      STD	Y+3,R25
     AD3 838A      STD	Y+2,R24
     AD4 E084      LDI	R24,4
     AD5 8388      STD	Y+0,R24
     AD6 2722      CLR	R18
     AD7 E50E      LDI	R16,0x5E
     AD8 E011      LDI	R17,1
     AD9 940E 19F0 CALL	_DisplayString
(0240) 	DisplayString("Waiting...",0,5,0xffff);  		//字符串显示调用
     ADB EF8F      LDI	R24,0xFF
     ADC EF9F      LDI	R25,0xFF
     ADD 839B      STD	Y+3,R25
     ADE 838A      STD	Y+2,R24
     ADF E085      LDI	R24,5
     AE0 8388      STD	Y+0,R24
     AE1 2722      CLR	R18
     AE2 E503      LDI	R16,0x53
     AE3 E011      LDI	R17,1
     AE4 940E 19F0 CALL	_DisplayString
(0241)   	mmcInit();
     AE6 940E 1497 CALL	_mmcInit
(0242)   	delay_nms(1);
     AE8 E001      LDI	R16,1
     AE9 E010      LDI	R17,0
     AEA DCE4      RCALL	_delay_nms
     AEB C01C      RJMP	0x0B08
(0243)   
(0244) 	  
(0245)   while(mmcReset())									//初始化SD卡					
(0246) 	{
(0247) 		retry++;
     AEC 94A3      INC	R10
(0248) 		if(retry>20)
     AED E184      LDI	R24,0x14
     AEE 158A      CP	R24,R10
     AEF F4C0      BCC	0x0B08
(0249) 		{
     AF0 C016      RJMP	0x0B07
(0250) 			while(1)   											//初始化失败显示
(0251) 			{
(0252) 				DisplayString("Init Failure",0,7,0xf800);  		//字符串显示调用
     AF1 E080      LDI	R24,0
     AF2 EF98      LDI	R25,0xF8
     AF3 839B      STD	Y+3,R25
     AF4 838A      STD	Y+2,R24
     AF5 E087      LDI	R24,7
     AF6 8388      STD	Y+0,R24
     AF7 2722      CLR	R18
     AF8 E406      LDI	R16,0x46
     AF9 E011      LDI	R17,1
     AFA 940E 19F0 CALL	_DisplayString
(0253) 	            DisplayString("Please Check SD",0,8,0xf800);  	//字符串显示调用
     AFC E080      LDI	R24,0
     AFD EF98      LDI	R25,0xF8
     AFE 839B      STD	Y+3,R25
     AFF 838A      STD	Y+2,R24
     B00 E088      LDI	R24,0x8
     B01 8388      STD	Y+0,R24
     B02 2722      CLR	R18
     B03 E306      LDI	R16,0x36
     B04 E011      LDI	R17,1
     B05 940E 19F0 CALL	_DisplayString
     B07 CFE9      RJMP	0x0AF1
     B08 940E 14A4 CALL	_mmcReset
     B0A 2300      TST	R16
     B0B F701      BNE	0x0AEC
(0254) 			}
(0255) 		}
(0256) 	} 
(0257) 	  	  
(0258) 	DisplayString("Init SD Success!",0,6,0xffff);  				//字符串显示调用
     B0C EF8F      LDI	R24,0xFF
     B0D EF9F      LDI	R25,0xFF
     B0E 839B      STD	Y+3,R25
     B0F 838A      STD	Y+2,R24
     B10 E086      LDI	R24,6
     B11 8388      STD	Y+0,R24
     B12 2722      CLR	R18
     B13 E205      LDI	R16,0x25
     B14 E011      LDI	R17,1
     B15 940E 19F0 CALL	_DisplayString
(0259) 	 
(0260) 	
(0261) 	if(FAT_Init())												//初始化文件系统 支持FAT16和FAT32	
     B17 940E 0C54 CALL	_FAT_Init
     B19 2300      TST	R16
     B1A F071      BEQ	0x0B29
(0262) 	{
     B1B C00C      RJMP	0x0B28
(0263) 		while(1)
(0264) 		{
(0265) 			while(1)
(0266) 			{
(0267) 				DisplayString("Init FAT Failure",0,7,0xf800);  //字符串显示调用
     B1C E080      LDI	R24,0
     B1D EF98      LDI	R25,0xF8
     B1E 839B      STD	Y+3,R25
     B1F 838A      STD	Y+2,R24
     B20 E087      LDI	R24,7
     B21 8388      STD	Y+0,R24
     B22 2722      CLR	R18
     B23 E104      LDI	R16,0x14
     B24 E011      LDI	R17,1
     B25 940E 19F0 CALL	_DisplayString
     B27 CFF4      RJMP	0x0B1C
     B28 CFFE      RJMP	0x0B27
(0268) 			}
(0269) 		}
(0270) 
(0271) 	}
(0272) 	printf("Begin initing\r\n");
     B29 E004      LDI	R16,4
     B2A E011      LDI	R17,1
     B2B 940E 25F4 CALL	_printf
(0273) 	_NewHeap(&_bss_end+1, &_bss_end + 550);                     //动态分配内存(malloc(512))需要初始化，空间比需要分配的要大才行
     B2D E526      LDI	R18,0x56
     B2E E130      LDI	R19,0x10
     B2F E301      LDI	R16,0x31
     B30 E01E      LDI	R17,0xE
     B31 940E 225D CALL	__NewHeap
(0274) 	SearchInit();  												//搜索文件初始化
     B33 940E 1229 CALL	_SearchInit
     B35 C022      RJMP	0x0B58
(0275) 
(0276) 	
(0277) 	while(1)                               						//轮流显示SD卡中的图片
(0278) 	 {
(0279) 	    disp_image() ;
     B36 DCB4      RCALL	_disp_image
(0280) 		delay_nms(1000) ;
     B37 EE08      LDI	R16,0xE8
     B38 E013      LDI	R17,3
     B39 DC95      RCALL	_delay_nms
(0281) 		delay_nms(1000) ;
     B3A EE08      LDI	R16,0xE8
     B3B E013      LDI	R17,3
     B3C DC92      RCALL	_delay_nms
(0282) 		delay_nms(1000) ;
     B3D EE08      LDI	R16,0xE8
     B3E E013      LDI	R17,3
     B3F DC8F      RCALL	_delay_nms
(0283) 		                              			
(0284) 		if(image_count<image_all)								//轮流显示SD卡中的BMP图片
     B40 9020 0102 LDS	R2,image_all
     B42 9030 0103 LDS	R3,image_all+1
     B44 9040 0100 LDS	R4,image_count
     B46 9050 0101 LDS	R5,image_count+1
     B48 1442      CP	R4,R2
     B49 0453      CPC	R5,R3
     B4A F438      BCC	0x0B52
(0285) 		    {
(0286) 		      image_count ++ ;
     B4B 01C2      MOVW	R24,R4
     B4C 9601      ADIW	R24,1
     B4D 9390 0101 STS	image_count+1,R25
     B4F 9380 0100 STS	image_count,R24
(0287) 		    }
     B51 C006      RJMP	0x0B58
(0288) 		 else 
(0289) 		    {
(0290) 			  image_count = 1 ;
     B52 E081      LDI	R24,1
     B53 E090      LDI	R25,0
     B54 9390 0101 STS	image_count+1,R25
     B56 9380 0100 STS	image_count,R24
     B58 CFDD      RJMP	0x0B36
     B59 9626      ADIW	R28,6
     B5A 9508      RET
_SD_SizeDisplay:
  Size                 --> Y,+4
  Capacity             --> Y,+8
     B5B 940E 20C0 CALL	push_arg4
     B5D 9728      SBIW	R28,0x8
FILE: E:\DMAVR-~3\ReadBmp\FAT.c
(0001) //FAT文件系统驱动程序，对网络开源代码的更改		
(0002) //编译环境 ICCAVR 7.16A
(0003) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0004) //作者： www.avrgcc.com
(0005) //日期：2010.01.14 
(0006) 
(0007) #include"FAT.h"
(0008) 
(0009) DWORD FirstDirClust;    //first directory cluster
(0010) DWORD FirstDataSector;	// The first sector number of data
(0011) WORD BytesPerSector;	// Bytes per sector
(0012) WORD FATsectors;		// The amount sector a FAT occupied
(0013) WORD SectorsPerClust;	// Sector per cluster
(0014) DWORD FirstFATSector;	// The first FAT sector
(0015) DWORD FirstDirSector;	// The first Dir sector
(0016) DWORD RootDirSectors;	// The sector number a Root dir occupied 
(0017) DWORD RootDirCount;		// The count of directory in root dir
(0018) BYTE FAT32_Enable;
(0019) 
(0020) BYTE (* FAT_ReadSector)(DWORD,BYTE *);
(0021) BYTE (* FAT_WriteSector)(DWORD,BYTE *);
(0022) void DisplayChar(unsigned char casc,unsigned char postion_x,unsigned char postion_y,unsigned int char_color);
(0023) void DisplayString(unsigned char *s,unsigned char x,unsigned char y,unsigned int s_color);
(0024) eeprom_read_byte(unsigned int addr);
(0025) void eeprom_write_byte(unsigned int addr, unsigned char p_buff);
(0026) 
(0027) //函数指针指向sd卡的读写函数
(0028) //function pointer to the sd card read & write single block
(0029) //wirte sector are not use in this player
(0030) BYTE (* FAT_ReadSector)(DWORD sector, BYTE * buffer)=mmcRead;//device read
(0031) BYTE (* FAT_WriteSector)(DWORD sector, BYTE * buffer)=mmcWrite;//device write
(0032) 
(0033) struct FileInfoStruct FileInfo;//temporarily buffer for file information
(0034) 
(0035) //读取SD卡容量并处理显示函数
(0036) void SD_SizeDisplay(DWORD Capacity)
(0037) {
(0038) 	static	unsigned int SizeQ,SizeB,SizeS,SizeG;
(0039) 	DWORD Size;
(0040)     DisplayString("SD Size:",0,8,0xf800);  //显示SD卡容量
     B5E E080      LDI	R24,0
     B5F EF98      LDI	R25,0xF8
     B60 839B      STD	Y+3,R25
     B61 838A      STD	Y+2,R24
     B62 E088      LDI	R24,0x8
     B63 8388      STD	Y+0,R24
     B64 2722      CLR	R18
     B65 EE01      LDI	R16,0xE1
     B66 E012      LDI	R17,2
     B67 940E 19F0 CALL	_DisplayString
(0041) 	Size=Capacity/1024/1024;
     B69 E08A      LDI	R24,0xA
     B6A E090      LDI	R25,0
     B6B 8508      LDD	R16,Y+8
     B6C 8519      LDD	R17,Y+9
     B6D 852A      LDD	R18,Y+10
     B6E 853B      LDD	R19,Y+11
     B6F 938A      ST	R24,-Y
     B70 940E 2244 CALL	lsr32
     B72 E08A      LDI	R24,0xA
     B73 E090      LDI	R25,0
     B74 938A      ST	R24,-Y
     B75 940E 2244 CALL	lsr32
     B77 830C      STD	Y+4,R16
     B78 831D      STD	Y+5,R17
     B79 832E      STD	Y+6,R18
     B7A 833F      STD	Y+7,R19
(0042) 	SizeQ=Size/1000;
     B7B EE88      LDI	R24,0xE8
     B7C E093      LDI	R25,3
     B7D E0A0      LDI	R26,0
     B7E E0B0      LDI	R27,0
     B7F 810C      LDD	R16,Y+4
     B80 811D      LDD	R17,Y+5
     B81 812E      LDD	R18,Y+6
     B82 813F      LDD	R19,Y+7
     B83 93BA      ST	R27,-Y
     B84 93AA      ST	R26,-Y
     B85 939A      ST	R25,-Y
     B86 938A      ST	R24,-Y
     B87 940E 20E8 CALL	div32u
     B89 9310 0DDD STS	SizeQ+1,R17
     B8B 9300 0DDC STS	SizeQ,R16
(0043) 	SizeB=(Size%1000)/100;
     B8D EE88      LDI	R24,0xE8
     B8E E093      LDI	R25,3
     B8F E0A0      LDI	R26,0
     B90 E0B0      LDI	R27,0
     B91 810C      LDD	R16,Y+4
     B92 811D      LDD	R17,Y+5
     B93 812E      LDD	R18,Y+6
     B94 813F      LDD	R19,Y+7
     B95 93BA      ST	R27,-Y
     B96 93AA      ST	R26,-Y
     B97 939A      ST	R25,-Y
     B98 938A      ST	R24,-Y
     B99 940E 20EA CALL	mod32u
     B9B E684      LDI	R24,0x64
     B9C E090      LDI	R25,0
     B9D E0A0      LDI	R26,0
     B9E E0B0      LDI	R27,0
     B9F 93BA      ST	R27,-Y
     BA0 93AA      ST	R26,-Y
     BA1 939A      ST	R25,-Y
     BA2 938A      ST	R24,-Y
     BA3 940E 20E8 CALL	div32u
     BA5 9310 0DDF STS	SizeB+1,R17
     BA7 9300 0DDE STS	SizeB,R16
(0044) 	SizeS=(Size%1000)%100/10;
     BA9 EE88      LDI	R24,0xE8
     BAA E093      LDI	R25,3
     BAB E0A0      LDI	R26,0
     BAC E0B0      LDI	R27,0
     BAD 810C      LDD	R16,Y+4
     BAE 811D      LDD	R17,Y+5
     BAF 812E      LDD	R18,Y+6
     BB0 813F      LDD	R19,Y+7
     BB1 93BA      ST	R27,-Y
     BB2 93AA      ST	R26,-Y
     BB3 939A      ST	R25,-Y
     BB4 938A      ST	R24,-Y
     BB5 940E 20EA CALL	mod32u
     BB7 E684      LDI	R24,0x64
     BB8 E090      LDI	R25,0
     BB9 E0A0      LDI	R26,0
     BBA E0B0      LDI	R27,0
     BBB 93BA      ST	R27,-Y
     BBC 93AA      ST	R26,-Y
     BBD 939A      ST	R25,-Y
     BBE 938A      ST	R24,-Y
     BBF 940E 20EA CALL	mod32u
     BC1 E08A      LDI	R24,0xA
     BC2 E090      LDI	R25,0
     BC3 E0A0      LDI	R26,0
     BC4 E0B0      LDI	R27,0
     BC5 93BA      ST	R27,-Y
     BC6 93AA      ST	R26,-Y
     BC7 939A      ST	R25,-Y
     BC8 938A      ST	R24,-Y
     BC9 940E 20E8 CALL	div32u
     BCB 9310 0DE1 STS	FAT.c:SizeS+1,R17
     BCD 9300 0DE0 STS	FAT.c:SizeS,R16
(0045) 	SizeG=(Size%1000)%100%10;
     BCF EE88      LDI	R24,0xE8
     BD0 E093      LDI	R25,3
     BD1 E0A0      LDI	R26,0
     BD2 E0B0      LDI	R27,0
     BD3 810C      LDD	R16,Y+4
     BD4 811D      LDD	R17,Y+5
     BD5 812E      LDD	R18,Y+6
     BD6 813F      LDD	R19,Y+7
     BD7 93BA      ST	R27,-Y
     BD8 93AA      ST	R26,-Y
     BD9 939A      ST	R25,-Y
     BDA 938A      ST	R24,-Y
     BDB 940E 20EA CALL	mod32u
     BDD E684      LDI	R24,0x64
     BDE E090      LDI	R25,0
     BDF E0A0      LDI	R26,0
     BE0 E0B0      LDI	R27,0
     BE1 93BA      ST	R27,-Y
     BE2 93AA      ST	R26,-Y
     BE3 939A      ST	R25,-Y
     BE4 938A      ST	R24,-Y
     BE5 940E 20EA CALL	mod32u
     BE7 E08A      LDI	R24,0xA
     BE8 E090      LDI	R25,0
     BE9 E0A0      LDI	R26,0
     BEA E0B0      LDI	R27,0
     BEB 93BA      ST	R27,-Y
     BEC 93AA      ST	R26,-Y
     BED 939A      ST	R25,-Y
     BEE 938A      ST	R24,-Y
     BEF 940E 20EA CALL	mod32u
     BF1 9310 0DE3 STS	FAT.c:SizeG+1,R17
     BF3 9300 0DE2 STS	FAT.c:SizeG,R16
(0046)     DisplayChar(SizeQ+'0',8,8,0x0eee);
     BF5 EE8E      LDI	R24,0xEE
     BF6 E09E      LDI	R25,0xE
     BF7 839B      STD	Y+3,R25
     BF8 838A      STD	Y+2,R24
     BF9 E088      LDI	R24,0x8
     BFA 8388      STD	Y+0,R24
     BFB E028      LDI	R18,0x8
     BFC 9100 0DDC LDS	R16,SizeQ
     BFE 9110 0DDD LDS	R17,SizeQ+1
     C00 5D00      SUBI	R16,0xD0
     C01 4F1F      SBCI	R17,0xFF
     C02 940E 1913 CALL	_DisplayChar
(0047) 	DisplayChar(SizeB+'0',9,8,0x0eee);
     C04 EE8E      LDI	R24,0xEE
     C05 E09E      LDI	R25,0xE
     C06 839B      STD	Y+3,R25
     C07 838A      STD	Y+2,R24
     C08 E088      LDI	R24,0x8
     C09 8388      STD	Y+0,R24
     C0A E029      LDI	R18,0x9
     C0B 9100 0DDE LDS	R16,SizeB
     C0D 9110 0DDF LDS	R17,SizeB+1
     C0F 5D00      SUBI	R16,0xD0
     C10 4F1F      SBCI	R17,0xFF
     C11 940E 1913 CALL	_DisplayChar
(0048) 	DisplayChar(SizeS+'0',10,8,0x0eee);
     C13 EE8E      LDI	R24,0xEE
     C14 E09E      LDI	R25,0xE
     C15 839B      STD	Y+3,R25
     C16 838A      STD	Y+2,R24
     C17 E088      LDI	R24,0x8
     C18 8388      STD	Y+0,R24
     C19 E02A      LDI	R18,0xA
     C1A 9100 0DE0 LDS	R16,FAT.c:SizeS
     C1C 9110 0DE1 LDS	R17,FAT.c:SizeS+1
     C1E 5D00      SUBI	R16,0xD0
     C1F 4F1F      SBCI	R17,0xFF
     C20 940E 1913 CALL	_DisplayChar
(0049) 	DisplayChar(SizeG+'0',11,8,0x0eee);
     C22 EE8E      LDI	R24,0xEE
     C23 E09E      LDI	R25,0xE
     C24 839B      STD	Y+3,R25
     C25 838A      STD	Y+2,R24
     C26 E088      LDI	R24,0x8
     C27 8388      STD	Y+0,R24
     C28 E02B      LDI	R18,0xB
     C29 9100 0DE2 LDS	R16,FAT.c:SizeG
     C2B 9110 0DE3 LDS	R17,FAT.c:SizeG+1
     C2D 5D00      SUBI	R16,0xD0
     C2E 4F1F      SBCI	R17,0xFF
     C2F 940E 1913 CALL	_DisplayChar
(0050) 	DisplayString("MB",13,8,0xf800);  		//显示SD卡容量
     C31 E080      LDI	R24,0
     C32 EF98      LDI	R25,0xF8
     C33 839B      STD	Y+3,R25
     C34 838A      STD	Y+2,R24
     C35 E088      LDI	R24,0x8
     C36 8388      STD	Y+0,R24
     C37 E02D      LDI	R18,0xD
     C38 ED0E      LDI	R16,0xDE
     C39 E012      LDI	R17,2
     C3A 940E 19F0 CALL	_DisplayString
(0051) 	DisplayString("BMP Num:",0,9,0xf800);  	//BMP图片数量，最大显示99张，可以更改算法
     C3C E080      LDI	R24,0
     C3D EF98      LDI	R25,0xF8
     C3E 839B      STD	Y+3,R25
     C3F 838A      STD	Y+2,R24
     C40 E089      LDI	R24,0x9
     C41 8388      STD	Y+0,R24
     C42 2722      CLR	R18
     C43 ED05      LDI	R16,0xD5
     C44 E012      LDI	R17,2
     C45 940E 19F0 CALL	_DisplayString
(0052) 	DisplayString("Finding.",8,9,0xffff);  	//BMP图片数量，最大显示99张，可以更改算法
     C47 EF8F      LDI	R24,0xFF
     C48 EF9F      LDI	R25,0xFF
     C49 839B      STD	Y+3,R25
     C4A 838A      STD	Y+2,R24
     C4B E089      LDI	R24,0x9
     C4C 8388      STD	Y+0,R24
     C4D E028      LDI	R18,0x8
     C4E EC0C      LDI	R16,0xCC
     C4F E012      LDI	R17,2
     C50 940E 19F0 CALL	_DisplayString
     C52 962C      ADIW	R28,0xC
     C53 9508      RET
_FAT_Init:
  CapacityDisp         --> Y,+522
  pr                   --> R14
  Capacity             --> Y,+518
  buffer               --> Y,+6
  hidsec               --> Y,+2
  bs                   --> R12
  bpb                  --> R10
     C54 940E 21AD CALL	push_xgsetF0FC
     C56 97EF      SBIW	R28,0x3F
     C57 97EF      SBIW	R28,0x3F
     C58 97EF      SBIW	R28,0x3F
     C59 97EF      SBIW	R28,0x3F
     C5A 97EF      SBIW	R28,0x3F
     C5B 97EF      SBIW	R28,0x3F
     C5C 97EF      SBIW	R28,0x3F
     C5D 97EF      SBIW	R28,0x3F
     C5E 9766      SBIW	R28,0x16
(0053) }
(0054) 
(0055) //FAT初始化，不含SD的初始化，用之前应先调用sd的初始化
(0056) unsigned char FAT_Init()//Initialize of FAT  need initialize SD first
(0057) {
(0058) 	struct bootsector710 *bs  = 0;
     C5F 24CC      CLR	R12
     C60 24DD      CLR	R13
(0059) 	struct bpb710        *bpb = 0;
     C61 24AA      CLR	R10
     C62 24BB      CLR	R11
(0060) //	struct partsector    *ps  = 0;
(0061) 	struct partrecord    *pr  = 0;
     C63 24EE      CLR	R14
     C64 24FF      CLR	R15
(0062) 
(0063) 	BYTE buffer[512];
(0064) 	DWORD hidsec=0;
     C65 E040      LDI	R20,0
     C66 E050      LDI	R21,0
     C67 E060      LDI	R22,0
     C68 E070      LDI	R23,0
     C69 834A      STD	Y+2,R20
     C6A 835B      STD	Y+3,R21
     C6B 836C      STD	Y+4,R22
     C6C 837D      STD	Y+5,R23
(0065) 	DWORD Capacity,CapacityDisp;
(0066) 
(0067) 
(0068) 	Capacity = mmcCapacity();
     C6D 940E 15EE CALL	_mmcCapacity
     C6F 01DE      MOVW	R26,R28
     C70 5FAA      SUBI	R26,0xFA
     C71 4FBD      SBCI	R27,0xFD
     C72 930D      ST	R16,X+
     C73 931D      ST	R17,X+
     C74 932D      ST	R18,X+
     C75 933C      ST	R19,253(X)
(0069) 	SD_SizeDisplay(Capacity);
     C76 01FE      MOVW	R30,R28
     C77 5FEA      SUBI	R30,0xFA
     C78 4FFD      SBCI	R31,0xFD
     C79 8100      LDD	R16,Z+0
     C7A 8111      LDD	R17,Z+1
     C7B 8122      LDD	R18,Z+2
     C7C 8133      LDD	R19,Z+3
     C7D DEDD      RCALL	_SD_SizeDisplay
(0070) 
(0071) 	if(Capacity<0xff)return 1;
     C7E EF4F      LDI	R20,0xFF
     C7F E050      LDI	R21,0
     C80 E060      LDI	R22,0
     C81 E070      LDI	R23,0
     C82 01FE      MOVW	R30,R28
     C83 5FEA      SUBI	R30,0xFA
     C84 4FFD      SBCI	R31,0xFD
     C85 8020      LDD	R2,Z+0
     C86 8031      LDD	R3,Z+1
     C87 8042      LDD	R4,Z+2
     C88 8053      LDD	R5,Z+3
     C89 1624      CP	R2,R20
     C8A 0635      CPC	R3,R21
     C8B 0646      CPC	R4,R22
     C8C 0657      CPC	R5,R23
     C8D F410      BCC	0x0C90
     C8E E001      LDI	R16,1
     C8F C13A      RJMP	0x0DCA
(0072) 
(0073) 
(0074) 	if(FAT_ReadSector(0,buffer))return 1;
     C90 01CE      MOVW	R24,R28
     C91 9606      ADIW	R24,6
     C92 8399      STD	Y+1,R25
     C93 8388      STD	Y+0,R24
     C94 E000      LDI	R16,0
     C95 E010      LDI	R17,0
     C96 E020      LDI	R18,0
     C97 E030      LDI	R19,0
     C98 91E0 0198 LDS	R30,FAT_ReadSector
     C9A 91F0 0199 LDS	R31,FAT_ReadSector+1
     C9C 940E 21FA CALL	xicallx
     C9E 2300      TST	R16
     C9F F011      BEQ	0x0CA2
     CA0 E001      LDI	R16,1
     CA1 C128      RJMP	0x0DCA
(0075) 	bs = (struct bootsector710 *)buffer;		
     CA2 01CE      MOVW	R24,R28
     CA3 9606      ADIW	R24,6
     CA4 016C      MOVW	R12,R24
(0076) 	pr = (struct partrecord *)((struct partsector *)buffer)->psPart;//first partition
     CA5 01CE      MOVW	R24,R28
     CA6 538C      SUBI	R24,0x3C
     CA7 4F9E      SBCI	R25,0xFE
     CA8 017C      MOVW	R14,R24
(0077) 	hidsec = pr->prStartLBA;//the hidden sectors
     CA9 01FC      MOVW	R30,R24
     CAA 9638      ADIW	R30,0x8
     CAB 8020      LDD	R2,Z+0
     CAC 8031      LDD	R3,Z+1
     CAD 8042      LDD	R4,Z+2
     CAE 8053      LDD	R5,Z+3
     CAF 822A      STD	Y+2,R2
     CB0 823B      STD	Y+3,R3
     CB1 824C      STD	Y+4,R4
     CB2 825D      STD	Y+5,R5
(0078) 	if(hidsec >= Capacity/512)
     CB3 E089      LDI	R24,0x9
     CB4 E090      LDI	R25,0
     CB5 01DE      MOVW	R26,R28
     CB6 5FAA      SUBI	R26,0xFA
     CB7 4FBD      SBCI	R27,0xFD
     CB8 910D      LD	R16,X+
     CB9 911D      LD	R17,X+
     CBA 912D      LD	R18,X+
     CBB 913C      LD	R19,253(X)
     CBC 938A      ST	R24,-Y
     CBD 940E 2244 CALL	lsr32
     CBF 802A      LDD	R2,Y+2
     CC0 803B      LDD	R3,Y+3
     CC1 804C      LDD	R4,Y+4
     CC2 805D      LDD	R5,Y+5
     CC3 1620      CP	R2,R16
     CC4 0631      CPC	R3,R17
     CC5 0642      CPC	R4,R18
     CC6 0653      CPC	R5,R19
     CC7 F048      BCS	0x0CD1
(0079) 	{
(0080) 		hidsec = 0;
     CC8 E040      LDI	R20,0
     CC9 E050      LDI	R21,0
     CCA E060      LDI	R22,0
     CCB E070      LDI	R23,0
     CCC 834A      STD	Y+2,R20
     CCD 835B      STD	Y+3,R21
     CCE 836C      STD	Y+4,R22
     CCF 837D      STD	Y+5,R23
(0081) 	}
     CD0 C03C      RJMP	0x0D0D
(0082) 	else 
(0083) 	{
(0084) 		if(FAT_ReadSector(pr->prStartLBA,buffer))return 1;//read the bpb sector
     CD1 01CE      MOVW	R24,R28
     CD2 9606      ADIW	R24,6
     CD3 8399      STD	Y+1,R25
     CD4 8388      STD	Y+0,R24
     CD5 01F7      MOVW	R30,R14
     CD6 8500      LDD	R16,Z+8
     CD7 8511      LDD	R17,Z+9
     CD8 8522      LDD	R18,Z+10
     CD9 8533      LDD	R19,Z+11
     CDA 91E0 0198 LDS	R30,FAT_ReadSector
     CDC 91F0 0199 LDS	R31,FAT_ReadSector+1
     CDE 940E 21FA CALL	xicallx
     CE0 2300      TST	R16
     CE1 F011      BEQ	0x0CE4
     CE2 E001      LDI	R16,1
     CE3 C0E6      RJMP	0x0DCA
(0085) 		bs = (struct bootsector710 *)buffer;
     CE4 01CE      MOVW	R24,R28
     CE5 9606      ADIW	R24,6
     CE6 016C      MOVW	R12,R24
(0086) 		if(bs->bsJump[0]!=0xE9 && bs->bsJump[0]!=0xEB)
     CE7 01FC      MOVW	R30,R24
     CE8 80E0      LDD	R14,Z+0
     CE9 24FF      CLR	R15
     CEA 2D8E      MOV	R24,R14
     CEB 3E89      CPI	R24,0xE9
     CEC F101      BEQ	0x0D0D
     CED 3E8B      CPI	R24,0xEB
     CEE F0F1      BEQ	0x0D0D
(0087) 		{
(0088) 			hidsec = 0;
     CEF E040      LDI	R20,0
     CF0 E050      LDI	R21,0
     CF1 E060      LDI	R22,0
     CF2 E070      LDI	R23,0
     CF3 834A      STD	Y+2,R20
     CF4 835B      STD	Y+3,R21
     CF5 836C      STD	Y+4,R22
     CF6 837D      STD	Y+5,R23
(0089) 			if(FAT_ReadSector(0,buffer))return 1;//read the bpb sector
     CF7 01CE      MOVW	R24,R28
     CF8 9606      ADIW	R24,6
     CF9 8399      STD	Y+1,R25
     CFA 8388      STD	Y+0,R24
     CFB E000      LDI	R16,0
     CFC E010      LDI	R17,0
     CFD E020      LDI	R18,0
     CFE E030      LDI	R19,0
     CFF 91E0 0198 LDS	R30,FAT_ReadSector
     D01 91F0 0199 LDS	R31,FAT_ReadSector+1
     D03 940E 21FA CALL	xicallx
     D05 2EE0      MOV	R14,R16
     D06 2300      TST	R16
     D07 F011      BEQ	0x0D0A
     D08 E001      LDI	R16,1
     D09 C0C0      RJMP	0x0DCA
(0090) 			bs = (struct bootsector710 *)buffer;	
     D0A 01CE      MOVW	R24,R28
     D0B 9606      ADIW	R24,6
     D0C 016C      MOVW	R12,R24
(0091) 		}
(0092) 	}
(0093) 
(0094) 	if(bs->bsJump[0]!=0xE9 && bs->bsJump[0]!=0xEB)//对付没有bootsect的sd卡	//dead with the card which has no bootsect
     D0D 01F6      MOVW	R30,R12
     D0E 80E0      LDD	R14,Z+0
     D0F 24FF      CLR	R15
     D10 2D8E      MOV	R24,R14
     D11 3E89      CPI	R24,0xE9
     D12 F021      BEQ	0x0D17
     D13 3E8B      CPI	R24,0xEB
     D14 F011      BEQ	0x0D17
(0095) 	{
(0096) 		return 1;
     D15 E001      LDI	R16,1
     D16 C0B3      RJMP	0x0DCA
(0097) 	}
(0098) 	
(0099) 	
(0100) 	
(0101) 	bpb = (struct bpb710 *)bs->bsBPB;
     D17 01C6      MOVW	R24,R12
     D18 960B      ADIW	R24,0xB
     D19 015C      MOVW	R10,R24
(0102) 
(0103) 	
(0104) 	if(bpb->bpbFATsecs)						//判断文件系统类型，不支持FAT12,支持FAT16和FAT32
     D1A 01FC      MOVW	R30,R24
     D1B 8423      LDD	R2,Z+11
     D1C 8434      LDD	R3,Z+12
     D1D 2022      TST	R2
     D1E F411      BNE	0x0D21
     D1F 2033      TST	R3
     D20 F0B1      BEQ	0x0D37
(0105) 	{
(0106) 		FAT32_Enable=0;						//FAT16
     D21 2422      CLR	R2
     D22 9220 0DF3 STS	FAT32_Enable,R2
(0107) 		FATsectors		= bpb->bpbFATsecs;	//FAT占用的扇区数	
     D24 8423      LDD	R2,Z+11
     D25 8434      LDD	R3,Z+12
     D26 9230 0E07 STS	FATsectors+1,R3
     D28 9220 0E06 STS	FATsectors,R2
(0108) 		FirstDirClust = 2;
     D2A E042      LDI	R20,2
     D2B E050      LDI	R21,0
     D2C E060      LDI	R22,0
     D2D E070      LDI	R23,0
     D2E 9350 0E0F STS	FirstDirClust+1,R21
     D30 9340 0E0E STS	FirstDirClust,R20
     D32 9370 0E11 STS	FirstDirClust+3,R23
     D34 9360 0E10 STS	FirstDirClust+2,R22
(0109) 	}
     D36 C016      RJMP	0x0D4D
(0110) 	else
(0111) 	{
(0112) 		FAT32_Enable=1;						 //FAT32
     D37 E081      LDI	R24,1
     D38 9380 0DF3 STS	FAT32_Enable,R24
(0113) 		FATsectors		= bpb->bpbBigFATsecs;//FAT占用的扇区数	//the sectors number occupied by one fat talbe
     D3A 01F5      MOVW	R30,R10
     D3B 8C21      LDD	R2,Z+25
     D3C 8C32      LDD	R3,Z+26
     D3D 9230 0E07 STS	FATsectors+1,R3
     D3F 9220 0E06 STS	FATsectors,R2
(0114) 		FirstDirClust = bpb->bpbRootClust;
     D41 A021      LDD	R2,Z+33
     D42 A032      LDD	R3,Z+34
     D43 A043      LDD	R4,Z+35
     D44 A054      LDD	R5,Z+36
     D45 9230 0E0F STS	FirstDirClust+1,R3
     D47 9220 0E0E STS	FirstDirClust,R2
     D49 9250 0E11 STS	FirstDirClust+3,R5
     D4B 9240 0E10 STS	FirstDirClust+2,R4
(0115) 	}
(0116) 
(0117) 	BytesPerSector	= bpb->bpbBytesPerSec;	//每扇区字节数
     D4D 01F5      MOVW	R30,R10
     D4E 8020      LDD	R2,Z+0
     D4F 8031      LDD	R3,Z+1
     D50 9230 0E09 STS	BytesPerSector+1,R3
     D52 9220 0E08 STS	BytesPerSector,R2
(0118) 	
(0119) 	SectorsPerClust	= (BYTE)bpb->bpbSecPerClust;//每簇扇区数
     D54 9632      ADIW	R30,2
     D55 8020      LDD	R2,Z+0
     D56 2433      CLR	R3
     D57 9230 0E05 STS	SectorsPerClust+1,R3
     D59 9220 0E04 STS	SectorsPerClust,R2
(0120) 	
(0121) 	FirstFATSector	= bpb->bpbResSectors+hidsec;//第一个FAT表扇区
     D5B 802A      LDD	R2,Y+2
     D5C 803B      LDD	R3,Y+3
     D5D 804C      LDD	R4,Y+4
     D5E 805D      LDD	R5,Y+5
     D5F 01F5      MOVW	R30,R10
     D60 8063      LDD	R6,Z+3
     D61 8074      LDD	R7,Z+4
     D62 2488      CLR	R8
     D63 2499      CLR	R9
     D64 0C62      ADD	R6,R2
     D65 1C73      ADC	R7,R3
     D66 1C84      ADC	R8,R4
     D67 1C95      ADC	R9,R5
     D68 9270 0E01 STS	FirstFATSector+1,R7
     D6A 9260 0E00 STS	FirstFATSector,R6
     D6C 9290 0E03 STS	FirstFATSector+3,R9
     D6E 9280 0E02 STS	FirstFATSector+2,R8
(0122) 	RootDirCount	= bpb->bpbRootDirEnts;//根目录项数
     D70 8026      LDD	R2,Z+6
     D71 8037      LDD	R3,Z+7
     D72 2444      CLR	R4
     D73 2455      CLR	R5
     D74 9230 0DF5 STS	RootDirCount+1,R3
     D76 9220 0DF4 STS	RootDirCount,R2
     D78 9250 0DF7 STS	RootDirCount+3,R5
     D7A 9240 0DF6 STS	RootDirCount+2,R4
(0123) 	RootDirSectors	= (RootDirCount*32)>>9;//根目录占用的扇区数
     D7C E240      LDI	R20,0x20
     D7D E050      LDI	R21,0
     D7E E060      LDI	R22,0
     D7F E070      LDI	R23,0
     D80 925A      ST	R5,-Y
     D81 924A      ST	R4,-Y
     D82 923A      ST	R3,-Y
     D83 922A      ST	R2,-Y
     D84 018A      MOVW	R16,R20
     D85 019B      MOVW	R18,R22
     D86 940E 2162 CALL	empy32u
     D88 E089      LDI	R24,0x9
     D89 E090      LDI	R25,0
     D8A 938A      ST	R24,-Y
     D8B 940E 2244 CALL	lsr32
     D8D 9310 0DF9 STS	RootDirSectors+1,R17
     D8F 9300 0DF8 STS	RootDirSectors,R16
     D91 9330 0DFB STS	RootDirSectors+3,R19
     D93 9320 0DFA STS	RootDirSectors+2,R18
(0124) 	FirstDirSector	= FirstFATSector+bpb->bpbFATs*FATsectors;//第一个目录扇区
     D95 9120 0E06 LDS	R18,FATsectors
     D97 9130 0E07 LDS	R19,FATsectors+1
     D99 01F5      MOVW	R30,R10
     D9A 8105      LDD	R16,Z+5
     D9B 2711      CLR	R17
     D9C 940E 2152 CALL	empy16s
     D9E 0118      MOVW	R2,R16
     D9F 2444      CLR	R4
     DA0 2455      CLR	R5
     DA1 9080 0E02 LDS	R8,FirstFATSector+2
     DA3 9090 0E03 LDS	R9,FirstFATSector+3
     DA5 9060 0E00 LDS	R6,FirstFATSector
     DA7 9070 0E01 LDS	R7,FirstFATSector+1
     DA9 0C62      ADD	R6,R2
     DAA 1C73      ADC	R7,R3
     DAB 1C84      ADC	R8,R4
     DAC 1C95      ADC	R9,R5
     DAD 9270 0DFD STS	FirstDirSector+1,R7
     DAF 9260 0DFC STS	FirstDirSector,R6
     DB1 9290 0DFF STS	FirstDirSector+3,R9
     DB3 9280 0DFE STS	FirstDirSector+2,R8
(0125) 	FirstDataSector	= FirstDirSector+RootDirSectors;//第一个数据扇区
     DB5 9040 0DFA LDS	R4,RootDirSectors+2
     DB7 9050 0DFB LDS	R5,RootDirSectors+3
     DB9 9020 0DF8 LDS	R2,RootDirSectors
     DBB 9030 0DF9 LDS	R3,RootDirSectors+1
     DBD 0C62      ADD	R6,R2
     DBE 1C73      ADC	R7,R3
     DBF 1C84      ADC	R8,R4
     DC0 1C95      ADC	R9,R5
     DC1 9270 0E0B STS	FirstDataSector+1,R7
     DC3 9260 0E0A STS	FirstDataSector,R6
     DC5 9290 0E0D STS	FirstDataSector+3,R9
     DC7 9280 0E0C STS	FirstDataSector+2,R8
(0126) 	return 0;
     DC9 2700      CLR	R16
     DCA 96EF      ADIW	R28,0x3F
     DCB 96EF      ADIW	R28,0x3F
     DCC 96EF      ADIW	R28,0x3F
     DCD 96EF      ADIW	R28,0x3F
     DCE 96EF      ADIW	R28,0x3F
     DCF 96EF      ADIW	R28,0x3F
     DD0 96EF      ADIW	R28,0x3F
     DD1 96EF      ADIW	R28,0x3F
     DD2 9666      ADIW	R28,0x16
     DD3 940C 21A2 JMP	pop_xgsetF0FC
_FAT_LoadPartCluster:
  sector               --> Y,+2
  buffer               --> Y,+16
  part                 --> Y,+14
  cluster              --> Y,+10
     DD5 940E 20C0 CALL	push_arg4
     DD7 940E 21C2 CALL	push_xgsetF000
     DD9 9726      SBIW	R28,6
(0127) }
(0128) 
(0129) //读一个簇中的一个扇区
(0130) //read one sector of one cluster, parameter part indicate which sector
(0131) unsigned char FAT_LoadPartCluster(unsigned long cluster,unsigned part,BYTE * buffer)
(0132) {
(0133) 	DWORD sector;
(0134) 	sector=FirstDataSector+(DWORD)(cluster-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
     DDA E042      LDI	R20,2
     DDB E050      LDI	R21,0
     DDC E060      LDI	R22,0
     DDD E070      LDI	R23,0
     DDE 850A      LDD	R16,Y+10
     DDF 851B      LDD	R17,Y+11
     DE0 852C      LDD	R18,Y+12
     DE1 853D      LDD	R19,Y+13
     DE2 1B04      SUB	R16,R20
     DE3 0B15      SBC	R17,R21
     DE4 0B26      SBC	R18,R22
     DE5 0B37      SBC	R19,R23
     DE6 9020 0E04 LDS	R2,SectorsPerClust
     DE8 9030 0E05 LDS	R3,SectorsPerClust+1
     DEA 2444      CLR	R4
     DEB 2455      CLR	R5
     DEC 925A      ST	R5,-Y
     DED 924A      ST	R4,-Y
     DEE 923A      ST	R3,-Y
     DEF 922A      ST	R2,-Y
     DF0 940E 2162 CALL	empy32u
     DF2 9040 0E0C LDS	R4,FirstDataSector+2
     DF4 9050 0E0D LDS	R5,FirstDataSector+3
     DF6 9020 0E0A LDS	R2,FirstDataSector
     DF8 9030 0E0B LDS	R3,FirstDataSector+1
     DFA 0E20      ADD	R2,R16
     DFB 1E31      ADC	R3,R17
     DFC 1E42      ADC	R4,R18
     DFD 1E53      ADC	R5,R19
     DFE 822A      STD	Y+2,R2
     DFF 823B      STD	Y+3,R3
     E00 824C      STD	Y+4,R4
     E01 825D      STD	Y+5,R5
(0135) 	if(FAT_ReadSector(sector+part,buffer))return 1;
     E02 8808      LDD	R0,Y+16
     E03 8819      LDD	R1,Y+17
     E04 8219      STD	Y+1,R1
     E05 8208      STD	Y+0,R0
     E06 842E      LDD	R2,Y+14
     E07 843F      LDD	R3,Y+15
     E08 2444      CLR	R4
     E09 2455      CLR	R5
     E0A 810A      LDD	R16,Y+2
     E0B 811B      LDD	R17,Y+3
     E0C 812C      LDD	R18,Y+4
     E0D 813D      LDD	R19,Y+5
     E0E 0D02      ADD	R16,R2
     E0F 1D13      ADC	R17,R3
     E10 1D24      ADC	R18,R4
     E11 1D35      ADC	R19,R5
     E12 91E0 0198 LDS	R30,FAT_ReadSector
     E14 91F0 0199 LDS	R31,FAT_ReadSector+1
     E16 940E 21FA CALL	xicallx
     E18 2300      TST	R16
     E19 F011      BEQ	0x0E1C
     E1A E001      LDI	R16,1
     E1B C001      RJMP	0x0E1D
(0136) 	else return 0;
     E1C 2700      CLR	R16
     E1D 9626      ADIW	R28,6
     E1E 940E 21C7 CALL	pop_xgsetF000
     E20 9624      ADIW	R28,4
     E21 9508      RET
_FAT_NextCluster:
  buffer               --> Y,+10
  offset               --> Y,+6
  sector               --> Y,+2
  cluster              --> Y,+528
     E22 940E 20C0 CALL	push_arg4
     E24 940E 21CC CALL	push_xgsetF00C
     E26 97EF      SBIW	R28,0x3F
     E27 97EF      SBIW	R28,0x3F
     E28 97EF      SBIW	R28,0x3F
     E29 97EF      SBIW	R28,0x3F
     E2A 97EF      SBIW	R28,0x3F
     E2B 97EF      SBIW	R28,0x3F
     E2C 97EF      SBIW	R28,0x3F
     E2D 97EF      SBIW	R28,0x3F
     E2E 9762      SBIW	R28,0x12
(0137) }
(0138) 
(0139) 
(0140) //读下一簇簇号
(0141) //Return the cluster number of next cluster of file
(0142) //Suitable for system which has limited RAM
(0143) unsigned long FAT_NextCluster(unsigned long cluster)
(0144) {
(0145) 	BYTE buffer[512];
(0146) 	DWORD sector;
(0147) 	DWORD offset;
(0148) 	if(FAT32_Enable)offset = cluster/128;
     E2F 9020 0DF3 LDS	R2,FAT32_Enable
     E31 2022      TST	R2
     E32 F089      BEQ	0x0E44
     E33 E087      LDI	R24,7
     E34 E090      LDI	R25,0
     E35 01DE      MOVW	R26,R28
     E36 5FA0      SUBI	R26,0xF0
     E37 4FBD      SBCI	R27,0xFD
     E38 910D      LD	R16,X+
     E39 911D      LD	R17,X+
     E3A 912D      LD	R18,X+
     E3B 913C      LD	R19,253(X)
     E3C 938A      ST	R24,-Y
     E3D 940E 2244 CALL	lsr32
     E3F 830E      STD	Y+6,R16
     E40 831F      STD	Y+7,R17
     E41 8728      STD	Y+8,R18
     E42 8739      STD	Y+9,R19
     E43 C010      RJMP	0x0E54
(0149) 	else offset = cluster/256;
     E44 E088      LDI	R24,0x8
     E45 E090      LDI	R25,0
     E46 01DE      MOVW	R26,R28
     E47 5FA0      SUBI	R26,0xF0
     E48 4FBD      SBCI	R27,0xFD
     E49 910D      LD	R16,X+
     E4A 911D      LD	R17,X+
     E4B 912D      LD	R18,X+
     E4C 913C      LD	R19,253(X)
     E4D 938A      ST	R24,-Y
     E4E 940E 2244 CALL	lsr32
     E50 830E      STD	Y+6,R16
     E51 831F      STD	Y+7,R17
     E52 8728      STD	Y+8,R18
     E53 8739      STD	Y+9,R19
(0150) 	if(cluster<2)return 0x0ffffff8;
     E54 E042      LDI	R20,2
     E55 E050      LDI	R21,0
     E56 E060      LDI	R22,0
     E57 E070      LDI	R23,0
     E58 01FE      MOVW	R30,R28
     E59 5FE0      SUBI	R30,0xF0
     E5A 4FFD      SBCI	R31,0xFD
     E5B 8020      LDD	R2,Z+0
     E5C 8031      LDD	R3,Z+1
     E5D 8042      LDD	R4,Z+2
     E5E 8053      LDD	R5,Z+3
     E5F 1624      CP	R2,R20
     E60 0635      CPC	R3,R21
     E61 0646      CPC	R4,R22
     E62 0657      CPC	R5,R23
     E63 F428      BCC	0x0E69
     E64 EF08      LDI	R16,0xF8
     E65 EF1F      LDI	R17,0xFF
     E66 EF2F      LDI	R18,0xFF
     E67 E03F      LDI	R19,0xF
     E68 C07E      RJMP	0x0EE7
(0151) 	sector=FirstFATSector+offset;//calculate the actual sector
     E69 802E      LDD	R2,Y+6
     E6A 803F      LDD	R3,Y+7
     E6B 8448      LDD	R4,Y+8
     E6C 8459      LDD	R5,Y+9
     E6D 9080 0E02 LDS	R8,FirstFATSector+2
     E6F 9090 0E03 LDS	R9,FirstFATSector+3
     E71 9060 0E00 LDS	R6,FirstFATSector
     E73 9070 0E01 LDS	R7,FirstFATSector+1
     E75 0C62      ADD	R6,R2
     E76 1C73      ADC	R7,R3
     E77 1C84      ADC	R8,R4
     E78 1C95      ADC	R9,R5
     E79 826A      STD	Y+2,R6
     E7A 827B      STD	Y+3,R7
     E7B 828C      STD	Y+4,R8
     E7C 829D      STD	Y+5,R9
(0152) 	if(FAT_ReadSector(sector,buffer))return 0x0ffffff8;//read fat table / return 0xfff8 when error occured
     E7D 01CE      MOVW	R24,R28
     E7E 960A      ADIW	R24,0xA
     E7F 8399      STD	Y+1,R25
     E80 8388      STD	Y+0,R24
     E81 810A      LDD	R16,Y+2
     E82 811B      LDD	R17,Y+3
     E83 812C      LDD	R18,Y+4
     E84 813D      LDD	R19,Y+5
     E85 91E0 0198 LDS	R30,FAT_ReadSector
     E87 91F0 0199 LDS	R31,FAT_ReadSector+1
     E89 940E 21FA CALL	xicallx
     E8B 2300      TST	R16
     E8C F029      BEQ	0x0E92
     E8D EF08      LDI	R16,0xF8
     E8E EF1F      LDI	R17,0xFF
     E8F EF2F      LDI	R18,0xFF
     E90 E03F      LDI	R19,0xF
     E91 C055      RJMP	0x0EE7
(0153) 
(0154) 	if(FAT32_Enable)
     E92 9020 0DF3 LDS	R2,FAT32_Enable
     E94 2022      TST	R2
     E95 F151      BEQ	0x0EC0
(0155) 	{
(0156) 		offset=cluster%128;//find the position
     E96 E74F      LDI	R20,0x7F
     E97 E050      LDI	R21,0
     E98 E060      LDI	R22,0
     E99 E070      LDI	R23,0
     E9A 01DE      MOVW	R26,R28
     E9B 5FA0      SUBI	R26,0xF0
     E9C 4FBD      SBCI	R27,0xFD
     E9D 902D      LD	R2,X+
     E9E 903D      LD	R3,X+
     E9F 904D      LD	R4,X+
     EA0 905C      LD	R5,253(X)
     EA1 2224      AND	R2,R20
     EA2 2235      AND	R3,R21
     EA3 2246      AND	R4,R22
     EA4 2257      AND	R5,R23
     EA5 822E      STD	Y+6,R2
     EA6 823F      STD	Y+7,R3
     EA7 8648      STD	Y+8,R4
     EA8 8659      STD	Y+9,R5
(0157) 		sector=((unsigned long *)buffer)[offset];	
     EA9 E082      LDI	R24,2
     EAA E090      LDI	R25,0
     EAB 810E      LDD	R16,Y+6
     EAC 811F      LDD	R17,Y+7
     EAD 8528      LDD	R18,Y+8
     EAE 8539      LDD	R19,Y+9
     EAF 938A      ST	R24,-Y
     EB0 940E 2238 CALL	lsl32
     EB2 01F8      MOVW	R30,R16
     EB3 01CE      MOVW	R24,R28
     EB4 960A      ADIW	R24,0xA
     EB5 0FE8      ADD	R30,R24
     EB6 1FF9      ADC	R31,R25
     EB7 8020      LDD	R2,Z+0
     EB8 8031      LDD	R3,Z+1
     EB9 8042      LDD	R4,Z+2
     EBA 8053      LDD	R5,Z+3
     EBB 822A      STD	Y+2,R2
     EBC 823B      STD	Y+3,R3
     EBD 824C      STD	Y+4,R4
     EBE 825D      STD	Y+5,R5
(0158) 	}
     EBF C023      RJMP	0x0EE3
(0159) 	else
(0160) 	{
(0161) 		offset=cluster%256;//find the position
     EC0 EF4F      LDI	R20,0xFF
     EC1 E050      LDI	R21,0
     EC2 E060      LDI	R22,0
     EC3 E070      LDI	R23,0
     EC4 01DE      MOVW	R26,R28
     EC5 5FA0      SUBI	R26,0xF0
     EC6 4FBD      SBCI	R27,0xFD
     EC7 902D      LD	R2,X+
     EC8 903D      LD	R3,X+
     EC9 904D      LD	R4,X+
     ECA 905C      LD	R5,253(X)
     ECB 2224      AND	R2,R20
     ECC 2235      AND	R3,R21
     ECD 2246      AND	R4,R22
     ECE 2257      AND	R5,R23
     ECF 822E      STD	Y+6,R2
     ED0 823F      STD	Y+7,R3
     ED1 8648      STD	Y+8,R4
     ED2 8659      STD	Y+9,R5
(0162) 		sector=((unsigned int *)buffer)[offset];
     ED3 01CE      MOVW	R24,R28
     ED4 960A      ADIW	R24,0xA
     ED5 81EE      LDD	R30,Y+6
     ED6 81FF      LDD	R31,Y+7
     ED7 0FEE      LSL	R30
     ED8 1FFF      ROL	R31
     ED9 0FE8      ADD	R30,R24
     EDA 1FF9      ADC	R31,R25
     EDB 8020      LDD	R2,Z+0
     EDC 8031      LDD	R3,Z+1
     EDD 2444      CLR	R4
     EDE 2455      CLR	R5
     EDF 822A      STD	Y+2,R2
     EE0 823B      STD	Y+3,R3
     EE1 824C      STD	Y+4,R4
     EE2 825D      STD	Y+5,R5
(0163) 	}
(0164) 	return (unsigned long)sector;//return the cluste number
     EE3 810A      LDD	R16,Y+2
     EE4 811B      LDD	R17,Y+3
     EE5 812C      LDD	R18,Y+4
     EE6 813D      LDD	R19,Y+5
     EE7 96EF      ADIW	R28,0x3F
     EE8 96EF      ADIW	R28,0x3F
     EE9 96EF      ADIW	R28,0x3F
     EEA 96EF      ADIW	R28,0x3F
     EEB 96EF      ADIW	R28,0x3F
     EEC 96EF      ADIW	R28,0x3F
     EED 96EF      ADIW	R28,0x3F
     EEE 96EF      ADIW	R28,0x3F
     EEF 9662      ADIW	R28,0x12
     EF0 940E 21D3 CALL	pop_xgsetF00C
     EF2 9624      ADIW	R28,4
     EF3 9508      RET
_CopyDirentruyItem:
  i                    --> R20
  Source               --> R18
  Desti                --> R16
     EF4 934A      ST	R20,-Y
(0165) }
(0166) 
(0167) #if FIX_DIRECTORY
(0168) //在给定目录下查找文件
(0169) //Find a item in the directory which specify by the parameter "cluster"
(0170) //Return the start cluster number
(0171) unsigned int FAT_FindItem(unsigned long cluster, BYTE *name, struct FileInfoStruct *FileInfo)
(0172) {
(0173) 	BYTE *buffer;
(0174) 	DWORD tempclust;
(0175) 	DWORD sector;
(0176) 	unsigned char cnt;
(0177) 	unsigned int offset;
(0178) 	unsigned char i;
(0179) 	struct direntry *item = 0;
(0180) 	if((cluster==0) && (FAT32_Enable == 0))// root directory
(0181) 	{
(0182) 		buffer=malloc(512);//apply memory
(0183) 		if(buffer==0)return 1;//if failed
(0184) 		for(cnt=0;cnt<RootDirSectors;cnt++)
(0185) 		{
(0186) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
(0187) 			for(offset=0;offset<512;offset+=32)
(0188) 			{
(0189) 				item=(struct direntry *)(&buffer[offset]);
(0190) 				if((item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0191) 				{
(0192) 					for(i=0;i<11;i++)
(0193) 					{
(0194) 						if(buffer[offset+i]!=name[i])break;
(0195) 					}
(0196) 					if(i==11)
(0197) 					{
(0198) 						//return the parameter of the item
(0199) 						FileInfo->StartCluster = item->deStartCluster + (((unsigned long)item->deHighClust)<<16);//don't care
(0200) 						FileInfo->Size         = item->deFileSize;
(0201) 						FileInfo->Attr         = item->deAttributes;
(0202) 						FileInfo->Sector       = FirstDirSector+cnt;
(0203) 						FileInfo->Offset       = offset;
(0204) 						free(buffer);
(0205) 						return 0;
(0206) 					}
(0207) 				}
(0208) 			}
(0209) 		}
(0210) 		free(buffer);//release
(0211) 	}
(0212) 	else//other folders
(0213) 	{
(0214) 		tempclust=cluster;
(0215) 		while(1)
(0216) 		{
(0217) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
(0218) 			buffer=malloc(512);//apply memory
(0219) 			if(buffer==0)return 1;//if failed
(0220) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
(0221) 			{
(0222) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
(0223) 				for(offset=0;offset<512;offset+=32)
(0224) 				{
(0225) 					item=(struct direntry *)(&buffer[offset]);
(0226) 					if((item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0227) 					{
(0228) 						for(i=0;i<11;i++)
(0229) 						{
(0230) 							if(buffer[offset+i]!=name[i])break;
(0231) 						}
(0232) 						if(i==11)
(0233) 						{
(0234) 							FileInfo->StartCluster = item->deStartCluster + (((unsigned long)item->deHighClust)<<16);//don't care
(0235) 							FileInfo->Size         = item->deFileSize;
(0236) 							FileInfo->Attr         = item->deAttributes;
(0237) 							FileInfo->Sector       = sector+cnt;
(0238) 							FileInfo->Offset       = offset;
(0239) 							free(buffer);
(0240) 							return 0;
(0241) 						}
(0242) 					}
(0243) 				}
(0244) 			}
(0245) 			free(buffer);//release
(0246) 			tempclust=FAT_NextCluster(tempclust);//next cluster
(0247) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
(0248) 		}
(0249) 	}
(0250) 	return 1;
(0251) }
(0252) 
(0253) // find a directory with the given path
(0254) unsigned long FAT_OpenDir(BYTE * dir)
(0255) {
(0256) 	BYTE name[11];
(0257) 	BYTE *p=dir;
(0258) 	BYTE deep=0;
(0259) 	BYTE i,j;
(0260) 	DWORD cluster=0;
(0261) 	if(FAT32_Enable)cluster = FirstDirClust;
(0262) 	if(*p != '\\')return 1;//invalid path
(0263) 	while(*p)
(0264) 	{
(0265) 		if(*p == '\\')
(0266) 		{
(0267) 			deep++;
(0268) 		}
(0269) 		p++;
(0270) 	}
(0271) 	p=dir;
(0272) 	for(i=0;i<deep-1;i++)
(0273) 	{
(0274) 		p++;
(0275) 		for(j=0;j<11;j++)name[j]=0x20;
(0276) 		j=0;
(0277) 		while(*p != '\\')
(0278) 		{
(0279) 			if((*p) >= 'a' && (*p) <= 'z')name[j] = (*p++)-0x20;
(0280) 			else name[j] = *p++;
(0281) 			j++;
(0282) 		}
(0283) 		if(FAT_FindItem(cluster,name, &FileInfo))return 1;//find the directory
(0284) 		cluster = FileInfo.StartCluster;
(0285) 	}
(0286) 	p++;
(0287) 	for(j=0;j<11;j++)name[j]=0x20;
(0288) 	j=0;
(0289) 	while(*p)
(0290) 	{
(0291) 		if(*p>='a' && *p<='z')name[j]=(*p++)-0x20;
(0292) 		else name[j]=*p++;
(0293) 		j++;
(0294) 	}
(0295) 	if(j == 0)return cluster;
(0296) 	if(FAT_FindItem(cluster,name, &FileInfo))return 1;//find the final directory
(0297) 	cluster = FileInfo.StartCluster;
(0298) 	return cluster;
(0299) }
(0300) #endif  
(0301) 
(0302) //复制记录项信息  //copy item
(0303) void CopyDirentruyItem(struct direntry *Desti,struct direntry *Source)
(0304) {
(0305) 	BYTE i;
(0306) 	for(i=0;i<8;i++)Desti->deName[i] = Source->deName[i];
     EF5 2744      CLR	R20
     EF6 C00B      RJMP	0x0F02
     EF7 2FE4      MOV	R30,R20
     EF8 27FF      CLR	R31
     EF9 0FE2      ADD	R30,R18
     EFA 1FF3      ADC	R31,R19
     EFB 8020      LDD	R2,Z+0
     EFC 2FE4      MOV	R30,R20
     EFD 27FF      CLR	R31
     EFE 0FE0      ADD	R30,R16
     EFF 1FF1      ADC	R31,R17
     F00 8220      STD	Z+0,R2
     F01 9543      INC	R20
     F02 3048      CPI	R20,0x8
     F03 F398      BCS	0x0EF7
(0307) 	for(i=0;i<3;i++)Desti->deExtension[i] = Source->deExtension[i];
     F04 2744      CLR	R20
     F05 C00F      RJMP	0x0F15
     F06 01C9      MOVW	R24,R18
     F07 9608      ADIW	R24,0x8
     F08 2FE4      MOV	R30,R20
     F09 27FF      CLR	R31
     F0A 0FE8      ADD	R30,R24
     F0B 1FF9      ADC	R31,R25
     F0C 8020      LDD	R2,Z+0
     F0D 01C8      MOVW	R24,R16
     F0E 9608      ADIW	R24,0x8
     F0F 2FE4      MOV	R30,R20
     F10 27FF      CLR	R31
     F11 0FE8      ADD	R30,R24
     F12 1FF9      ADC	R31,R25
     F13 8220      STD	Z+0,R2
     F14 9543      INC	R20
     F15 3043      CPI	R20,3
     F16 F378      BCS	0x0F06
(0308) 	Desti->deAttributes = Source->deAttributes;
     F17 01F9      MOVW	R30,R18
     F18 8423      LDD	R2,Z+11
     F19 01F8      MOVW	R30,R16
     F1A 8623      STD	Z+11,R2
(0309) 	Desti->deLowerCase = Source->deLowerCase;
     F1B 01F9      MOVW	R30,R18
     F1C 8424      LDD	R2,Z+12
     F1D 01F8      MOVW	R30,R16
     F1E 8624      STD	Z+12,R2
(0310) 	Desti->deCHundredth = Source->deCHundredth;
     F1F 01F9      MOVW	R30,R18
     F20 8425      LDD	R2,Z+13
     F21 01F8      MOVW	R30,R16
     F22 8625      STD	Z+13,R2
(0311) 	for(i=0;i<2;i++)Desti->deCTime[i] = Source->deCTime[i];
     F23 2744      CLR	R20
     F24 C00F      RJMP	0x0F34
     F25 01C9      MOVW	R24,R18
     F26 960E      ADIW	R24,0xE
     F27 2FE4      MOV	R30,R20
     F28 27FF      CLR	R31
     F29 0FE8      ADD	R30,R24
     F2A 1FF9      ADC	R31,R25
     F2B 8020      LDD	R2,Z+0
     F2C 01C8      MOVW	R24,R16
     F2D 960E      ADIW	R24,0xE
     F2E 2FE4      MOV	R30,R20
     F2F 27FF      CLR	R31
     F30 0FE8      ADD	R30,R24
     F31 1FF9      ADC	R31,R25
     F32 8220      STD	Z+0,R2
     F33 9543      INC	R20
     F34 3042      CPI	R20,2
     F35 F378      BCS	0x0F25
(0312) 	for(i=0;i<2;i++)Desti->deCDate[i] = Source->deCDate[i];
     F36 2744      CLR	R20
     F37 C00F      RJMP	0x0F47
     F38 01C9      MOVW	R24,R18
     F39 9640      ADIW	R24,0x10
     F3A 2FE4      MOV	R30,R20
     F3B 27FF      CLR	R31
     F3C 0FE8      ADD	R30,R24
     F3D 1FF9      ADC	R31,R25
     F3E 8020      LDD	R2,Z+0
     F3F 01C8      MOVW	R24,R16
     F40 9640      ADIW	R24,0x10
     F41 2FE4      MOV	R30,R20
     F42 27FF      CLR	R31
     F43 0FE8      ADD	R30,R24
     F44 1FF9      ADC	R31,R25
     F45 8220      STD	Z+0,R2
     F46 9543      INC	R20
     F47 3042      CPI	R20,2
     F48 F378      BCS	0x0F38
(0313) 	for(i=0;i<2;i++)Desti->deADate[i] = Source->deADate[i];
     F49 2744      CLR	R20
     F4A C00F      RJMP	0x0F5A
     F4B 01C9      MOVW	R24,R18
     F4C 9642      ADIW	R24,0x12
     F4D 2FE4      MOV	R30,R20
     F4E 27FF      CLR	R31
     F4F 0FE8      ADD	R30,R24
     F50 1FF9      ADC	R31,R25
     F51 8020      LDD	R2,Z+0
     F52 01C8      MOVW	R24,R16
     F53 9642      ADIW	R24,0x12
     F54 2FE4      MOV	R30,R20
     F55 27FF      CLR	R31
     F56 0FE8      ADD	R30,R24
     F57 1FF9      ADC	R31,R25
     F58 8220      STD	Z+0,R2
     F59 9543      INC	R20
     F5A 3042      CPI	R20,2
     F5B F378      BCS	0x0F4B
(0314) 	Desti->deHighClust = Source->deHighClust;
     F5C 01F9      MOVW	R30,R18
     F5D 8824      LDD	R2,Z+20
     F5E 8835      LDD	R3,Z+21
     F5F 01F8      MOVW	R30,R16
     F60 8A35      STD	Z+21,R3
     F61 8A24      STD	Z+20,R2
(0315) 	for(i=0;i<2;i++)Desti->deMTime[i] = Source->deMTime[i];
     F62 2744      CLR	R20
     F63 C00F      RJMP	0x0F73
     F64 01C9      MOVW	R24,R18
     F65 9646      ADIW	R24,0x16
     F66 2FE4      MOV	R30,R20
     F67 27FF      CLR	R31
     F68 0FE8      ADD	R30,R24
     F69 1FF9      ADC	R31,R25
     F6A 8020      LDD	R2,Z+0
     F6B 01C8      MOVW	R24,R16
     F6C 9646      ADIW	R24,0x16
     F6D 2FE4      MOV	R30,R20
     F6E 27FF      CLR	R31
     F6F 0FE8      ADD	R30,R24
     F70 1FF9      ADC	R31,R25
     F71 8220      STD	Z+0,R2
     F72 9543      INC	R20
     F73 3042      CPI	R20,2
     F74 F378      BCS	0x0F64
(0316) 	for(i=0;i<2;i++)Desti->deMDate[i] = Source->deMDate[i];
     F75 2744      CLR	R20
     F76 C00F      RJMP	0x0F86
     F77 01C9      MOVW	R24,R18
     F78 9648      ADIW	R24,0x18
     F79 2FE4      MOV	R30,R20
     F7A 27FF      CLR	R31
     F7B 0FE8      ADD	R30,R24
     F7C 1FF9      ADC	R31,R25
     F7D 8020      LDD	R2,Z+0
     F7E 01C8      MOVW	R24,R16
     F7F 9648      ADIW	R24,0x18
     F80 2FE4      MOV	R30,R20
     F81 27FF      CLR	R31
     F82 0FE8      ADD	R30,R24
     F83 1FF9      ADC	R31,R25
     F84 8220      STD	Z+0,R2
     F85 9543      INC	R20
     F86 3042      CPI	R20,2
     F87 F378      BCS	0x0F77
(0317) 	Desti->deStartCluster = Source->deStartCluster;
     F88 01F9      MOVW	R30,R18
     F89 8C22      LDD	R2,Z+26
     F8A 8C33      LDD	R3,Z+27
     F8B 01F8      MOVW	R30,R16
     F8C 8E33      STD	Z+27,R3
     F8D 8E22      STD	Z+26,R2
(0318) 	Desti->deFileSize = Source->deFileSize;
     F8E 01F9      MOVW	R30,R18
     F8F 8C24      LDD	R2,Z+28
     F90 8C35      LDD	R3,Z+29
     F91 8C46      LDD	R4,Z+30
     F92 8C57      LDD	R5,Z+31
     F93 01F8      MOVW	R30,R16
     F94 8E24      STD	Z+28,R2
     F95 8E35      STD	Z+29,R3
     F96 8E46      STD	Z+30,R4
     F97 8E57      STD	Z+31,R5
     F98 9149      LD	R20,Y+
     F99 9508      RET
_WriteFolderCluster:
  cluster              --> Y,+6
  addr                 --> R20
     F9A 933A      ST	R19,-Y
     F9B 932A      ST	R18,-Y
     F9C 934A      ST	R20,-Y
     F9D 935A      ST	R21,-Y
     F9E 01A8      MOVW	R20,R16
     F9F 9724      SBIW	R28,4
(0319) }
(0320) 
(0321) 
(0322) #if FIX_DIRECTORY
(0323) 
(0324) BYTE Search(BYTE *dir,struct direntry *MusicInfo,WORD *Count,BYTE *type)//当COUNT为零时，有它带回这个目录下总共有多少图片
(0325) {                                                            //不为零时有MusicInfo带回第Count图片的详细文件信息
(0326) 	BYTE *buffer;
(0327) 	DWORD sector;
(0328) 	DWORD cluster;
(0329) 	DWORD tempclust;
(0330) 	unsigned char cnt;
(0331) 	unsigned int offset;
(0332) 	unsigned int i=0;
(0333) 	struct direntry *item = 0;
(0334) 	cluster = FAT_OpenDir(dir);
(0335) 	if(cluster == 1)return 1;
(0336) 	if(cluster==0 && FAT32_Enable==0)// 根目录，FAT16文件系统
(0337) 	{
(0338) 		buffer=malloc(512);//动态分配内存512大小
(0339) 		if(buffer==0)return 1;//动态分配失败
(0340) 		for(cnt=0;cnt<RootDirSectors;cnt++)
(0341) 		{
(0342) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
(0343) 			for(offset=0;offset<512;offset+=32)
(0344) 			{
(0345) 				item=(struct direntry *)(&buffer[offset]);//pointer convert
(0346) 				//find a valid item and display it
(0347) 				if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0348) 				{
(0349) 					if((item->deExtension[0] == 'b')&&(item->deExtension[1] == 'm')&&(item->deExtension[2] == 'p'))
(0350) 					{
(0351) 						CopyDirentruyItem(MusicInfo,item);
(0352) 						*type=1;
(0353) 						i++;
(0354) 						if(i==*Count){free(buffer);return 0;}	
(0355) 					}
(0356) 				}
(0357) 			}
(0358) 		}
(0359) 		free(buffer);//release
(0360) 	}
(0361) 	else//other folders
(0362) 	{
(0363) 		tempclust=cluster;
(0364) 		while(1)
(0365) 		{
(0366) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
(0367) 			buffer=malloc(512);//apply memory
(0368) 			if(buffer==0)return 1;//if failed
(0369) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
(0370) 			{
(0371) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
(0372) 				for(offset=0;offset<512;offset+=32)
(0373) 				{
(0374) 					item=(struct direntry *)(&buffer[offset]);
(0375) 					if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
(0376) 					{
(0377) 						if((item->deExtension[0] == 'b')&&(item->deExtension[1] == 'm')&&(item->deExtension[2] == 'p'))
(0378) 						{
(0379) 							CopyDirentruyItem(MusicInfo,item);
(0380) 							*type=1;
(0381) 							i++;
(0382) 							if(i==*Count){free(buffer);return 0;}	
(0383) 						}	
(0384) 					}
(0385) 				}
(0386) 			}
(0387) 			free(buffer);//release
(0388) 			tempclust=FAT_NextCluster(tempclust);//next cluster
(0389) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
(0390) 		}
(0391) 	}
(0392) 	if(*Count==0)*Count=i;
(0393) 	return 0;	
(0394) }
(0395) 
(0396) #else  
(0397) 
(0398) void WriteFolderCluster(WORD addr,DWORD cluster)
(0399) {
(0400) #if FAT_DEBUG
(0401) 	printf("\r\nWrite EEPROM address:%d with value:%ld",addr,cluster);
     FA0 802E      LDD	R2,Y+6
     FA1 803F      LDD	R3,Y+7
     FA2 8448      LDD	R4,Y+8
     FA3 8459      LDD	R5,Y+9
     FA4 8228      STD	Y+0,R2
     FA5 8239      STD	Y+1,R3
     FA6 824A      STD	Y+2,R4
     FA7 825B      STD	Y+3,R5
     FA8 019A      MOVW	R18,R20
     FA9 EA03      LDI	R16,0xA3
     FAA E012      LDI	R17,2
     FAB 940E 25F4 CALL	_printf
(0402) #endif
(0403) 	eeprom_write_byte(addr,cluster>>24);
     FAD E188      LDI	R24,0x18
     FAE E090      LDI	R25,0
     FAF 810E      LDD	R16,Y+6
     FB0 811F      LDD	R17,Y+7
     FB1 8528      LDD	R18,Y+8
     FB2 8539      LDD	R19,Y+9
     FB3 938A      ST	R24,-Y
     FB4 940E 2244 CALL	lsr32
     FB6 2F20      MOV	R18,R16
     FB7 018A      MOVW	R16,R20
     FB8 940E 1C51 CALL	_eeprom_write_byte
(0404) 	eeprom_write_byte(addr+1,cluster>>16);
     FBA 802E      LDD	R2,Y+6
     FBB 803F      LDD	R3,Y+7
     FBC 8448      LDD	R4,Y+8
     FBD 8459      LDD	R5,Y+9
     FBE 0112      MOVW	R2,R4
     FBF 2444      CLR	R4
     FC0 2455      CLR	R5
     FC1 2D22      MOV	R18,R2
     FC2 018A      MOVW	R16,R20
     FC3 5F0F      SUBI	R16,0xFF
     FC4 4F1F      SBCI	R17,0xFF
     FC5 940E 1C51 CALL	_eeprom_write_byte
(0405) 	eeprom_write_byte(addr+2,cluster>>8);
     FC7 E088      LDI	R24,0x8
     FC8 E090      LDI	R25,0
     FC9 810E      LDD	R16,Y+6
     FCA 811F      LDD	R17,Y+7
     FCB 8528      LDD	R18,Y+8
     FCC 8539      LDD	R19,Y+9
     FCD 938A      ST	R24,-Y
     FCE 940E 2244 CALL	lsr32
     FD0 2F20      MOV	R18,R16
     FD1 018A      MOVW	R16,R20
     FD2 5F0E      SUBI	R16,0xFE
     FD3 4F1F      SBCI	R17,0xFF
     FD4 940E 1C51 CALL	_eeprom_write_byte
(0406) 	eeprom_write_byte(addr+3,cluster>>0);
     FD6 802E      LDD	R2,Y+6
     FD7 803F      LDD	R3,Y+7
     FD8 8448      LDD	R4,Y+8
     FD9 8459      LDD	R5,Y+9
     FDA 2D22      MOV	R18,R2
     FDB 018A      MOVW	R16,R20
     FDC 5F0D      SUBI	R16,0xFD
     FDD 4F1F      SBCI	R17,0xFF
     FDE 940E 1C51 CALL	_eeprom_write_byte
     FE0 9624      ADIW	R28,4
     FE1 9159      LD	R21,Y+
     FE2 9149      LD	R20,Y+
     FE3 9622      ADIW	R28,2
     FE4 9508      RET
_GetFolderCluster:
  temp                 --> Y,+4
  addr                 --> R20
     FE5 940E 21B8 CALL	push_xgset300C
     FE7 01A8      MOVW	R20,R16
     FE8 9728      SBIW	R28,0x8
(0407) }
(0408) 
(0409) DWORD GetFolderCluster(WORD addr)
(0410) {
(0411) 	DWORD temp;
(0412) 	
(0413) 	temp = eeprom_read_byte(addr);
     FE9 018A      MOVW	R16,R20
     FEA 940E 1C45 CALL	_eeprom_read_byte
     FEC 0118      MOVW	R2,R16
     FED 2444      CLR	R4
     FEE FC37      SBRC	R3,7
     FEF 9440      COM	R4
     FF0 2455      CLR	R5
     FF1 FC47      SBRC	R4,7
     FF2 9450      COM	R5
     FF3 822C      STD	Y+4,R2
     FF4 823D      STD	Y+5,R3
     FF5 824E      STD	Y+6,R4
     FF6 825F      STD	Y+7,R5
(0414) 	temp <<= 8;
     FF7 E088      LDI	R24,0x8
     FF8 E090      LDI	R25,0
     FF9 810C      LDD	R16,Y+4
     FFA 811D      LDD	R17,Y+5
     FFB 812E      LDD	R18,Y+6
     FFC 813F      LDD	R19,Y+7
     FFD 938A      ST	R24,-Y
     FFE 940E 2238 CALL	lsl32
    1000 830C      STD	Y+4,R16
    1001 831D      STD	Y+5,R17
    1002 832E      STD	Y+6,R18
    1003 833F      STD	Y+7,R19
(0415) 	temp += eeprom_read_byte(addr+1);
    1004 018A      MOVW	R16,R20
    1005 5F0F      SUBI	R16,0xFF
    1006 4F1F      SBCI	R17,0xFF
    1007 940E 1C45 CALL	_eeprom_read_byte
    1009 0118      MOVW	R2,R16
    100A 2444      CLR	R4
    100B FC37      SBRC	R3,7
    100C 9440      COM	R4
    100D 2455      CLR	R5
    100E FC47      SBRC	R4,7
    100F 9450      COM	R5
    1010 806C      LDD	R6,Y+4
    1011 807D      LDD	R7,Y+5
    1012 808E      LDD	R8,Y+6
    1013 809F      LDD	R9,Y+7
    1014 0C62      ADD	R6,R2
    1015 1C73      ADC	R7,R3
    1016 1C84      ADC	R8,R4
    1017 1C95      ADC	R9,R5
    1018 826C      STD	Y+4,R6
    1019 827D      STD	Y+5,R7
    101A 828E      STD	Y+6,R8
    101B 829F      STD	Y+7,R9
(0416) 	temp <<= 8;
    101C E088      LDI	R24,0x8
    101D E090      LDI	R25,0
    101E 810C      LDD	R16,Y+4
    101F 811D      LDD	R17,Y+5
    1020 812E      LDD	R18,Y+6
    1021 813F      LDD	R19,Y+7
    1022 938A      ST	R24,-Y
    1023 940E 2238 CALL	lsl32
    1025 830C      STD	Y+4,R16
    1026 831D      STD	Y+5,R17
    1027 832E      STD	Y+6,R18
    1028 833F      STD	Y+7,R19
(0417) 	temp += eeprom_read_byte(addr+2);
    1029 018A      MOVW	R16,R20
    102A 5F0E      SUBI	R16,0xFE
    102B 4F1F      SBCI	R17,0xFF
    102C 940E 1C45 CALL	_eeprom_read_byte
    102E 0158      MOVW	R10,R16
    102F 0115      MOVW	R2,R10
    1030 2444      CLR	R4
    1031 FC37      SBRC	R3,7
    1032 9440      COM	R4
    1033 2455      CLR	R5
    1034 FC47      SBRC	R4,7
    1035 9450      COM	R5
    1036 806C      LDD	R6,Y+4
    1037 807D      LDD	R7,Y+5
    1038 808E      LDD	R8,Y+6
    1039 809F      LDD	R9,Y+7
    103A 0C62      ADD	R6,R2
    103B 1C73      ADC	R7,R3
    103C 1C84      ADC	R8,R4
    103D 1C95      ADC	R9,R5
    103E 826C      STD	Y+4,R6
    103F 827D      STD	Y+5,R7
    1040 828E      STD	Y+6,R8
    1041 829F      STD	Y+7,R9
(0418) 	temp <<= 8;
    1042 E088      LDI	R24,0x8
    1043 E090      LDI	R25,0
    1044 810C      LDD	R16,Y+4
    1045 811D      LDD	R17,Y+5
    1046 812E      LDD	R18,Y+6
    1047 813F      LDD	R19,Y+7
    1048 938A      ST	R24,-Y
    1049 940E 2238 CALL	lsl32
    104B 830C      STD	Y+4,R16
    104C 831D      STD	Y+5,R17
    104D 832E      STD	Y+6,R18
    104E 833F      STD	Y+7,R19
(0419) 	temp += eeprom_read_byte(addr+3);
    104F 018A      MOVW	R16,R20
    1050 5F0D      SUBI	R16,0xFD
    1051 4F1F      SBCI	R17,0xFF
    1052 940E 1C45 CALL	_eeprom_read_byte
    1054 0158      MOVW	R10,R16
    1055 0115      MOVW	R2,R10
    1056 2444      CLR	R4
    1057 FC37      SBRC	R3,7
    1058 9440      COM	R4
    1059 2455      CLR	R5
    105A FC47      SBRC	R4,7
    105B 9450      COM	R5
    105C 806C      LDD	R6,Y+4
    105D 807D      LDD	R7,Y+5
    105E 808E      LDD	R8,Y+6
    105F 809F      LDD	R9,Y+7
    1060 0C62      ADD	R6,R2
    1061 1C73      ADC	R7,R3
    1062 1C84      ADC	R8,R4
    1063 1C95      ADC	R9,R5
    1064 826C      STD	Y+4,R6
    1065 827D      STD	Y+5,R7
    1066 828E      STD	Y+6,R8
    1067 829F      STD	Y+7,R9
(0420) #if FAT_DEBUG
(0421) 	printf("\r\nRead EEPROM address: %d value is: %ld",addr,temp);
    1068 802C      LDD	R2,Y+4
    1069 803D      LDD	R3,Y+5
    106A 804E      LDD	R4,Y+6
    106B 805F      LDD	R5,Y+7
    106C 8228      STD	Y+0,R2
    106D 8239      STD	Y+1,R3
    106E 824A      STD	Y+2,R4
    106F 825B      STD	Y+3,R5
    1070 019A      MOVW	R18,R20
    1071 E70B      LDI	R16,0x7B
    1072 E012      LDI	R17,2
    1073 940E 25F4 CALL	_printf
(0422) #endif
(0423) 	return temp;
    1075 810C      LDD	R16,Y+4
    1076 811D      LDD	R17,Y+5
    1077 812E      LDD	R18,Y+6
    1078 813F      LDD	R19,Y+7
    1079 9628      ADIW	R28,0x8
    107A 940C 21BD JMP	pop_xgset300C
_SearchFolder:
  tempclust            --> Y,+6
  sector               --> Y,+2
  cnt                  --> R14
  buffer               --> Y,+12
  offset               --> R10
  item                 --> Y,+10
  addr                 --> Y,+28
  cluster              --> Y,+24
    107C 940E 20C0 CALL	push_arg4
    107E 940E 21AD CALL	push_xgsetF0FC
    1080 972E      SBIW	R28,0xE
(0424) }
(0425) 
(0426) BYTE SearchFolder(DWORD cluster,WORD *addr)
(0427) {
(0428) 	BYTE *buffer;
(0429) 	//BYTE buff[3];
(0430) 	DWORD sector;
(0431) 	//DWORD cluster;
(0432) 	DWORD tempclust;
(0433) 	unsigned char cnt;
(0434) 	unsigned int offset;
(0435) 	//unsigned int i=0;
(0436) 	//unsigned char j;//long name buffer offset;
(0437) //	unsigned char *p;//long name buffer pointer
(0438) 	struct direntry *item = 0;
    1081 2400      CLR	R0
    1082 2411      CLR	R1
    1083 861B      STD	Y+11,R1
    1084 860A      STD	Y+10,R0
(0439) 	//struct winentry *we =0;
(0440) 	
(0441) 	if(cluster==0 && FAT32_Enable==0)// root directory
    1085 8C28      LDD	R2,Y+24
    1086 8C39      LDD	R3,Y+25
    1087 8C4A      LDD	R4,Y+26
    1088 8C5B      LDD	R5,Y+27
    1089 9488      BCLR	0
    108A 2022      TST	R2
    108B 0432      CPC	R3,R2
    108C 0442      CPC	R4,R2
    108D 0452      CPC	R5,R2
    108E F009      BEQ	0x1090
    108F C0A2      RJMP	0x1132
    1090 9020 0DF3 LDS	R2,FAT32_Enable
    1092 2022      TST	R2
    1093 F009      BEQ	0x1095
    1094 C09D      RJMP	0x1132
(0442) 	{
(0443) 		
(0444) 		buffer=malloc(512);//apply memory
    1095 E000      LDI	R16,0
    1096 E012      LDI	R17,2
    1097 940E 229A CALL	_malloc
    1099 871D      STD	Y+13,R17
    109A 870C      STD	Y+12,R16
(0445) 		if(buffer==0) {printf("Apply Memory Failure");return 1;}//if failed
    109B 0108      MOVW	R0,R16
    109C 3000      CPI	R16,0
    109D 0701      CPC	R16,R17
    109E F431      BNE	0x10A5
    109F E606      LDI	R16,0x66
    10A0 E012      LDI	R17,2
    10A1 940E 25F4 CALL	_printf
    10A3 E001      LDI	R16,1
    10A4 C17F      RJMP	0x1224
(0446) 		for(cnt=0;cnt<RootDirSectors;cnt++)
    10A5 24EE      CLR	R14
    10A6 C074      RJMP	0x111B
(0447) 		{
(0448) 			if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
    10A7 840C      LDD	R0,Y+12
    10A8 841D      LDD	R1,Y+13
    10A9 8219      STD	Y+1,R1
    10AA 8208      STD	Y+0,R0
    10AB 2C2E      MOV	R2,R14
    10AC 2433      CLR	R3
    10AD 2444      CLR	R4
    10AE 2455      CLR	R5
    10AF 9120 0DFE LDS	R18,FirstDirSector+2
    10B1 9130 0DFF LDS	R19,FirstDirSector+3
    10B3 9100 0DFC LDS	R16,FirstDirSector
    10B5 9110 0DFD LDS	R17,FirstDirSector+1
    10B7 0D02      ADD	R16,R2
    10B8 1D13      ADC	R17,R3
    10B9 1D24      ADC	R18,R4
    10BA 1D35      ADC	R19,R5
    10BB 91E0 0198 LDS	R30,FAT_ReadSector
    10BD 91F0 0199 LDS	R31,FAT_ReadSector+1
    10BF 940E 21FA CALL	xicallx
    10C1 2300      TST	R16
    10C2 F031      BEQ	0x10C9
    10C3 850C      LDD	R16,Y+12
    10C4 851D      LDD	R17,Y+13
    10C5 940E 2399 CALL	_free
    10C7 E001      LDI	R16,1
    10C8 C15B      RJMP	0x1224
(0449) 			for(offset=0;offset<512;offset+=32)
    10C9 24AA      CLR	R10
    10CA 24BB      CLR	R11
    10CB C048      RJMP	0x1114
(0450) 			{
(0451) 				item=(struct direntry *)(&buffer[offset]);//pointer convert
    10CC 0115      MOVW	R2,R10
    10CD 840C      LDD	R0,Y+12
    10CE 841D      LDD	R1,Y+13
    10CF 0C20      ADD	R2,R0
    10D0 1C31      ADC	R3,R1
    10D1 863B      STD	Y+11,R3
    10D2 862A      STD	Y+10,R2
(0452) 				//find a valid item and display it
(0453) 				if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5))
    10D3 01F1      MOVW	R30,R2
    10D4 80C0      LDD	R12,Z+0
    10D5 24DD      CLR	R13
    10D6 2D8C      MOV	R24,R12
    10D7 328E      CPI	R24,0x2E
    10D8 F409      BNE	0x10DA
    10D9 C037      RJMP	0x1111
    10DA 2388      TST	R24
    10DB F409      BNE	0x10DD
    10DC C034      RJMP	0x1111
    10DD 3E85      CPI	R24,0xE5
    10DE F409      BNE	0x10E0
    10DF C031      RJMP	0x1111
(0454) 				{
(0455) 					if(item->deAttributes & ATTR_DIRECTORY )
    10E0 8423      LDD	R2,Z+11
    10E1 FE24      SBRS	R2,4
    10E2 C02E      RJMP	0x1111
(0456) 					{
(0457) 						#if FAT_DEBUG
(0458) 							printf("\r\nFound a folder!");
    10E3 E504      LDI	R16,0x54
    10E4 E012      LDI	R17,2
    10E5 940E 25F4 CALL	_printf
(0459) 						#endif
(0460) 						if(*addr==RECORD_ADDR_END)return 0;
    10E7 8DEC      LDD	R30,Y+28
    10E8 8DFD      LDD	R31,Y+29
    10E9 8180      LDD	R24,Z+0
    10EA 8191      LDD	R25,Z+1
    10EB 3080      CPI	R24,0
    10EC E0E2      LDI	R30,2
    10ED 079E      CPC	R25,R30
    10EE F411      BNE	0x10F1
    10EF 2700      CLR	R16
    10F0 C133      RJMP	0x1224
(0461) 						else
(0462) 						{
(0463) 							WriteFolderCluster(*addr,item->deStartCluster+(((unsigned long)item->deHighClust)<<16));
    10F1 85EA      LDD	R30,Y+10
    10F2 85FB      LDD	R31,Y+11
    10F3 8824      LDD	R2,Z+20
    10F4 8835      LDD	R3,Z+21
    10F5 2444      CLR	R4
    10F6 2455      CLR	R5
    10F7 0121      MOVW	R4,R2
    10F8 2422      CLR	R2
    10F9 2433      CLR	R3
    10FA 8C62      LDD	R6,Z+26
    10FB 8C73      LDD	R7,Z+27
    10FC 2488      CLR	R8
    10FD 2499      CLR	R9
    10FE 0C62      ADD	R6,R2
    10FF 1C73      ADC	R7,R3
    1100 1C84      ADC	R8,R4
    1101 1C95      ADC	R9,R5
    1102 8288      STD	Y+0,R8
    1103 8299      STD	Y+1,R9
    1104 0193      MOVW	R18,R6
    1105 8DEC      LDD	R30,Y+28
    1106 8DFD      LDD	R31,Y+29
    1107 8100      LDD	R16,Z+0
    1108 8111      LDD	R17,Z+1
    1109 DE90      RCALL	_WriteFolderCluster
(0464) 							*addr+=4;
    110A 8DEC      LDD	R30,Y+28
    110B 8DFD      LDD	R31,Y+29
    110C 8180      LDD	R24,Z+0
    110D 8191      LDD	R25,Z+1
    110E 9604      ADIW	R24,4
    110F 8391      STD	Z+1,R25
    1110 8380      STD	Z+0,R24
    1111 01C5      MOVW	R24,R10
    1112 9680      ADIW	R24,0x20
    1113 015C      MOVW	R10,R24
    1114 01C5      MOVW	R24,R10
    1115 3080      CPI	R24,0
    1116 E0E2      LDI	R30,2
    1117 079E      CPC	R25,R30
    1118 F408      BCC	0x111A
    1119 CFB2      RJMP	0x10CC
    111A 94E3      INC	R14
    111B 9040 0DFA LDS	R4,RootDirSectors+2
    111D 9050 0DFB LDS	R5,RootDirSectors+3
    111F 9020 0DF8 LDS	R2,RootDirSectors
    1121 9030 0DF9 LDS	R3,RootDirSectors+1
    1123 2C6E      MOV	R6,R14
    1124 2477      CLR	R7
    1125 2488      CLR	R8
    1126 2499      CLR	R9
    1127 1462      CP	R6,R2
    1128 0473      CPC	R7,R3
    1129 0484      CPC	R8,R4
    112A 0495      CPC	R9,R5
    112B F408      BCC	0x112D
    112C CF7A      RJMP	0x10A7
(0465) 						}
(0466) 					}
(0467) 				}
(0468) 			}
(0469) 		}
(0470) 		free(buffer);//release
    112D 850C      LDD	R16,Y+12
    112E 851D      LDD	R17,Y+13
    112F 940E 2399 CALL	_free
(0471) 	}
    1131 C0F1      RJMP	0x1223
(0472) 	else//other folders
(0473) 	{
(0474) 		tempclust=cluster;
    1132 8C28      LDD	R2,Y+24
    1133 8C39      LDD	R3,Y+25
    1134 8C4A      LDD	R4,Y+26
    1135 8C5B      LDD	R5,Y+27
    1136 822E      STD	Y+6,R2
    1137 823F      STD	Y+7,R3
    1138 8648      STD	Y+8,R4
    1139 8659      STD	Y+9,R5
    113A C0E7      RJMP	0x1222
(0475) 		while(1)
(0476) 		{
(0477) 			sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
    113B E042      LDI	R20,2
    113C E050      LDI	R21,0
    113D E060      LDI	R22,0
    113E E070      LDI	R23,0
    113F 810E      LDD	R16,Y+6
    1140 811F      LDD	R17,Y+7
    1141 8528      LDD	R18,Y+8
    1142 8539      LDD	R19,Y+9
    1143 1B04      SUB	R16,R20
    1144 0B15      SBC	R17,R21
    1145 0B26      SBC	R18,R22
    1146 0B37      SBC	R19,R23
    1147 9020 0E04 LDS	R2,SectorsPerClust
    1149 9030 0E05 LDS	R3,SectorsPerClust+1
    114B 2444      CLR	R4
    114C 2455      CLR	R5
    114D 925A      ST	R5,-Y
    114E 924A      ST	R4,-Y
    114F 923A      ST	R3,-Y
    1150 922A      ST	R2,-Y
    1151 940E 2162 CALL	empy32u
    1153 9040 0E0C LDS	R4,FirstDataSector+2
    1155 9050 0E0D LDS	R5,FirstDataSector+3
    1157 9020 0E0A LDS	R2,FirstDataSector
    1159 9030 0E0B LDS	R3,FirstDataSector+1
    115B 0E20      ADD	R2,R16
    115C 1E31      ADC	R3,R17
    115D 1E42      ADC	R4,R18
    115E 1E53      ADC	R5,R19
    115F 822A      STD	Y+2,R2
    1160 823B      STD	Y+3,R3
    1161 824C      STD	Y+4,R4
    1162 825D      STD	Y+5,R5
(0478) 			buffer=malloc(512);//apply memory
    1163 E000      LDI	R16,0
    1164 E012      LDI	R17,2
    1165 940E 229A CALL	_malloc
    1167 0168      MOVW	R12,R16
    1168 86DD      STD	Y+13,R13
    1169 86CC      STD	Y+12,R12
(0479) 			if(buffer==0)return 1;//if failed
    116A 0106      MOVW	R0,R12
    116B 3000      CPI	R16,0
    116C 0701      CPC	R16,R17
    116D F411      BNE	0x1170
    116E E001      LDI	R16,1
    116F C0B4      RJMP	0x1224
(0480) 			for(cnt=0;cnt<SectorsPerClust;cnt++)
    1170 24EE      CLR	R14
    1171 C071      RJMP	0x11E3
(0481) 			{
(0482) 				if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
    1172 840C      LDD	R0,Y+12
    1173 841D      LDD	R1,Y+13
    1174 8219      STD	Y+1,R1
    1175 8208      STD	Y+0,R0
    1176 2C2E      MOV	R2,R14
    1177 2433      CLR	R3
    1178 2444      CLR	R4
    1179 2455      CLR	R5
    117A 810A      LDD	R16,Y+2
    117B 811B      LDD	R17,Y+3
    117C 812C      LDD	R18,Y+4
    117D 813D      LDD	R19,Y+5
    117E 0D02      ADD	R16,R2
    117F 1D13      ADC	R17,R3
    1180 1D24      ADC	R18,R4
    1181 1D35      ADC	R19,R5
    1182 91E0 0198 LDS	R30,FAT_ReadSector
    1184 91F0 0199 LDS	R31,FAT_ReadSector+1
    1186 940E 21FA CALL	xicallx
    1188 2EC0      MOV	R12,R16
    1189 2300      TST	R16
    118A F031      BEQ	0x1191
    118B 850C      LDD	R16,Y+12
    118C 851D      LDD	R17,Y+13
    118D 940E 2399 CALL	_free
    118F E001      LDI	R16,1
    1190 C093      RJMP	0x1224
(0483) 				for(offset=0;offset<512;offset+=32)
    1191 24AA      CLR	R10
    1192 24BB      CLR	R11
    1193 C048      RJMP	0x11DC
(0484) 				{
(0485) 					item=(struct direntry *)(&buffer[offset]);
    1194 0115      MOVW	R2,R10
    1195 840C      LDD	R0,Y+12
    1196 841D      LDD	R1,Y+13
    1197 0C20      ADD	R2,R0
    1198 1C31      ADC	R3,R1
    1199 863B      STD	Y+11,R3
    119A 862A      STD	Y+10,R2
(0486) 					if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5))
    119B 01F1      MOVW	R30,R2
    119C 80C0      LDD	R12,Z+0
    119D 24DD      CLR	R13
    119E 2D8C      MOV	R24,R12
    119F 328E      CPI	R24,0x2E
    11A0 F409      BNE	0x11A2
    11A1 C037      RJMP	0x11D9
    11A2 2388      TST	R24
    11A3 F409      BNE	0x11A5
    11A4 C034      RJMP	0x11D9
    11A5 3E85      CPI	R24,0xE5
    11A6 F409      BNE	0x11A8
    11A7 C031      RJMP	0x11D9
(0487) 					{				
(0488) 						if(item->deAttributes & ATTR_DIRECTORY )
    11A8 8423      LDD	R2,Z+11
    11A9 FE24      SBRS	R2,4
    11AA C02E      RJMP	0x11D9
(0489) 						{
(0490) 							#if FAT_DEBUG
(0491) 								printf("\r\nFound a folder!");
    11AB E504      LDI	R16,0x54
    11AC E012      LDI	R17,2
    11AD 940E 25F4 CALL	_printf
(0492) 							#endif
(0493) 							if(*addr==RECORD_ADDR_END)return 0;
    11AF 8DEC      LDD	R30,Y+28
    11B0 8DFD      LDD	R31,Y+29
    11B1 8180      LDD	R24,Z+0
    11B2 8191      LDD	R25,Z+1
    11B3 3080      CPI	R24,0
    11B4 E0E2      LDI	R30,2
    11B5 079E      CPC	R25,R30
    11B6 F411      BNE	0x11B9
    11B7 2700      CLR	R16
    11B8 C06B      RJMP	0x1224
(0494) 							else
(0495) 							{
(0496) 								WriteFolderCluster(*addr,item->deStartCluster+(((unsigned long)item->deHighClust)<<16));
    11B9 85EA      LDD	R30,Y+10
    11BA 85FB      LDD	R31,Y+11
    11BB 8824      LDD	R2,Z+20
    11BC 8835      LDD	R3,Z+21
    11BD 2444      CLR	R4
    11BE 2455      CLR	R5
    11BF 0121      MOVW	R4,R2
    11C0 2422      CLR	R2
    11C1 2433      CLR	R3
    11C2 8C62      LDD	R6,Z+26
    11C3 8C73      LDD	R7,Z+27
    11C4 2488      CLR	R8
    11C5 2499      CLR	R9
    11C6 0C62      ADD	R6,R2
    11C7 1C73      ADC	R7,R3
    11C8 1C84      ADC	R8,R4
    11C9 1C95      ADC	R9,R5
    11CA 8288      STD	Y+0,R8
    11CB 8299      STD	Y+1,R9
    11CC 0193      MOVW	R18,R6
    11CD 8DEC      LDD	R30,Y+28
    11CE 8DFD      LDD	R31,Y+29
    11CF 8100      LDD	R16,Z+0
    11D0 8111      LDD	R17,Z+1
    11D1 DDC8      RCALL	_WriteFolderCluster
(0497) 								*addr+=4;
    11D2 8DEC      LDD	R30,Y+28
    11D3 8DFD      LDD	R31,Y+29
    11D4 8180      LDD	R24,Z+0
    11D5 8191      LDD	R25,Z+1
    11D6 9604      ADIW	R24,4
    11D7 8391      STD	Z+1,R25
    11D8 8380      STD	Z+0,R24
    11D9 01C5      MOVW	R24,R10
    11DA 9680      ADIW	R24,0x20
    11DB 015C      MOVW	R10,R24
    11DC 01C5      MOVW	R24,R10
    11DD 3080      CPI	R24,0
    11DE E0E2      LDI	R30,2
    11DF 079E      CPC	R25,R30
    11E0 F408      BCC	0x11E2
    11E1 CFB2      RJMP	0x1194
    11E2 94E3      INC	R14
    11E3 9020 0E04 LDS	R2,SectorsPerClust
    11E5 9030 0E05 LDS	R3,SectorsPerClust+1
    11E7 2C4E      MOV	R4,R14
    11E8 2455      CLR	R5
    11E9 1442      CP	R4,R2
    11EA 0453      CPC	R5,R3
    11EB F408      BCC	0x11ED
    11EC CF85      RJMP	0x1172
(0498) 							}
(0499) 						}
(0500) 					}
(0501) 				}
(0502) 			}
(0503) 			free(buffer);//release
    11ED 850C      LDD	R16,Y+12
    11EE 851D      LDD	R17,Y+13
    11EF 940E 2399 CALL	_free
(0504) 			tempclust=FAT_NextCluster(tempclust);//next cluster
    11F1 810E      LDD	R16,Y+6
    11F2 811F      LDD	R17,Y+7
    11F3 8528      LDD	R18,Y+8
    11F4 8539      LDD	R19,Y+9
    11F5 DC2C      RCALL	_FAT_NextCluster
    11F6 830E      STD	Y+6,R16
    11F7 831F      STD	Y+7,R17
    11F8 8728      STD	Y+8,R18
    11F9 8739      STD	Y+9,R19
(0505) 			if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
    11FA EF4F      LDI	R20,0xFF
    11FB EF5F      LDI	R21,0xFF
    11FC EF6F      LDI	R22,0xFF
    11FD E07F      LDI	R23,0xF
    11FE 802E      LDD	R2,Y+6
    11FF 803F      LDD	R3,Y+7
    1200 8448      LDD	R4,Y+8
    1201 8459      LDD	R5,Y+9
    1202 1624      CP	R2,R20
    1203 0635      CPC	R3,R21
    1204 0646      CPC	R4,R22
    1205 0657      CPC	R5,R23
    1206 F0D1      BEQ	0x1221
    1207 EF48      LDI	R20,0xF8
    1208 EF5F      LDI	R21,0xFF
    1209 EF6F      LDI	R22,0xFF
    120A E07F      LDI	R23,0xF
    120B 1624      CP	R2,R20
    120C 0635      CPC	R3,R21
    120D 0646      CPC	R4,R22
    120E 0657      CPC	R5,R23
    120F F089      BEQ	0x1221
    1210 9020 0DF3 LDS	R2,FAT32_Enable
    1212 2022      TST	R2
    1213 F471      BNE	0x1222
    1214 EF4F      LDI	R20,0xFF
    1215 EF5F      LDI	R21,0xFF
    1216 E060      LDI	R22,0
    1217 E070      LDI	R23,0
    1218 802E      LDD	R2,Y+6
    1219 803F      LDD	R3,Y+7
    121A 8448      LDD	R4,Y+8
    121B 8459      LDD	R5,Y+9
    121C 1624      CP	R2,R20
    121D 0635      CPC	R3,R21
    121E 0646      CPC	R4,R22
    121F 0657      CPC	R5,R23
    1220 F409      BNE	0x1222
    1221 C001      RJMP	0x1223
    1222 CF18      RJMP	0x113B
(0506) 		}
(0507) 	}
(0508) 	return 0;		
    1223 2700      CLR	R16
    1224 962E      ADIW	R28,0xE
    1225 940E 21A2 CALL	pop_xgsetF0FC
    1227 9624      ADIW	R28,4
    1228 9508      RET
_SearchInit:
  temp_addr            --> Y,+6
  cluster              --> Y,+2
  addr                 --> R20
    1229 934A      ST	R20,-Y
    122A 935A      ST	R21,-Y
    122B 9728      SBIW	R28,0x8
(0509) }
(0510) 
(0511) 
(0512) 
(0513) BYTE SearchInit()
(0514) {	
(0515) 	WORD addr = RECORD_ADDR_START;
    122C 2744      CLR	R20
    122D 2755      CLR	R21
(0516) 	WORD temp_addr;
(0517) 	DWORD cluster;
(0518) 	
(0519) #if FAT_DEBUG
(0520) 	printf("\r\nSearchInit");
    122E E407      LDI	R16,0x47
    122F E012      LDI	R17,2
    1230 940E 25F4 CALL	_printf
(0521) #endif
(0522) 
(0523) 	if(FAT32_Enable)
    1232 9020 0DF3 LDS	R2,FAT32_Enable
    1234 2022      TST	R2
    1235 F071      BEQ	0x1244
(0524) 		WriteFolderCluster(addr,FirstDirClust);
    1236 9040 0E10 LDS	R4,FirstDirClust+2
    1238 9050 0E11 LDS	R5,FirstDirClust+3
    123A 9020 0E0E LDS	R2,FirstDirClust
    123C 9030 0E0F LDS	R3,FirstDirClust+1
    123E 8248      STD	Y+0,R4
    123F 8259      STD	Y+1,R5
    1240 0191      MOVW	R18,R2
    1241 018A      MOVW	R16,R20
    1242 DD57      RCALL	_WriteFolderCluster
    1243 C00A      RJMP	0x124E
(0525) 	else 
(0526) 		WriteFolderCluster(RECORD_ADDR_START,0);
    1244 E080      LDI	R24,0
    1245 E090      LDI	R25,0
    1246 E0A0      LDI	R26,0
    1247 E0B0      LDI	R27,0
    1248 83A8      STD	Y+0,R26
    1249 83B9      STD	Y+1,R27
    124A 019C      MOVW	R18,R24
    124B 2700      CLR	R16
    124C 2711      CLR	R17
    124D DD4C      RCALL	_WriteFolderCluster
(0527) 	
(0528) 	addr += 4;
    124E 5F4C      SUBI	R20,0xFC
    124F 4F5F      SBCI	R21,0xFF
(0529) 	
(0530) 	WriteFolderCluster(addr, 0xffffffff);
    1250 EF8F      LDI	R24,0xFF
    1251 EF9F      LDI	R25,0xFF
    1252 EFAF      LDI	R26,0xFF
    1253 EFBF      LDI	R27,0xFF
    1254 83A8      STD	Y+0,R26
    1255 83B9      STD	Y+1,R27
    1256 019C      MOVW	R18,R24
    1257 018A      MOVW	R16,R20
    1258 DD41      RCALL	_WriteFolderCluster
(0531) 	temp_addr = addr;
    1259 835F      STD	Y+7,R21
    125A 834E      STD	Y+6,R20
(0532) 	addr = RECORD_ADDR_START;
    125B 2744      CLR	R20
    125C 2755      CLR	R21
    125D C057      RJMP	0x12B5
(0533) 	while(1)
(0534) 	{
(0535) 		cluster = GetFolderCluster(addr);
    125E 018A      MOVW	R16,R20
    125F DD85      RCALL	_GetFolderCluster
    1260 830A      STD	Y+2,R16
    1261 831B      STD	Y+3,R17
    1262 832C      STD	Y+4,R18
    1263 833D      STD	Y+5,R19
(0536) 		if(cluster == 0xffffffff)return 0;
    1264 EF8F      LDI	R24,0xFF
    1265 EF9F      LDI	R25,0xFF
    1266 EFAF      LDI	R26,0xFF
    1267 EFBF      LDI	R27,0xFF
    1268 802A      LDD	R2,Y+2
    1269 803B      LDD	R3,Y+3
    126A 804C      LDD	R4,Y+4
    126B 805D      LDD	R5,Y+5
    126C 1628      CP	R2,R24
    126D 0639      CPC	R3,R25
    126E 064A      CPC	R4,R26
    126F 065B      CPC	R5,R27
    1270 F411      BNE	0x1273
    1271 2700      CLR	R16
    1272 C048      RJMP	0x12BB
(0537) 		else
(0538) 		{
(0539) 			if(SearchFolder(cluster,&temp_addr))
    1273 01CE      MOVW	R24,R28
    1274 9606      ADIW	R24,6
    1275 8399      STD	Y+1,R25
    1276 8388      STD	Y+0,R24
    1277 810A      LDD	R16,Y+2
    1278 811B      LDD	R17,Y+3
    1279 812C      LDD	R18,Y+4
    127A 813D      LDD	R19,Y+5
    127B DE00      RCALL	_SearchFolder
    127C 2300      TST	R16
    127D F021      BEQ	0x1282
(0540) 			{
(0541) 				#if FAT_DEBUG
(0542) 					printf("\r\nERROR: search folder error");
    127E E20A      LDI	R16,0x2A
    127F E012      LDI	R17,2
    1280 940E 25F4 CALL	_printf
(0543) 				#endif
(0544) 			}
(0545) 			#if FAT_DEBUG
(0546) 				printf("\r\nSearch one folder, write the end flag if the the value is not the right value");
    1282 ED0A      LDI	R16,0xDA
    1283 E011      LDI	R17,1
    1284 940E 25F4 CALL	_printf
(0547) 			#endif
(0548) 			if(GetFolderCluster(temp_addr) != 0xffffffff)
    1286 810E      LDD	R16,Y+6
    1287 811F      LDD	R17,Y+7
    1288 DD5C      RCALL	_GetFolderCluster
    1289 EF8F      LDI	R24,0xFF
    128A EF9F      LDI	R25,0xFF
    128B EFAF      LDI	R26,0xFF
    128C EFBF      LDI	R27,0xFF
    128D 1708      CP	R16,R24
    128E 0719      CPC	R17,R25
    128F 072A      CPC	R18,R26
    1290 073B      CPC	R19,R27
    1291 F051      BEQ	0x129C
(0549) 				WriteFolderCluster(temp_addr,0XFFFFFFFF);
    1292 EF8F      LDI	R24,0xFF
    1293 EF9F      LDI	R25,0xFF
    1294 EFAF      LDI	R26,0xFF
    1295 EFBF      LDI	R27,0xFF
    1296 83A8      STD	Y+0,R26
    1297 83B9      STD	Y+1,R27
    1298 019C      MOVW	R18,R24
    1299 810E      LDD	R16,Y+6
    129A 811F      LDD	R17,Y+7
    129B DCFE      RCALL	_WriteFolderCluster
(0550) 			if(temp_addr == RECORD_ADDR_END)
    129C 818E      LDD	R24,Y+6
    129D 819F      LDD	R25,Y+7
    129E 3080      CPI	R24,0
    129F E0E2      LDI	R30,2
    12A0 079E      CPC	R25,R30
    12A1 F489      BNE	0x12B3
(0551) 			{
(0552) 				#if FAT_DEBUG
(0553) 					printf("\r\nWARNING: EEPROM is full, no more space!");
    12A2 EB00      LDI	R16,0xB0
    12A3 E011      LDI	R17,1
    12A4 940E 25F4 CALL	_printf
(0554) 				#endif
(0555) 				WriteFolderCluster(temp_addr - 4,0XFFFFFFFF);
    12A6 EF8F      LDI	R24,0xFF
    12A7 EF9F      LDI	R25,0xFF
    12A8 EFAF      LDI	R26,0xFF
    12A9 EFBF      LDI	R27,0xFF
    12AA 83A8      STD	Y+0,R26
    12AB 83B9      STD	Y+1,R27
    12AC 019C      MOVW	R18,R24
    12AD 810E      LDD	R16,Y+6
    12AE 811F      LDD	R17,Y+7
    12AF 5004      SUBI	R16,4
    12B0 4010      SBCI	R17,0
    12B1 DCE8      RCALL	_WriteFolderCluster
(0556) 				break;
    12B2 C003      RJMP	0x12B6
(0557) 			}
(0558) 		}
(0559) 		addr+=4;
    12B3 5F4C      SUBI	R20,0xFC
    12B4 4F5F      SBCI	R21,0xFF
    12B5 CFA8      RJMP	0x125E
(0560) 	}
(0561) 	#if FAT_DEBUG
(0562) 		printf("\r\nSearch Completed!");
    12B6 E90C      LDI	R16,0x9C
    12B7 E011      LDI	R17,1
    12B8 940E 25F4 CALL	_printf
(0563) 	#endif
(0564) return 1;
    12BA E001      LDI	R16,1
    12BB 9628      ADIW	R28,0x8
    12BC 9159      LD	R21,Y+
    12BD 9149      LD	R20,Y+
    12BE 9508      RET
_Search:
  addr                 --> Y,+23
  cluster              --> Y,+13
  tempclust            --> Y,+9
  sector               --> Y,+5
  cnt                  --> R10
  i                    --> Y,+21
  buffer               --> Y,+19
  file_type            --> Y,+2
  offset               --> R14
  item                 --> Y,+17
  type                 --> Y,+39
  Count                --> Y,+37
  MusicInfo            --> Y,+35
    12BF 940E 20C0 CALL	push_arg4
    12C1 940E 21AD CALL	push_xgsetF0FC
    12C3 9769      SBIW	R28,0x19
(0565) }
(0566) 
(0567) 
(0568) 
(0569) BYTE Search(/*BYTE *dirWORD *music_record_addr,*/struct direntry *MusicInfo,WORD *Count,BYTE *type)//当COUNT为零时，有它带回这个目录下总共有多少图片
(0570) {                                                            //不为零时有MusicInfo带回第Count图片的详细文件信息
(0571) 	BYTE *buffer;
(0572) 	DWORD sector;
(0573) 	DWORD cluster;
(0574) 	DWORD tempclust;
(0575) 	unsigned char cnt;
(0576) 	unsigned int offset;
(0577) 	unsigned int i=0;
    12C4 2400      CLR	R0
    12C5 2411      CLR	R1
    12C6 8A1E      STD	Y+22,R1
    12C7 8A0D      STD	Y+21,R0
(0578) 	//unsigned char j;//long name buffer offset;
(0579) 	//unsigned char *p;//long name buffer pointer
(0580) 	struct direntry *item = 0;
    12C8 8A1A      STD	Y+18,R1
    12C9 8A09      STD	Y+17,R0
(0581) 	//struct winentry *we =0;
(0582) 	//cluster = FAT_OpenDir(dir);
(0583) 	//if(cluster == 1)return 1;
(0584) 	
(0585) 	BYTE file_type[3] ;
(0586) 	WORD addr =RECORD_ADDR_START;
    12CA 8E18      STD	Y+24,R1
    12CB 8A0F      STD	Y+23,R0
(0587) 	
(0588) 	switch(*type)
    12CC A1EF      LDD	R30,Y+39
    12CD A5F8      LDD	R31,Y+40
    12CE 80A0      LDD	R10,Z+0
    12CF 24BB      CLR	R11
    12D0 01C5      MOVW	R24,R10
    12D1 3081      CPI	R24,1
    12D2 E0E0      LDI	R30,0
    12D3 079E      CPC	R25,R30
    12D4 F029      BEQ	0x12DA
    12D5 3082      CPI	R24,2
    12D6 E0E0      LDI	R30,0
    12D7 079E      CPC	R25,R30
    12D8 F041      BEQ	0x12E1
    12D9 C1AA      RJMP	0x1484
(0589) 	  {
(0590) 	    case  1 : file_type[0] = 'B' ;
    12DA E482      LDI	R24,0x42
    12DB 838A      STD	Y+2,R24
(0591)                   file_type[1] = 'M' ; 
    12DC E48D      LDI	R24,0x4D
    12DD 838B      STD	Y+3,R24
(0592) 				  file_type[2] = 'P' ;
    12DE E580      LDI	R24,0x50
    12DF 838C      STD	Y+4,R24
(0593) 				  
(0594) 				  break ;
    12E0 C1A3      RJMP	0x1484
(0595) 				  
(0596) 		case  2 : file_type[0] = 'B' ;
    12E1 E482      LDI	R24,0x42
    12E2 838A      STD	Y+2,R24
(0597) 		          file_type[1] = 'I' ;
    12E3 E489      LDI	R24,0x49
    12E4 838B      STD	Y+3,R24
(0598) 				  file_type[2] = 'N' ;
    12E5 E48E      LDI	R24,0x4E
    12E6 838C      STD	Y+4,R24
(0599) 				  
(0600) 				  break;
    12E7 C19C      RJMP	0x1484
(0601) 				  
(0602) 	  
(0603) 	  }
(0604) 	
(0605) 	
(0606) 	
(0607) 	while(1)
(0608) 	{
(0609) 		cluster = GetFolderCluster(addr);
    12E8 890F      LDD	R16,Y+23
    12E9 8D18      LDD	R17,Y+24
    12EA DCFA      RCALL	_GetFolderCluster
    12EB 870D      STD	Y+13,R16
    12EC 871E      STD	Y+14,R17
    12ED 872F      STD	Y+15,R18
    12EE 8B38      STD	Y+16,R19
(0610) 		addr += 4;
    12EF 898F      LDD	R24,Y+23
    12F0 8D98      LDD	R25,Y+24
    12F1 9604      ADIW	R24,4
    12F2 8F98      STD	Y+24,R25
    12F3 8B8F      STD	Y+23,R24
(0611) 		if(cluster == 0xffffffff) break;
    12F4 EF4F      LDI	R20,0xFF
    12F5 EF5F      LDI	R21,0xFF
    12F6 EF6F      LDI	R22,0xFF
    12F7 EF7F      LDI	R23,0xFF
    12F8 842D      LDD	R2,Y+13
    12F9 843E      LDD	R3,Y+14
    12FA 844F      LDD	R4,Y+15
    12FB 8858      LDD	R5,Y+16
    12FC 1624      CP	R2,R20
    12FD 0635      CPC	R3,R21
    12FE 0646      CPC	R4,R22
    12FF 0657      CPC	R5,R23
    1300 F409      BNE	0x1302
    1301 C183      RJMP	0x1485
(0612) 		
(0613) 		else
(0614) 		{
(0615) 			//*music_record_addr = addr - 4;	/* record in which record found the right file */
(0616) 			if(cluster==0 && FAT32_Enable==0)// 根目录，FAT16文件系统
    1302 842D      LDD	R2,Y+13
    1303 843E      LDD	R3,Y+14
    1304 844F      LDD	R4,Y+15
    1305 8858      LDD	R5,Y+16
    1306 9488      BCLR	0
    1307 2022      TST	R2
    1308 0432      CPC	R3,R2
    1309 0442      CPC	R4,R2
    130A 0452      CPC	R5,R2
    130B F009      BEQ	0x130D
    130C C092      RJMP	0x139F
    130D 9020 0DF3 LDS	R2,FAT32_Enable
    130F 2022      TST	R2
    1310 F009      BEQ	0x1312
    1311 C08D      RJMP	0x139F
(0617) 			{
(0618) 			
(0619) 			
(0620) 				buffer=malloc(512);//动态分配空间512字节
    1312 E000      LDI	R16,0
    1313 E012      LDI	R17,2
    1314 940E 229A CALL	_malloc
    1316 8B1C      STD	Y+20,R17
    1317 8B0B      STD	Y+19,R16
(0621) 				if(buffer==0)return 1;//if failed
    1318 0108      MOVW	R0,R16
    1319 3000      CPI	R16,0
    131A 0701      CPC	R16,R17
    131B F411      BNE	0x131E
    131C E001      LDI	R16,1
    131D C174      RJMP	0x1492
(0622) 				
(0623) 				
(0624) 				for(cnt=0;cnt<RootDirSectors;cnt++)
    131E 24AA      CLR	R10
    131F C068      RJMP	0x1388
(0625) 				{
(0626) 					if(FAT_ReadSector(FirstDirSector+cnt,buffer)){free(buffer);return 1;}
    1320 880B      LDD	R0,Y+19
    1321 881C      LDD	R1,Y+20
    1322 8219      STD	Y+1,R1
    1323 8208      STD	Y+0,R0
    1324 2C2A      MOV	R2,R10
    1325 2433      CLR	R3
    1326 2444      CLR	R4
    1327 2455      CLR	R5
    1328 9120 0DFE LDS	R18,FirstDirSector+2
    132A 9130 0DFF LDS	R19,FirstDirSector+3
    132C 9100 0DFC LDS	R16,FirstDirSector
    132E 9110 0DFD LDS	R17,FirstDirSector+1
    1330 0D02      ADD	R16,R2
    1331 1D13      ADC	R17,R3
    1332 1D24      ADC	R18,R4
    1333 1D35      ADC	R19,R5
    1334 91E0 0198 LDS	R30,FAT_ReadSector
    1336 91F0 0199 LDS	R31,FAT_ReadSector+1
    1338 940E 21FA CALL	xicallx
    133A 2300      TST	R16
    133B F031      BEQ	0x1342
    133C 890B      LDD	R16,Y+19
    133D 891C      LDD	R17,Y+20
    133E 940E 2399 CALL	_free
    1340 E001      LDI	R16,1
    1341 C150      RJMP	0x1492
(0627) 					for(offset=0;offset<512;offset+=32)
    1342 24EE      CLR	R14
    1343 24FF      CLR	R15
    1344 C03C      RJMP	0x1381
(0628) 					{
(0629) 						item=(struct direntry *)(&buffer[offset]);//pointer convert
    1345 0117      MOVW	R2,R14
    1346 880B      LDD	R0,Y+19
    1347 881C      LDD	R1,Y+20
    1348 0C20      ADD	R2,R0
    1349 1C31      ADC	R3,R1
    134A 8A3A      STD	Y+18,R3
    134B 8A29      STD	Y+17,R2
(0630) 						//find a valid item and display it
(0631) 						if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
    134C 01F1      MOVW	R30,R2
    134D 80C0      LDD	R12,Z+0
    134E 24DD      CLR	R13
    134F 2D8C      MOV	R24,R12
    1350 328E      CPI	R24,0x2E
    1351 F409      BNE	0x1353
    1352 C02B      RJMP	0x137E
    1353 2388      TST	R24
    1354 F409      BNE	0x1356
    1355 C028      RJMP	0x137E
    1356 3E85      CPI	R24,0xE5
    1357 F131      BEQ	0x137E
    1358 8583      LDD	R24,Z+11
    1359 308F      CPI	R24,0xF
    135A F119      BEQ	0x137E
(0632) 						{
(0633) 						
(0634) 							if((item->deExtension[0] == file_type[0])&&(item->deExtension[1] == file_type[1])&&(item->deExtension[2] == file_type[2]))
    135B 802A      LDD	R2,Y+2
    135C 8430      LDD	R3,Z+8
    135D 1432      CP	R3,R2
    135E F4F9      BNE	0x137E
    135F 802B      LDD	R2,Y+3
    1360 8431      LDD	R3,Z+9
    1361 1432      CP	R3,R2
    1362 F4D9      BNE	0x137E
    1363 802C      LDD	R2,Y+4
    1364 8432      LDD	R3,Z+10
    1365 1432      CP	R3,R2
    1366 F4B9      BNE	0x137E
(0635) 							{
(0636) 								
(0637) 								CopyDirentruyItem(MusicInfo,item);
    1367 019F      MOVW	R18,R30
    1368 A10B      LDD	R16,Y+35
    1369 A11C      LDD	R17,Y+36
    136A DB89      RCALL	_CopyDirentruyItem
(0638) 								
(0639) 								i++;
    136B 898D      LDD	R24,Y+21
    136C 899E      LDD	R25,Y+22
    136D 9601      ADIW	R24,1
    136E 8B9E      STD	Y+22,R25
    136F 8B8D      STD	Y+21,R24
(0640) 								if(i==*Count){free(buffer);return 0;}
    1370 A1ED      LDD	R30,Y+37
    1371 A1FE      LDD	R31,Y+38
    1372 8020      LDD	R2,Z+0
    1373 8031      LDD	R3,Z+1
    1374 010C      MOVW	R0,R24
    1375 1582      CP	R24,R2
    1376 0593      CPC	R25,R3
    1377 F431      BNE	0x137E
    1378 890B      LDD	R16,Y+19
    1379 891C      LDD	R17,Y+20
    137A 940E 2399 CALL	_free
    137C 2700      CLR	R16
    137D C114      RJMP	0x1492
    137E 01C7      MOVW	R24,R14
    137F 9680      ADIW	R24,0x20
    1380 017C      MOVW	R14,R24
    1381 01C7      MOVW	R24,R14
    1382 3080      CPI	R24,0
    1383 E0E2      LDI	R30,2
    1384 079E      CPC	R25,R30
    1385 F408      BCC	0x1387
    1386 CFBE      RJMP	0x1345
    1387 94A3      INC	R10
    1388 9040 0DFA LDS	R4,RootDirSectors+2
    138A 9050 0DFB LDS	R5,RootDirSectors+3
    138C 9020 0DF8 LDS	R2,RootDirSectors
    138E 9030 0DF9 LDS	R3,RootDirSectors+1
    1390 2C6A      MOV	R6,R10
    1391 2477      CLR	R7
    1392 2488      CLR	R8
    1393 2499      CLR	R9
    1394 1462      CP	R6,R2
    1395 0473      CPC	R7,R3
    1396 0484      CPC	R8,R4
    1397 0495      CPC	R9,R5
    1398 F408      BCC	0x139A
    1399 CF86      RJMP	0x1320
(0641) 							}							 
(0642) 						}
(0643) 					}
(0644) 				}
(0645) 				free(buffer);//release释放空间
    139A 890B      LDD	R16,Y+19
    139B 891C      LDD	R17,Y+20
    139C 940E 2399 CALL	_free
(0646) 			}
    139E C0E5      RJMP	0x1484
(0647) 			else//other folders
(0648) 			{
(0649) 				tempclust=cluster;
    139F 842D      LDD	R2,Y+13
    13A0 843E      LDD	R3,Y+14
    13A1 844F      LDD	R4,Y+15
    13A2 8858      LDD	R5,Y+16
    13A3 8629      STD	Y+9,R2
    13A4 863A      STD	Y+10,R3
    13A5 864B      STD	Y+11,R4
    13A6 865C      STD	Y+12,R5
    13A7 C0DB      RJMP	0x1483
(0650) 				while(1)
(0651) 				{
(0652) 					sector=FirstDataSector+(DWORD)(tempclust-2)*(DWORD)SectorsPerClust;//calculate the actual sector number
    13A8 E042      LDI	R20,2
    13A9 E050      LDI	R21,0
    13AA E060      LDI	R22,0
    13AB E070      LDI	R23,0
    13AC 8509      LDD	R16,Y+9
    13AD 851A      LDD	R17,Y+10
    13AE 852B      LDD	R18,Y+11
    13AF 853C      LDD	R19,Y+12
    13B0 1B04      SUB	R16,R20
    13B1 0B15      SBC	R17,R21
    13B2 0B26      SBC	R18,R22
    13B3 0B37      SBC	R19,R23
    13B4 9020 0E04 LDS	R2,SectorsPerClust
    13B6 9030 0E05 LDS	R3,SectorsPerClust+1
    13B8 2444      CLR	R4
    13B9 2455      CLR	R5
    13BA 925A      ST	R5,-Y
    13BB 924A      ST	R4,-Y
    13BC 923A      ST	R3,-Y
    13BD 922A      ST	R2,-Y
    13BE 940E 2162 CALL	empy32u
    13C0 9040 0E0C LDS	R4,FirstDataSector+2
    13C2 9050 0E0D LDS	R5,FirstDataSector+3
    13C4 9020 0E0A LDS	R2,FirstDataSector
    13C6 9030 0E0B LDS	R3,FirstDataSector+1
    13C8 0E20      ADD	R2,R16
    13C9 1E31      ADC	R3,R17
    13CA 1E42      ADC	R4,R18
    13CB 1E53      ADC	R5,R19
    13CC 822D      STD	Y+5,R2
    13CD 823E      STD	Y+6,R3
    13CE 824F      STD	Y+7,R4
    13CF 8658      STD	Y+8,R5
(0653) 					buffer=malloc(512);//apply memory
    13D0 E000      LDI	R16,0
    13D1 E012      LDI	R17,2
    13D2 940E 229A CALL	_malloc
    13D4 0168      MOVW	R12,R16
    13D5 8ADC      STD	Y+20,R13
    13D6 8ACB      STD	Y+19,R12
(0654) 					if(buffer==0)return 1;//if failed
    13D7 0106      MOVW	R0,R12
    13D8 3000      CPI	R16,0
    13D9 0701      CPC	R16,R17
    13DA F411      BNE	0x13DD
    13DB E001      LDI	R16,1
    13DC C0B5      RJMP	0x1492
(0655) 					for(cnt=0;cnt<SectorsPerClust;cnt++)
    13DD 24AA      CLR	R10
    13DE C065      RJMP	0x1444
(0656) 					{
(0657) 						if(FAT_ReadSector(sector+cnt,buffer)){free(buffer);return 1;}
    13DF 880B      LDD	R0,Y+19
    13E0 881C      LDD	R1,Y+20
    13E1 8219      STD	Y+1,R1
    13E2 8208      STD	Y+0,R0
    13E3 2C2A      MOV	R2,R10
    13E4 2433      CLR	R3
    13E5 2444      CLR	R4
    13E6 2455      CLR	R5
    13E7 810D      LDD	R16,Y+5
    13E8 811E      LDD	R17,Y+6
    13E9 812F      LDD	R18,Y+7
    13EA 8538      LDD	R19,Y+8
    13EB 0D02      ADD	R16,R2
    13EC 1D13      ADC	R17,R3
    13ED 1D24      ADC	R18,R4
    13EE 1D35      ADC	R19,R5
    13EF 91E0 0198 LDS	R30,FAT_ReadSector
    13F1 91F0 0199 LDS	R31,FAT_ReadSector+1
    13F3 940E 21FA CALL	xicallx
    13F5 2EC0      MOV	R12,R16
    13F6 2300      TST	R16
    13F7 F031      BEQ	0x13FE
    13F8 890B      LDD	R16,Y+19
    13F9 891C      LDD	R17,Y+20
    13FA 940E 2399 CALL	_free
    13FC E001      LDI	R16,1
    13FD C094      RJMP	0x1492
(0658) 						for(offset=0;offset<512;offset+=32)
    13FE 24EE      CLR	R14
    13FF 24FF      CLR	R15
    1400 C03C      RJMP	0x143D
(0659) 						{
(0660) 							item=(struct direntry *)(&buffer[offset]);
    1401 0117      MOVW	R2,R14
    1402 880B      LDD	R0,Y+19
    1403 881C      LDD	R1,Y+20
    1404 0C20      ADD	R2,R0
    1405 1C31      ADC	R3,R1
    1406 8A3A      STD	Y+18,R3
    1407 8A29      STD	Y+17,R2
(0661) 							if((item->deName[0] != '.') && (item->deName[0] != 0x00) && (item->deName[0] != 0xe5) && (item->deAttributes != 0x0f))
    1408 01F1      MOVW	R30,R2
    1409 80C0      LDD	R12,Z+0
    140A 24DD      CLR	R13
    140B 2D8C      MOV	R24,R12
    140C 328E      CPI	R24,0x2E
    140D F409      BNE	0x140F
    140E C02B      RJMP	0x143A
    140F 2388      TST	R24
    1410 F409      BNE	0x1412
    1411 C028      RJMP	0x143A
    1412 3E85      CPI	R24,0xE5
    1413 F131      BEQ	0x143A
    1414 8583      LDD	R24,Z+11
    1415 308F      CPI	R24,0xF
    1416 F119      BEQ	0x143A
(0662) 							{		
(0663)                                		
(0664) 								if((item->deExtension[0] == file_type[0])&&(item->deExtension[1] == file_type[1])&&(item->deExtension[2] == file_type[2]))
    1417 802A      LDD	R2,Y+2
    1418 8430      LDD	R3,Z+8
    1419 1432      CP	R3,R2
    141A F4F9      BNE	0x143A
    141B 802B      LDD	R2,Y+3
    141C 8431      LDD	R3,Z+9
    141D 1432      CP	R3,R2
    141E F4D9      BNE	0x143A
    141F 802C      LDD	R2,Y+4
    1420 8432      LDD	R3,Z+10
    1421 1432      CP	R3,R2
    1422 F4B9      BNE	0x143A
(0665) 								{
(0666) 								    
(0667) 									CopyDirentruyItem(MusicInfo,item);
    1423 019F      MOVW	R18,R30
    1424 A10B      LDD	R16,Y+35
    1425 A11C      LDD	R17,Y+36
    1426 DACD      RCALL	_CopyDirentruyItem
(0668) 									
(0669) 									i++;
    1427 898D      LDD	R24,Y+21
    1428 899E      LDD	R25,Y+22
    1429 9601      ADIW	R24,1
    142A 8B9E      STD	Y+22,R25
    142B 8B8D      STD	Y+21,R24
(0670) 									if(i==*Count){free(buffer);return 0;}
    142C A1ED      LDD	R30,Y+37
    142D A1FE      LDD	R31,Y+38
    142E 8020      LDD	R2,Z+0
    142F 8031      LDD	R3,Z+1
    1430 010C      MOVW	R0,R24
    1431 1582      CP	R24,R2
    1432 0593      CPC	R25,R3
    1433 F431      BNE	0x143A
    1434 890B      LDD	R16,Y+19
    1435 891C      LDD	R17,Y+20
    1436 940E 2399 CALL	_free
    1438 2700      CLR	R16
    1439 C058      RJMP	0x1492
    143A 01C7      MOVW	R24,R14
    143B 9680      ADIW	R24,0x20
    143C 017C      MOVW	R14,R24
    143D 01C7      MOVW	R24,R14
    143E 3080      CPI	R24,0
    143F E0E2      LDI	R30,2
    1440 079E      CPC	R25,R30
    1441 F408      BCC	0x1443
    1442 CFBE      RJMP	0x1401
    1443 94A3      INC	R10
    1444 9020 0E04 LDS	R2,SectorsPerClust
    1446 9030 0E05 LDS	R3,SectorsPerClust+1
    1448 2C4A      MOV	R4,R10
    1449 2455      CLR	R5
    144A 1442      CP	R4,R2
    144B 0453      CPC	R5,R3
    144C F408      BCC	0x144E
    144D CF91      RJMP	0x13DF
(0671) 								}
(0672) 							}
(0673) 						}
(0674) 					}
(0675) 					free(buffer);//release
    144E 890B      LDD	R16,Y+19
    144F 891C      LDD	R17,Y+20
    1450 940E 2399 CALL	_free
(0676) 					tempclust=FAT_NextCluster(tempclust);//next cluster
    1452 8509      LDD	R16,Y+9
    1453 851A      LDD	R17,Y+10
    1454 852B      LDD	R18,Y+11
    1455 853C      LDD	R19,Y+12
    1456 D9CB      RCALL	_FAT_NextCluster
    1457 8709      STD	Y+9,R16
    1458 871A      STD	Y+10,R17
    1459 872B      STD	Y+11,R18
    145A 873C      STD	Y+12,R19
(0677) 					if(tempclust == 0x0fffffff || tempclust == 0x0ffffff8 || (FAT32_Enable == 0 && tempclust == 0xffff))break;
    145B EF4F      LDI	R20,0xFF
    145C EF5F      LDI	R21,0xFF
    145D EF6F      LDI	R22,0xFF
    145E E07F      LDI	R23,0xF
    145F 8429      LDD	R2,Y+9
    1460 843A      LDD	R3,Y+10
    1461 844B      LDD	R4,Y+11
    1462 845C      LDD	R5,Y+12
    1463 1624      CP	R2,R20
    1464 0635      CPC	R3,R21
    1465 0646      CPC	R4,R22
    1466 0657      CPC	R5,R23
    1467 F0D1      BEQ	0x1482
    1468 EF48      LDI	R20,0xF8
    1469 EF5F      LDI	R21,0xFF
    146A EF6F      LDI	R22,0xFF
    146B E07F      LDI	R23,0xF
    146C 1624      CP	R2,R20
    146D 0635      CPC	R3,R21
    146E 0646      CPC	R4,R22
    146F 0657      CPC	R5,R23
    1470 F089      BEQ	0x1482
    1471 9020 0DF3 LDS	R2,FAT32_Enable
    1473 2022      TST	R2
    1474 F471      BNE	0x1483
    1475 EF4F      LDI	R20,0xFF
    1476 EF5F      LDI	R21,0xFF
    1477 E060      LDI	R22,0
    1478 E070      LDI	R23,0
    1479 8429      LDD	R2,Y+9
    147A 843A      LDD	R3,Y+10
    147B 844B      LDD	R4,Y+11
    147C 845C      LDD	R5,Y+12
    147D 1624      CP	R2,R20
    147E 0635      CPC	R3,R21
    147F 0646      CPC	R4,R22
    1480 0657      CPC	R5,R23
    1481 F409      BNE	0x1483
    1482 C001      RJMP	0x1484
    1483 CF24      RJMP	0x13A8
    1484 CE63      RJMP	0x12E8
(0678) 				}
(0679) 			}
(0680) 		}
(0681) 	}
(0682) 	if(*Count==0)*Count=i;
    1485 A1ED      LDD	R30,Y+37
    1486 A1FE      LDD	R31,Y+38
    1487 8020      LDD	R2,Z+0
    1488 8031      LDD	R3,Z+1
    1489 2022      TST	R2
    148A F431      BNE	0x1491
    148B 2033      TST	R3
    148C F421      BNE	0x1491
    148D 880D      LDD	R0,Y+21
    148E 881E      LDD	R1,Y+22
    148F 8211      STD	Z+1,R1
    1490 8200      STD	Z+0,R0
(0683) 	/*
(0684) 	GUI_sprintf_chartohex(130,300,*type,0xffff,0x0000) ;
(0685) 	GUI_sprintf_chartohex(160,300,i,0xffff,0x0000) ;
(0686) 	GUI_sprintf_chartohex(190,300,*Count,0xffff,0x0000) ;
(0687) 	while(1) ;*/
(0688) 	return 0;	
    1491 2700      CLR	R16
    1492 9669      ADIW	R28,0x19
    1493 940E 21A2 CALL	pop_xgsetF0FC
    1495 9624      ADIW	R28,4
    1496 9508      RET
FILE: E:\DMAVR-~3\ReadBmp\mmc.c
(0001) //SD卡驱动函数，采取网络上开源的第三方库文件
(0002) //欣世纪电子略作修改，由于部分SD卡并非标准SD卡命令，因此可能存在兼容性问题，建议使用金士顿SD卡
(0003) //SD卡片选信号SD_CS在mmcconf.h文件中修改，DMAVR-M128为PG3脚控制SD_CS
(0004) //由于DMAVR-128板载SPI接口同时连接在TLC5615芯片上，因此，初始化时要先将SS管脚拉高，禁止TLC5615芯片
(0005) 
(0006) //***********************************************************************
(0007) //			包含文件
(0008) //***********************************************************************
(0009) #include "libtypes.h"		// include our global settings
(0010) #include "DM_spi.h"			// include spi bus support
(0011) #include "mmc.h"
(0012) #include "mmcconf.h"	   // include project-specific hardware configuration
(0013) #include <stdio.h>
(0014) //#include <delay.h>
(0015) #include <iom128v.h>
(0016) 
(0017) #define   set(x)                (1<<(x))
(0018) #define   sbi(temp,x)    		temp|=(1<<(x))     //置位
(0019) #define   clr(x)                (~(1<<(x)))
(0020) #define   cbi(temp,x)     		temp&=~(1<<(x))    //清零
(0021) //***********************************************************************
(0022) //			IO口初始化
(0023) //***********************************************************************
(0024) //void McuInit()
(0025) //{
(0026) 	//PORTB=0XFF;
(0027) 	//DDRB=0XFF;
(0028) //}
(0029) 
(0030) //***********************************************************************
(0031) //			SD卡初始化
(0032) //***********************************************************************
(0033) void mmcInit(void)
(0034) {
(0035) 	// initialize SPI interface
(0036) 	spiInit();
_mmcInit:
    1497 940E 16B9 CALL	_spiInit
(0037) 	// release chip select
(0038) 	sbi(MMC_CS_DDR, MMC_CS_PIN);
    1499 9180 0064 LDS	R24,0x0064
    149B 6088      ORI	R24,0x8
    149C 9380 0064 STS	0x0064,R24
(0039) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    149E 9180 0065 LDS	R24,0x0065
    14A0 6088      ORI	R24,0x8
    14A1 9380 0065 STS	0x0065,R24
    14A3 9508      RET
_mmcReset:
  retry                --> R10
  r1                   --> R20
  i                    --> R22
    14A4 940E 21CC CALL	push_xgsetF00C
    14A6 9722      SBIW	R28,2
(0040) }
(0041) 
(0042) //***********************************************************************
(0043) //			识别SD卡是否存在
(0044) //***********************************************************************
(0045) 
(0046) u08 mmcReset(void)
(0047) {
(0048) 	u08 i;
(0049) 	u08 retry;
(0050) 	u08 r1=0;
    14A7 2744      CLR	R20
(0051) 
(0052) 	retry = 0;
    14A8 24AA      CLR	R10
(0053) 	do
(0054) 	{
(0055) 		// send dummy bytes with CS high before accessing
(0056) 		for(i=0;i<10;i++) spiTransferByte(0xFF);
    14A9 2766      CLR	R22
    14AA C004      RJMP	0x14AF
    14AB EF0F      LDI	R16,0xFF
    14AC 940E 16CD CALL	_spiTransferByte
    14AE 9563      INC	R22
    14AF 306A      CPI	R22,0xA
    14B0 F3D0      BCS	0x14AB
(0057) 		// resetting card, go to SPI mode
(0058) 		r1 = mmcSendCommand(MMC_GO_IDLE_STATE, 0);
    14B1 E080      LDI	R24,0
    14B2 E090      LDI	R25,0
    14B3 E0A0      LDI	R26,0
    14B4 E0B0      LDI	R27,0
    14B5 83A8      STD	Y+0,R26
    14B6 83B9      STD	Y+1,R27
    14B7 019C      MOVW	R18,R24
    14B8 2700      CLR	R16
    14B9 D034      RCALL	_mmcSendCommand
    14BA 2F40      MOV	R20,R16
(0059) 		#ifdef MMC_DEBUG
(0060) 		//rprintf("MMC_GO_IDLE_STATE: R1=0x%x\r\n", r1);
(0061) 		#endif
(0062) 		// do retry counter
(0063) 		retry++;
    14BB 94A3      INC	R10
(0064) 		if(retry>10) return -1;
    14BC E08A      LDI	R24,0xA
    14BD 158A      CP	R24,R10
    14BE F410      BCC	0x14C1
    14BF EF0F      LDI	R16,0xFF
    14C0 C02A      RJMP	0x14EB
(0065) 	} while(r1 != 0x01);
    14C1 3041      CPI	R20,1
    14C2 F731      BNE	0x14A9
(0066) 
(0067) 	// TODO: check card parameters for voltage compliance
(0068) 	// before issuing initialize command
(0069) 
(0070) 	retry = 0;
    14C3 24AA      CLR	R10
(0071) 	do
(0072) 	{
(0073) 		// initializing card for operation
(0074) 		r1 = mmcSendCommand(MMC_SEND_OP_COND, 0);
    14C4 E080      LDI	R24,0
    14C5 E090      LDI	R25,0
    14C6 E0A0      LDI	R26,0
    14C7 E0B0      LDI	R27,0
    14C8 83A8      STD	Y+0,R26
    14C9 83B9      STD	Y+1,R27
    14CA 019C      MOVW	R18,R24
    14CB E001      LDI	R16,1
    14CC D021      RCALL	_mmcSendCommand
    14CD 2F40      MOV	R20,R16
(0075) 		#ifdef MMC_DEBUG
(0076) 		//rprintf("MMC_SEND_OP_COND: R1=0x%x\r\n", r1);
(0077) 		#endif
(0078) 		// do retry counter
(0079) 		retry++;
    14CE 94A3      INC	R10
(0080) 		if(retry>100) return -1;
    14CF E684      LDI	R24,0x64
    14D0 158A      CP	R24,R10
    14D1 F410      BCC	0x14D4
    14D2 EF0F      LDI	R16,0xFF
    14D3 C017      RJMP	0x14EB
(0081) 	} while(r1);
    14D4 2344      TST	R20
    14D5 F771      BNE	0x14C4
(0082) 		
(0083) 	// turn off CRC checking to simplify communication
(0084) 	r1 = mmcSendCommand(MMC_CRC_ON_OFF, 0);
    14D6 E080      LDI	R24,0
    14D7 E090      LDI	R25,0
    14D8 E0A0      LDI	R26,0
    14D9 E0B0      LDI	R27,0
    14DA 83A8      STD	Y+0,R26
    14DB 83B9      STD	Y+1,R27
    14DC 019C      MOVW	R18,R24
    14DD E30B      LDI	R16,0x3B
    14DE D00F      RCALL	_mmcSendCommand
(0085) 	#ifdef MMC_DEBUG
(0086) 	//rprintf("MMC_CRC_ON_OFF: R1=0x%x\r\n", r1);
(0087) 	#endif
(0088) 
(0089) 	// set block length to 512 bytes
(0090) 	r1 = mmcSendCommand(MMC_SET_BLOCKLEN, 512);
    14DF E080      LDI	R24,0
    14E0 E092      LDI	R25,2
    14E1 E0A0      LDI	R26,0
    14E2 E0B0      LDI	R27,0
    14E3 83A8      STD	Y+0,R26
    14E4 83B9      STD	Y+1,R27
    14E5 019C      MOVW	R18,R24
    14E6 E100      LDI	R16,0x10
    14E7 D006      RCALL	_mmcSendCommand
    14E8 2EA0      MOV	R10,R16
    14E9 2D4A      MOV	R20,R10
(0091) 	#ifdef MMC_DEBUG
(0092) 	//rprintf("MMC_SET_BLOCKLEN: R1=0x%x\r\n", r1);
(0093) 	#endif
(0094) 
(0095) 	// return success
(0096) 	return 0;
    14EA 2700      CLR	R16
    14EB 9622      ADIW	R28,2
    14EC 940C 21D3 JMP	pop_xgsetF00C
_mmcSendCommand:
  r1                   --> R10
  arg                  --> Y,+3
  cmd                  --> R10
    14EE 933A      ST	R19,-Y
    14EF 932A      ST	R18,-Y
    14F0 92AA      ST	R10,-Y
    14F1 2EA0      MOV	R10,R16
    14F2 9722      SBIW	R28,2
(0097) }
(0098) 
(0099) //***********************************************************************
(0100) //			发送SD卡命令函数
(0101) //***********************************************************************
(0102) 
(0103) u08 mmcSendCommand(u08 cmd, u32 arg)
(0104) {
(0105) 	u08 r1;
(0106) 
(0107) 	// assert chip select
(0108) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    14F3 9180 0065 LDS	R24,0x0065
    14F5 7F87      ANDI	R24,0xF7
    14F6 9380 0065 STS	0x0065,R24
(0109) 	// issue the command
(0110) 	r1 = mmcCommand(cmd, arg);
    14F8 802B      LDD	R2,Y+3
    14F9 803C      LDD	R3,Y+4
    14FA 804D      LDD	R4,Y+5
    14FB 805E      LDD	R5,Y+6
    14FC 8248      STD	Y+0,R4
    14FD 8259      STD	Y+1,R5
    14FE 0191      MOVW	R18,R2
    14FF 2D0A      MOV	R16,R10
    1500 D0AA      RCALL	_mmcCommand
    1501 2EA0      MOV	R10,R16
(0111) 	// release chip select
(0112) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    1502 9180 0065 LDS	R24,0x0065
    1504 6088      ORI	R24,0x8
    1505 9380 0065 STS	0x0065,R24
(0113) 
(0114) 	return r1;
    1507 9622      ADIW	R28,2
    1508 90A9      LD	R10,Y+
    1509 9622      ADIW	R28,2
    150A 9508      RET
_mmcRead:
  r1                   --> R12
  i                    --> R20
  buffer               --> R10
  sector               --> Y,+8
    150B 940E 20C0 CALL	push_arg4
    150D 940E 21DA CALL	push_xgset303C
    150F 9722      SBIW	R28,2
    1510 84AC      LDD	R10,Y+12
    1511 84BD      LDD	R11,Y+13
(0115) }
(0116) 
(0117) //***********************************************************************
(0118) //			读SD卡数据函数，扇区读，一次512个字节
(0119) //***********************************************************************
(0120) u08 mmcRead(u32 sector, u08* buffer)
(0121) {
(0122) 	u08 r1;
(0123) 	u16 i;
(0124) 
(0125) 	// assert chip select
(0126) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    1512 9180 0065 LDS	R24,0x0065
    1514 7F87      ANDI	R24,0xF7
    1515 9380 0065 STS	0x0065,R24
(0127) 	for(i=0;i<10;i++) spiTransferByte(0xFF);
    1517 2744      CLR	R20
    1518 2755      CLR	R21
    1519 C005      RJMP	0x151F
    151A EF0F      LDI	R16,0xFF
    151B 940E 16CD CALL	_spiTransferByte
    151D 5F4F      SUBI	R20,0xFF
    151E 4F5F      SBCI	R21,0xFF
    151F 304A      CPI	R20,0xA
    1520 E0A0      LDI	R26,0
    1521 075A      CPC	R21,R26
    1522 F3B8      BCS	0x151A
(0128) 	// issue command
(0129) 	r1 = mmcCommand(MMC_READ_SINGLE_BLOCK, sector<<9);
    1523 E089      LDI	R24,0x9
    1524 E090      LDI	R25,0
    1525 8508      LDD	R16,Y+8
    1526 8519      LDD	R17,Y+9
    1527 852A      LDD	R18,Y+10
    1528 853B      LDD	R19,Y+11
    1529 938A      ST	R24,-Y
    152A 940E 2238 CALL	lsl32
    152C 8328      STD	Y+0,R18
    152D 8339      STD	Y+1,R19
    152E 0198      MOVW	R18,R16
    152F E101      LDI	R16,0x11
    1530 D07A      RCALL	_mmcCommand
    1531 2EC0      MOV	R12,R16
(0130) 	#ifdef MMC_DEBUG
(0131) 	//rprintf("MMC Read Block R1=0x%x\r\n", r1);
(0132) 	#endif
(0133) 	// check for valid response
(0134) 	if(r1 != 0x00)
    1532 2300      TST	R16
    1533 F009      BEQ	0x1535
(0135) 		return r1;
    1534 C021      RJMP	0x1556
(0136) 	// wait for block start
(0137) 	while(spiTransferByte(0xFF) != MMC_STARTBLOCK_READ);
    1535 EF0F      LDI	R16,0xFF
    1536 940E 16CD CALL	_spiTransferByte
    1538 3F0E      CPI	R16,0xFE
    1539 F7D9      BNE	0x1535
(0138) 	// read in data
(0139) 	for(i=0; i<0x200; i++)
    153A 2744      CLR	R20
    153B 2755      CLR	R21
    153C C009      RJMP	0x1546
(0140) 	{
(0141) 		*buffer++ =spiTransferByte(0xFF);
    153D EF0F      LDI	R16,0xFF
    153E 940E 16CD CALL	_spiTransferByte
    1540 2EC0      MOV	R12,R16
    1541 01F5      MOVW	R30,R10
    1542 92C1      ST	R12,Z+
    1543 015F      MOVW	R10,R30
    1544 5F4F      SUBI	R20,0xFF
    1545 4F5F      SBCI	R21,0xFF
    1546 3040      CPI	R20,0
    1547 E0E2      LDI	R30,2
    1548 075E      CPC	R21,R30
    1549 F398      BCS	0x153D
(0142) 	}
(0143) 	// read 16-bit CRC
(0144) 	spiTransferByte(0xFF);
    154A EF0F      LDI	R16,0xFF
    154B 940E 16CD CALL	_spiTransferByte
(0145) 	spiTransferByte(0xFF);
    154D EF0F      LDI	R16,0xFF
    154E 940E 16CD CALL	_spiTransferByte
(0146) 	// release chip select
(0147) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    1550 9180 0065 LDS	R24,0x0065
    1552 6088      ORI	R24,0x8
    1553 9380 0065 STS	0x0065,R24
(0148) 	// return success
(0149) 	return 0;
    1555 2700      CLR	R16
    1556 9622      ADIW	R28,2
    1557 940E 21E1 CALL	pop_xgset303C
    1559 9624      ADIW	R28,4
    155A 9508      RET
_mmcWrite:
  r1                   --> R20
  i                    --> R22
  buffer               --> Y,+12
  sector               --> Y,+8
    155B 940E 20C0 CALL	push_arg4
    155D 940E 21CC CALL	push_xgsetF00C
    155F 9722      SBIW	R28,2
(0150) }
(0151) 
(0152) //***********************************************************************
(0153) //			向SD卡中指定地址写数据，扇区写，一次512个字节
(0154) //***********************************************************************
(0155) u08 mmcWrite(u32 sector, u08* buffer)
(0156) {
(0157) 	u08 r1;
(0158) 	u16 i;
(0159) 
(0160) 	// assert chip select
(0161) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    1560 9180 0065 LDS	R24,0x0065
    1562 7F87      ANDI	R24,0xF7
    1563 9380 0065 STS	0x0065,R24
(0162) 	// issue command
(0163) 	r1 = mmcCommand(MMC_WRITE_BLOCK, sector<<9);
    1565 E089      LDI	R24,0x9
    1566 E090      LDI	R25,0
    1567 8508      LDD	R16,Y+8
    1568 8519      LDD	R17,Y+9
    1569 852A      LDD	R18,Y+10
    156A 853B      LDD	R19,Y+11
    156B 938A      ST	R24,-Y
    156C 940E 2238 CALL	lsl32
    156E 8328      STD	Y+0,R18
    156F 8339      STD	Y+1,R19
    1570 0198      MOVW	R18,R16
    1571 E108      LDI	R16,0x18
    1572 D038      RCALL	_mmcCommand
    1573 2F40      MOV	R20,R16
(0164) 	#ifdef MMC_DEBUG
(0165) 	//rprintf("MMC Write Block R1=0x%x\r\n", r1);
(0166) 	#endif
(0167) 	// check for valid response
(0168) 	if(r1 != 0x00)
    1574 2300      TST	R16
    1575 F009      BEQ	0x1577
(0169) 		return r1;
    1576 C02F      RJMP	0x15A6
(0170) 	// send dummy
(0171) 	spiTransferByte(0xFF);
    1577 EF0F      LDI	R16,0xFF
    1578 940E 16CD CALL	_spiTransferByte
(0172) 	// send data start token
(0173) 	spiTransferByte(MMC_STARTBLOCK_WRITE);
    157A EF0E      LDI	R16,0xFE
    157B 940E 16CD CALL	_spiTransferByte
(0174) 	// write data
(0175) 	for(i=0; i<0x200; i++)
    157D 2766      CLR	R22
    157E 2777      CLR	R23
    157F C007      RJMP	0x1587
(0176) 	{
(0177) 		spiTransferByte(*buffer);   //为了节省空间，只写入buffer[0]的数据，若写入512个不同数据，改为*buffer++
    1580 85EC      LDD	R30,Y+12
    1581 85FD      LDD	R31,Y+13
    1582 8100      LDD	R16,Z+0
    1583 940E 16CD CALL	_spiTransferByte
    1585 5F6F      SUBI	R22,0xFF
    1586 4F7F      SBCI	R23,0xFF
    1587 3060      CPI	R22,0
    1588 E0E2      LDI	R30,2
    1589 077E      CPC	R23,R30
    158A F3A8      BCS	0x1580
(0178) 	}
(0179) 	// write 16-bit CRC (dummy values)
(0180) 	spiTransferByte(0xFF);
    158B EF0F      LDI	R16,0xFF
    158C 940E 16CD CALL	_spiTransferByte
(0181) 	spiTransferByte(0xFF);
    158E EF0F      LDI	R16,0xFF
    158F 940E 16CD CALL	_spiTransferByte
(0182) 	// read data response token
(0183) 	r1 = spiTransferByte(0xFF);
    1591 EF0F      LDI	R16,0xFF
    1592 940E 16CD CALL	_spiTransferByte
    1594 2F40      MOV	R20,R16
(0184) 	if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
    1595 2F84      MOV	R24,R20
    1596 718F      ANDI	R24,0x1F
    1597 3085      CPI	R24,5
    1598 F009      BEQ	0x159A
(0185) 		return r1;
    1599 C00C      RJMP	0x15A6
(0186) 	#ifdef MMC_DEBUG
(0187) 	//rprintf("Data Response Token=0x%x\r\n", r1);
(0188) 	#endif
(0189) 	// wait until card not busy
(0190) 	while(!spiTransferByte(0xFF));
    159A EF0F      LDI	R16,0xFF
    159B 940E 16CD CALL	_spiTransferByte
    159D 2EA0      MOV	R10,R16
    159E 2300      TST	R16
    159F F3D1      BEQ	0x159A
(0191) 	// release chip select
(0192) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    15A0 9180 0065 LDS	R24,0x0065
    15A2 6088      ORI	R24,0x8
    15A3 9380 0065 STS	0x0065,R24
(0193) 	// return success
(0194) 	return 0;
    15A5 2700      CLR	R16
    15A6 9622      ADIW	R28,2
    15A7 940E 21D3 CALL	pop_xgsetF00C
    15A9 9624      ADIW	R28,4
    15AA 9508      RET
_mmcCommand:
  retry                --> R20
  r1                   --> R10
  arg                  --> Y,+6
  cmd                  --> R22
    15AB 933A      ST	R19,-Y
    15AC 932A      ST	R18,-Y
    15AD 940E 21CC CALL	push_xgsetF00C
    15AF 2F60      MOV	R22,R16
(0195) }
(0196) 
(0197) //***********************************************************************
(0198) //			单命令传送函数
(0199) //***********************************************************************
(0200) u08 mmcCommand(u08 cmd, u32 arg)
(0201) {
(0202) 	u08 r1;
(0203) 	u08 retry=0;
    15B0 2744      CLR	R20
(0204) 	// send command
(0205) 	spiTransferByte(cmd | 0x40);
    15B1 2F06      MOV	R16,R22
    15B2 6400      ORI	R16,0x40
    15B3 940E 16CD CALL	_spiTransferByte
(0206) 	spiTransferByte(arg>>24);
    15B5 E188      LDI	R24,0x18
    15B6 E090      LDI	R25,0
    15B7 810E      LDD	R16,Y+6
    15B8 811F      LDD	R17,Y+7
    15B9 8528      LDD	R18,Y+8
    15BA 8539      LDD	R19,Y+9
    15BB 938A      ST	R24,-Y
    15BC 940E 2244 CALL	lsr32
    15BE 940E 16CD CALL	_spiTransferByte
(0207) 	spiTransferByte(arg>>16);
    15C0 802E      LDD	R2,Y+6
    15C1 803F      LDD	R3,Y+7
    15C2 8448      LDD	R4,Y+8
    15C3 8459      LDD	R5,Y+9
    15C4 0112      MOVW	R2,R4
    15C5 2444      CLR	R4
    15C6 2455      CLR	R5
    15C7 2D02      MOV	R16,R2
    15C8 940E 16CD CALL	_spiTransferByte
(0208) 	spiTransferByte(arg>>8);
    15CA E088      LDI	R24,0x8
    15CB E090      LDI	R25,0
    15CC 810E      LDD	R16,Y+6
    15CD 811F      LDD	R17,Y+7
    15CE 8528      LDD	R18,Y+8
    15CF 8539      LDD	R19,Y+9
    15D0 938A      ST	R24,-Y
    15D1 940E 2244 CALL	lsr32
    15D3 940E 16CD CALL	_spiTransferByte
(0209) 	spiTransferByte(arg);
    15D5 810E      LDD	R16,Y+6
    15D6 940E 16CD CALL	_spiTransferByte
(0210) 	spiTransferByte(0x95);	// crc valid only for MMC_GO_IDLE_STATE
    15D8 E905      LDI	R16,0x95
    15D9 940E 16CD CALL	_spiTransferByte
    15DB C007      RJMP	0x15E3
(0211) 	// end command
(0212) 	// wait for response
(0213) 	// if more than 8 retries, card has timed-out
(0214) 	// return the received 0xFF
(0215) 	while((r1 = spiTransferByte(0xFF)) == 0xFF)
(0216) 		if(retry++ > 8) break;
    15DC 2E24      MOV	R2,R20
    15DD 2433      CLR	R3
    15DE 5F4F      SUBI	R20,0xFF
    15DF E088      LDI	R24,0x8
    15E0 1582      CP	R24,R2
    15E1 F408      BCC	0x15E3
    15E2 C006      RJMP	0x15E9
    15E3 EF0F      LDI	R16,0xFF
    15E4 940E 16CD CALL	_spiTransferByte
    15E6 2EA0      MOV	R10,R16
    15E7 3F0F      CPI	R16,0xFF
    15E8 F399      BEQ	0x15DC
(0217) 	// return response
(0218) 	return r1;
    15E9 2D0A      MOV	R16,R10
    15EA 940E 21D3 CALL	pop_xgsetF00C
    15EC 9622      ADIW	R28,2
    15ED 9508      RET
_mmcCapacity:
  Capacity             --> Y,+18
  retry                --> R10
  buffer               --> Y,+2
  temp                 --> R10
  r1                   --> R14
  i                    --> R12
    15EE 940E 21AD CALL	push_xgsetF0FC
    15F0 9766      SBIW	R28,0x16
(0219) }
(0220) 
(0221) //***********************************************************************
(0222) //			SD卡容量读取函数，返回容量数
(0223) //***********************************************************************
(0224) 
(0225) u32 mmcCapacity()
(0226) {
(0227) 	u08 r1;
(0228) 	u16 i;
(0229) 	u16 temp;
(0230) 	u08 buffer[16];
(0231) 	u32 Capacity;
(0232) 	u16 retry =0;
    15F1 24AA      CLR	R10
    15F2 24BB      CLR	R11
(0233) 
(0234) 	r1 = mmcSendCommand(9, 0);						//写命令	
    15F3 E040      LDI	R20,0
    15F4 E050      LDI	R21,0
    15F5 E060      LDI	R22,0
    15F6 E070      LDI	R23,0
    15F7 8368      STD	Y+0,R22
    15F8 8379      STD	Y+1,R23
    15F9 019A      MOVW	R18,R20
    15FA E009      LDI	R16,0x9
    15FB DEF2      RCALL	_mmcSendCommand
    15FC 2EE0      MOV	R14,R16
(0235) 	if(r1 != 0x00)
    15FD 2300      TST	R16
    15FE F031      BEQ	0x1605
(0236) 		return r1;
    15FF 0187      MOVW	R16,R14
    1600 0198      MOVW	R18,R16
    1601 2711      CLR	R17
    1602 2722      CLR	R18
    1603 2733      CLR	R19
    1604 C0B1      RJMP	0x16B6
(0237) 
(0238) 	cbi(MMC_CS_PORT,MMC_CS_PIN);
    1605 9180 0065 LDS	R24,0x0065
    1607 7F87      ANDI	R24,0xF7
    1608 9380 0065 STS	0x0065,R24
    160A C013      RJMP	0x161E
(0239) 	while(spiTransferByte(0xff) != 0xfe)if(retry++ > 0xfffe){sbi(MMC_CS_PORT,MMC_CS_PIN);return 1;}
    160B 0115      MOVW	R2,R10
    160C 01C1      MOVW	R24,R2
    160D 9601      ADIW	R24,1
    160E 015C      MOVW	R10,R24
    160F EF8E      LDI	R24,0xFE
    1610 EF9F      LDI	R25,0xFF
    1611 1582      CP	R24,R2
    1612 0593      CPC	R25,R3
    1613 F450      BCC	0x161E
    1614 9180 0065 LDS	R24,0x0065
    1616 6088      ORI	R24,0x8
    1617 9380 0065 STS	0x0065,R24
    1619 E001      LDI	R16,1
    161A E010      LDI	R17,0
    161B E020      LDI	R18,0
    161C E030      LDI	R19,0
    161D C098      RJMP	0x16B6
    161E EF0F      LDI	R16,0xFF
    161F 940E 16CD CALL	_spiTransferByte
    1621 2EC0      MOV	R12,R16
    1622 3F0E      CPI	R16,0xFE
    1623 F739      BNE	0x160B
(0240) 
(0241) 	
(0242) 	for(i=0;i<16;i++)
    1624 24CC      CLR	R12
    1625 24DD      CLR	R13
    1626 C00D      RJMP	0x1634
(0243) 	{
(0244) 		buffer[i]=spiTransferByte(0xff);
    1627 EF0F      LDI	R16,0xFF
    1628 940E 16CD CALL	_spiTransferByte
    162A 2EA0      MOV	R10,R16
    162B 01CE      MOVW	R24,R28
    162C 9602      ADIW	R24,2
    162D 01F6      MOVW	R30,R12
    162E 0FE8      ADD	R30,R24
    162F 1FF9      ADC	R31,R25
    1630 82A0      STD	Z+0,R10
    1631 01C6      MOVW	R24,R12
    1632 9601      ADIW	R24,1
    1633 016C      MOVW	R12,R24
    1634 01C6      MOVW	R24,R12
    1635 3180      CPI	R24,0x10
    1636 E0E0      LDI	R30,0
    1637 079E      CPC	R25,R30
    1638 F370      BCS	0x1627
(0245) 	}	
(0246) 
(0247) 	spiTransferByte(0xff);
    1639 EF0F      LDI	R16,0xFF
    163A 940E 16CD CALL	_spiTransferByte
(0248) 	spiTransferByte(0xff);
    163C EF0F      LDI	R16,0xFF
    163D 940E 16CD CALL	_spiTransferByte
(0249) 	
(0250) 	spiTransferByte(0xff);
    163F EF0F      LDI	R16,0xFF
    1640 940E 16CD CALL	_spiTransferByte
(0251) 	
(0252) 	sbi(MMC_CS_PORT,MMC_CS_PIN);
    1642 9180 0065 LDS	R24,0x0065
    1644 6088      ORI	R24,0x8
    1645 9380 0065 STS	0x0065,R24
(0253) 
(0254) 	spiTransferByte(0xff);// extra 8 CLK
    1647 EF0F      LDI	R16,0xFF
    1648 940E 16CD CALL	_spiTransferByte
(0255) 
(0256) /*********************************/
(0257) //	C_SIZE
(0258) 	i = buffer[6]&0x03;
    164A 8588      LDD	R24,Y+8
    164B 2799      CLR	R25
    164C 7083      ANDI	R24,3
    164D 7090      ANDI	R25,0
    164E 016C      MOVW	R12,R24
(0259) 	i<<=8;
    164F 2CDC      MOV	R13,R12
    1650 24CC      CLR	R12
(0260) 	i += buffer[7];
    1651 8429      LDD	R2,Y+9
    1652 2433      CLR	R3
    1653 0CC2      ADD	R12,R2
    1654 1CD3      ADC	R13,R3
(0261) 	i<<=2;
    1655 0CCC      LSL	R12
    1656 1CDD      ROL	R13
    1657 0CCC      LSL	R12
    1658 1CDD      ROL	R13
(0262) 	i += ((buffer[8]&0xc0)>>6);
    1659 E026      LDI	R18,6
    165A E030      LDI	R19,0
    165B 850A      LDD	R16,Y+10
    165C 2711      CLR	R17
    165D 7C00      ANDI	R16,0xC0
    165E 7010      ANDI	R17,0
    165F 940E 20C5 CALL	asr16
    1661 0EC0      ADD	R12,R16
    1662 1ED1      ADC	R13,R17
(0263) 
(0264) /**********************************/
(0265) //  C_SIZE_MULT
(0266) 
(0267) 	r1 = buffer[9]&0x03;
    1663 858B      LDD	R24,Y+11
    1664 7083      ANDI	R24,3
    1665 2EE8      MOV	R14,R24
(0268) 	r1<<=1;
    1666 0CEE      LSL	R14
(0269) 	r1 += ((buffer[10]&0x80)>>7);
    1667 858C      LDD	R24,Y+12
    1668 7880      ANDI	R24,0x80
    1669 9586      LSR	R24
    166A 9586      LSR	R24
    166B 9586      LSR	R24
    166C 9586      LSR	R24
    166D 9586      LSR	R24
    166E 9586      LSR	R24
    166F 9586      LSR	R24
    1670 0EE8      ADD	R14,R24
(0270) 
(0271) 
(0272) /**********************************/
(0273) // BLOCKNR
(0274) 
(0275) 	r1+=2;
    1671 2D8E      MOV	R24,R14
    1672 5F8E      SUBI	R24,0xFE
    1673 2EE8      MOV	R14,R24
(0276) 
(0277) 	temp = 1;
    1674 E081      LDI	R24,1
    1675 E090      LDI	R25,0
    1676 015C      MOVW	R10,R24
    1677 C003      RJMP	0x167B
(0278) 	while(r1)
(0279) 	{
(0280) 		temp*=2;
    1678 0CAA      LSL	R10
    1679 1CBB      ROL	R11
(0281) 		r1--;
    167A 94EA      DEC	R14
    167B 20EE      TST	R14
    167C F7D9      BNE	0x1678
(0282) 	}
(0283) 	
(0284) 	Capacity = ((u32)(i+1))*((u32)temp);
    167D 0115      MOVW	R2,R10
    167E 2444      CLR	R4
    167F 2455      CLR	R5
    1680 0186      MOVW	R16,R12
    1681 5F0F      SUBI	R16,0xFF
    1682 4F1F      SBCI	R17,0xFF
    1683 2722      CLR	R18
    1684 2733      CLR	R19
    1685 925A      ST	R5,-Y
    1686 924A      ST	R4,-Y
    1687 923A      ST	R3,-Y
    1688 922A      ST	R2,-Y
    1689 940E 2162 CALL	empy32u
    168B 8B0A      STD	Y+18,R16
    168C 8B1B      STD	Y+19,R17
    168D 8B2C      STD	Y+20,R18
    168E 8B3D      STD	Y+21,R19
(0285) 
(0286) 
(0287) // READ_BL_LEN
(0288) 
(0289) 	i = buffer[5]&0x0f;
    168F 818F      LDD	R24,Y+7
    1690 2799      CLR	R25
    1691 708F      ANDI	R24,0xF
    1692 7090      ANDI	R25,0
    1693 016C      MOVW	R12,R24
(0290) 
(0291) 
(0292) //BLOCK_LEN
(0293) 
(0294) 	temp = 1;
    1694 E081      LDI	R24,1
    1695 E090      LDI	R25,0
    1696 015C      MOVW	R10,R24
    1697 C005      RJMP	0x169D
(0295) 	while(i)
(0296) 	{
(0297) 		temp*=2;
    1698 0CAA      LSL	R10
    1699 1CBB      ROL	R11
(0298) 		i--;
    169A 01C6      MOVW	R24,R12
    169B 9701      SBIW	R24,1
    169C 016C      MOVW	R12,R24
    169D 20CC      TST	R12
    169E F7C9      BNE	0x1698
    169F 20DD      TST	R13
    16A0 F7B9      BNE	0x1698
(0299) 	}
(0300) 
(0301) 
(0302) //The final result
(0303) 	
(0304) 	Capacity *= (u32)temp;	 
    16A1 0115      MOVW	R2,R10
    16A2 2444      CLR	R4
    16A3 2455      CLR	R5
    16A4 890A      LDD	R16,Y+18
    16A5 891B      LDD	R17,Y+19
    16A6 892C      LDD	R18,Y+20
    16A7 893D      LDD	R19,Y+21
    16A8 925A      ST	R5,-Y
    16A9 924A      ST	R4,-Y
    16AA 923A      ST	R3,-Y
    16AB 922A      ST	R2,-Y
    16AC 940E 2162 CALL	empy32u
    16AE 8B0A      STD	Y+18,R16
    16AF 8B1B      STD	Y+19,R17
    16B0 8B2C      STD	Y+20,R18
    16B1 8B3D      STD	Y+21,R19
(0305) 	return Capacity;		
    16B2 890A      LDD	R16,Y+18
    16B3 891B      LDD	R17,Y+19
    16B4 892C      LDD	R18,Y+20
    16B5 893D      LDD	R19,Y+21
    16B6 9666      ADIW	R28,0x16
    16B7 940C 21A2 JMP	pop_xgsetF0FC
FILE: E:\DMAVR-~3\ReadBmp\spi.c
(0001) //SPI接口驱动程序，采用开源的第三方库函数
(0002) //欣世纪电子略作修改
(0003) 
(0004) //#include <avr/io.h>
(0005) //#include <avr/interrupt.h>
(0006) 
(0007) #include "DM_spi.h"
(0008) #include <string.h>
(0009) #include <stdio.h>
(0010) //#include <delay.h>
(0011) #include <iom128v.h>
(0012) 
(0013) #define   set(x)                (1<<(x))
(0014) #define   sbi(temp,x)    		temp|=(1<<(x))
(0015) #define   clr(x)                (~(1<<(x)))
(0016) #define   cbi(temp,x)     		temp&=~(1<<(x))
(0017) 
(0018) #define	outb(addr, data)	addr = (data)
(0019) #define	inb(addr)			(addr)
(0020) #define	outw(addr, data)	addr = (data)
(0021) #define	inw(addr)			(addr)
(0022) 
(0023) 
(0024) volatile u08 spiTransferComplete;
(0025) 
(0026) // SPI interrupt service handler
(0027) #ifdef SPI_USEINT
(0028) SIGNAL(SIG_SPI)
(0029) {
(0030) 	spiTransferComplete = TRUE;
(0031) }
(0032) #endif
(0033) 
(0034) // access routines
(0035) void spiInit()
(0036) {
(0037) 	// setup SPI I/O pins
(0038) 	sbi(PORTB, 1);	// set SCK hi
_spiInit:
    16B9 9AC1      SBI	0x18,1
(0039) 	sbi(DDRB, 1);	// set SCK as output
    16BA 9AB9      SBI	0x17,1
(0040) 	cbi(DDRB, 3);	// set MISO as input
    16BB 98BB      CBI	0x17,3
(0041) 	sbi(DDRB, 2);	// set MOSI as output
    16BC 9ABA      SBI	0x17,2
(0042) 	sbi(DDRB, 0);	// SS must be output for Master mode to work
    16BD 9AB8      SBI	0x17,0
(0043) 	sbi(PORTB,0);   // set SS hi
    16BE 9AC0      SBI	0x18,0
(0044) 	
(0045) 	// setup SPI interface :
(0046) 	// master mode
(0047) 	sbi(SPCR, MSTR);
    16BF 9A6C      SBI	0x0D,4
(0048) 	// clock = f/4
(0049) //	cbi(SPCR, SPR0);
(0050) //	cbi(SPCR, SPR1);
(0051) 	// clock = f/16
(0052) 	cbi(SPCR, SPR0);
    16C0 9868      CBI	0x0D,0
(0053) 	sbi(SPCR, SPR1);
    16C1 9A69      SBI	0x0D,1
(0054) 	// select clock phase positive-going in middle of data
(0055) 	cbi(SPCR, CPOL);
    16C2 986B      CBI	0x0D,3
(0056) 	// Data order MSB first
(0057) 	cbi(SPCR,DORD);
    16C3 986D      CBI	0x0D,5
(0058) 	// enable SPI
(0059) 	sbi(SPCR, SPE);
    16C4 9A6E      SBI	0x0D,6
(0060) 		
(0061) 	
(0062) 	// some other possible configs
(0063) 	//outp((1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
(0064) 	//outp((1<<CPHA)|(1<<CPOL)|(1<<MSTR)|(1<<SPE)|(1<<SPR0)|(1<<SPR1), SPCR );
(0065) 	//outp((1<<CPHA)|(1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
(0066) 	
(0067) 	// clear status
(0068) 	inb(SPSR);
(0069) 	spiTransferComplete = TRUE;
    16C5 EF8F      LDI	R24,0xFF
    16C6 9380 0E12 STS	spiTransferComplete,R24
    16C8 9508      RET
(0070) 
(0071) 	// enable SPI interrupt
(0072) 	#ifdef SPI_USEINT
(0073) 	sbi(SPCR, SPIE);
(0074) 	#endif
(0075) }
(0076) /*
(0077) void spiSetBitrate(u08 spr)
(0078) {
(0079) 	outb(SPCR, (inb(SPCR) & ((1<<SPR0)|(1<<SPR1))) | (spr&((1<<SPR0)|(1<<SPR1)))));
(0080) }
(0081) */
(0082) void spiSendByte(u08 data)
(0083) {
(0084) 	// send a byte over SPI and ignore reply
(0085) 	#ifdef SPI_USEINT
(0086) 		while(!spiTransferComplete);
(0087) 		spiTransferComplete = FALSE;
(0088) 	#else
(0089) 		while(!(inb(SPSR) & (1<<SPIF)));
_spiSendByte:
  data                 --> R16
    16C9 9B77      SBIS	0x0E,7
    16CA CFFE      RJMP	_spiSendByte
(0090) 	#endif
(0091) 
(0092) 	outb(SPDR, data);
    16CB B90F      OUT	0x0F,R16
    16CC 9508      RET
(0093) }
(0094) 
(0095) u08 spiTransferByte(u08 data)
(0096) {
(0097) 	#ifdef SPI_USEINT
(0098) 	// send the given data
(0099) 	spiTransferComplete = FALSE;
(0100) 	outb(SPDR, data);
(0101) 	// wait for transfer to complete
(0102) 	while(!spiTransferComplete);
(0103) 	#else
(0104) 	// send the given data
(0105) 	outb(SPDR, data);
_spiTransferByte:
  data                 --> R16
    16CD B90F      OUT	0x0F,R16
(0106) 	// wait for transfer to complete
(0107) 	while(!(inb(SPSR) & (1<<SPIF)));
    16CE 9B77      SBIS	0x0E,7
    16CF CFFE      RJMP	0x16CE
(0108) 	#endif
(0109) 	// return the received data
(0110) 	return inb(SPDR);
    16D0 B10F      IN	R16,0x0F
    16D1 9508      RET
_spiTransferWord:
  rxData               --> R10
  data                 --> R20
    16D2 940E 21B8 CALL	push_xgset300C
    16D4 01A8      MOVW	R20,R16
(0111) }
(0112) 
(0113) u16 spiTransferWord(u16 data)
(0114) {
(0115) 	u16 rxData = 0;
(0116) 
(0117) 	// send MS byte of given data
(0118) 	rxData = (spiTransferByte((data>>8) & 0x00FF))<<8;
    16D5 018A      MOVW	R16,R20
    16D6 2F01      MOV	R16,R17
    16D7 2711      CLR	R17
    16D8 7010      ANDI	R17,0
    16D9 DFF3      RCALL	_spiTransferByte
    16DA 2EA0      MOV	R10,R16
    16DB 24BB      CLR	R11
    16DC 2CBA      MOV	R11,R10
    16DD 24AA      CLR	R10
(0119) 	// send LS byte of given data
(0120) 	rxData |= (spiTransferByte(data & 0x00FF));
    16DE 018A      MOVW	R16,R20
    16DF 7010      ANDI	R17,0
    16E0 DFEC      RCALL	_spiTransferByte
    16E1 2E20      MOV	R2,R16
    16E2 2433      CLR	R3
    16E3 28A2      OR	R10,R2
    16E4 28B3      OR	R11,R3
(0121) 
(0122) 	// return the received data
(0123) 	return rxData;
    16E5 0185      MOVW	R16,R10
    16E6 940C 21BD JMP	pop_xgset300C
FILE: E:\DMAVR-~3\ReadBmp\TFT.c
(0001) //TFT液晶读写相关函数及初始化函数等
(0002) //相关头文件 TFT.h
(0003) 
(0004) 
(0005) #include  <BMP_TFT.h>
(0006) 
(0007) 
(0008) uint color[]={0xf800,0x07e0,0x001f,0xffe0,0x0000,0xffff,0x07ff,0xf81f}; //八种颜色代码
(0009) //unsigned char RamVar_1[512];            				//定义无符号整型变量(Ram变量)
(0010) 
(0011) //***********************************************************************
(0012) //	  IO口初始化
(0013) //***********************************************************************
(0014) 
(0015) void McuInit()
(0016) {
(0017) 	LCD_Data=0xFF;                     //各相关IO口初始化
_McuInit:
    16E8 EF8F      LDI	R24,0xFF
    16E9 BB8B      OUT	0x1B,R24
(0018) 	DDR_Data=0xFF;
    16EA BB8A      OUT	0x1A,R24
(0019) 
(0020) 	PORTF=0xFF;
    16EB 9380 0062 STS	0x0062,R24
(0021) 	DDRF=0xFF;
    16ED 9380 0061 STS	0x0061,R24
(0022) 
(0023) 	PORTG=0x0F;                        
    16EF E08F      LDI	R24,0xF
    16F0 9380 0065 STS	0x0065,R24
(0024) 	DDRG=0x0F;
    16F2 9380 0064 STS	0x0064,R24
(0025) 
(0026) 	PORTD=0xFF;
    16F4 EF8F      LDI	R24,0xFF
    16F5 BB82      OUT	0x12,R24
(0027) 	DDRD=0xFF;
    16F6 BB81      OUT	0x11,R24
(0028)   	
(0029) 	D_LE1;                             //关掉数码管，以免显示乱码，因为共用PA口                   
    16F7 9A94      SBI	0x12,4
(0030)     W_LE1;                     
    16F8 9A95      SBI	0x12,5
(0031)     LCD_Data=0xFF;                      //关所有数码管            
    16F9 BB8B      OUT	0x1B,R24
(0032)     W_LE0; 
    16FA 9895      CBI	0x12,5
(0033) 
(0034)     PORTB=0xFF;
    16FB BB88      OUT	0x18,R24
(0035) 	DDRB=0xFF;
    16FC BB87      OUT	0x17,R24
(0036) 
(0037) 	LCD_BL0;
    16FD 9180 0065 LDS	R24,0x0065
    16FF 7F8B      ANDI	R24,0xFB
    1700 9380 0065 STS	0x0065,R24
    1702 9508      RET
(0038) 
(0039) 
(0040) }
(0041) 
(0042) 
(0043) //***********************************************************************
(0044) //	   写寻址寄存器地址，厂家规定0x22
(0045) //***********************************************************************
(0046) 
(0047) void LCD_WR_REG(uchar index)           
(0048) {
(0049) 	LCD_RS0;                            //根据控制器datasheet，RS为0时，为写寄存器地址
_LCD_WR_REG:
  index                --> R16
    1703 9180 0062 LDS	R24,0x0062
    1705 7F8D      ANDI	R24,0xFD
    1706 9380 0062 STS	0x0062,R24
(0050) 	LCD_EC0;
    1708 9180 0062 LDS	R24,0x0062
    170A 7F87      ANDI	R24,0xF7
    170B 9380 0062 STS	0x0062,R24
(0051) 	LCD_Data = 0x00;
    170D 2422      CLR	R2
    170E BA2B      OUT	0x1B,R2
(0052) 	LCD_WR0;
    170F 9180 0062 LDS	R24,0x0062
    1711 7F8B      ANDI	R24,0xFB
    1712 9380 0062 STS	0x0062,R24
(0053) 	LCD_WR1;
    1714 9180 0062 LDS	R24,0x0062
    1716 6084      ORI	R24,4
    1717 9380 0062 STS	0x0062,R24
(0054) 	LCD_Data = index;
    1719 BB0B      OUT	0x1B,R16
(0055) 	LCD_WR0;
    171A 9180 0062 LDS	R24,0x0062
    171C 7F8B      ANDI	R24,0xFB
    171D 9380 0062 STS	0x0062,R24
(0056) 	LCD_WR1;
    171F 9180 0062 LDS	R24,0x0062
    1721 6084      ORI	R24,4
    1722 9380 0062 STS	0x0062,R24
(0057) 	LCD_EC1;
    1724 9180 0062 LDS	R24,0x0062
    1726 6088      ORI	R24,0x8
    1727 9380 0062 STS	0x0062,R24
(0058) 	LCD_RS0;
    1729 9180 0062 LDS	R24,0x0062
    172B 7F8D      ANDI	R24,0xFD
    172C 9380 0062 STS	0x0062,R24
    172E 9508      RET
_LCD_RD_REG16:
  pd                   --> R10
  index                --> R10
    172F 92AA      ST	R10,-Y
    1730 92BA      ST	R11,-Y
    1731 2EA0      MOV	R10,R16
(0059) }
(0060) 
(0061) //***********************************************************************
(0062) //	   读数据，从GRAM中读取，第一个字节无效，从第二个字节开始读取
(0063) //***********************************************************************
(0064) 
(0065) unsigned int LCD_RD_REG16(uchar index)
(0066) {
(0067) 	unsigned int pd;
(0068) 
(0069) 	LCD_RS0;
    1732 9180 0062 LDS	R24,0x0062
    1734 7F8D      ANDI	R24,0xFD
    1735 9380 0062 STS	0x0062,R24
(0070) 	LCD_EC0;
    1737 9180 0062 LDS	R24,0x0062
    1739 7F87      ANDI	R24,0xF7
    173A 9380 0062 STS	0x0062,R24
(0071) 	
(0072) 	delay_3us();
    173C 940E 079B CALL	_delay_3us
(0073) 	
(0074) 	LCD_Data = 0x00;
    173E 2422      CLR	R2
    173F BA2B      OUT	0x1B,R2
(0075) 	delay_3us();
    1740 940E 079B CALL	_delay_3us
(0076) 
(0077) 	LCD_WR0;
    1742 9180 0062 LDS	R24,0x0062
    1744 7F8B      ANDI	R24,0xFB
    1745 9380 0062 STS	0x0062,R24
(0078) 	delay_3us();
    1747 940E 079B CALL	_delay_3us
(0079) 
(0080) 	LCD_WR1;
    1749 9180 0062 LDS	R24,0x0062
    174B 6084      ORI	R24,4
    174C 9380 0062 STS	0x0062,R24
(0081) 	delay_3us();
    174E 940E 079B CALL	_delay_3us
(0082) 
(0083) 	LCD_Data = index;
    1750 BAAB      OUT	0x1B,R10
(0084) 	delay_3us();
    1751 940E 079B CALL	_delay_3us
(0085) 
(0086) 	LCD_WR0;
    1753 9180 0062 LDS	R24,0x0062
    1755 7F8B      ANDI	R24,0xFB
    1756 9380 0062 STS	0x0062,R24
(0087) 	delay_3us();
    1758 940E 079B CALL	_delay_3us
(0088) 
(0089) 	LCD_WR1;
    175A 9180 0062 LDS	R24,0x0062
    175C 6084      ORI	R24,4
    175D 9380 0062 STS	0x0062,R24
(0090) 	delay_3us();
    175F 940E 079B CALL	_delay_3us
(0091) 
(0092) 	LCD_RS1;
    1761 9180 0062 LDS	R24,0x0062
    1763 6082      ORI	R24,2
    1764 9380 0062 STS	0x0062,R24
(0093) 	delay_3us();
    1766 940E 079B CALL	_delay_3us
(0094) 
(0095) 	LCD_Data = 0xFF;
    1768 EF8F      LDI	R24,0xFF
    1769 BB8B      OUT	0x1B,R24
(0096) 	delay_3us();
    176A 940E 079B CALL	_delay_3us
(0097) 
(0098) 	LCD_RD0;
    176C 9180 0065 LDS	R24,0x0065
    176E 7E8F      ANDI	R24,0xEF
    176F 9380 0065 STS	0x0065,R24
(0099) 	delay_3us();
    1771 940E 079B CALL	_delay_3us
(0100) 
(0101)     //DDR_IN;  //数据输入
(0102) 	delay_3us();
    1773 940E 079B CALL	_delay_3us
(0103) 
(0104) 	LCD_RD1;
    1775 9180 0065 LDS	R24,0x0065
    1777 6180      ORI	R24,0x10
    1778 9380 0065 STS	0x0065,R24
(0105) 	pd = LCD_Data;
    177A B2AB      IN	R10,0x1B
    177B 24BB      CLR	R11
(0106) 	delay_3us();
    177C 940E 079B CALL	_delay_3us
(0107) 
(0108) 	LCD_Data = 0xFF;
    177E EF8F      LDI	R24,0xFF
    177F BB8B      OUT	0x1B,R24
(0109) 	LCD_RD0;
    1780 9180 0065 LDS	R24,0x0065
    1782 7E8F      ANDI	R24,0xEF
    1783 9380 0065 STS	0x0065,R24
(0110) 	delay_3us();
    1785 940E 079B CALL	_delay_3us
(0111) 
(0112) 	LCD_RD1;
    1787 9180 0065 LDS	R24,0x0065
    1789 6180      ORI	R24,0x10
    178A 9380 0065 STS	0x0065,R24
(0113) 	pd = pd + LCD_Data*256;
    178C B32B      IN	R18,0x1B
    178D 2733      CLR	R19
    178E E000      LDI	R16,0
    178F E011      LDI	R17,1
    1790 940E 2152 CALL	empy16s
    1792 0EA0      ADD	R10,R16
    1793 1EB1      ADC	R11,R17
(0114) 	LCD_EC1;
    1794 9180 0062 LDS	R24,0x0062
    1796 6088      ORI	R24,0x8
    1797 9380 0062 STS	0x0062,R24
(0115) 	LCD_RS0;
    1799 9180 0062 LDS	R24,0x0062
    179B 7F8D      ANDI	R24,0xFD
    179C 9380 0062 STS	0x0062,R24
(0116) 	return pd;
    179E 0185      MOVW	R16,R10
    179F 90B9      LD	R11,Y+
    17A0 90A9      LD	R10,Y+
    17A1 9508      RET
(0117) }
(0118) 
(0119) //***********************************************************************
(0120) //	   写控制命令，index为寄存器地址，val为控制命令，16位长度
(0121) //***********************************************************************
(0122) 
(0123) void LCD_WR_CMD(uchar index,uint val)
(0124) {
(0125) 	LCD_RS0;
_LCD_WR_CMD:
  val                  --> R18
  index                --> R16
    17A2 9180 0062 LDS	R24,0x0062
    17A4 7F8D      ANDI	R24,0xFD
    17A5 9380 0062 STS	0x0062,R24
(0126) 	LCD_EC0;
    17A7 9180 0062 LDS	R24,0x0062
    17A9 7F87      ANDI	R24,0xF7
    17AA 9380 0062 STS	0x0062,R24
(0127) 	LCD_Data = 0x00;
    17AC 2422      CLR	R2
    17AD BA2B      OUT	0x1B,R2
(0128) 	LCD_WR0;
    17AE 9180 0062 LDS	R24,0x0062
    17B0 7F8B      ANDI	R24,0xFB
    17B1 9380 0062 STS	0x0062,R24
(0129) 	LCD_WR1;
    17B3 9180 0062 LDS	R24,0x0062
    17B5 6084      ORI	R24,4
    17B6 9380 0062 STS	0x0062,R24
(0130) 	LCD_Data = index;
    17B8 BB0B      OUT	0x1B,R16
(0131) 	LCD_WR0;
    17B9 9180 0062 LDS	R24,0x0062
    17BB 7F8B      ANDI	R24,0xFB
    17BC 9380 0062 STS	0x0062,R24
(0132) 	LCD_WR1;
    17BE 9180 0062 LDS	R24,0x0062
    17C0 6084      ORI	R24,4
    17C1 9380 0062 STS	0x0062,R24
(0133) 	LCD_EC1;
    17C3 9180 0062 LDS	R24,0x0062
    17C5 6088      ORI	R24,0x8
    17C6 9380 0062 STS	0x0062,R24
(0134) 	LCD_RS0;
    17C8 9180 0062 LDS	R24,0x0062
    17CA 7F8D      ANDI	R24,0xFD
    17CB 9380 0062 STS	0x0062,R24
(0135) 
(0136) 	LCD_RS1;                             //根据控制器datasheet，RS为1时，为写控制命令或者数据到GRAM
    17CD 9180 0062 LDS	R24,0x0062
    17CF 6082      ORI	R24,2
    17D0 9380 0062 STS	0x0062,R24
(0137) 	LCD_EC0;
    17D2 9180 0062 LDS	R24,0x0062
    17D4 7F87      ANDI	R24,0xF7
    17D5 9380 0062 STS	0x0062,R24
(0138) 	LCD_Data = (uchar)(val>>8);
    17D7 0119      MOVW	R2,R18
    17D8 2C23      MOV	R2,R3
    17D9 2433      CLR	R3
    17DA BA2B      OUT	0x1B,R2
(0139) 	LCD_WR0;
    17DB 9180 0062 LDS	R24,0x0062
    17DD 7F8B      ANDI	R24,0xFB
    17DE 9380 0062 STS	0x0062,R24
(0140) 	LCD_WR1;
    17E0 9180 0062 LDS	R24,0x0062
    17E2 6084      ORI	R24,4
    17E3 9380 0062 STS	0x0062,R24
(0141) 	LCD_EC1;
    17E5 9180 0062 LDS	R24,0x0062
    17E7 6088      ORI	R24,0x8
    17E8 9380 0062 STS	0x0062,R24
(0142) 	LCD_RS0;
    17EA 9180 0062 LDS	R24,0x0062
    17EC 7F8D      ANDI	R24,0xFD
    17ED 9380 0062 STS	0x0062,R24
(0143) 	LCD_RS1;
    17EF 9180 0062 LDS	R24,0x0062
    17F1 6082      ORI	R24,2
    17F2 9380 0062 STS	0x0062,R24
(0144) 	LCD_EC0;
    17F4 9180 0062 LDS	R24,0x0062
    17F6 7F87      ANDI	R24,0xF7
    17F7 9380 0062 STS	0x0062,R24
(0145) 	LCD_Data = (uchar)val;
    17F9 BB2B      OUT	0x1B,R18
(0146) 	LCD_WR0;
    17FA 9180 0062 LDS	R24,0x0062
    17FC 7F8B      ANDI	R24,0xFB
    17FD 9380 0062 STS	0x0062,R24
(0147) 	LCD_WR1;
    17FF 9180 0062 LDS	R24,0x0062
    1801 6084      ORI	R24,4
    1802 9380 0062 STS	0x0062,R24
(0148) 	LCD_EC1;
    1804 9180 0062 LDS	R24,0x0062
    1806 6088      ORI	R24,0x8
    1807 9380 0062 STS	0x0062,R24
(0149) 	LCD_RS0;
    1809 9180 0062 LDS	R24,0x0062
    180B 7F8D      ANDI	R24,0xFD
    180C 9380 0062 STS	0x0062,R24
    180E 9508      RET
(0150) }
(0151) 
(0152) //***********************************************************************
(0153) //	   向GRAM存储器写数据，用来显示，定义为16位指针调用
(0154) //***********************************************************************
(0155) 
(0156) void LCD_WR_Data(uint val)
(0157) {
(0158) 
(0159) 
(0160) 	LCD_Data = (uchar)(val>>8);
_LCD_WR_Data:
  val                  --> R16
    180F 0118      MOVW	R2,R16
    1810 2C23      MOV	R2,R3
    1811 2433      CLR	R3
    1812 BA2B      OUT	0x1B,R2
(0161) 	LCD_WR0;
    1813 9180 0062 LDS	R24,0x0062
    1815 7F8B      ANDI	R24,0xFB
    1816 9380 0062 STS	0x0062,R24
(0162) 	LCD_WR1;
    1818 9180 0062 LDS	R24,0x0062
    181A 6084      ORI	R24,4
    181B 9380 0062 STS	0x0062,R24
(0163) 	//LCD_RS1;
(0164) 	LCD_Data = (uchar)val;
    181D BB0B      OUT	0x1B,R16
(0165) 	LCD_WR0;
    181E 9180 0062 LDS	R24,0x0062
    1820 7F8B      ANDI	R24,0xFB
    1821 9380 0062 STS	0x0062,R24
(0166) 	LCD_WR1;
    1823 9180 0062 LDS	R24,0x0062
    1825 6084      ORI	R24,4
    1826 9380 0062 STS	0x0062,R24
    1828 9508      RET
(0167) 
(0168) }
(0169) 
(0170) //***********************************************************************
(0171) //	   向GRAM存储器写数据，用来显示，定义为8位指针调用
(0172) //***********************************************************************
(0173) void LCD_WR_DataP(uint val)
(0174) {
(0175) 
(0176) 	LCD_Data = (uchar)val;
_LCD_WR_DataP:
  val                  --> R16
    1829 BB0B      OUT	0x1B,R16
(0177) 	LCD_WR0;
    182A 9180 0062 LDS	R24,0x0062
    182C 7F8B      ANDI	R24,0xFB
    182D 9380 0062 STS	0x0062,R24
(0178) 	LCD_WR1;
    182F 9180 0062 LDS	R24,0x0062
    1831 6084      ORI	R24,4
    1832 9380 0062 STS	0x0062,R24
    1834 9508      RET
(0179) }
(0180) 
(0181) 
(0182) void LCD_Init()
(0183) {
(0184) 	LCD_RST0;                      //复位有效，至少2ms
_LCD_Init:
    1835 9897      CBI	0x12,7
(0185) 	delay_nms(10);
    1836 E00A      LDI	R16,0xA
    1837 E010      LDI	R17,0
    1838 940E 07CF CALL	_delay_nms
(0186) 	LCD_RST1;                      //复位结束
    183A 9A97      SBI	0x12,7
(0187) 	delay_nms(10);
    183B E00A      LDI	R16,0xA
    183C E010      LDI	R17,0
    183D 940E 07CF CALL	_delay_nms
(0188) 
(0189)     LCD_WR_CMD(0x00,0x0001);		//启动晶振，必须有至少10ms的延时，保证稳定
    183F E021      LDI	R18,1
    1840 E030      LDI	R19,0
    1841 2700      CLR	R16
    1842 DF5F      RCALL	_LCD_WR_CMD
(0190)     delay_nms(10);
    1843 E00A      LDI	R16,0xA
    1844 E010      LDI	R17,0
    1845 940E 07CF CALL	_delay_nms
(0191)     LCD_WR_CMD(0x03,0x0030);        //设置数据扫描方向，由左至右，水平扫描
    1847 E320      LDI	R18,0x30
    1848 E030      LDI	R19,0
    1849 E003      LDI	R16,3
    184A DF57      RCALL	_LCD_WR_CMD
(0192)     //LCD_WR_CMD(0x03,0x0230);      //HWM=1为高速数据模式
(0193)     LCD_WR_CMD(0x01,0x011D);
    184B E12D      LDI	R18,0x1D
    184C E031      LDI	R19,1
    184D E001      LDI	R16,1
    184E DF53      RCALL	_LCD_WR_CMD
(0194)     //delay_us(1000);
(0195)     LCD_WR_CMD(0x0a,0x0106); 
    184F E026      LDI	R18,6
    1850 E031      LDI	R19,1
    1851 E00A      LDI	R16,0xA
    1852 DF4F      RCALL	_LCD_WR_CMD
(0196)     //delay_us(1000);
(0197)     LCD_WR_CMD(0x07,0x0037);        //非8位模式,开显示
    1853 E327      LDI	R18,0x37
    1854 E030      LDI	R19,0
    1855 E007      LDI	R16,7
    1856 DF4B      RCALL	_LCD_WR_CMD
(0198) 
(0199)     LCD_WR_CMD(0x08,0x0707);        //光栅周期数为7，若为0，则无显示，是为了保证足够的时间让光栅回到行左边
    1857 E027      LDI	R18,7
    1858 E037      LDI	R19,7
    1859 E008      LDI	R16,0x8
    185A DF47      RCALL	_LCD_WR_CMD
(0200)     LCD_WR_CMD(0x0c,0x01);
    185B E021      LDI	R18,1
    185C E030      LDI	R19,0
    185D E00C      LDI	R16,0xC
    185E DF43      RCALL	_LCD_WR_CMD
(0201)     LCD_WR_CMD(0x02,0x0400);        //驱动波形控制指令
    185F E020      LDI	R18,0
    1860 E034      LDI	R19,4
    1861 E002      LDI	R16,2
    1862 DF3F      RCALL	_LCD_WR_CMD
(0202)     //delay_us(1000);
(0203)     LCD_WR_CMD(0x0a,0x0107);        //门驱动和电源控制IC指令，后面要紧跟需要的指令
    1863 E027      LDI	R18,7
    1864 E031      LDI	R19,1
    1865 E00A      LDI	R16,0xA
    1866 DF3B      RCALL	_LCD_WR_CMD
(0204)  //   delay_us(1000);
(0205) 
(0206)     LCD_WR_CMD(0x12,0x0001);        //VciOUT = 3V × 0.83 = 2.49V
    1867 E021      LDI	R18,1
    1868 E030      LDI	R19,0
    1869 E102      LDI	R16,0x12
    186A DF37      RCALL	_LCD_WR_CMD
(0207)     // only 100(=VCI), 000(.92 VCI),001(.83),010(.73VCI) is valid. other is inhibited
(0208)   //  delay_us(1000);
(0209)     LCD_WR_CMD(0x0a,0x0101); 
    186B E021      LDI	R18,1
    186C E031      LDI	R19,1
    186D E00A      LDI	R16,0xA
    186E DF33      RCALL	_LCD_WR_CMD
(0210)    // delay_us(1000);
(0211)    
(0212)    // LCD_WR_CMD(0x13,0x404);
(0213)    // delay_us(1);LCD_WR_CMD(0x0a,0x0101); delay_us(1);
(0214) 
(0215)     LCD_WR_CMD(0x11,0x0505);   //CAD=0
    186F E025      LDI	R18,5
    1870 E035      LDI	R19,5
    1871 E101      LDI	R16,0x11
    1872 DF2F      RCALL	_LCD_WR_CMD
(0216)    // delay_us(1);LCD_WR_CMD(0x0a,0x0101); delay_us(1);
(0217) 
(0218) 
(0219) 
(0220)     LCD_WR_CMD(0x14,0x2c0f); // last 4 bit must be 1!!! vcomg = 1, 
    1873 E02F      LDI	R18,0xF
    1874 E23C      LDI	R19,0x2C
    1875 E104      LDI	R16,0x14
    1876 DF2B      RCALL	_LCD_WR_CMD
(0221)     // VDV4-0 == 09-0e,10-12 // other is inhibited.!!! 
(0222)     delay_3us();
    1877 940E 079B CALL	_delay_3us
(0223)     LCD_WR_CMD(0x0a,0x0102); 
    1879 E022      LDI	R18,2
    187A E031      LDI	R19,1
    187B E00A      LDI	R16,0xA
    187C DF25      RCALL	_LCD_WR_CMD
(0224)    // delay_us(1);
(0225) 
(0226)     LCD_WR_CMD(0x10,0x1a10);// if Vci > 3.0V, use 0x1a10.
    187D E120      LDI	R18,0x10
    187E E13A      LDI	R19,0x1A
    187F E100      LDI	R16,0x10
    1880 DF21      RCALL	_LCD_WR_CMD
(0227)     delay_3us();
    1881 940E 079B CALL	_delay_3us
(0228)     LCD_WR_CMD(0x0a,0x0100); 
    1883 E020      LDI	R18,0
    1884 E031      LDI	R19,1
    1885 E00A      LDI	R16,0xA
    1886 DF1B      RCALL	_LCD_WR_CMD
(0229)   //  delay_3us();
(0230) 
(0231)     LCD_WR_CMD(0x13,0x0616); //////////!!!!!!!!!!!!! VERY IMPORTANT!!!
    1887 E126      LDI	R18,0x16
    1888 E036      LDI	R19,6
    1889 E103      LDI	R16,0x13
    188A DF17      RCALL	_LCD_WR_CMD
(0232)     //set VRH3-0 to fit REG1out= 3 to DDVDH-0.5
(0233)     delay_3us();
    188B 940E 079B CALL	_delay_3us
(0234)     LCD_WR_CMD(0x0a,0x0101); 
    188D E021      LDI	R18,1
    188E E031      LDI	R19,1
    188F E00A      LDI	R16,0xA
    1890 DF11      RCALL	_LCD_WR_CMD
(0235)   //  delay_nms(1);
(0236) 
(0237)     LCD_WR_CMD(0x30,0x0003);
    1891 E023      LDI	R18,3
    1892 E030      LDI	R19,0
    1893 E300      LDI	R16,0x30
    1894 DF0D      RCALL	_LCD_WR_CMD
(0238)     LCD_WR_CMD(0x31,0x0404);
    1895 E024      LDI	R18,4
    1896 E034      LDI	R19,4
    1897 E301      LDI	R16,0x31
    1898 DF09      RCALL	_LCD_WR_CMD
(0239)     LCD_WR_CMD(0x32,0x0303);
    1899 E023      LDI	R18,3
    189A E033      LDI	R19,3
    189B E302      LDI	R16,0x32
    189C DF05      RCALL	_LCD_WR_CMD
(0240)     LCD_WR_CMD(0x33,0x0406);
    189D E026      LDI	R18,6
    189E E034      LDI	R19,4
    189F E303      LDI	R16,0x33
    18A0 DF01      RCALL	_LCD_WR_CMD
(0241)     LCD_WR_CMD(0x34,0x0404);
    18A1 E024      LDI	R18,4
    18A2 E034      LDI	R19,4
    18A3 E304      LDI	R16,0x34
    18A4 DEFD      RCALL	_LCD_WR_CMD
(0242)     LCD_WR_CMD(0x35,0x0303);
    18A5 E023      LDI	R18,3
    18A6 E033      LDI	R19,3
    18A7 E305      LDI	R16,0x35
    18A8 DEF9      RCALL	_LCD_WR_CMD
(0243)     LCD_WR_CMD(0x36,0x0407);
    18A9 E027      LDI	R18,7
    18AA E034      LDI	R19,4
    18AB E306      LDI	R16,0x36
    18AC DEF5      RCALL	_LCD_WR_CMD
(0244)     LCD_WR_CMD(0x37,0x0604);
    18AD E024      LDI	R18,4
    18AE E036      LDI	R19,6
    18AF E307      LDI	R16,0x37
    18B0 DEF1      RCALL	_LCD_WR_CMD
(0245)     
(0246)     delay_3us();
    18B1 940E 079B CALL	_delay_3us
(0247)   //  LCD_WR_CMD(0x0a,0x0100);
(0248)    // delay_nms(1); 
(0249)     
(0250)     //*********** SAP, AP set****************	
(0251)     LCD_WR_CMD(0x10,0x1a10);//BT2-0 Ok,and...
    18B3 E120      LDI	R18,0x10
    18B4 E13A      LDI	R19,0x1A
    18B5 E100      LDI	R16,0x10
    18B6 DEEB      RCALL	_LCD_WR_CMD
(0252)     delay_3us();
    18B7 940E 079B CALL	_delay_3us
(0253)     LCD_WR_CMD(0x0a,0x0100); 
    18B9 E020      LDI	R18,0
    18BA E031      LDI	R19,1
    18BB E00A      LDI	R16,0xA
    18BC DEE5      RCALL	_LCD_WR_CMD
(0254)   //  delay_us(100);	
(0255) 	//*********** PON  set********************
(0256) 	LCD_WR_CMD(0x13,0x0616); //////////
    18BD E126      LDI	R18,0x16
    18BE E036      LDI	R19,6
    18BF E103      LDI	R16,0x13
    18C0 DEE1      RCALL	_LCD_WR_CMD
(0257)     
(0258)  //   delay_3us();
(0259)   //  LCD_WR_CMD(0x0a,0x0101); 
(0260)    // delay_us(100);
(0261)     
(0262)     //***********Display ON set*****************
(0263)    // LCD_WR_CMD(0x07,0x0037);
(0264)  //   delay_3us();
(0265)   // LCD_WR_CMD(0x0a,0x0100); 
(0266)     delay_n100us(1); 
    18C1 E001      LDI	R16,1
    18C2 E010      LDI	R17,0
    18C3 940C 07BA JMP	_delay_n100us
_LCD_clear:
  num                  --> R20
  p                    --> R10
    18C5 940E 21B8 CALL	push_xgset300C
    18C7 0158      MOVW	R10,R16
(0267)      
(0268) }
(0269) 
(0270) 
(0271) 
(0272) 
(0273) 
(0274) 
(0275) //***********************************************************************
(0276) //	   清屏子程序
(0277) //***********************************************************************
(0278) 
(0279) 
(0280) void LCD_clear(uint p)
(0281) {
(0282) 	uint num;
(0283) 	
(0284) 	LCD_WR_CMD(0x44,127*256+0);
    18C8 E020      LDI	R18,0
    18C9 E73F      LDI	R19,0x7F
    18CA E404      LDI	R16,0x44
    18CB DED6      RCALL	_LCD_WR_CMD
(0285) 	LCD_WR_CMD(0x45,239*256+80);
    18CC E520      LDI	R18,0x50
    18CD EE3F      LDI	R19,0xEF
    18CE E405      LDI	R16,0x45
    18CF DED2      RCALL	_LCD_WR_CMD
(0286) 	LCD_WR_CMD(0x21,80*256+0);	
    18D0 E020      LDI	R18,0
    18D1 E530      LDI	R19,0x50
    18D2 E201      LDI	R16,0x21
    18D3 DECE      RCALL	_LCD_WR_CMD
(0287) 	LCD_WR_REG(0x22);
    18D4 E202      LDI	R16,0x22
    18D5 DE2D      RCALL	_LCD_WR_REG
(0288) 	LCD_EC0;
    18D6 9180 0062 LDS	R24,0x0062
    18D8 7F87      ANDI	R24,0xF7
    18D9 9380 0062 STS	0x0062,R24
(0289) 	LCD_RS1;
    18DB 9180 0062 LDS	R24,0x0062
    18DD 6082      ORI	R24,2
    18DE 9380 0062 STS	0x0062,R24
(0290) 	for(num=160*128;num>0;num--)
    18E0 E040      LDI	R20,0
    18E1 E550      LDI	R21,0x50
    18E2 C004      RJMP	0x18E7
(0291) 	{
(0292) 		LCD_WR_Data(p);
    18E3 0185      MOVW	R16,R10
    18E4 DF2A      RCALL	_LCD_WR_Data
    18E5 5041      SUBI	R20,1
    18E6 4050      SBCI	R21,0
    18E7 3040      CPI	R20,0
    18E8 0745      CPC	R20,R21
    18E9 F7C9      BNE	0x18E3
(0293) 	}
(0294) 	LCD_WR_CMD(0x44,95*256+0);
    18EA E020      LDI	R18,0
    18EB E53F      LDI	R19,0x5F
    18EC E404      LDI	R16,0x44
    18ED DEB4      RCALL	_LCD_WR_CMD
(0295) 	LCD_WR_CMD(0x45,79*256+16);
    18EE E120      LDI	R18,0x10
    18EF E43F      LDI	R19,0x4F
    18F0 E405      LDI	R16,0x45
    18F1 DEB0      RCALL	_LCD_WR_CMD
(0296) 	LCD_WR_CMD(0x21,16*256+0);	
    18F2 E020      LDI	R18,0
    18F3 E130      LDI	R19,0x10
    18F4 E201      LDI	R16,0x21
    18F5 DEAC      RCALL	_LCD_WR_CMD
(0297) 	LCD_WR_REG(0x22);
    18F6 E202      LDI	R16,0x22
    18F7 DE0B      RCALL	_LCD_WR_REG
(0298) 	LCD_EC0;
    18F8 9180 0062 LDS	R24,0x0062
    18FA 7F87      ANDI	R24,0xF7
    18FB 9380 0062 STS	0x0062,R24
(0299) 	LCD_RS1;
    18FD 9180 0062 LDS	R24,0x0062
    18FF 6082      ORI	R24,2
    1900 9380 0062 STS	0x0062,R24
(0300) 	for(num=64*96;num>0;num--)
    1902 E040      LDI	R20,0
    1903 E158      LDI	R21,0x18
    1904 C004      RJMP	0x1909
(0301) 	{
(0302) 		LCD_WR_Data(p);
    1905 0185      MOVW	R16,R10
    1906 DF08      RCALL	_LCD_WR_Data
    1907 5041      SUBI	R20,1
    1908 4050      SBCI	R21,0
    1909 3040      CPI	R20,0
    190A 0745      CPC	R20,R21
    190B F7C9      BNE	0x1905
(0303) 	}
(0304) 	LCD_EC1;
    190C 9180 0062 LDS	R24,0x0062
    190E 6088      ORI	R24,0x8
    190F 9380 0062 STS	0x0062,R24
    1911 940C 21BD JMP	pop_xgset300C
_DisplayChar:
  p                    --> R22
  j                    --> R20
  i                    --> R12
  b                    --> R10
  char_color           --> Y,+12
  postion_y            --> R14
  postion_x            --> R12
  casc                 --> R10
    1913 940E 21AD CALL	push_xgsetF0FC
    1915 2EC2      MOV	R12,R18
    1916 2EA0      MOV	R10,R16
    1917 84EA      LDD	R14,Y+10
(0305) }
(0306) 
(0307) //***********************************************************************
(0308) //	   8X16点阵的字符显示函数
(0309) //	   casc:字符对应字模中的位置
(0310) //     x:显示位置第几列,每行是128/8 ==16列
(0311) //     y:显示位置第几行,整屏是160/16==10行
(0312) //     char_color:字体颜色
(0313) //***********************************************************************
(0314) 
(0315) void DisplayChar(uchar casc,uchar postion_x,uchar postion_y,uint char_color)
(0316) {
(0317) 
(0318) 	uchar i,j,b;
(0319) 	 
(0320) 	 uchar *p;
(0321) 	
(0322) 	
(0323) 	LCD_WR_CMD(0x44,(postion_x*8+7)*256+(postion_x*8));	            //x end point
    1918 2C2C      MOV	R2,R12
    1919 2433      CLR	R3
    191A 0C22      LSL	R2
    191B 1C33      ROL	R3
    191C 0C22      LSL	R2
    191D 1C33      ROL	R3
    191E 0C22      LSL	R2
    191F 1C33      ROL	R3
    1920 E000      LDI	R16,0
    1921 E011      LDI	R17,1
    1922 0191      MOVW	R18,R2
    1923 940E 2152 CALL	empy16s
    1925 0198      MOVW	R18,R16
    1926 5020      SUBI	R18,0
    1927 4F39      SBCI	R19,0xF9
    1928 0D22      ADD	R18,R2
    1929 1D33      ADC	R19,R3
    192A E404      LDI	R16,0x44
    192B DE76      RCALL	_LCD_WR_CMD
(0324) 	LCD_WR_CMD(0x45,(postion_y*16+15+80)*256+(postion_y*16+80));	//y end point
    192C E180      LDI	R24,0x10
    192D 9D8E      MUL	R24,R14
    192E 0110      MOVW	R2,R0
    192F E000      LDI	R16,0
    1930 E011      LDI	R17,1
    1931 0191      MOVW	R18,R2
    1932 940E 2152 CALL	empy16s
    1934 0198      MOVW	R18,R16
    1935 5020      SUBI	R18,0
    1936 4A31      SBCI	R19,0xA1
    1937 01C1      MOVW	R24,R2
    1938 5B80      SUBI	R24,0xB0
    1939 4F9F      SBCI	R25,0xFF
    193A 0F28      ADD	R18,R24
    193B 1F39      ADC	R19,R25
    193C E405      LDI	R16,0x45
    193D DE64      RCALL	_LCD_WR_CMD
(0325) 	LCD_WR_CMD(0x21,(postion_y*16+80)*256+(postion_x*8));	
    193E E180      LDI	R24,0x10
    193F 9D8E      MUL	R24,R14
    1940 0190      MOVW	R18,R0
    1941 E000      LDI	R16,0
    1942 E011      LDI	R17,1
    1943 940E 2152 CALL	empy16s
    1945 0198      MOVW	R18,R16
    1946 5020      SUBI	R18,0
    1947 4B30      SBCI	R19,0xB0
    1948 2C2C      MOV	R2,R12
    1949 2433      CLR	R3
    194A 0C22      LSL	R2
    194B 1C33      ROL	R3
    194C 0C22      LSL	R2
    194D 1C33      ROL	R3
    194E 0C22      LSL	R2
    194F 1C33      ROL	R3
    1950 0D22      ADD	R18,R2
    1951 1D33      ADC	R19,R3
    1952 E201      LDI	R16,0x21
    1953 DE4E      RCALL	_LCD_WR_CMD
(0326) 	LCD_WR_REG(0x22);
    1954 E202      LDI	R16,0x22
    1955 DDAD      RCALL	_LCD_WR_REG
(0327) 	LCD_EC0;
    1956 9180 0062 LDS	R24,0x0062
    1958 7F87      ANDI	R24,0xF7
    1959 9380 0062 STS	0x0062,R24
(0328) 	LCD_RS1;
    195B 9180 0062 LDS	R24,0x0062
    195D 6082      ORI	R24,2
    195E 9380 0062 STS	0x0062,R24
(0329) 	p=ascii;
    1960 EE6A      LDI	R22,0xEA
    1961 E072      LDI	R23,2
(0330) 	p+=casc*16;
    1962 E180      LDI	R24,0x10
    1963 9D8A      MUL	R24,R10
    1964 0D60      ADD	R22,R0
    1965 1D71      ADC	R23,R1
(0331) 	for(j=0;j<16;j++)
    1966 2744      CLR	R20
    1967 C016      RJMP	0x197E
(0332) 	{
(0333) 		b=*(p+j);
    1968 2FE4      MOV	R30,R20
    1969 27FF      CLR	R31
    196A 0FE6      ADD	R30,R22
    196B 1FF7      ADC	R31,R23
    196C 80A0      LDD	R10,Z+0
(0334) 		for(i=0;i<8;i++)
    196D 24CC      CLR	R12
    196E C00B      RJMP	0x197A
(0335) 		{
(0336) 			if(b&0x80)
    196F FEA7      SBRS	R10,7
    1970 C004      RJMP	0x1975
(0337) 			{
(0338) 				LCD_WR_Data(char_color);                //字体颜色
    1971 850C      LDD	R16,Y+12
    1972 851D      LDD	R17,Y+13
    1973 DE9B      RCALL	_LCD_WR_Data
(0339) 			}
    1974 C003      RJMP	0x1978
(0340) 			else
(0341) 			{
(0342) 				LCD_WR_Data(0x0000);       				//背景颜色
    1975 2700      CLR	R16
    1976 2711      CLR	R17
    1977 DE97      RCALL	_LCD_WR_Data
(0343) 			}
(0344) 			b=b<<1;
    1978 0CAA      LSL	R10
    1979 94C3      INC	R12
    197A 2D8C      MOV	R24,R12
    197B 3088      CPI	R24,0x8
    197C F390      BCS	0x196F
    197D 9543      INC	R20
    197E 3140      CPI	R20,0x10
    197F F340      BCS	0x1968
(0345) 			
(0346) 		}	
(0347) 	}
(0348) 	LCD_EC1;
    1980 9180 0062 LDS	R24,0x0062
    1982 6088      ORI	R24,0x8
    1983 9380 0062 STS	0x0062,R24
    1985 940C 21A2 JMP	pop_xgsetF0FC
_DisplayGB2312:
  p                    --> R22
  j                    --> R20
  i                    --> R12
  b                    --> R10
  gb_color             --> Y,+12
  postion_y            --> R14
  postion_x            --> R12
  gb                   --> R10
    1987 940E 21AD CALL	push_xgsetF0FC
    1989 2EC2      MOV	R12,R18
    198A 2EA0      MOV	R10,R16
    198B 84EA      LDD	R14,Y+10
(0349) }
(0350) //***********************************************************************
(0351) //        16X16点阵的汉字显示函数，字库可以自己提取
(0352) //		  gb:汉字对应字模中的位置
(0353) //         x:显示位置第几列
(0354) //         y:显示位置第几行
(0355) //		  color:字体颜色
(0356) //***********************************************************************
(0357) 
(0358) void DisplayGB2312(uchar gb,uchar postion_x,uchar postion_y,uint gb_color)
(0359) {
(0360) 
(0361) 	uchar i,j,b;
(0362) 	uchar *p;
(0363) 	
(0364) 	LCD_WR_CMD(0x44,(postion_x*16+15)*256+(postion_x*16));	        //x end point
    198C E180      LDI	R24,0x10
    198D 9D8C      MUL	R24,R12
    198E 0110      MOVW	R2,R0
    198F E000      LDI	R16,0
    1990 E011      LDI	R17,1
    1991 0191      MOVW	R18,R2
    1992 940E 2152 CALL	empy16s
    1994 0198      MOVW	R18,R16
    1995 5020      SUBI	R18,0
    1996 4F31      SBCI	R19,0xF1
    1997 0D22      ADD	R18,R2
    1998 1D33      ADC	R19,R3
    1999 E404      LDI	R16,0x44
    199A DE07      RCALL	_LCD_WR_CMD
(0365) 	LCD_WR_CMD(0x45,(postion_y*16+15+80)*256+(postion_y*16+80));	//y end point
    199B E180      LDI	R24,0x10
    199C 9D8E      MUL	R24,R14
    199D 0110      MOVW	R2,R0
    199E E000      LDI	R16,0
    199F E011      LDI	R17,1
    19A0 0191      MOVW	R18,R2
    19A1 940E 2152 CALL	empy16s
    19A3 0198      MOVW	R18,R16
    19A4 5020      SUBI	R18,0
    19A5 4A31      SBCI	R19,0xA1
    19A6 01C1      MOVW	R24,R2
    19A7 5B80      SUBI	R24,0xB0
    19A8 4F9F      SBCI	R25,0xFF
    19A9 0F28      ADD	R18,R24
    19AA 1F39      ADC	R19,R25
    19AB E405      LDI	R16,0x45
    19AC DDF5      RCALL	_LCD_WR_CMD
(0366) 	LCD_WR_CMD(0x21,(postion_y*16+80)*256+(postion_x*16));	
    19AD E180      LDI	R24,0x10
    19AE 9D8E      MUL	R24,R14
    19AF 0190      MOVW	R18,R0
    19B0 E000      LDI	R16,0
    19B1 E011      LDI	R17,1
    19B2 940E 2152 CALL	empy16s
    19B4 0198      MOVW	R18,R16
    19B5 5020      SUBI	R18,0
    19B6 4B30      SBCI	R19,0xB0
    19B7 E180      LDI	R24,0x10
    19B8 9D8C      MUL	R24,R12
    19B9 0D20      ADD	R18,R0
    19BA 1D31      ADC	R19,R1
    19BB E201      LDI	R16,0x21
    19BC DDE5      RCALL	_LCD_WR_CMD
(0367) 	LCD_WR_REG(0x22);
    19BD E202      LDI	R16,0x22
    19BE DD44      RCALL	_LCD_WR_REG
(0368) 	LCD_EC0;
    19BF 9180 0062 LDS	R24,0x0062
    19C1 7F87      ANDI	R24,0xF7
    19C2 9380 0062 STS	0x0062,R24
(0369) 	LCD_RS1;
    19C4 9180 0062 LDS	R24,0x0062
    19C6 6082      ORI	R24,2
    19C7 9380 0062 STS	0x0062,R24
(0370) 	p=GB2312;
    19C9 EE6A      LDI	R22,0xEA
    19CA E07A      LDI	R23,0xA
(0371) 	p+=gb*32;
    19CB E280      LDI	R24,0x20
    19CC 9D8A      MUL	R24,R10
    19CD 0D60      ADD	R22,R0
    19CE 1D71      ADC	R23,R1
(0372) 	for(j=0;j<32;j++)
    19CF 2744      CLR	R20
    19D0 C016      RJMP	0x19E7
(0373) 	{
(0374) 		b=*(p+j);
    19D1 2FE4      MOV	R30,R20
    19D2 27FF      CLR	R31
    19D3 0FE6      ADD	R30,R22
    19D4 1FF7      ADC	R31,R23
    19D5 80A0      LDD	R10,Z+0
(0375) 		for(i=0;i<8;i++)
    19D6 24CC      CLR	R12
    19D7 C00B      RJMP	0x19E3
(0376) 		{
(0377) 			if(b&0x80)
    19D8 FEA7      SBRS	R10,7
    19D9 C004      RJMP	0x19DE
(0378) 			{
(0379) 				LCD_WR_Data(gb_color);          //字体颜色
    19DA 850C      LDD	R16,Y+12
    19DB 851D      LDD	R17,Y+13
    19DC DE32      RCALL	_LCD_WR_Data
(0380) 			}
    19DD C003      RJMP	0x19E1
(0381) 			else
(0382) 			{
(0383) 				LCD_WR_Data(0x0000);         //背景颜色
    19DE 2700      CLR	R16
    19DF 2711      CLR	R17
    19E0 DE2E      RCALL	_LCD_WR_Data
(0384) 			}
(0385) 			b=b<<1;
    19E1 0CAA      LSL	R10
    19E2 94C3      INC	R12
    19E3 2D8C      MOV	R24,R12
    19E4 3088      CPI	R24,0x8
    19E5 F390      BCS	0x19D8
    19E6 9543      INC	R20
    19E7 3240      CPI	R20,0x20
    19E8 F340      BCS	0x19D1
(0386) 			
(0387) 		}	
(0388) 	}
(0389) 	LCD_EC1;
    19E9 9180 0062 LDS	R24,0x0062
    19EB 6088      ORI	R24,0x8
    19EC 9380 0062 STS	0x0062,R24
    19EE 940C 21A2 JMP	pop_xgsetF0FC
_DisplayString:
  s_color              --> Y,+12
  y                    --> R22
  x                    --> R10
  s                    --> R20
    19F0 940E 21CC CALL	push_xgsetF00C
    19F2 2EA2      MOV	R10,R18
    19F3 01A8      MOVW	R20,R16
    19F4 9724      SBIW	R28,4
    19F5 856A      LDD	R22,Y+10
(0390) }
(0391) 
(0392) //***********************************************************************
(0393) //         英文字符显示函数
(0394) //		   s:ASCII码对应字模中的位置
(0395) //         x:显示位置第几列
(0396) //         y:显示位置第几行
(0397) //***********************************************************************
(0398) 
(0399) void DisplayString(uchar *s,uchar x,uchar y,uint s_color)                      //英文字符串显示.
(0400) {
    19F6 C017      RJMP	0x1A0E
(0401) 	while (*s) 
(0402) 	{ 
(0403) 		DisplayChar(*s,x,y,s_color);
    19F7 840C      LDD	R0,Y+12
    19F8 841D      LDD	R1,Y+13
    19F9 821B      STD	Y+3,R1
    19FA 820A      STD	Y+2,R0
    19FB 8368      STD	Y+0,R22
    19FC 2D2A      MOV	R18,R10
    19FD 01FA      MOVW	R30,R20
    19FE 8100      LDD	R16,Z+0
    19FF DF13      RCALL	_DisplayChar
(0404) 		if(++x>=16)
    1A00 2D8A      MOV	R24,R10
    1A01 5F8F      SUBI	R24,0xFF
    1A02 2EA8      MOV	R10,R24
    1A03 3180      CPI	R24,0x10
    1A04 F038      BCS	0x1A0C
(0405) 		{
(0406) 			x=0;
    1A05 24AA      CLR	R10
(0407) 			if(++y>=10)
    1A06 2F86      MOV	R24,R22
    1A07 5F8F      SUBI	R24,0xFF
    1A08 2F68      MOV	R22,R24
    1A09 306A      CPI	R22,0xA
    1A0A F008      BCS	0x1A0C
(0408) 			{
(0409) 				y=0;
    1A0B 2766      CLR	R22
(0410) 			}
(0411) 		}
(0412) 		s++;
    1A0C 5F4F      SUBI	R20,0xFF
    1A0D 4F5F      SBCI	R21,0xFF
    1A0E 01FA      MOVW	R30,R20
    1A0F 8020      LDD	R2,Z+0
    1A10 2022      TST	R2
    1A11 F729      BNE	0x19F7
    1A12 9624      ADIW	R28,4
    1A13 940C 21D3 JMP	pop_xgsetF00C
_GUIback:
  num                  --> R20
  back_color           --> R10
    1A15 940E 21B8 CALL	push_xgset300C
    1A17 0158      MOVW	R10,R16
(0413)     }
(0414) }
(0415) 
(0416) //***********************************************************************
(0417) //          打点绘图背景颜色函数，可先调用,相当于清屏函数
(0418) //***********************************************************************
(0419) 
(0420) void GUIback(uint back_color)                 //背景函数
(0421)   {
(0422)   	uint num;
(0423) 	LCD_WR_CMD(0x44,127*256+0);              //水平显示区域
    1A18 E020      LDI	R18,0
    1A19 E73F      LDI	R19,0x7F
    1A1A E404      LDI	R16,0x44
    1A1B DD86      RCALL	_LCD_WR_CMD
(0424) 	LCD_WR_CMD(0x45,239*256+80);			 //垂直显示区域
    1A1C E520      LDI	R18,0x50
    1A1D EE3F      LDI	R19,0xEF
    1A1E E405      LDI	R16,0x45
    1A1F DD82      RCALL	_LCD_WR_CMD
(0425) 	LCD_WR_CMD(0x21,80*256);				 //显示RAM起始位置，大屏起始点为0x5000
    1A20 E020      LDI	R18,0
    1A21 E530      LDI	R19,0x50
    1A22 E201      LDI	R16,0x21
    1A23 DD7E      RCALL	_LCD_WR_CMD
(0426) 	LCD_WR_REG(0x22);                     	 //执行写数据到GRAM操作
    1A24 E202      LDI	R16,0x22
    1A25 DCDD      RCALL	_LCD_WR_REG
(0427)     LCD_EC0;
    1A26 9180 0062 LDS	R24,0x0062
    1A28 7F87      ANDI	R24,0xF7
    1A29 9380 0062 STS	0x0062,R24
(0428) 	LCD_RS1;
    1A2B 9180 0062 LDS	R24,0x0062
    1A2D 6082      ORI	R24,2
    1A2E 9380 0062 STS	0x0062,R24
(0429) 	for(num=160*128;num>0;num--)
    1A30 E040      LDI	R20,0
    1A31 E550      LDI	R21,0x50
    1A32 C004      RJMP	0x1A37
(0430) 	{
(0431) 		LCD_WR_Data(back_color);
    1A33 0185      MOVW	R16,R10
    1A34 DDDA      RCALL	_LCD_WR_Data
    1A35 5041      SUBI	R20,1
    1A36 4050      SBCI	R21,0
    1A37 3040      CPI	R20,0
    1A38 0745      CPC	R20,R21
    1A39 F7C9      BNE	0x1A33
(0432) 	}
(0433) 	LCD_EC1;
    1A3A 9180 0062 LDS	R24,0x0062
    1A3C 6088      ORI	R24,0x8
    1A3D 9380 0062 STS	0x0062,R24
    1A3F 940C 21BD JMP	pop_xgset300C
_GUIpoint:
  point_color          --> Y,+2
  y                    --> R12
  x                    --> R10
    1A41 92AA      ST	R10,-Y
    1A42 92CA      ST	R12,-Y
    1A43 2EC2      MOV	R12,R18
    1A44 2EA0      MOV	R10,R16
(0434)   }
(0435) 
(0436) //***********************************************************************
(0437) //         大屏GUI打点函数，（x,y）为坐标
(0438) //***********************************************************************
(0439) 
(0440) void GUIpoint(uchar x,uchar y,uint point_color)                      //打点函数
(0441) {
(0442) 	
(0443) 	LCD_WR_CMD(0x44,127*256+0);              //水平显示区域
    1A45 E020      LDI	R18,0
    1A46 E73F      LDI	R19,0x7F
    1A47 E404      LDI	R16,0x44
    1A48 DD59      RCALL	_LCD_WR_CMD
(0444) 	LCD_WR_CMD(0x45,239*256+80);			 //垂直显示区域
    1A49 E520      LDI	R18,0x50
    1A4A EE3F      LDI	R19,0xEF
    1A4B E405      LDI	R16,0x45
    1A4C DD55      RCALL	_LCD_WR_CMD
(0445) 	LCD_WR_CMD(0x21,(y+80)*256+x);			 //显示RAM起始位置，大屏起始点为0x5000
    1A4D 2D2C      MOV	R18,R12
    1A4E 2733      CLR	R19
    1A4F E000      LDI	R16,0
    1A50 E011      LDI	R17,1
    1A51 940E 2152 CALL	empy16s
    1A53 0198      MOVW	R18,R16
    1A54 5020      SUBI	R18,0
    1A55 4B30      SBCI	R19,0xB0
    1A56 2C2A      MOV	R2,R10
    1A57 2433      CLR	R3
    1A58 0D22      ADD	R18,R2
    1A59 1D33      ADC	R19,R3
    1A5A E201      LDI	R16,0x21
    1A5B DD46      RCALL	_LCD_WR_CMD
(0446) 	LCD_WR_REG(0x22);                     	 //执行写数据到GRAM操作
    1A5C E202      LDI	R16,0x22
    1A5D DCA5      RCALL	_LCD_WR_REG
(0447) 	LCD_EC0;
    1A5E 9180 0062 LDS	R24,0x0062
    1A60 7F87      ANDI	R24,0xF7
    1A61 9380 0062 STS	0x0062,R24
(0448) 	LCD_RS1;
    1A63 9180 0062 LDS	R24,0x0062
    1A65 6082      ORI	R24,2
    1A66 9380 0062 STS	0x0062,R24
(0449) 	
(0450) 	LCD_WR_Data(point_color);               //打点颜色	
    1A68 810A      LDD	R16,Y+2
    1A69 811B      LDD	R17,Y+3
    1A6A DDA4      RCALL	_LCD_WR_Data
(0451) 	
(0452) 	LCD_EC1;	
    1A6B 9180 0062 LDS	R24,0x0062
    1A6D 6088      ORI	R24,0x8
    1A6E 9380 0062 STS	0x0062,R24
    1A70 90C9      LD	R12,Y+
    1A71 90A9      LD	R10,Y+
    1A72 9508      RET
_GUIline:
  temp                 --> R14
  dy                   --> R20
  dx                   --> R20
  s2                   --> Y,+4
  s1                   --> Y,+2
  status               --> R20
  i                    --> R14
  Dx                   --> R10
  Dy                   --> R12
  sub                  --> R22
  line_color           --> Y,+24
  y1                   --> R12
  x1                   --> R10
  y0                   --> Y,+18
  x0                   --> Y,+16
    1A73 940E 20C0 CALL	push_arg4
    1A75 940E 21AD CALL	push_xgsetF0FC
    1A77 9726      SBIW	R28,6
    1A78 88AC      LDD	R10,Y+20
    1A79 88CE      LDD	R12,Y+22
(0453) }
(0454) 
(0455) 
(0456) 
(0457) //***********************************************************************
(0458) //         大屏GUI画线函数，（x0,y0）为起始坐标,（x1,y1）为终点坐标
(0459) //		   line_color 线的颜色
(0460) //***********************************************************************
(0461) 
(0462) void GUIline(uchar x0,uchar y0,uchar x1,uchar y1,uint line_color)   //画线函数
(0463) {
(0464)   	int temp; 
(0465)     int dx,dy;               	//定义起点到终点的横、纵坐标增加值 
(0466)     int s1,s2,status,i; 
(0467)     int Dx,Dy,sub; 
(0468) 	
(0469) 	dx = x1 - x0; 
    1A7A 8828      LDD	R2,Y+16
    1A7B 2433      CLR	R3
    1A7C 2D4A      MOV	R20,R10
    1A7D 2755      CLR	R21
    1A7E 1942      SUB	R20,R2
    1A7F 0953      SBC	R21,R3
(0470)     if(dx >= 0)                 //X的方向是增加的 
    1A80 3040      CPI	R20,0
    1A81 E0E0      LDI	R30,0
    1A82 075E      CPC	R21,R30
    1A83 F02C      BLT	0x1A89
(0471)         s1 = 1; 
    1A84 E081      LDI	R24,1
    1A85 E090      LDI	R25,0
    1A86 839B      STD	Y+3,R25
    1A87 838A      STD	Y+2,R24
    1A88 C004      RJMP	0x1A8D
(0472)     else                     	//X的方向是降低的 
(0473)         s1 = -1;      
    1A89 EF8F      LDI	R24,0xFF
    1A8A EF9F      LDI	R25,0xFF
    1A8B 839B      STD	Y+3,R25
    1A8C 838A      STD	Y+2,R24
(0474)     dy = y1 - y0;                 //判断Y的方向是增加还是降到的 
    1A8D 882A      LDD	R2,Y+18
    1A8E 2433      CLR	R3
    1A8F 2D4C      MOV	R20,R12
    1A90 2755      CLR	R21
    1A91 1942      SUB	R20,R2
    1A92 0953      SBC	R21,R3
(0475)     if(dy >= 0) 
    1A93 3040      CPI	R20,0
    1A94 E0E0      LDI	R30,0
    1A95 075E      CPC	R21,R30
    1A96 F02C      BLT	0x1A9C
(0476)         s2 = 1; 
    1A97 E081      LDI	R24,1
    1A98 E090      LDI	R25,0
    1A99 839D      STD	Y+5,R25
    1A9A 838C      STD	Y+4,R24
    1A9B C004      RJMP	0x1AA0
(0477)     else 
(0478)         s2 =- 1; 
    1A9C EF8F      LDI	R24,0xFF
    1A9D EF9F      LDI	R25,0xFF
    1A9E 839D      STD	Y+5,R25
    1A9F 838C      STD	Y+4,R24
(0479)    
(0480)     Dx = abs(x1-x0);             //计算横、纵标志增加值的绝对值 
    1AA0 8828      LDD	R2,Y+16
    1AA1 2433      CLR	R3
    1AA2 2D0A      MOV	R16,R10
    1AA3 2711      CLR	R17
    1AA4 1902      SUB	R16,R2
    1AA5 0913      SBC	R17,R3
    1AA6 940E 2095 CALL	_abs
    1AA8 0158      MOVW	R10,R16
(0481)     Dy = abs(y1-y0); 
    1AA9 882A      LDD	R2,Y+18
    1AAA 2433      CLR	R3
    1AAB 2D0C      MOV	R16,R12
    1AAC 2711      CLR	R17
    1AAD 1902      SUB	R16,R2
    1AAE 0913      SBC	R17,R3
    1AAF 940E 2095 CALL	_abs
    1AB1 0168      MOVW	R12,R16
(0482)         
(0483)     if(Dy > Dx)                               
    1AB2 16A0      CP	R10,R16
    1AB3 06B1      CPC	R11,R17
    1AB4 F434      BGE	0x1ABB
(0484)     {                     		//以45度角为分界线，靠进Y轴是status=1,靠近X轴是status=0  
(0485)         temp = Dx; 
    1AB5 0175      MOVW	R14,R10
(0486)         Dx = Dy; 
    1AB6 0156      MOVW	R10,R12
(0487)         Dy = temp; 
    1AB7 0167      MOVW	R12,R14
(0488)     status = 1; 
    1AB8 E041      LDI	R20,1
    1AB9 E050      LDI	R21,0
(0489)     }  
    1ABA C002      RJMP	0x1ABD
(0490)     else 
(0491)         status = 0; 
    1ABB 2744      CLR	R20
    1ABC 2755      CLR	R21
(0492) 
(0493) /*********Bresenham算法画任意两点间的直线********/  
(0494)     sub = Dy + Dy - Dx;                 //第1次判断下个点的位置 
    1ABD 01B6      MOVW	R22,R12
    1ABE 0D6C      ADD	R22,R12
    1ABF 1D7D      ADC	R23,R13
    1AC0 196A      SUB	R22,R10
    1AC1 097B      SBC	R23,R11
(0495)     for(i = 0;i < Dx;i ++) 
    1AC2 24EE      CLR	R14
    1AC3 24FF      CLR	R15
    1AC4 C03E      RJMP	0x1B03
(0496)     {  
(0497)         GUIpoint(x0,y0,line_color);           //画点  
    1AC5 8C08      LDD	R0,Y+24
    1AC6 8C19      LDD	R1,Y+25
    1AC7 8219      STD	Y+1,R1
    1AC8 8208      STD	Y+0,R0
    1AC9 892A      LDD	R18,Y+18
    1ACA 8908      LDD	R16,Y+16
    1ACB DF75      RCALL	_GUIpoint
(0498)         if(sub >= 0)                                
    1ACC 3060      CPI	R22,0
    1ACD E0E0      LDI	R30,0
    1ACE 077E      CPC	R23,R30
    1ACF F0C4      BLT	0x1AE8
(0499)         {  
(0500)             if(status == 1)               //在靠近Y轴区，x值加1 
    1AD0 3041      CPI	R20,1
    1AD1 E0E0      LDI	R30,0
    1AD2 075E      CPC	R21,R30
    1AD3 F441      BNE	0x1ADC
(0501)                 x0 += s1;  
    1AD4 8828      LDD	R2,Y+16
    1AD5 2433      CLR	R3
    1AD6 800A      LDD	R0,Y+2
    1AD7 801B      LDD	R1,Y+3
    1AD8 0C20      ADD	R2,R0
    1AD9 1C31      ADC	R3,R1
    1ADA 8A28      STD	Y+16,R2
    1ADB C007      RJMP	0x1AE3
(0502)             else                     //在靠近X轴区，y值加1                
(0503)                 y0 += s2;  
    1ADC 882A      LDD	R2,Y+18
    1ADD 2433      CLR	R3
    1ADE 800C      LDD	R0,Y+4
    1ADF 801D      LDD	R1,Y+5
    1AE0 0C20      ADD	R2,R0
    1AE1 1C31      ADC	R3,R1
    1AE2 8A2A      STD	Y+18,R2
(0504)             sub -= (Dx + Dx);                 //判断下下个点的位置  
    1AE3 0115      MOVW	R2,R10
    1AE4 0C2A      ADD	R2,R10
    1AE5 1C3B      ADC	R3,R11
    1AE6 1962      SUB	R22,R2
    1AE7 0973      SBC	R23,R3
(0505)         }  
(0506)         if(status == 1) 
    1AE8 3041      CPI	R20,1
    1AE9 E0E0      LDI	R30,0
    1AEA 075E      CPC	R21,R30
    1AEB F441      BNE	0x1AF4
(0507)             y0 += s2;  
    1AEC 882A      LDD	R2,Y+18
    1AED 2433      CLR	R3
    1AEE 800C      LDD	R0,Y+4
    1AEF 801D      LDD	R1,Y+5
    1AF0 0C20      ADD	R2,R0
    1AF1 1C31      ADC	R3,R1
    1AF2 8A2A      STD	Y+18,R2
    1AF3 C007      RJMP	0x1AFB
(0508)         else        
(0509)             x0 += s1;  
    1AF4 8828      LDD	R2,Y+16
    1AF5 2433      CLR	R3
    1AF6 800A      LDD	R0,Y+2
    1AF7 801B      LDD	R1,Y+3
    1AF8 0C20      ADD	R2,R0
    1AF9 1C31      ADC	R3,R1
    1AFA 8A28      STD	Y+16,R2
(0510)         sub += Dy + Dy;  
    1AFB 0116      MOVW	R2,R12
    1AFC 0C2C      ADD	R2,R12
    1AFD 1C3D      ADC	R3,R13
    1AFE 0D62      ADD	R22,R2
    1AFF 1D73      ADC	R23,R3
    1B00 01C7      MOVW	R24,R14
    1B01 9601      ADIW	R24,1
    1B02 017C      MOVW	R14,R24
    1B03 14EA      CP	R14,R10
    1B04 04FB      CPC	R15,R11
    1B05 F40C      BGE	0x1B07
    1B06 CFBE      RJMP	0x1AC5
    1B07 9626      ADIW	R28,6
    1B08 940E 21A2 CALL	pop_xgsetF0FC
    1B0A 9624      ADIW	R28,4
    1B0B 9508      RET
_GUIfull:
  j                    --> R10
  i                    --> R14
  full_colour          --> Y,+12
  y1                   --> Y,+10
  x1                   --> Y,+8
  y0                   --> R14
  x0                   --> R12
    1B0C 940E 21B1 CALL	push_xgset00FC
    1B0E 2EE2      MOV	R14,R18
    1B0F 2EC0      MOV	R12,R16
    1B10 9722      SBIW	R28,2
(0511)          
(0512)     }  
(0513) } 
(0514) 
(0515) /**************************************************************************** 
(0516) * 名称：GUI_Full(unsigned char x0,unsigned char y0,unsigned char x1,unsigned char y1,unsigned char full_colour) 
(0517) * 功能：用绘图的方法填充一个矩形 
(0518) * 入口参数：x0 			起始点横坐标 
(0519) *           y0    		起始点纵坐标 
(0520) *           x1 			终止点横坐标 
(0521) *           y1      	终止点纵坐标 
(0522) *          full_color      	显示颜色 
(0523) * 出口参数：无 
(0524) ****************************************************************************/ 
(0525) void GUIfull(uchar x0,uchar y0,uchar x1,uchar y1,uint full_colour) 
(0526) { 
(0527)     unsigned char i,j; 
(0528) for(j = y0;j <= y1;j ++) 
    1B11 2CAE      MOV	R10,R14
    1B12 C012      RJMP	0x1B25
(0529)     for(i = x0;i <= x1;i ++) 
    1B13 2CEC      MOV	R14,R12
    1B14 C008      RJMP	0x1B1D
(0530)     GUIpoint(i,j,full_colour); 
    1B15 840C      LDD	R0,Y+12
    1B16 841D      LDD	R1,Y+13
    1B17 8219      STD	Y+1,R1
    1B18 8208      STD	Y+0,R0
    1B19 2D2A      MOV	R18,R10
    1B1A 2D0E      MOV	R16,R14
    1B1B DF25      RCALL	_GUIpoint
    1B1C 94E3      INC	R14
    1B1D 8428      LDD	R2,Y+8
    1B1E 2433      CLR	R3
    1B1F 2C4E      MOV	R4,R14
    1B20 2455      CLR	R5
    1B21 1424      CP	R2,R4
    1B22 0435      CPC	R3,R5
    1B23 F78C      BGE	0x1B15
    1B24 94A3      INC	R10
    1B25 842A      LDD	R2,Y+10
    1B26 2433      CLR	R3
    1B27 2C4A      MOV	R4,R10
    1B28 2455      CLR	R5
    1B29 1424      CP	R2,R4
    1B2A 0435      CPC	R3,R5
    1B2B F73C      BGE	0x1B13
    1B2C 9622      ADIW	R28,2
    1B2D 940C 219B JMP	pop_xgset00FC
_plotC:
  yc_colour            --> R22
  yc                   --> R14
  xc                   --> R12
  y                    --> R10
  x                    --> R20
    1B2F 940E 21AD CALL	push_xgsetF0FC
    1B31 2EA2      MOV	R10,R18
    1B32 2F40      MOV	R20,R16
    1B33 9722      SBIW	R28,2
    1B34 84CC      LDD	R12,Y+12
    1B35 84EE      LDD	R14,Y+14
    1B36 84FF      LDD	R15,Y+15
    1B37 8968      LDD	R22,Y+16
    1B38 8979      LDD	R23,Y+17
(0531) } 
(0532) 
(0533) 
(0534) /**************************************************************************** 
(0535) * 名称：plotC(int x,int y,int xc,int yc,unsigned char yc_colour) 
(0536) * 功能：八分点画圆函数 
(0537) * 入口参数：x    		指定线起点所在行的位置 
(0538) *           y    		指定线起点所在列的位置 
(0539) *          yc_color 	显示颜色,根据彩色代码设定 
(0540) * 出口参数：无 
(0541) ****************************************************************************/ 
(0542) void plotC(uchar x,uchar y,uchar xc,int yc,uint yc_colour) 
(0543) { 
(0544)     GUIpoint(xc+x,yc+y,yc_colour); 
    1B39 8379      STD	Y+1,R23
    1B3A 8368      STD	Y+0,R22
    1B3B 2C2A      MOV	R2,R10
    1B3C 2433      CLR	R3
    1B3D 0197      MOVW	R18,R14
    1B3E 0D22      ADD	R18,R2
    1B3F 1D33      ADC	R19,R3
    1B40 2D0C      MOV	R16,R12
    1B41 0F04      ADD	R16,R20
    1B42 DEFE      RCALL	_GUIpoint
(0545)     GUIpoint(xc+x,yc-y,yc_colour); 
    1B43 8379      STD	Y+1,R23
    1B44 8368      STD	Y+0,R22
    1B45 2C2A      MOV	R2,R10
    1B46 2433      CLR	R3
    1B47 0197      MOVW	R18,R14
    1B48 1922      SUB	R18,R2
    1B49 0933      SBC	R19,R3
    1B4A 2D0C      MOV	R16,R12
    1B4B 0F04      ADD	R16,R20
    1B4C DEF4      RCALL	_GUIpoint
(0546)     GUIpoint(xc-x,yc+y,yc_colour); 
    1B4D 8379      STD	Y+1,R23
    1B4E 8368      STD	Y+0,R22
    1B4F 2C2A      MOV	R2,R10
    1B50 2433      CLR	R3
    1B51 0197      MOVW	R18,R14
    1B52 0D22      ADD	R18,R2
    1B53 1D33      ADC	R19,R3
    1B54 2D0C      MOV	R16,R12
    1B55 1B04      SUB	R16,R20
    1B56 DEEA      RCALL	_GUIpoint
(0547)     GUIpoint(xc-x,yc-y,yc_colour); 
    1B57 8379      STD	Y+1,R23
    1B58 8368      STD	Y+0,R22
    1B59 2C2A      MOV	R2,R10
    1B5A 2433      CLR	R3
    1B5B 0197      MOVW	R18,R14
    1B5C 1922      SUB	R18,R2
    1B5D 0933      SBC	R19,R3
    1B5E 2D0C      MOV	R16,R12
    1B5F 1B04      SUB	R16,R20
    1B60 DEE0      RCALL	_GUIpoint
(0548)     GUIpoint(xc+y,yc+x,yc_colour); 
    1B61 8379      STD	Y+1,R23
    1B62 8368      STD	Y+0,R22
    1B63 2E24      MOV	R2,R20
    1B64 2433      CLR	R3
    1B65 0197      MOVW	R18,R14
    1B66 0D22      ADD	R18,R2
    1B67 1D33      ADC	R19,R3
    1B68 2D0C      MOV	R16,R12
    1B69 0D0A      ADD	R16,R10
    1B6A DED6      RCALL	_GUIpoint
(0549)     GUIpoint(xc+y,yc-x,yc_colour); 
    1B6B 8379      STD	Y+1,R23
    1B6C 8368      STD	Y+0,R22
    1B6D 2E24      MOV	R2,R20
    1B6E 2433      CLR	R3
    1B6F 0197      MOVW	R18,R14
    1B70 1922      SUB	R18,R2
    1B71 0933      SBC	R19,R3
    1B72 2D0C      MOV	R16,R12
    1B73 0D0A      ADD	R16,R10
    1B74 DECC      RCALL	_GUIpoint
(0550)     GUIpoint(xc-y,yc+x,yc_colour); 
    1B75 8379      STD	Y+1,R23
    1B76 8368      STD	Y+0,R22
    1B77 2E24      MOV	R2,R20
    1B78 2433      CLR	R3
    1B79 0197      MOVW	R18,R14
    1B7A 0D22      ADD	R18,R2
    1B7B 1D33      ADC	R19,R3
    1B7C 2D0C      MOV	R16,R12
    1B7D 190A      SUB	R16,R10
    1B7E DEC2      RCALL	_GUIpoint
(0551)     GUIpoint(xc-y,yc-x,yc_colour); 
    1B7F 8379      STD	Y+1,R23
    1B80 8368      STD	Y+0,R22
    1B81 2E24      MOV	R2,R20
    1B82 2433      CLR	R3
    1B83 0197      MOVW	R18,R14
    1B84 1922      SUB	R18,R2
    1B85 0933      SBC	R19,R3
    1B86 2D0C      MOV	R16,R12
    1B87 190A      SUB	R16,R10
    1B88 DEB8      RCALL	_GUIpoint
    1B89 9622      ADIW	R28,2
    1B8A 940C 21A2 JMP	pop_xgsetF0FC
_GUIcircle:
  d                    --> R10
  y                    --> R22
  x                    --> R20
  circle_colour        --> Y,+18
  r                    --> R10
  yc                   --> R12
  xc                   --> R14
    1B8C 940E 21AD CALL	push_xgsetF0FC
    1B8E 2EC2      MOV	R12,R18
    1B8F 2EE0      MOV	R14,R16
    1B90 9726      SBIW	R28,6
    1B91 88A8      LDD	R10,Y+16
(0552) } 
(0553) 
(0554) /**************************************************************************** 
(0555) * 名称：GUI_Circle(int xc,int yc,int r,unsigned char circle_colour) 
(0556) * 功能：画圆 
(0557) * 入口参数：xc 				圆心的行坐标 
(0558) *           yc    			圆心的列坐标 
(0559) *           r 				半径 
(0560) *          circle_color     显示颜色 
(0561) * 出口参数：无 
(0562) ****************************************************************************/ 
(0563) void GUIcircle(uchar xc,uchar yc,uchar r,uint circle_colour) 
(0564) { 
(0565)     int x,y,d; 
(0566)     y = r; 
    1B92 2D6A      MOV	R22,R10
    1B93 2777      CLR	R23
(0567)     d = 3 - (r + r); 
    1B94 2C2A      MOV	R2,R10
    1B95 2433      CLR	R3
    1B96 2C42      MOV	R4,R2
    1B97 2455      CLR	R5
    1B98 0C42      ADD	R4,R2
    1B99 1C53      ADC	R5,R3
    1B9A E083      LDI	R24,3
    1B9B E090      LDI	R25,0
    1B9C 015C      MOVW	R10,R24
    1B9D 18A4      SUB	R10,R4
    1B9E 08B5      SBC	R11,R5
(0568)     x = 0; 
    1B9F 2744      CLR	R20
    1BA0 2755      CLR	R21
    1BA1 C02D      RJMP	0x1BCF
(0569)     while(x <= y) 
(0570)     { 
(0571)         plotC(x,y,xc,yc,circle_colour); 
    1BA2 880A      LDD	R0,Y+18
    1BA3 881B      LDD	R1,Y+19
    1BA4 821D      STD	Y+5,R1
    1BA5 820C      STD	Y+4,R0
    1BA6 2C2C      MOV	R2,R12
    1BA7 2433      CLR	R3
    1BA8 823B      STD	Y+3,R3
    1BA9 822A      STD	Y+2,R2
    1BAA 82E8      STD	Y+0,R14
    1BAB 2F26      MOV	R18,R22
    1BAC 2F04      MOV	R16,R20
    1BAD DF81      RCALL	_plotC
(0572)         if(d < 0) 
    1BAE 01C5      MOVW	R24,R10
    1BAF 3080      CPI	R24,0
    1BB0 E0E0      LDI	R30,0
    1BB1 079E      CPC	R25,R30
    1BB2 F45C      BGE	0x1BBE
(0573)             d += (x + x + x + x) + 6; 
    1BB3 01CA      MOVW	R24,R20
    1BB4 0F84      ADD	R24,R20
    1BB5 1F95      ADC	R25,R21
    1BB6 0F84      ADD	R24,R20
    1BB7 1F95      ADC	R25,R21
    1BB8 0F84      ADD	R24,R20
    1BB9 1F95      ADC	R25,R21
    1BBA 9606      ADIW	R24,6
    1BBB 0EA8      ADD	R10,R24
    1BBC 1EB9      ADC	R11,R25
    1BBD C00F      RJMP	0x1BCD
(0574)         else 
(0575)         { 
(0576)             d+=((x - y) + (x - y) + (x - y) + (x - y)) + 10; 
    1BBE 011A      MOVW	R2,R20
    1BBF 1A26      SUB	R2,R22
    1BC0 0A37      SBC	R3,R23
    1BC1 01C1      MOVW	R24,R2
    1BC2 0D82      ADD	R24,R2
    1BC3 1D93      ADC	R25,R3
    1BC4 0D82      ADD	R24,R2
    1BC5 1D93      ADC	R25,R3
    1BC6 0D82      ADD	R24,R2
    1BC7 1D93      ADC	R25,R3
    1BC8 960A      ADIW	R24,0xA
    1BC9 0EA8      ADD	R10,R24
    1BCA 1EB9      ADC	R11,R25
(0577)             y = y - 1; 
    1BCB 5061      SUBI	R22,1
    1BCC 4070      SBCI	R23,0
(0578)         } 
(0579)         x = x + 1; 
    1BCD 5F4F      SUBI	R20,0xFF
    1BCE 4F5F      SBCI	R21,0xFF
    1BCF 1764      CP	R22,R20
    1BD0 0775      CPC	R23,R21
    1BD1 F684      BGE	0x1BA2
    1BD2 9626      ADIW	R28,6
    1BD3 940C 21A2 JMP	pop_xgsetF0FC
_GUI_sprintf_nu:
  color                --> Y,+8
  nu                   --> Y,+6
  y                    --> R12
  x                    --> R10
    1BD5 92AA      ST	R10,-Y
    1BD6 92CA      ST	R12,-Y
    1BD7 0169      MOVW	R12,R18
    1BD8 0158      MOVW	R10,R16
    1BD9 9724      SBIW	R28,4
(0580)     } 
(0581) }
(0582) 
(0583) /*********************************************
(0584) //显示数字函数
(0585) //(x，y)点的坐标量，nu数字值,color颜色,b_color背景颜色
(0586) **********************************************/
(0587) void  GUI_sprintf_nu(uint x, uint y,uint nu, uint color)
(0588) {  
(0589)   DisplayChar(nu+'0',x,y,color);
    1BDA 8408      LDD	R0,Y+8
    1BDB 8419      LDD	R1,Y+9
    1BDC 821B      STD	Y+3,R1
    1BDD 820A      STD	Y+2,R0
    1BDE 82C8      STD	Y+0,R12
    1BDF 2D2A      MOV	R18,R10
    1BE0 810E      LDD	R16,Y+6
    1BE1 811F      LDD	R17,Y+7
    1BE2 5D00      SUBI	R16,0xD0
    1BE3 4F1F      SBCI	R17,0xFF
    1BE4 DD2E      RCALL	_DisplayChar
    1BE5 9624      ADIW	R28,4
    1BE6 90C9      LD	R12,Y+
    1BE7 90A9      LD	R10,Y+
    1BE8 9508      RET
_GUI_sprintf_chartobit:
  i                    --> R20
  color                --> R12
  bin_data             --> Y,+12
  y                    --> R10
  x                    --> R22
    1BE9 940E 21E8 CALL	push_xgsetF03C
    1BEB 0159      MOVW	R10,R18
    1BEC 01B8      MOVW	R22,R16
    1BED 9724      SBIW	R28,4
    1BEE 84CE      LDD	R12,Y+14
    1BEF 84DF      LDD	R13,Y+15
(0590) }
(0591) 
(0592) /**********************************************************
(0593) //写入二进制字符
(0594) //(x，y)开始点的坐标量，color 线的颜色，
(0595) ************************************************************/
(0596) void  GUI_sprintf_chartobit(uint x, uint y,uint bin_data, uint color)
(0597) {  
(0598)   uint i ;
(0599)   for(i=0;i<8;i++)
    1BF0 2744      CLR	R20
    1BF1 2755      CLR	R21
    1BF2 C023      RJMP	0x1C16
(0600)     {
(0601) 	  if((bin_data&(0x80>>i))==(0x80>>i))
    1BF3 E800      LDI	R16,0x80
    1BF4 E010      LDI	R17,0
    1BF5 019A      MOVW	R18,R20
    1BF6 940E 20C5 CALL	asr16
    1BF8 842C      LDD	R2,Y+12
    1BF9 843D      LDD	R3,Y+13
    1BFA 2220      AND	R2,R16
    1BFB 2231      AND	R3,R17
    1BFC 1620      CP	R2,R16
    1BFD 0631      CPC	R3,R17
    1BFE F451      BNE	0x1C09
(0602) 	    {
(0603) 		  GUI_sprintf_nu(x,y,1,color) ;
    1BFF 82DB      STD	Y+3,R13
    1C00 82CA      STD	Y+2,R12
    1C01 E081      LDI	R24,1
    1C02 E090      LDI	R25,0
    1C03 8399      STD	Y+1,R25
    1C04 8388      STD	Y+0,R24
    1C05 0195      MOVW	R18,R10
    1C06 018B      MOVW	R16,R22
    1C07 DFCD      RCALL	_GUI_sprintf_nu
(0604) 		}
    1C08 C009      RJMP	0x1C12
(0605) 	  else 
(0606) 	    {
(0607) 		  GUI_sprintf_nu(x,y,0,color) ;
    1C09 82DB      STD	Y+3,R13
    1C0A 82CA      STD	Y+2,R12
    1C0B 2422      CLR	R2
    1C0C 2433      CLR	R3
    1C0D 8239      STD	Y+1,R3
    1C0E 8228      STD	Y+0,R2
    1C0F 0195      MOVW	R18,R10
    1C10 018B      MOVW	R16,R22
    1C11 DFC3      RCALL	_GUI_sprintf_nu
(0608) 		}
(0609) 		
(0610) 	  x+=1 ;
    1C12 5F6F      SUBI	R22,0xFF
    1C13 4F7F      SBCI	R23,0xFF
    1C14 5F4F      SUBI	R20,0xFF
    1C15 4F5F      SBCI	R21,0xFF
    1C16 3048      CPI	R20,0x8
    1C17 E0E0      LDI	R30,0
    1C18 075E      CPC	R21,R30
    1C19 F2C8      BCS	0x1BF3
    1C1A 9624      ADIW	R28,4
    1C1B 940C 21F1 JMP	pop_xgsetF03C
_GUI_sprintf_chartohex:
  i                    --> Y,+5
  color                --> R12
  hex_data             --> R22
  y                    --> R10
  x                    --> R20
    1C1D 940E 21E8 CALL	push_xgsetF03C
    1C1F 0159      MOVW	R10,R18
    1C20 01A8      MOVW	R20,R16
    1C21 9724      SBIW	R28,4
    1C22 856C      LDD	R22,Y+12
    1C23 857D      LDD	R23,Y+13
    1C24 84CE      LDD	R12,Y+14
    1C25 84DF      LDD	R13,Y+15
(0611) 	}
(0612)  
(0613) }
(0614) 
(0615) 
(0616) /**********************************************************
(0617) //写入十六进制字符
(0618) //(x，y)开始点的坐标量，color 线的颜色，
(0619) ************************************************************/
(0620) void  GUI_sprintf_chartohex(uint x, uint y,uint hex_data, uint color)
(0621) {  
(0622)   uint i ;
(0623) 
(0624) 		  GUI_sprintf_nu(x,y,hex_data>>4,color) ;
    1C26 82DB      STD	Y+3,R13
    1C27 82CA      STD	Y+2,R12
    1C28 011B      MOVW	R2,R22
    1C29 9436      LSR	R3
    1C2A 9427      ROR	R2
    1C2B 9436      LSR	R3
    1C2C 9427      ROR	R2
    1C2D 9436      LSR	R3
    1C2E 9427      ROR	R2
    1C2F 9436      LSR	R3
    1C30 9427      ROR	R2
    1C31 8239      STD	Y+1,R3
    1C32 8228      STD	Y+0,R2
    1C33 0195      MOVW	R18,R10
    1C34 018A      MOVW	R16,R20
    1C35 DF9F      RCALL	_GUI_sprintf_nu
(0625) 		  x+=1 ;
    1C36 5F4F      SUBI	R20,0xFF
    1C37 4F5F      SBCI	R21,0xFF
(0626) 		  GUI_sprintf_nu(x,y,hex_data&0x0f,color) ;
    1C38 82DB      STD	Y+3,R13
    1C39 82CA      STD	Y+2,R12
    1C3A 01CB      MOVW	R24,R22
    1C3B 708F      ANDI	R24,0xF
    1C3C 7090      ANDI	R25,0
    1C3D 8399      STD	Y+1,R25
    1C3E 8388      STD	Y+0,R24
    1C3F 0195      MOVW	R18,R10
    1C40 018A      MOVW	R16,R20
    1C41 DF93      RCALL	_GUI_sprintf_nu
    1C42 9624      ADIW	R28,4
    1C43 940C 21F1 JMP	pop_xgsetF03C
_eeprom_read_byte:
  readtemp             --> R10
  addr                 --> R16
    1C45 92AA      ST	R10,-Y
FILE: E:\DMAVR-~3\ReadBmp\EEPROM.C
(0001) //DMAVR-128的读写EEPROM示例程序，记录CPU启动的次数到EEPROM中
(0002) //在LED数码管上显示读出的数据,可用复位键刷新显示
(0003) //编译环境 ICCAVR 7.16A
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //作者：阿迪 www.avrgcc.com
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <string.h>
(0012) #include <stdio.h>
(0013) #define	 F_CPU	7372800							// 单片机主频为7.3728MHz,用于延时子程序
(0014) //#include <delay.h>
(0015) #include <iom128v.h>
(0016) 
(0017) 
(0018) //***********************************************************************
(0019) //			定义变量区
(0020) //***********************************************************************
(0021) 
(0022) #define uchar           unsigned char
(0023) #define uint            unsigned int
(0024) 
(0025) 
(0026) 
(0027) //***********************************************************************
(0028) //                EEPROM读取函数*/
(0029) //            addr：地址；number：长度；p_buff：读出数据存放指针
(0030) //***********************************************************************
(0031)  eeprom_read_byte(unsigned int addr) 
(0032) {
(0033)    unsigned char readtemp;
(0034) 	while(EECR & (1 << EEWE));               //等待前面的写完成
    1C46 99E1      SBIC	0x1C,1
    1C47 CFFE      RJMP	0x1C46
(0035) 
(0036) 	EEARH = 0x00;                           //写高字节地址
    1C48 2422      CLR	R2
    1C49 BA2F      OUT	0x1F,R2
(0037) 	
(0038) 		EEARL = addr;                 	//写地址低字节
    1C4A BB0E      OUT	0x1E,R16
(0039) 		EECR |= (1 << EERE);            	//读允许位置1
    1C4B 9AE0      SBI	0x1C,0
(0040) 		readtemp = EEDR;               	//读出EEDR中的数据
    1C4C B2AD      IN	R10,0x1D
(0041)    return readtemp;	
    1C4D 2D0A      MOV	R16,R10
    1C4E 2711      CLR	R17
    1C4F 90A9      LD	R10,Y+
    1C50 9508      RET
(0042) }
(0043) 
(0044) //***********************************************************************
(0045) //              EEPROM写入函数
(0046) //          addr：地址；number：长度；p_buff：写入数据存放指针
(0047) //***********************************************************************
(0048) void eeprom_write_byte(unsigned int addr, unsigned char p_buff) 
(0049) {
(0050) 
(0051) 	EEARH = 0x00;
_eeprom_write_byte:
  p_buff               --> R18
  addr                 --> R16
    1C51 2422      CLR	R2
    1C52 BA2F      OUT	0x1F,R2
(0052) 	
(0053) 	
(0054) 		while(EECR & (1 << EEWE));       //等待前面的写完成
    1C53 99E1      SBIC	0x1C,1
    1C54 CFFE      RJMP	0x1C53
(0055) 		EEARL = addr;                 //写地址
    1C55 BB0E      OUT	0x1E,R16
(0056) 		EEDR = p_buff;               //写数据到EEDR
    1C56 BB2D      OUT	0x1D,R18
(0057) 		EECR |= (1 << EEMWE);            //主机写入允许位
    1C57 9AE2      SBI	0x1C,2
(0058) 		EECR&=~(1<<EEWE);
    1C58 98E1      CBI	0x1C,1
(0059) 		EECR |= (1 << EEWE);             //EEWE为1，执行写操作
    1C59 9AE1      SBI	0x1C,1
    1C5A 9508      RET
_putchar$device_specific$:
_putchar:
  c                    --> R20
    1C5B 934A      ST	R20,-Y
    1C5C 2F40      MOV	R20,R16
FILE: E:\DMAVR-~3\ReadBmp\uart.c
(0001) //串口发送接收驱动程序
(0002) //采用标准输入输出格式进行打印，UART1输出，通过串口调试助手可以查看调试信息
(0003) //编译环境 ICCAVR 7.16A
(0004) //系统时钟7.3728MHZ，设置熔丝位为外部高频石英晶体振荡，启动时间4.1ms
(0005) //作者：阿迪 www.avrgcc.com
(0006) //日期：2010.01.14
(0007) //***********************************************************************
(0008) //			包含文件
(0009) //***********************************************************************
(0010) 
(0011) #include <stdio.h>
(0012) #include <string.h>
(0013) #include <iom128v.h>
(0014) 
(0015) #define uchar           unsigned char
(0016) #define uint            unsigned int
(0017) #define ulong           unsigned long
(0018) #define	F_CPU		   7372800		 						    //单片机主频为7.3728MHz
(0019) #define baud           9600                                     //设置波特率的大小
(0020) #define baud_setting   (uint)((ulong)F_CPU/(16*(ulong)baud)-1)  //波特率计算公式
(0021) #define baud_h         (uchar)(baud_setting>>8)                 //提取高位
(0022) #define baud_l         (uchar)(baud_setting)                    //低位
(0023) 
(0024) //***********************************************************************
(0025) // 用于输出的标准格式函数，用printf输出到UART1
(0026) //***********************************************************************
(0027) 
(0028) extern int _textmode;
(0029) 
(0030) int putchar(char c)
(0031)     {
(0032)     if (_textmode && c == '\n')
    1C5D 9020 0E2E LDS	R2,_textmode
    1C5F 9030 0E2F LDS	R3,_textmode+1
    1C61 2022      TST	R2
    1C62 F411      BNE	0x1C65
    1C63 2033      TST	R3
    1C64 F021      BEQ	0x1C69
    1C65 304A      CPI	R20,0xA
    1C66 F411      BNE	0x1C69
(0033)         putchar('\r');
    1C67 E00D      LDI	R16,0xD
    1C68 DFF2      RCALL	_putchar$device_specific$
(0034)     while ( !(UCSR1A & (1<<UDRE1)) )   // UDRE, data register empty
    1C69 9020 009B LDS	R2,0x009B
    1C6B FE25      SBRS	R2,5
    1C6C CFFC      RJMP	0x1C69
(0035)         ;
(0036)     UDR1 = c;
    1C6D 9340 009C STS	0x009C,R20
(0037)     return c;
    1C6F 2F04      MOV	R16,R20
    1C70 2711      CLR	R17
    1C71 9149      LD	R20,Y+
    1C72 9508      RET
(0038)     }
(0039) //***********************************************************************
(0040) // 用于输入的标准格式函数，用getchar通过UART1输入到单片机，代替C中的scanf
(0041) //***********************************************************************
(0042) 
(0043) int getchar(void)
(0044)     {
(0045)     while ((UCSR1A & 0x80) == 0)
_getchar$device_specific$:
_getchar:
    1C73 9020 009B LDS	R2,0x009B
    1C75 FE27      SBRS	R2,7
    1C76 CFFC      RJMP	_getchar$device_specific$
(0046)         ;
(0047)     return UDR1;
    1C77 9100 009C LDS	R16,0x009C
    1C79 2711      CLR	R17
    1C7A 9508      RET
(0048)     } 
(0049) //***********************************************************************
(0050) // 串口1初始化接口函数
(0051) // 初始化uart,查询方式读写
(0052) //***********************************************************************
(0053) void UART_Init(void)
(0054) {
(0055)  
(0056)   UCSR1B =(1<<RXEN1)|(1<<TXEN1);             		//发送接收使能
_UART_Init:
    1C7B E188      LDI	R24,0x18
    1C7C 9380 009A STS	0x009A,R24
(0057)   UBRR1H=baud_h;                                	//写波特率的值
    1C7E 2422      CLR	R2
    1C7F 9220 0098 STS	0x0098,R2
(0058)   UBRR1L=baud_l; 
FILE: <library>
    1C81 E28F      LDI	R24,0x2F
    1C82 9380 0099 STS	0x0099,R24
    1C84 9508      RET
__print:
    1C85 940E 20C0 CALL	push_arg4
    1C87 940E 21AD CALL	push_xgsetF0FC
    1C89 9762      SBIW	R28,0x12
    1C8A 2400      CLR	R0
    1C8B 2411      CLR	R1
    1C8C 861D      STD	Y+13,R1
    1C8D 860C      STD	Y+12,R0
    1C8E C3F9      RJMP	0x2088
    1C8F 8DEE      LDD	R30,Y+30
    1C90 8DFF      LDD	R31,Y+31
    1C91 8180      LDD	R24,Z+0
    1C92 3285      CPI	R24,0x25
    1C93 F059      BEQ	0x1C9F
    1C94 8100      LDD	R16,Z+0
    1C95 8DEC      LDD	R30,Y+28
    1C96 8DFD      LDD	R31,Y+29
    1C97 940E 21FA CALL	xicallx
    1C99 858C      LDD	R24,Y+12
    1C9A 859D      LDD	R25,Y+13
    1C9B 9601      ADIW	R24,1
    1C9C 879D      STD	Y+13,R25
    1C9D 878C      STD	Y+12,R24
    1C9E C3E4      RJMP	0x2083
    1C9F 2400      CLR	R0
    1CA0 2411      CLR	R1
    1CA1 861B      STD	Y+11,R1
    1CA2 860A      STD	Y+10,R0
    1CA3 EF8F      LDI	R24,0xFF
    1CA4 EF9F      LDI	R25,0xFF
    1CA5 879F      STD	Y+15,R25
    1CA6 878E      STD	Y+14,R24
    1CA7 2766      CLR	R22
    1CA8 2777      CLR	R23
    1CA9 E143      LDI	R20,0x13
    1CAA E05E      LDI	R21,0xE
    1CAB E280      LDI	R24,0x20
    1CAC 2EC8      MOV	R12,R24
    1CAD 8D8E      LDD	R24,Y+30
    1CAE 8D9F      LDD	R25,Y+31
    1CAF 9601      ADIW	R24,1
    1CB0 8F9F      STD	Y+31,R25
    1CB1 8F8E      STD	Y+30,R24
    1CB2 24AA      CLR	R10
    1CB3 24BB      CLR	R11
    1CB4 8DEE      LDD	R30,Y+30
    1CB5 8DFF      LDD	R31,Y+31
    1CB6 80E0      LDD	R14,Z+0
    1CB7 24FF      CLR	R15
    1CB8 01C7      MOVW	R24,R14
    1CB9 3280      CPI	R24,0x20
    1CBA E0E0      LDI	R30,0
    1CBB 079E      CPC	R25,R30
    1CBC F0F1      BEQ	0x1CDB
    1CBD 3283      CPI	R24,0x23
    1CBE E0E0      LDI	R30,0
    1CBF 079E      CPC	R25,R30
    1CC0 F091      BEQ	0x1CD3
    1CC1 3280      CPI	R24,0x20
    1CC2 E0E0      LDI	R30,0
    1CC3 079E      CPC	R25,R30
    1CC4 F0E4      BLT	0x1CE1
    1CC5 01C7      MOVW	R24,R14
    1CC6 328B      CPI	R24,0x2B
    1CC7 E0E0      LDI	R30,0
    1CC8 079E      CPC	R25,R30
    1CC9 F069      BEQ	0x1CD7
    1CCA 328D      CPI	R24,0x2D
    1CCB E0E0      LDI	R30,0
    1CCC 079E      CPC	R25,R30
    1CCD F039      BEQ	0x1CD5
    1CCE 3380      CPI	R24,0x30
    1CCF E0E0      LDI	R30,0
    1CD0 079E      CPC	R25,R30
    1CD1 F069      BEQ	0x1CDF
    1CD2 C00E      RJMP	0x1CE1
    1CD3 6061      ORI	R22,1
    1CD4 C00F      RJMP	0x1CE4
    1CD5 6064      ORI	R22,4
    1CD6 C00D      RJMP	0x1CE4
    1CD7 6068      ORI	R22,0x8
    1CD8 E28B      LDI	R24,0x2B
    1CD9 2EC8      MOV	R12,R24
    1CDA C009      RJMP	0x1CE4
    1CDB 6068      ORI	R22,0x8
    1CDC E280      LDI	R24,0x20
    1CDD 2EC8      MOV	R12,R24
    1CDE C005      RJMP	0x1CE4
    1CDF 6160      ORI	R22,0x10
    1CE0 C003      RJMP	0x1CE4
    1CE1 E081      LDI	R24,1
    1CE2 E090      LDI	R25,0
    1CE3 015C      MOVW	R10,R24
    1CE4 20AA      TST	R10
    1CE5 F411      BNE	0x1CE8
    1CE6 20BB      TST	R11
    1CE7 F009      BEQ	0x1CE9
    1CE8 C006      RJMP	0x1CEF
    1CE9 8D8E      LDD	R24,Y+30
    1CEA 8D9F      LDD	R25,Y+31
    1CEB 9601      ADIW	R24,1
    1CEC 8F9F      STD	Y+31,R25
    1CED 8F8E      STD	Y+30,R24
    1CEE CFC5      RJMP	0x1CB4
    1CEF 8DEE      LDD	R30,Y+30
    1CF0 8DFF      LDD	R31,Y+31
    1CF1 8100      LDD	R16,Z+0
    1CF2 2711      CLR	R17
    1CF3 940E 25C3 CALL	_isdigit
    1CF5 3000      CPI	R16,0
    1CF6 0701      CPC	R16,R17
    1CF7 F0B9      BEQ	0x1D0F
    1CF8 8D0E      LDD	R16,Y+30
    1CF9 8D1F      LDD	R17,Y+31
    1CFA 940E 23B3 CALL	_atoi
    1CFC 871B      STD	Y+11,R17
    1CFD 870A      STD	Y+10,R16
    1CFE C005      RJMP	0x1D04
    1CFF 8D8E      LDD	R24,Y+30
    1D00 8D9F      LDD	R25,Y+31
    1D01 9601      ADIW	R24,1
    1D02 8F9F      STD	Y+31,R25
    1D03 8F8E      STD	Y+30,R24
    1D04 8DEE      LDD	R30,Y+30
    1D05 8DFF      LDD	R31,Y+31
    1D06 8100      LDD	R16,Z+0
    1D07 2711      CLR	R17
    1D08 940E 25C3 CALL	_isdigit
    1D0A 0158      MOVW	R10,R16
    1D0B 3000      CPI	R16,0
    1D0C 0701      CPC	R16,R17
    1D0D F789      BNE	0x1CFF
    1D0E C015      RJMP	0x1D24
    1D0F 8DEE      LDD	R30,Y+30
    1D10 8DFF      LDD	R31,Y+31
    1D11 8180      LDD	R24,Z+0
    1D12 328A      CPI	R24,0x2A
    1D13 F481      BNE	0x1D24
    1D14 A188      LDD	R24,Y+32
    1D15 A199      LDD	R25,Y+33
    1D16 9602      ADIW	R24,2
    1D17 A399      STD	Y+33,R25
    1D18 A388      STD	Y+32,R24
    1D19 01FC      MOVW	R30,R24
    1D1A 9732      SBIW	R30,2
    1D1B 8020      LDD	R2,Z+0
    1D1C 8031      LDD	R3,Z+1
    1D1D 863B      STD	Y+11,R3
    1D1E 862A      STD	Y+10,R2
    1D1F 8D8E      LDD	R24,Y+30
    1D20 8D9F      LDD	R25,Y+31
    1D21 9601      ADIW	R24,1
    1D22 8F9F      STD	Y+31,R25
    1D23 8F8E      STD	Y+30,R24
    1D24 8DEE      LDD	R30,Y+30
    1D25 8DFF      LDD	R31,Y+31
    1D26 8180      LDD	R24,Z+0
    1D27 328E      CPI	R24,0x2E
    1D28 F009      BEQ	0x1D2A
    1D29 C03A      RJMP	0x1D64
    1D2A 01CF      MOVW	R24,R30
    1D2B 9601      ADIW	R24,1
    1D2C 8F9F      STD	Y+31,R25
    1D2D 8F8E      STD	Y+30,R24
    1D2E 01FC      MOVW	R30,R24
    1D2F 8100      LDD	R16,Z+0
    1D30 2711      CLR	R17
    1D31 940E 25C3 CALL	_isdigit
    1D33 0158      MOVW	R10,R16
    1D34 3000      CPI	R16,0
    1D35 0701      CPC	R16,R17
    1D36 F0C1      BEQ	0x1D4F
    1D37 8D0E      LDD	R16,Y+30
    1D38 8D1F      LDD	R17,Y+31
    1D39 940E 23B3 CALL	_atoi
    1D3B 0158      MOVW	R10,R16
    1D3C 86BF      STD	Y+15,R11
    1D3D 86AE      STD	Y+14,R10
    1D3E C005      RJMP	0x1D44
    1D3F 8D8E      LDD	R24,Y+30
    1D40 8D9F      LDD	R25,Y+31
    1D41 9601      ADIW	R24,1
    1D42 8F9F      STD	Y+31,R25
    1D43 8F8E      STD	Y+30,R24
    1D44 8DEE      LDD	R30,Y+30
    1D45 8DFF      LDD	R31,Y+31
    1D46 8100      LDD	R16,Z+0
    1D47 2711      CLR	R17
    1D48 940E 25C3 CALL	_isdigit
    1D4A 0158      MOVW	R10,R16
    1D4B 3000      CPI	R16,0
    1D4C 0701      CPC	R16,R17
    1D4D F789      BNE	0x1D3F
    1D4E C015      RJMP	0x1D64
    1D4F 8DEE      LDD	R30,Y+30
    1D50 8DFF      LDD	R31,Y+31
    1D51 8180      LDD	R24,Z+0
    1D52 328A      CPI	R24,0x2A
    1D53 F481      BNE	0x1D64
    1D54 A188      LDD	R24,Y+32
    1D55 A199      LDD	R25,Y+33
    1D56 9602      ADIW	R24,2
    1D57 A399      STD	Y+33,R25
    1D58 A388      STD	Y+32,R24
    1D59 01FC      MOVW	R30,R24
    1D5A 9732      SBIW	R30,2
    1D5B 8020      LDD	R2,Z+0
    1D5C 8031      LDD	R3,Z+1
    1D5D 863F      STD	Y+15,R3
    1D5E 862E      STD	Y+14,R2
    1D5F 8D8E      LDD	R24,Y+30
    1D60 8D9F      LDD	R25,Y+31
    1D61 9601      ADIW	R24,1
    1D62 8F9F      STD	Y+31,R25
    1D63 8F8E      STD	Y+30,R24
    1D64 8DEE      LDD	R30,Y+30
    1D65 8DFF      LDD	R31,Y+31
    1D66 8180      LDD	R24,Z+0
    1D67 368C      CPI	R24,0x6C
    1D68 F429      BNE	0x1D6E
    1D69 01CF      MOVW	R24,R30
    1D6A 9601      ADIW	R24,1
    1D6B 8F9F      STD	Y+31,R25
    1D6C 8F8E      STD	Y+30,R24
    1D6D 6062      ORI	R22,2
    1D6E 8DEE      LDD	R30,Y+30
    1D6F 8DFF      LDD	R31,Y+31
    1D70 80A0      LDD	R10,Z+0
    1D71 24BB      CLR	R11
    1D72 01C5      MOVW	R24,R10
    1D73 3588      CPI	R24,0x58
    1D74 E0E0      LDI	R30,0
    1D75 079E      CPC	R25,R30
    1D76 F409      BNE	0x1D78
    1D77 C090      RJMP	0x1E08
    1D78 E588      LDI	R24,0x58
    1D79 158A      CP	R24,R10
    1D7A 059B      CPC	R25,R11
    1D7B F094      BLT	0x1D8E
    1D7C 01C5      MOVW	R24,R10
    1D7D 3485      CPI	R24,0x45
    1D7E E0E0      LDI	R30,0
    1D7F 079E      CPC	R25,R30
    1D80 F409      BNE	0x1D82
    1D81 C2FD      RJMP	0x207F
    1D82 3485      CPI	R24,0x45
    1D83 E0E0      LDI	R30,0
    1D84 079E      CPC	R25,R30
    1D85 F40C      BGE	0x1D87
    1D86 C040      RJMP	0x1DC7
    1D87 01C5      MOVW	R24,R10
    1D88 3583      CPI	R24,0x53
    1D89 E0E0      LDI	R30,0
    1D8A 079E      CPC	R25,R30
    1D8B F409      BNE	0x1D8D
    1D8C C16E      RJMP	0x1EFB
    1D8D C039      RJMP	0x1DC7
    1D8E 01C5      MOVW	R24,R10
    1D8F 3683      CPI	R24,0x63
    1D90 E0E0      LDI	R30,0
    1D91 079E      CPC	R25,R30
    1D92 F409      BNE	0x1D94
    1D93 C143      RJMP	0x1ED7
    1D94 3684      CPI	R24,0x64
    1D95 E0E0      LDI	R30,0
    1D96 079E      CPC	R25,R30
    1D97 F409      BNE	0x1D99
    1D98 C03B      RJMP	0x1DD4
    1D99 3685      CPI	R24,0x65
    1D9A E0E0      LDI	R30,0
    1D9B 079E      CPC	R25,R30
    1D9C F409      BNE	0x1D9E
    1D9D C2E1      RJMP	0x207F
    1D9E 3686      CPI	R24,0x66
    1D9F E0E0      LDI	R30,0
    1DA0 079E      CPC	R25,R30
    1DA1 F409      BNE	0x1DA3
    1DA2 C2DC      RJMP	0x207F
    1DA3 3689      CPI	R24,0x69
    1DA4 E0E0      LDI	R30,0
    1DA5 079E      CPC	R25,R30
    1DA6 F409      BNE	0x1DA8
    1DA7 C02C      RJMP	0x1DD4
    1DA8 368F      CPI	R24,0x6F
    1DA9 E0E0      LDI	R30,0
    1DAA 079E      CPC	R25,R30
    1DAB F409      BNE	0x1DAD
    1DAC C05B      RJMP	0x1E08
    1DAD 3780      CPI	R24,0x70
    1DAE E0E0      LDI	R30,0
    1DAF 079E      CPC	R25,R30
    1DB0 F409      BNE	0x1DB2
    1DB1 C056      RJMP	0x1E08
    1DB2 3683      CPI	R24,0x63
    1DB3 E0E0      LDI	R30,0
    1DB4 079E      CPC	R25,R30
    1DB5 F08C      BLT	0x1DC7
    1DB6 01C5      MOVW	R24,R10
    1DB7 3783      CPI	R24,0x73
    1DB8 E0E0      LDI	R30,0
    1DB9 079E      CPC	R25,R30
    1DBA F409      BNE	0x1DBC
    1DBB C1FE      RJMP	0x1FBA
    1DBC 3785      CPI	R24,0x75
    1DBD E0E0      LDI	R30,0
    1DBE 079E      CPC	R25,R30
    1DBF F409      BNE	0x1DC1
    1DC0 C047      RJMP	0x1E08
    1DC1 3788      CPI	R24,0x78
    1DC2 E0E0      LDI	R30,0
    1DC3 079E      CPC	R25,R30
    1DC4 F409      BNE	0x1DC6
    1DC5 C042      RJMP	0x1E08
    1DC6 C000      RJMP	0x1DC7
    1DC7 8DEE      LDD	R30,Y+30
    1DC8 8DFF      LDD	R31,Y+31
    1DC9 8100      LDD	R16,Z+0
    1DCA 8DEC      LDD	R30,Y+28
    1DCB 8DFD      LDD	R31,Y+29
    1DCC 940E 21FA CALL	xicallx
    1DCE 858C      LDD	R24,Y+12
    1DCF 859D      LDD	R25,Y+13
    1DD0 9601      ADIW	R24,1
    1DD1 879D      STD	Y+13,R25
    1DD2 878C      STD	Y+12,R24
    1DD3 C2AF      RJMP	0x2083
    1DD4 FF61      SBRS	R22,1
    1DD5 C01E      RJMP	0x1DF4
    1DD6 A188      LDD	R24,Y+32
    1DD7 A199      LDD	R25,Y+33
    1DD8 9604      ADIW	R24,4
    1DD9 A399      STD	Y+33,R25
    1DDA A388      STD	Y+32,R24
    1DDB 01FC      MOVW	R30,R24
    1DDC 9734      SBIW	R30,4
    1DDD 8020      LDD	R2,Z+0
    1DDE 8031      LDD	R3,Z+1
    1DDF 8042      LDD	R4,Z+2
    1DE0 8053      LDD	R5,Z+3
    1DE1 822E      STD	Y+6,R2
    1DE2 823F      STD	Y+7,R3
    1DE3 8648      STD	Y+8,R4
    1DE4 8659      STD	Y+9,R5
    1DE5 E08A      LDI	R24,0xA
    1DE6 E090      LDI	R25,0
    1DE7 839B      STD	Y+3,R25
    1DE8 838A      STD	Y+2,R24
    1DE9 802E      LDD	R2,Y+6
    1DEA 803F      LDD	R3,Y+7
    1DEB 8448      LDD	R4,Y+8
    1DEC 8459      LDD	R5,Y+9
    1DED 8248      STD	Y+0,R4
    1DEE 8259      STD	Y+1,R5
    1DEF 0191      MOVW	R18,R2
    1DF0 018A      MOVW	R16,R20
    1DF1 940E 2464 CALL	_ltoa
    1DF3 C0BF      RJMP	0x1EB3
    1DF4 A188      LDD	R24,Y+32
    1DF5 A199      LDD	R25,Y+33
    1DF6 9602      ADIW	R24,2
    1DF7 A399      STD	Y+33,R25
    1DF8 A388      STD	Y+32,R24
    1DF9 01FC      MOVW	R30,R24
    1DFA 9732      SBIW	R30,2
    1DFB 8020      LDD	R2,Z+0
    1DFC 8031      LDD	R3,Z+1
    1DFD 8A39      STD	Y+17,R3
    1DFE 8A28      STD	Y+16,R2
    1DFF E08A      LDI	R24,0xA
    1E00 E090      LDI	R25,0
    1E01 8399      STD	Y+1,R25
    1E02 8388      STD	Y+0,R24
    1E03 0191      MOVW	R18,R2
    1E04 018A      MOVW	R16,R20
    1E05 940E 23F9 CALL	_itoa
    1E07 C0AB      RJMP	0x1EB3
    1E08 FF61      SBRS	R22,1
    1E09 C010      RJMP	0x1E1A
    1E0A A188      LDD	R24,Y+32
    1E0B A199      LDD	R25,Y+33
    1E0C 9604      ADIW	R24,4
    1E0D A399      STD	Y+33,R25
    1E0E A388      STD	Y+32,R24
    1E0F 01FC      MOVW	R30,R24
    1E10 9734      SBIW	R30,4
    1E11 8020      LDD	R2,Z+0
    1E12 8031      LDD	R3,Z+1
    1E13 8042      LDD	R4,Z+2
    1E14 8053      LDD	R5,Z+3
    1E15 822E      STD	Y+6,R2
    1E16 823F      STD	Y+7,R3
    1E17 8648      STD	Y+8,R4
    1E18 8659      STD	Y+9,R5
    1E19 C00B      RJMP	0x1E25
    1E1A A188      LDD	R24,Y+32
    1E1B A199      LDD	R25,Y+33
    1E1C 9602      ADIW	R24,2
    1E1D A399      STD	Y+33,R25
    1E1E A388      STD	Y+32,R24
    1E1F 01FC      MOVW	R30,R24
    1E20 9732      SBIW	R30,2
    1E21 8020      LDD	R2,Z+0
    1E22 8031      LDD	R3,Z+1
    1E23 8A39      STD	Y+17,R3
    1E24 8A28      STD	Y+16,R2
    1E25 8DEE      LDD	R30,Y+30
    1E26 8DFF      LDD	R31,Y+31
    1E27 8180      LDD	R24,Z+0
    1E28 3785      CPI	R24,0x75
    1E29 F4D9      BNE	0x1E45
    1E2A FF61      SBRS	R22,1
    1E2B C00F      RJMP	0x1E3B
    1E2C E08A      LDI	R24,0xA
    1E2D E090      LDI	R25,0
    1E2E 839B      STD	Y+3,R25
    1E2F 838A      STD	Y+2,R24
    1E30 802E      LDD	R2,Y+6
    1E31 803F      LDD	R3,Y+7
    1E32 8448      LDD	R4,Y+8
    1E33 8459      LDD	R5,Y+9
    1E34 8248      STD	Y+0,R4
    1E35 8259      STD	Y+1,R5
    1E36 0191      MOVW	R18,R2
    1E37 018A      MOVW	R16,R20
    1E38 940E 251C CALL	_ultoa
    1E3A C078      RJMP	0x1EB3
    1E3B E08A      LDI	R24,0xA
    1E3C E090      LDI	R25,0
    1E3D 8399      STD	Y+1,R25
    1E3E 8388      STD	Y+0,R24
    1E3F 8928      LDD	R18,Y+16
    1E40 8939      LDD	R19,Y+17
    1E41 018A      MOVW	R16,R20
    1E42 940E 2583 CALL	_utoa
    1E44 C06E      RJMP	0x1EB3
    1E45 8DEE      LDD	R30,Y+30
    1E46 8DFF      LDD	R31,Y+31
    1E47 8180      LDD	R24,Z+0
    1E48 368F      CPI	R24,0x6F
    1E49 F509      BNE	0x1E6B
    1E4A FF60      SBRS	R22,0
    1E4B C004      RJMP	0x1E50
    1E4C E380      LDI	R24,0x30
    1E4D 01FA      MOVW	R30,R20
    1E4E 9381      ST	R24,Z+
    1E4F 01AF      MOVW	R20,R30
    1E50 FF61      SBRS	R22,1
    1E51 C00F      RJMP	0x1E61
    1E52 E088      LDI	R24,0x8
    1E53 E090      LDI	R25,0
    1E54 839B      STD	Y+3,R25
    1E55 838A      STD	Y+2,R24
    1E56 802E      LDD	R2,Y+6
    1E57 803F      LDD	R3,Y+7
    1E58 8448      LDD	R4,Y+8
    1E59 8459      LDD	R5,Y+9
    1E5A 8248      STD	Y+0,R4
    1E5B 8259      STD	Y+1,R5
    1E5C 0191      MOVW	R18,R2
    1E5D 018A      MOVW	R16,R20
    1E5E 940E 251C CALL	_ultoa
    1E60 C052      RJMP	0x1EB3
    1E61 E088      LDI	R24,0x8
    1E62 E090      LDI	R25,0
    1E63 8399      STD	Y+1,R25
    1E64 8388      STD	Y+0,R24
    1E65 8928      LDD	R18,Y+16
    1E66 8939      LDD	R19,Y+17
    1E67 018A      MOVW	R16,R20
    1E68 940E 2583 CALL	_utoa
    1E6A C048      RJMP	0x1EB3
    1E6B 8DEE      LDD	R30,Y+30
    1E6C 8DFF      LDD	R31,Y+31
    1E6D 8180      LDD	R24,Z+0
    1E6E 3780      CPI	R24,0x70
    1E6F F439      BNE	0x1E77
    1E70 E380      LDI	R24,0x30
    1E71 01FA      MOVW	R30,R20
    1E72 9381      ST	R24,Z+
    1E73 E788      LDI	R24,0x78
    1E74 9381      ST	R24,Z+
    1E75 01AF      MOVW	R20,R30
    1E76 C00C      RJMP	0x1E83
    1E77 FF60      SBRS	R22,0
    1E78 C00A      RJMP	0x1E83
    1E79 E380      LDI	R24,0x30
    1E7A 01FA      MOVW	R30,R20
    1E7B 9381      ST	R24,Z+
    1E7C 01AF      MOVW	R20,R30
    1E7D 8DEE      LDD	R30,Y+30
    1E7E 8DFF      LDD	R31,Y+31
    1E7F 8020      LDD	R2,Z+0
    1E80 01FA      MOVW	R30,R20
    1E81 9221      ST	R2,Z+
    1E82 01AF      MOVW	R20,R30
    1E83 FF61      SBRS	R22,1
    1E84 C00F      RJMP	0x1E94
    1E85 E180      LDI	R24,0x10
    1E86 E090      LDI	R25,0
    1E87 839B      STD	Y+3,R25
    1E88 838A      STD	Y+2,R24
    1E89 802E      LDD	R2,Y+6
    1E8A 803F      LDD	R3,Y+7
    1E8B 8448      LDD	R4,Y+8
    1E8C 8459      LDD	R5,Y+9
    1E8D 8248      STD	Y+0,R4
    1E8E 8259      STD	Y+1,R5
    1E8F 0191      MOVW	R18,R2
    1E90 018A      MOVW	R16,R20
    1E91 940E 251C CALL	_ultoa
    1E93 C009      RJMP	0x1E9D
    1E94 E180      LDI	R24,0x10
    1E95 E090      LDI	R25,0
    1E96 8399      STD	Y+1,R25
    1E97 8388      STD	Y+0,R24
    1E98 8928      LDD	R18,Y+16
    1E99 8939      LDD	R19,Y+17
    1E9A 018A      MOVW	R16,R20
    1E9B 940E 2583 CALL	_utoa
    1E9D 8DEE      LDD	R30,Y+30
    1E9E 8DFF      LDD	R31,Y+31
    1E9F 8180      LDD	R24,Z+0
    1EA0 3588      CPI	R24,0x58
    1EA1 F489      BNE	0x1EB3
    1EA2 E143      LDI	R20,0x13
    1EA3 E05E      LDI	R21,0xE
    1EA4 C00A      RJMP	0x1EAF
    1EA5 01FA      MOVW	R30,R20
    1EA6 8100      LDD	R16,Z+0
    1EA7 2711      CLR	R17
    1EA8 940E 25E1 CALL	_toupper
    1EAA 0158      MOVW	R10,R16
    1EAB 01FA      MOVW	R30,R20
    1EAC 82A0      STD	Z+0,R10
    1EAD 5F4F      SUBI	R20,0xFF
    1EAE 4F5F      SBCI	R21,0xFF
    1EAF 01FA      MOVW	R30,R20
    1EB0 8020      LDD	R2,Z+0
    1EB1 2022      TST	R2
    1EB2 F791      BNE	0x1EA5
    1EB3 E143      LDI	R20,0x13
    1EB4 E05E      LDI	R21,0xE
    1EB5 858E      LDD	R24,Y+14
    1EB6 859F      LDD	R25,Y+15
    1EB7 3F8F      CPI	R24,0xFF
    1EB8 EFEF      LDI	R30,0xFF
    1EB9 079E      CPC	R25,R30
    1EBA F421      BNE	0x1EBF
    1EBB 2400      CLR	R0
    1EBC 2411      CLR	R1
    1EBD 861F      STD	Y+15,R1
    1EBE 860E      STD	Y+14,R0
    1EBF 840E      LDD	R0,Y+14
    1EC0 841F      LDD	R1,Y+15
    1EC1 2000      TST	R0
    1EC2 F419      BNE	0x1EC6
    1EC3 2011      TST	R1
    1EC4 F409      BNE	0x1EC6
    1EC5 C104      RJMP	0x1FCA
    1EC6 E103      LDI	R16,0x13
    1EC7 E01E      LDI	R17,0xE
    1EC8 940E 20B4 CALL	_strlen
    1ECA 0158      MOVW	R10,R16
    1ECB 8AB9      STD	Y+17,R11
    1ECC 8AA8      STD	Y+16,R10
    1ECD 840E      LDD	R0,Y+14
    1ECE 841F      LDD	R1,Y+15
    1ECF 140A      CP	R0,R10
    1ED0 041B      CPC	R1,R11
    1ED1 F00C      BLT	0x1ED3
    1ED2 C0F7      RJMP	0x1FCA
    1ED3 0105      MOVW	R0,R10
    1ED4 861F      STD	Y+15,R1
    1ED5 860E      STD	Y+14,R0
    1ED6 C0F3      RJMP	0x1FCA
    1ED7 A188      LDD	R24,Y+32
    1ED8 A199      LDD	R25,Y+33
    1ED9 9602      ADIW	R24,2
    1EDA A399      STD	Y+33,R25
    1EDB A388      STD	Y+32,R24
    1EDC 01FC      MOVW	R30,R24
    1EDD 9732      SBIW	R30,2
    1EDE 8020      LDD	R2,Z+0
    1EDF 8031      LDD	R3,Z+1
    1EE0 822C      STD	Y+4,R2
    1EE1 E081      LDI	R24,1
    1EE2 E090      LDI	R25,0
    1EE3 840A      LDD	R0,Y+10
    1EE4 841B      LDD	R1,Y+11
    1EE5 1580      CP	R24,R0
    1EE6 0591      CPC	R25,R1
    1EE7 F444      BGE	0x1EF0
    1EE8 861F      STD	Y+15,R1
    1EE9 860E      STD	Y+14,R0
    1EEA 2422      CLR	R2
    1EEB 822D      STD	Y+5,R2
    1EEC 01AE      MOVW	R20,R28
    1EED 5F4C      SUBI	R20,0xFC
    1EEE 4F5F      SBCI	R21,0xFF
    1EEF C0DA      RJMP	0x1FCA
    1EF0 810C      LDD	R16,Y+4
    1EF1 8DEC      LDD	R30,Y+28
    1EF2 8DFD      LDD	R31,Y+29
    1EF3 940E 21FA CALL	xicallx
    1EF5 858C      LDD	R24,Y+12
    1EF6 859D      LDD	R25,Y+13
    1EF7 9601      ADIW	R24,1
    1EF8 879D      STD	Y+13,R25
    1EF9 878C      STD	Y+12,R24
    1EFA C188      RJMP	0x2083
    1EFB A188      LDD	R24,Y+32
    1EFC A199      LDD	R25,Y+33
    1EFD 9602      ADIW	R24,2
    1EFE A399      STD	Y+33,R25
    1EFF A388      STD	Y+32,R24
    1F00 01FC      MOVW	R30,R24
    1F01 9732      SBIW	R30,2
    1F02 80E0      LDD	R14,Z+0
    1F03 80F1      LDD	R15,Z+1
    1F04 858E      LDD	R24,Y+14
    1F05 859F      LDD	R25,Y+15
    1F06 3F8F      CPI	R24,0xFF
    1F07 EFEF      LDI	R30,0xFF
    1F08 079E      CPC	R25,R30
    1F09 F421      BNE	0x1F0E
    1F0A 2400      CLR	R0
    1F0B 2411      CLR	R1
    1F0C 861F      STD	Y+15,R1
    1F0D 860E      STD	Y+14,R0
    1F0E 840A      LDD	R0,Y+10
    1F0F 841B      LDD	R1,Y+11
    1F10 2000      TST	R0
    1F11 F411      BNE	0x1F14
    1F12 2011      TST	R1
    1F13 F051      BEQ	0x1F1E
    1F14 0187      MOVW	R16,R14
    1F15 940E 2250 CALL	_cstrlen
    1F17 0158      MOVW	R10,R16
    1F18 842A      LDD	R2,Y+10
    1F19 843B      LDD	R3,Y+11
    1F1A 1A20      SUB	R2,R16
    1F1B 0A31      SBC	R3,R17
    1F1C 863B      STD	Y+11,R3
    1F1D 862A      STD	Y+10,R2
    1F1E 840E      LDD	R0,Y+14
    1F1F 841F      LDD	R1,Y+15
    1F20 2000      TST	R0
    1F21 F441      BNE	0x1F2A
    1F22 2011      TST	R1
    1F23 F431      BNE	0x1F2A
    1F24 0187      MOVW	R16,R14
    1F25 940E 2250 CALL	_cstrlen
    1F27 0158      MOVW	R10,R16
    1F28 86BF      STD	Y+15,R11
    1F29 86AE      STD	Y+14,R10
    1F2A 840A      LDD	R0,Y+10
    1F2B 841B      LDD	R1,Y+11
    1F2C 2000      TST	R0
    1F2D F411      BNE	0x1F30
    1F2E 2011      TST	R1
    1F2F F031      BEQ	0x1F36
    1F30 FF63      SBRS	R22,3
    1F31 C004      RJMP	0x1F36
    1F32 01C0      MOVW	R24,R0
    1F33 9701      SBIW	R24,1
    1F34 879B      STD	Y+11,R25
    1F35 878A      STD	Y+10,R24
    1F36 FF64      SBRS	R22,4
    1F37 C026      RJMP	0x1F5E
    1F38 FF63      SBRS	R22,3
    1F39 C00A      RJMP	0x1F44
    1F3A 2D0C      MOV	R16,R12
    1F3B 8DEC      LDD	R30,Y+28
    1F3C 8DFD      LDD	R31,Y+29
    1F3D 940E 21FA CALL	xicallx
    1F3F 858C      LDD	R24,Y+12
    1F40 859D      LDD	R25,Y+13
    1F41 9601      ADIW	R24,1
    1F42 879D      STD	Y+13,R25
    1F43 878C      STD	Y+12,R24
    1F44 FD62      SBRC	R22,2
    1F45 C04C      RJMP	0x1F92
    1F46 C00F      RJMP	0x1F56
    1F47 E300      LDI	R16,0x30
    1F48 8DEC      LDD	R30,Y+28
    1F49 8DFD      LDD	R31,Y+29
    1F4A 940E 21FA CALL	xicallx
    1F4C 858C      LDD	R24,Y+12
    1F4D 859D      LDD	R25,Y+13
    1F4E 9601      ADIW	R24,1
    1F4F 879D      STD	Y+13,R25
    1F50 878C      STD	Y+12,R24
    1F51 858A      LDD	R24,Y+10
    1F52 859B      LDD	R25,Y+11
    1F53 9701      SBIW	R24,1
    1F54 879B      STD	Y+11,R25
    1F55 878A      STD	Y+10,R24
    1F56 2422      CLR	R2
    1F57 2433      CLR	R3
    1F58 840A      LDD	R0,Y+10
    1F59 841B      LDD	R1,Y+11
    1F5A 1420      CP	R2,R0
    1F5B 0431      CPC	R3,R1
    1F5C F354      BLT	0x1F47
    1F5D C034      RJMP	0x1F92
    1F5E FD62      SBRC	R22,2
    1F5F C017      RJMP	0x1F77
    1F60 C00F      RJMP	0x1F70
    1F61 E200      LDI	R16,0x20
    1F62 8DEC      LDD	R30,Y+28
    1F63 8DFD      LDD	R31,Y+29
    1F64 940E 21FA CALL	xicallx
    1F66 858C      LDD	R24,Y+12
    1F67 859D      LDD	R25,Y+13
    1F68 9601      ADIW	R24,1
    1F69 879D      STD	Y+13,R25
    1F6A 878C      STD	Y+12,R24
    1F6B 858A      LDD	R24,Y+10
    1F6C 859B      LDD	R25,Y+11
    1F6D 9701      SBIW	R24,1
    1F6E 879B      STD	Y+11,R25
    1F6F 878A      STD	Y+10,R24
    1F70 2422      CLR	R2
    1F71 2433      CLR	R3
    1F72 840A      LDD	R0,Y+10
    1F73 841B      LDD	R1,Y+11
    1F74 1420      CP	R2,R0
    1F75 0431      CPC	R3,R1
    1F76 F354      BLT	0x1F61
    1F77 FF63      SBRS	R22,3
    1F78 C019      RJMP	0x1F92
    1F79 2D0C      MOV	R16,R12
    1F7A 8DEC      LDD	R30,Y+28
    1F7B 8DFD      LDD	R31,Y+29
    1F7C 940E 21FA CALL	xicallx
    1F7E 858C      LDD	R24,Y+12
    1F7F 859D      LDD	R25,Y+13
    1F80 9601      ADIW	R24,1
    1F81 879D      STD	Y+13,R25
    1F82 878C      STD	Y+12,R24
    1F83 C00E      RJMP	0x1F92
    1F84 01F7      MOVW	R30,R14
    1F85 9106      ELPM	R16,14(Z)
    1F86 8DEC      LDD	R30,Y+28
    1F87 8DFD      LDD	R31,Y+29
    1F88 940E 21FA CALL	xicallx
    1F8A 858C      LDD	R24,Y+12
    1F8B 859D      LDD	R25,Y+13
    1F8C 9601      ADIW	R24,1
    1F8D 879D      STD	Y+13,R25
    1F8E 878C      STD	Y+12,R24
    1F8F 01C7      MOVW	R24,R14
    1F90 9601      ADIW	R24,1
    1F91 017C      MOVW	R14,R24
    1F92 01F7      MOVW	R30,R14
    1F93 9026      ELPM	R2,1(Z)
    1F94 2022      TST	R2
    1F95 F051      BEQ	0x1FA0
    1F96 84AE      LDD	R10,Y+14
    1F97 84BF      LDD	R11,Y+15
    1F98 01C5      MOVW	R24,R10
    1F99 9701      SBIW	R24,1
    1F9A 879F      STD	Y+15,R25
    1F9B 878E      STD	Y+14,R24
    1F9C 20AA      TST	R10
    1F9D F731      BNE	0x1F84
    1F9E 20BB      TST	R11
    1F9F F721      BNE	0x1F84
    1FA0 FF62      SBRS	R22,2
    1FA1 C0E1      RJMP	0x2083
    1FA2 C00F      RJMP	0x1FB2
    1FA3 E200      LDI	R16,0x20
    1FA4 8DEC      LDD	R30,Y+28
    1FA5 8DFD      LDD	R31,Y+29
    1FA6 940E 21FA CALL	xicallx
    1FA8 858C      LDD	R24,Y+12
    1FA9 859D      LDD	R25,Y+13
    1FAA 9601      ADIW	R24,1
    1FAB 879D      STD	Y+13,R25
    1FAC 878C      STD	Y+12,R24
    1FAD 858A      LDD	R24,Y+10
    1FAE 859B      LDD	R25,Y+11
    1FAF 9701      SBIW	R24,1
    1FB0 879B      STD	Y+11,R25
    1FB1 878A      STD	Y+10,R24
    1FB2 2422      CLR	R2
    1FB3 2433      CLR	R3
    1FB4 840A      LDD	R0,Y+10
    1FB5 841B      LDD	R1,Y+11
    1FB6 1420      CP	R2,R0
    1FB7 0431      CPC	R3,R1
    1FB8 F354      BLT	0x1FA3
    1FB9 C0C9      RJMP	0x2083
    1FBA A188      LDD	R24,Y+32
    1FBB A199      LDD	R25,Y+33
    1FBC 9602      ADIW	R24,2
    1FBD A399      STD	Y+33,R25
    1FBE A388      STD	Y+32,R24
    1FBF 01FC      MOVW	R30,R24
    1FC0 9732      SBIW	R30,2
    1FC1 8140      LDD	R20,Z+0
    1FC2 8151      LDD	R21,Z+1
    1FC3 3040      CPI	R20,0
    1FC4 0745      CPC	R20,R21
    1FC5 F421      BNE	0x1FCA
    1FC6 E982      LDI	R24,0x92
    1FC7 E090      LDI	R25,0
    1FC8 017C      MOVW	R14,R24
    1FC9 CF3A      RJMP	0x1F04
    1FCA 858E      LDD	R24,Y+14
    1FCB 859F      LDD	R25,Y+15
    1FCC 3F8F      CPI	R24,0xFF
    1FCD EFEF      LDI	R30,0xFF
    1FCE 079E      CPC	R25,R30
    1FCF F421      BNE	0x1FD4
    1FD0 2400      CLR	R0
    1FD1 2411      CLR	R1
    1FD2 861F      STD	Y+15,R1
    1FD3 860E      STD	Y+14,R0
    1FD4 840A      LDD	R0,Y+10
    1FD5 841B      LDD	R1,Y+11
    1FD6 2000      TST	R0
    1FD7 F411      BNE	0x1FDA
    1FD8 2011      TST	R1
    1FD9 F051      BEQ	0x1FE4
    1FDA 018A      MOVW	R16,R20
    1FDB 940E 20B4 CALL	_strlen
    1FDD 0158      MOVW	R10,R16
    1FDE 842A      LDD	R2,Y+10
    1FDF 843B      LDD	R3,Y+11
    1FE0 1A20      SUB	R2,R16
    1FE1 0A31      SBC	R3,R17
    1FE2 863B      STD	Y+11,R3
    1FE3 862A      STD	Y+10,R2
    1FE4 840E      LDD	R0,Y+14
    1FE5 841F      LDD	R1,Y+15
    1FE6 2000      TST	R0
    1FE7 F441      BNE	0x1FF0
    1FE8 2011      TST	R1
    1FE9 F431      BNE	0x1FF0
    1FEA 018A      MOVW	R16,R20
    1FEB 940E 20B4 CALL	_strlen
    1FED 0158      MOVW	R10,R16
    1FEE 86BF      STD	Y+15,R11
    1FEF 86AE      STD	Y+14,R10
    1FF0 840A      LDD	R0,Y+10
    1FF1 841B      LDD	R1,Y+11
    1FF2 2000      TST	R0
    1FF3 F411      BNE	0x1FF6
    1FF4 2011      TST	R1
    1FF5 F031      BEQ	0x1FFC
    1FF6 FF63      SBRS	R22,3
    1FF7 C004      RJMP	0x1FFC
    1FF8 01C0      MOVW	R24,R0
    1FF9 9701      SBIW	R24,1
    1FFA 879B      STD	Y+11,R25
    1FFB 878A      STD	Y+10,R24
    1FFC FF64      SBRS	R22,4
    1FFD C026      RJMP	0x2024
    1FFE FF63      SBRS	R22,3
    1FFF C00A      RJMP	0x200A
    2000 2D0C      MOV	R16,R12
    2001 8DEC      LDD	R30,Y+28
    2002 8DFD      LDD	R31,Y+29
    2003 940E 21FA CALL	xicallx
    2005 858C      LDD	R24,Y+12
    2006 859D      LDD	R25,Y+13
    2007 9601      ADIW	R24,1
    2008 879D      STD	Y+13,R25
    2009 878C      STD	Y+12,R24
    200A FD62      SBRC	R22,2
    200B C04B      RJMP	0x2057
    200C C00F      RJMP	0x201C
    200D E300      LDI	R16,0x30
    200E 8DEC      LDD	R30,Y+28
    200F 8DFD      LDD	R31,Y+29
    2010 940E 21FA CALL	xicallx
    2012 858C      LDD	R24,Y+12
    2013 859D      LDD	R25,Y+13
    2014 9601      ADIW	R24,1
    2015 879D      STD	Y+13,R25
    2016 878C      STD	Y+12,R24
    2017 858A      LDD	R24,Y+10
    2018 859B      LDD	R25,Y+11
    2019 9701      SBIW	R24,1
    201A 879B      STD	Y+11,R25
    201B 878A      STD	Y+10,R24
    201C 2422      CLR	R2
    201D 2433      CLR	R3
    201E 840A      LDD	R0,Y+10
    201F 841B      LDD	R1,Y+11
    2020 1420      CP	R2,R0
    2021 0431      CPC	R3,R1
    2022 F354      BLT	0x200D
    2023 C033      RJMP	0x2057
    2024 FD62      SBRC	R22,2
    2025 C017      RJMP	0x203D
    2026 C00F      RJMP	0x2036
    2027 E200      LDI	R16,0x20
    2028 8DEC      LDD	R30,Y+28
    2029 8DFD      LDD	R31,Y+29
    202A 940E 21FA CALL	xicallx
    202C 858C      LDD	R24,Y+12
    202D 859D      LDD	R25,Y+13
    202E 9601      ADIW	R24,1
    202F 879D      STD	Y+13,R25
    2030 878C      STD	Y+12,R24
    2031 858A      LDD	R24,Y+10
    2032 859B      LDD	R25,Y+11
    2033 9701      SBIW	R24,1
    2034 879B      STD	Y+11,R25
    2035 878A      STD	Y+10,R24
    2036 2422      CLR	R2
    2037 2433      CLR	R3
    2038 840A      LDD	R0,Y+10
    2039 841B      LDD	R1,Y+11
    203A 1420      CP	R2,R0
    203B 0431      CPC	R3,R1
    203C F354      BLT	0x2027
    203D FF63      SBRS	R22,3
    203E C018      RJMP	0x2057
    203F 2D0C      MOV	R16,R12
    2040 8DEC      LDD	R30,Y+28
    2041 8DFD      LDD	R31,Y+29
    2042 940E 21FA CALL	xicallx
    2044 858C      LDD	R24,Y+12
    2045 859D      LDD	R25,Y+13
    2046 9601      ADIW	R24,1
    2047 879D      STD	Y+13,R25
    2048 878C      STD	Y+12,R24
    2049 C00D      RJMP	0x2057
    204A 01FA      MOVW	R30,R20
    204B 8100      LDD	R16,Z+0
    204C 8DEC      LDD	R30,Y+28
    204D 8DFD      LDD	R31,Y+29
    204E 940E 21FA CALL	xicallx
    2050 858C      LDD	R24,Y+12
    2051 859D      LDD	R25,Y+13
    2052 9601      ADIW	R24,1
    2053 879D      STD	Y+13,R25
    2054 878C      STD	Y+12,R24
    2055 5F4F      SUBI	R20,0xFF
    2056 4F5F      SBCI	R21,0xFF
    2057 01FA      MOVW	R30,R20
    2058 8020      LDD	R2,Z+0
    2059 2022      TST	R2
    205A F051      BEQ	0x2065
    205B 84AE      LDD	R10,Y+14
    205C 84BF      LDD	R11,Y+15
    205D 01C5      MOVW	R24,R10
    205E 9701      SBIW	R24,1
    205F 879F      STD	Y+15,R25
    2060 878E      STD	Y+14,R24
    2061 20AA      TST	R10
    2062 F739      BNE	0x204A
    2063 20BB      TST	R11
    2064 F729      BNE	0x204A
    2065 FF62      SBRS	R22,2
    2066 C01C      RJMP	0x2083
    2067 C00F      RJMP	0x2077
    2068 E200      LDI	R16,0x20
    2069 8DEC      LDD	R30,Y+28
    206A 8DFD      LDD	R31,Y+29
    206B 940E 21FA CALL	xicallx
    206D 858C      LDD	R24,Y+12
    206E 859D      LDD	R25,Y+13
    206F 9601      ADIW	R24,1
    2070 879D      STD	Y+13,R25
    2071 878C      STD	Y+12,R24
    2072 858A      LDD	R24,Y+10
    2073 859B      LDD	R25,Y+11
    2074 9701      SBIW	R24,1
    2075 879B      STD	Y+11,R25
    2076 878A      STD	Y+10,R24
    2077 2422      CLR	R2
    2078 2433      CLR	R3
    2079 840A      LDD	R0,Y+10
    207A 841B      LDD	R1,Y+11
    207B 1420      CP	R2,R0
    207C 0431      CPC	R3,R1
    207D F354      BLT	0x2068
    207E C004      RJMP	0x2083
    207F EA84      LDI	R24,0xA4
    2080 E090      LDI	R25,0
    2081 017C      MOVW	R14,R24
    2082 CE81      RJMP	0x1F04
    2083 8D8E      LDD	R24,Y+30
    2084 8D9F      LDD	R25,Y+31
    2085 9601      ADIW	R24,1
    2086 8F9F      STD	Y+31,R25
    2087 8F8E      STD	Y+30,R24
    2088 8DEE      LDD	R30,Y+30
    2089 8DFF      LDD	R31,Y+31
    208A 8020      LDD	R2,Z+0
    208B 2022      TST	R2
    208C F009      BEQ	0x208E
    208D CC01      RJMP	0x1C8F
    208E 850C      LDD	R16,Y+12
    208F 851D      LDD	R17,Y+13
    2090 9662      ADIW	R28,0x12
    2091 940E 21A2 CALL	pop_xgsetF0FC
    2093 9624      ADIW	R28,4
    2094 9508      RET
_abs:
    2095 FF17      SBRS	R17,7
    2096 9508      RET
    2097 9510      COM	R17
    2098 9501      NEG	R16
    2099 4F1F      SBCI	R17,0xFF
    209A 9508      RET
_memcpy:
    209B 2FA0      MOV	R26,R16
    209C 2FB1      MOV	R27,R17
    209D 2FE2      MOV	R30,R18
    209E 2FF3      MOV	R31,R19
    209F 8188      LDD	R24,Y+0
    20A0 8199      LDD	R25,Y+1
    20A1 3080      CPI	R24,0
    20A2 0798      CPC	R25,R24
    20A3 C003      RJMP	0x20A7
    20A4 9001      LD	R0,Z+
    20A5 920D      ST	R0,X+
    20A6 9701      SBIW	R24,1
    20A7 F7E1      BNE	0x20A4
    20A8 9508      RET
_memset:
    20A9 8188      LDD	R24,Y+0
    20AA 8199      LDD	R25,Y+1
    20AB 3080      CPI	R24,0
    20AC 0789      CPC	R24,R25
    20AD F029      BEQ	0x20B3
    20AE 2FE0      MOV	R30,R16
    20AF 2FF1      MOV	R31,R17
    20B0 9321      ST	R18,Z+
    20B1 9701      SBIW	R24,1
    20B2 F7E9      BNE	0x20B0
    20B3 9508      RET
_strlen:
    20B4 2FE0      MOV	R30,R16
    20B5 2FF1      MOV	R31,R17
    20B6 27AA      CLR	R26
    20B7 27BB      CLR	R27
    20B8 9001      LD	R0,Z+
    20B9 2000      TST	R0
    20BA F011      BEQ	0x20BD
    20BB 9611      ADIW	R26,1
    20BC CFFB      RJMP	0x20B8
    20BD 2F0A      MOV	R16,R26
    20BE 2F1B      MOV	R17,R27
    20BF 9508      RET
push_arg4:
    20C0 933A      ST	R19,-Y
    20C1 932A      ST	R18,-Y
push_arg2:
    20C2 931A      ST	R17,-Y
    20C3 930A      ST	R16,-Y
    20C4 9508      RET
asr16:
    20C5 2322      TST	R18
    20C6 F021      BEQ	0x20CB
    20C7 9515      ASR	R17
    20C8 9507      ROR	R16
    20C9 952A      DEC	R18
    20CA CFFA      RJMP	asr16
    20CB 9508      RET
mod16u:
    20CC 9468      BSET	6
    20CD C001      RJMP	xdiv16u
div16u:
    20CE 94E8      BCLR	6
xdiv16u:
    20CF 92EA      ST	R14,-Y
    20D0 92FA      ST	R15,-Y
    20D1 938A      ST	R24,-Y
    20D2 24EE      CLR	R14
    20D3 24FF      CLR	R15
    20D4 E180      LDI	R24,0x10
    20D5 0F00      LSL	R16
    20D6 1F11      ROL	R17
    20D7 1CEE      ROL	R14
    20D8 1CFF      ROL	R15
    20D9 16E2      CP	R14,R18
    20DA 06F3      CPC	R15,R19
    20DB F018      BCS	0x20DF
    20DC 1AE2      SUB	R14,R18
    20DD 0AF3      SBC	R15,R19
    20DE 9503      INC	R16
    20DF 958A      DEC	R24
    20E0 F7A1      BNE	0x20D5
    20E1 F416      BRTC	0x20E4
    20E2 2D0E      MOV	R16,R14
    20E3 2D1F      MOV	R17,R15
    20E4 9189      LD	R24,Y+
    20E5 90F9      LD	R15,Y+
    20E6 90E9      LD	R14,Y+
    20E7 9508      RET
div32u:
    20E8 94E8      BCLR	6
    20E9 C001      RJMP	0x20EB
mod32u:
    20EA 9468      BSET	6
    20EB D030      RCALL	long_div_prolog
    20EC 24CC      CLR	R12
    20ED C009      RJMP	0x20F7
div32s:
    20EE 94E8      BCLR	6
    20EF C001      RJMP	0x20F1
mod32s:
    20F0 9468      BSET	6
    20F1 D02A      RCALL	long_div_prolog
    20F2 FD37      SBRC	R19,7
    20F3 940E 2203 CALL	neg32
    20F5 FDB7      SBRC	R27,7
    20F6 D052      RCALL	neg_R24_R27
    20F7 2477      CLR	R7
    20F8 2488      CLR	R8
    20F9 2499      CLR	R9
    20FA 24AA      CLR	R10
    20FB 24BB      CLR	R11
    20FC D042      RCALL	tst_R16_R19
    20FD F0C1      BEQ	0x2116
    20FE D045      RCALL	tst_R24_R27
    20FF F0B1      BEQ	0x2116
    2100 E2E8      LDI	R30,0x28
    2101 0F00      LSL	R16
    2102 1F11      ROL	R17
    2103 1F22      ROL	R18
    2104 1F33      ROL	R19
    2105 1C77      ROL	R7
    2106 1C88      ROL	R8
    2107 1C99      ROL	R9
    2108 1CAA      ROL	R10
    2109 1CBB      ROL	R11
    210A 1688      CP	R8,R24
    210B 0699      CPC	R9,R25
    210C 06AA      CPC	R10,R26
    210D 06BB      CPC	R11,R27
    210E F028      BCS	0x2114
    210F 1A88      SUB	R8,R24
    2110 0A99      SBC	R9,R25
    2111 0AAA      SBC	R10,R26
    2112 0ABB      SBC	R11,R27
    2113 9503      INC	R16
    2114 95EA      DEC	R30
    2115 F759      BNE	0x2101
    2116 F426      BRTC	0x211B
    2117 2D08      MOV	R16,R8
    2118 2D19      MOV	R17,R9
    2119 2D2A      MOV	R18,R10
    211A 2D3B      MOV	R19,R11
    211B C013      RJMP	long_div_epilog
long_div_prolog:
    211C 927A      ST	R7,-Y
    211D 928A      ST	R8,-Y
    211E 929A      ST	R9,-Y
    211F 92AA      ST	R10,-Y
    2120 92BA      ST	R11,-Y
    2121 92CA      ST	R12,-Y
    2122 93EA      ST	R30,-Y
    2123 938A      ST	R24,-Y
    2124 939A      ST	R25,-Y
    2125 93AA      ST	R26,-Y
    2126 93BA      ST	R27,-Y
    2127 858B      LDD	R24,Y+11
    2128 859C      LDD	R25,Y+12
    2129 85AD      LDD	R26,Y+13
    212A 85BE      LDD	R27,Y+14
    212B 2EC3      MOV	R12,R19
    212C F00E      BRTS	0x212E
    212D 26CB      EOR	R12,R27
    212E 9508      RET
long_div_epilog:
    212F FCC7      SBRC	R12,7
    2130 940E 2203 CALL	neg32
    2132 91B9      LD	R27,Y+
    2133 91A9      LD	R26,Y+
    2134 9199      LD	R25,Y+
    2135 9189      LD	R24,Y+
    2136 91E9      LD	R30,Y+
    2137 90C9      LD	R12,Y+
    2138 90B9      LD	R11,Y+
    2139 90A9      LD	R10,Y+
    213A 9099      LD	R9,Y+
    213B 9089      LD	R8,Y+
    213C 9079      LD	R7,Y+
    213D 9624      ADIW	R28,4
    213E 9508      RET
tst_R16_R19:
    213F 2FE0      MOV	R30,R16
    2140 2BE1      OR	R30,R17
    2141 2BE2      OR	R30,R18
    2142 2BE3      OR	R30,R19
    2143 9508      RET
tst_R24_R27:
    2144 2FE8      MOV	R30,R24
    2145 2BE9      OR	R30,R25
    2146 2BEA      OR	R30,R26
    2147 2BEB      OR	R30,R27
    2148 9508      RET
neg_R24_R27:
    2149 9580      COM	R24
    214A 9590      COM	R25
    214B 95A0      COM	R26
    214C 95B0      COM	R27
    214D 5F8F      SUBI	R24,0xFF
    214E 4F9F      SBCI	R25,0xFF
    214F 4FAF      SBCI	R26,0xFF
    2150 4FBF      SBCI	R27,0xFF
    2151 9508      RET
empy16s:
    2152 920A      ST	R0,-Y
    2153 921A      ST	R1,-Y
    2154 938A      ST	R24,-Y
    2155 939A      ST	R25,-Y
    2156 9F02      MUL	R16,R18
    2157 01C0      MOVW	R24,R0
    2158 9F12      MUL	R17,R18
    2159 0D90      ADD	R25,R0
    215A 9F03      MUL	R16,R19
    215B 0D90      ADD	R25,R0
    215C 018C      MOVW	R16,R24
    215D 9199      LD	R25,Y+
    215E 9189      LD	R24,Y+
    215F 9019      LD	R1,Y+
    2160 9009      LD	R0,Y+
    2161 9508      RET
empy32u:
empy32s:
    2162 940E 220C CALL	long_prolog
    2164 927A      ST	R7,-Y
    2165 940E 2225 CALL	tstzero1
    2167 F159      BEQ	0x2193
    2168 2477      CLR	R7
    2169 940E 222B CALL	tstzero2
    216B F419      BNE	0x216F
    216C 018C      MOVW	R16,R24
    216D 019D      MOVW	R18,R26
    216E C024      RJMP	0x2193
    216F 920A      ST	R0,-Y
    2170 921A      ST	R1,-Y
    2171 9F08      MUL	R16,R24
    2172 2CB0      MOV	R11,R0
    2173 2CA1      MOV	R10,R1
    2174 9F28      MUL	R18,R24
    2175 2C90      MOV	R9,R0
    2176 2C81      MOV	R8,R1
    2177 9F18      MUL	R17,R24
    2178 0CA0      ADD	R10,R0
    2179 1C91      ADC	R9,R1
    217A 1C87      ADC	R8,R7
    217B 9F09      MUL	R16,R25
    217C 0CA0      ADD	R10,R0
    217D 1C91      ADC	R9,R1
    217E 1C87      ADC	R8,R7
    217F 9F19      MUL	R17,R25
    2180 0C90      ADD	R9,R0
    2181 1C81      ADC	R8,R1
    2182 9F0A      MUL	R16,R26
    2183 0C90      ADD	R9,R0
    2184 1C81      ADC	R8,R1
    2185 9F38      MUL	R19,R24
    2186 0C80      ADD	R8,R0
    2187 9F29      MUL	R18,R25
    2188 0C80      ADD	R8,R0
    2189 9F1A      MUL	R17,R26
    218A 0C80      ADD	R8,R0
    218B 9F0B      MUL	R16,R27
    218C 0C80      ADD	R8,R0
    218D 9019      LD	R1,Y+
    218E 9009      LD	R0,Y+
    218F 2D0B      MOV	R16,R11
    2190 2D1A      MOV	R17,R10
    2191 2D29      MOV	R18,R9
    2192 2D38      MOV	R19,R8
    2193 9079      LD	R7,Y+
    2194 940C 221A JMP	long_epilog
pop_xgset003C:
    2196 90A9      LD	R10,Y+
    2197 90B9      LD	R11,Y+
    2198 90C9      LD	R12,Y+
    2199 90D9      LD	R13,Y+
    219A 9508      RET
pop_xgset00FC:
    219B 90A9      LD	R10,Y+
    219C 90B9      LD	R11,Y+
    219D 90C9      LD	R12,Y+
    219E 90D9      LD	R13,Y+
    219F 90E9      LD	R14,Y+
    21A0 90F9      LD	R15,Y+
    21A1 9508      RET
pop_xgsetF0FC:
    21A2 90A9      LD	R10,Y+
    21A3 90B9      LD	R11,Y+
    21A4 90C9      LD	R12,Y+
    21A5 90D9      LD	R13,Y+
    21A6 90E9      LD	R14,Y+
    21A7 90F9      LD	R15,Y+
    21A8 9149      LD	R20,Y+
    21A9 9159      LD	R21,Y+
    21AA 9169      LD	R22,Y+
    21AB 9179      LD	R23,Y+
    21AC 9508      RET
push_xgsetF0FC:
    21AD 937A      ST	R23,-Y
    21AE 936A      ST	R22,-Y
push_xgset30FC:
    21AF 935A      ST	R21,-Y
    21B0 934A      ST	R20,-Y
push_xgset00FC:
    21B1 92FA      ST	R15,-Y
    21B2 92EA      ST	R14,-Y
push_xgset003C:
    21B3 92DA      ST	R13,-Y
    21B4 92CA      ST	R12,-Y
    21B5 92BA      ST	R11,-Y
    21B6 92AA      ST	R10,-Y
    21B7 9508      RET
push_xgset300C:
    21B8 935A      ST	R21,-Y
    21B9 934A      ST	R20,-Y
    21BA 92BA      ST	R11,-Y
    21BB 92AA      ST	R10,-Y
    21BC 9508      RET
pop_xgset300C:
    21BD 90A9      LD	R10,Y+
    21BE 90B9      LD	R11,Y+
    21BF 9149      LD	R20,Y+
    21C0 9159      LD	R21,Y+
    21C1 9508      RET
push_xgsetF000:
    21C2 937A      ST	R23,-Y
    21C3 936A      ST	R22,-Y
    21C4 935A      ST	R21,-Y
    21C5 934A      ST	R20,-Y
    21C6 9508      RET
pop_xgsetF000:
    21C7 9149      LD	R20,Y+
    21C8 9159      LD	R21,Y+
    21C9 9169      LD	R22,Y+
    21CA 9179      LD	R23,Y+
    21CB 9508      RET
push_xgsetF00C:
    21CC 937A      ST	R23,-Y
    21CD 936A      ST	R22,-Y
    21CE 935A      ST	R21,-Y
    21CF 934A      ST	R20,-Y
    21D0 92BA      ST	R11,-Y
    21D1 92AA      ST	R10,-Y
    21D2 9508      RET
pop_xgsetF00C:
    21D3 90A9      LD	R10,Y+
    21D4 90B9      LD	R11,Y+
    21D5 9149      LD	R20,Y+
    21D6 9159      LD	R21,Y+
    21D7 9169      LD	R22,Y+
    21D8 9179      LD	R23,Y+
    21D9 9508      RET
push_xgset303C:
    21DA 935A      ST	R21,-Y
    21DB 934A      ST	R20,-Y
    21DC 92DA      ST	R13,-Y
    21DD 92CA      ST	R12,-Y
    21DE 92BA      ST	R11,-Y
    21DF 92AA      ST	R10,-Y
    21E0 9508      RET
pop_xgset303C:
    21E1 90A9      LD	R10,Y+
    21E2 90B9      LD	R11,Y+
    21E3 90C9      LD	R12,Y+
    21E4 90D9      LD	R13,Y+
    21E5 9149      LD	R20,Y+
    21E6 9159      LD	R21,Y+
    21E7 9508      RET
push_xgsetF03C:
    21E8 937A      ST	R23,-Y
    21E9 936A      ST	R22,-Y
    21EA 935A      ST	R21,-Y
    21EB 934A      ST	R20,-Y
    21EC 92DA      ST	R13,-Y
    21ED 92CA      ST	R12,-Y
    21EE 92BA      ST	R11,-Y
    21EF 92AA      ST	R10,-Y
    21F0 9508      RET
pop_xgsetF03C:
    21F1 90A9      LD	R10,Y+
    21F2 90B9      LD	R11,Y+
    21F3 90C9      LD	R12,Y+
    21F4 90D9      LD	R13,Y+
    21F5 9149      LD	R20,Y+
    21F6 9159      LD	R21,Y+
    21F7 9169      LD	R22,Y+
    21F8 9179      LD	R23,Y+
    21F9 9508      RET
xicallx:
    21FA 920A      ST	R0,-Y
    21FB 95D8      ELPM
    21FC 920A      ST	R0,-Y
    21FD 9631      ADIW	R30,1
    21FE 95D8      ELPM
    21FF 2DF0      MOV	R31,R0
    2200 91E9      LD	R30,Y+
    2201 9009      LD	R0,Y+
    2202 9409      IJMP
neg32:
    2203 9500      COM	R16
    2204 9510      COM	R17
    2205 9520      COM	R18
    2206 9530      COM	R19
    2207 5F0F      SUBI	R16,0xFF
    2208 4F1F      SBCI	R17,0xFF
    2209 4F2F      SBCI	R18,0xFF
    220A 4F3F      SBCI	R19,0xFF
    220B 9508      RET
long_prolog:
    220C 928A      ST	R8,-Y
    220D 929A      ST	R9,-Y
    220E 92AA      ST	R10,-Y
    220F 92BA      ST	R11,-Y
    2210 93EA      ST	R30,-Y
    2211 938A      ST	R24,-Y
    2212 939A      ST	R25,-Y
    2213 93AA      ST	R26,-Y
    2214 93BA      ST	R27,-Y
    2215 8589      LDD	R24,Y+9
    2216 859A      LDD	R25,Y+10
    2217 85AB      LDD	R26,Y+11
    2218 85BC      LDD	R27,Y+12
    2219 9508      RET
long_epilog:
    221A 91B9      LD	R27,Y+
    221B 91A9      LD	R26,Y+
    221C 9199      LD	R25,Y+
    221D 9189      LD	R24,Y+
    221E 91E9      LD	R30,Y+
    221F 90B9      LD	R11,Y+
    2220 90A9      LD	R10,Y+
    2221 9099      LD	R9,Y+
    2222 9089      LD	R8,Y+
    2223 9624      ADIW	R28,4
    2224 9508      RET
tstzero1:
    2225 27EE      CLR	R30
    2226 2BE0      OR	R30,R16
    2227 2BE1      OR	R30,R17
    2228 2BE2      OR	R30,R18
    2229 2BE3      OR	R30,R19
    222A 9508      RET
tstzero2:
    222B 27EE      CLR	R30
    222C 2BE8      OR	R30,R24
    222D 2BE9      OR	R30,R25
    222E 2BEA      OR	R30,R26
    222F 2BEB      OR	R30,R27
    2230 9508      RET
lsl16:
    2231 2322      TST	R18
    2232 F021      BEQ	0x2237
    2233 0F00      LSL	R16
    2234 1F11      ROL	R17
    2235 952A      DEC	R18
    2236 CFFA      RJMP	lsl16
    2237 9508      RET
lsl32:
    2238 920F      PUSH	R0
    2239 9009      LD	R0,Y+
    223A 2000      TST	R0
    223B F031      BEQ	0x2242
    223C 0F00      LSL	R16
    223D 1F11      ROL	R17
    223E 1F22      ROL	R18
    223F 1F33      ROL	R19
    2240 940A      DEC	R0
    2241 CFF8      RJMP	0x223A
    2242 900F      POP	R0
    2243 9508      RET
lsr32:
    2244 920F      PUSH	R0
    2245 9009      LD	R0,Y+
    2246 2000      TST	R0
    2247 F031      BEQ	0x224E
    2248 9536      LSR	R19
    2249 9527      ROR	R18
    224A 9517      ROR	R17
    224B 9507      ROR	R16
    224C 940A      DEC	R0
    224D CFF8      RJMP	0x2246
    224E 900F      POP	R0
    224F 9508      RET
_cstrlen:
    2250 2FE0      MOV	R30,R16
    2251 2FF1      MOV	R31,R17
    2252 27AA      CLR	R26
    2253 27BB      CLR	R27
    2254 95C8      LPM
    2255 2000      TST	R0
    2256 F019      BEQ	0x225A
    2257 9631      ADIW	R30,1
    2258 9611      ADIW	R26,1
    2259 CFFA      RJMP	0x2254
    225A 2F0A      MOV	R16,R26
    225B 2F1B      MOV	R17,R27
    225C 9508      RET
__NewHeap:
    225D 934A      ST	R20,-Y
    225E 935A      ST	R21,-Y
    225F EF8F      LDI	R24,0xFF
    2260 EF9F      LDI	R25,0xFF
    2261 2308      AND	R16,R24
    2262 2319      AND	R17,R25
    2263 2328      AND	R18,R24
    2264 2339      AND	R19,R25
    2265 01A8      MOVW	R20,R16
    2266 9020 0E2C LDS	R2,__FreeList
    2268 9030 0E2D LDS	R3,__FreeList+1
    226A 01FA      MOVW	R30,R20
    226B 8231      STD	Z+1,R3
    226C 8220      STD	Z+0,R2
    226D 9350 0E2D STS	__FreeList+1,R21
    226F 9340 0E2C STS	__FreeList,R20
    2271 01CF      MOVW	R24,R30
    2272 9606      ADIW	R24,6
    2273 0119      MOVW	R2,R18
    2274 1A28      SUB	R2,R24
    2275 0A39      SBC	R3,R25
    2276 8235      STD	Z+5,R3
    2277 8224      STD	Z+4,R2
    2278 8333      STD	Z+3,R19
    2279 8322      STD	Z+2,R18
    227A 9159      LD	R21,Y+
    227B 9149      LD	R20,Y+
    227C 9508      RET
_calloc:
    227D 940E 21B3 CALL	push_xgset003C
    227F 0169      MOVW	R12,R18
    2280 0158      MOVW	R10,R16
    2281 9722      SBIW	R28,2
    2282 0195      MOVW	R18,R10
    2283 0186      MOVW	R16,R12
    2284 940E 2152 CALL	empy16s
    2286 0168      MOVW	R12,R16
    2287 D012      RCALL	_malloc
    2288 0158      MOVW	R10,R16
    2289 3000      CPI	R16,0
    228A 0701      CPC	R16,R17
    228B F419      BNE	0x228F
    228C 2700      CLR	R16
    228D 2711      CLR	R17
    228E C008      RJMP	0x2297
    228F 82D9      STD	Y+1,R13
    2290 82C8      STD	Y+0,R12
    2291 2722      CLR	R18
    2292 2733      CLR	R19
    2293 0185      MOVW	R16,R10
    2294 940E 20A9 CALL	_memset
    2296 0185      MOVW	R16,R10
    2297 9622      ADIW	R28,2
    2298 940C 2196 JMP	pop_xgset003C
_malloc:
    229A 940E 21CC CALL	push_xgsetF00C
    229C E26C      LDI	R22,0x2C
    229D E07E      LDI	R23,0xE
    229E C053      RJMP	0x22F2
    229F 01FA      MOVW	R30,R20
    22A0 8024      LDD	R2,Z+4
    22A1 8035      LDD	R3,Z+5
    22A2 1620      CP	R2,R16
    22A3 0631      CPC	R3,R17
    22A4 F408      BCC	0x22A6
    22A5 C049      RJMP	0x22EF
    22A6 1A20      SUB	R2,R16
    22A7 0A31      SBC	R3,R17
    22A8 E08E      LDI	R24,0xE
    22A9 E090      LDI	R25,0
    22AA 1582      CP	R24,R2
    22AB 0593      CPC	R25,R3
    22AC F008      BCS	0x22AE
    22AD C031      RJMP	0x22DF
    22AE 01C8      MOVW	R24,R16
    22AF 9606      ADIW	R24,6
    22B0 015C      MOVW	R10,R24
    22B1 0EAE      ADD	R10,R30
    22B2 1EBF      ADC	R11,R31
    22B3 8020      LDD	R2,Z+0
    22B4 8031      LDD	R3,Z+1
    22B5 01F5      MOVW	R30,R10
    22B6 8231      STD	Z+1,R3
    22B7 8220      STD	Z+0,R2
    22B8 01C8      MOVW	R24,R16
    22B9 9606      ADIW	R24,6
    22BA 01FA      MOVW	R30,R20
    22BB 8024      LDD	R2,Z+4
    22BC 8035      LDD	R3,Z+5
    22BD 1A28      SUB	R2,R24
    22BE 0A39      SBC	R3,R25
    22BF 01F5      MOVW	R30,R10
    22C0 8235      STD	Z+5,R3
    22C1 8224      STD	Z+4,R2
    22C2 01CF      MOVW	R24,R30
    22C3 9604      ADIW	R24,4
    22C4 01FC      MOVW	R30,R24
    22C5 8180      LDD	R24,Z+0
    22C6 8191      LDD	R25,Z+1
    22C7 7F8E      ANDI	R24,0xFE
    22C8 8391      STD	Z+1,R25
    22C9 8380      STD	Z+0,R24
    22CA 01FA      MOVW	R30,R20
    22CB 8022      LDD	R2,Z+2
    22CC 8033      LDD	R3,Z+3
    22CD 01F5      MOVW	R30,R10
    22CE 8233      STD	Z+3,R3
    22CF 8222      STD	Z+2,R2
    22D0 01FA      MOVW	R30,R20
    22D1 82B3      STD	Z+3,R11
    22D2 82A2      STD	Z+2,R10
    22D3 01CF      MOVW	R24,R30
    22D4 9606      ADIW	R24,6
    22D5 8022      LDD	R2,Z+2
    22D6 8033      LDD	R3,Z+3
    22D7 1A28      SUB	R2,R24
    22D8 0A39      SBC	R3,R25
    22D9 8235      STD	Z+5,R3
    22DA 8224      STD	Z+4,R2
    22DB 01FB      MOVW	R30,R22
    22DC 82B1      STD	Z+1,R11
    22DD 82A0      STD	Z+0,R10
    22DE C006      RJMP	0x22E5
    22DF 01FA      MOVW	R30,R20
    22E0 8020      LDD	R2,Z+0
    22E1 8031      LDD	R3,Z+1
    22E2 01FB      MOVW	R30,R22
    22E3 8231      STD	Z+1,R3
    22E4 8220      STD	Z+0,R2
    22E5 2422      CLR	R2
    22E6 2433      CLR	R3
    22E7 01FA      MOVW	R30,R20
    22E8 8231      STD	Z+1,R3
    22E9 8220      STD	Z+0,R2
    22EA 01CF      MOVW	R24,R30
    22EB 9606      ADIW	R24,6
    22EC 015C      MOVW	R10,R24
    22ED 018C      MOVW	R16,R24
    22EE C00D      RJMP	0x22FC
    22EF 01FB      MOVW	R30,R22
    22F0 8160      LDD	R22,Z+0
    22F1 8171      LDD	R23,Z+1
    22F2 01FB      MOVW	R30,R22
    22F3 8020      LDD	R2,Z+0
    22F4 8031      LDD	R3,Z+1
    22F5 01A1      MOVW	R20,R2
    22F6 3040      CPI	R20,0
    22F7 0745      CPC	R20,R21
    22F8 F009      BEQ	0x22FA
    22F9 CFA5      RJMP	0x229F
    22FA 2700      CLR	R16
    22FB 2711      CLR	R17
    22FC 940C 21D3 JMP	pop_xgsetF00C
_realloc:
    22FE 940E 21E8 CALL	push_xgsetF03C
    2300 0169      MOVW	R12,R18
    2301 01A8      MOVW	R20,R16
    2302 9722      SBIW	R28,2
    2303 01BA      MOVW	R22,R20
    2304 5066      SUBI	R22,6
    2305 4070      SBCI	R23,0
    2306 0116      MOVW	R2,R12
    2307 0E24      ADD	R2,R20
    2308 1E35      ADC	R3,R21
    2309 01FB      MOVW	R30,R22
    230A 8042      LDD	R4,Z+2
    230B 8053      LDD	R5,Z+3
    230C 1442      CP	R4,R2
    230D 0453      CPC	R5,R3
    230E F020      BCS	0x2313
    230F 82D5      STD	Z+5,R13
    2310 82C4      STD	Z+4,R12
    2311 018A      MOVW	R16,R20
    2312 C01A      RJMP	0x232D
    2313 0186      MOVW	R16,R12
    2314 DF85      RCALL	_malloc
    2315 0158      MOVW	R10,R16
    2316 3000      CPI	R16,0
    2317 0701      CPC	R16,R17
    2318 F419      BNE	0x231C
    2319 2700      CLR	R16
    231A 2711      CLR	R17
    231B C011      RJMP	0x232D
    231C 01FB      MOVW	R30,R22
    231D 8024      LDD	R2,Z+4
    231E 8035      LDD	R3,Z+5
    231F 142C      CP	R2,R12
    2320 043D      CPC	R3,R13
    2321 F410      BCC	0x2324
    2322 80C4      LDD	R12,Z+4
    2323 80D5      LDD	R13,Z+5
    2324 82D9      STD	Y+1,R13
    2325 82C8      STD	Y+0,R12
    2326 019A      MOVW	R18,R20
    2327 0185      MOVW	R16,R10
    2328 940E 209B CALL	_memcpy
    232A 018A      MOVW	R16,R20
    232B D06D      RCALL	_free
    232C 0185      MOVW	R16,R10
    232D 9622      ADIW	R28,2
    232E 940C 21F1 JMP	pop_xgsetF03C
    2330 940E 21E8 CALL	push_xgsetF03C
    2332 01A8      MOVW	R20,R16
    2333 E28C      LDI	R24,0x2C
    2334 E09E      LDI	R25,0xE
    2335 015C      MOVW	R10,R24
    2336 C04A      RJMP	0x2381
    2337 01FA      MOVW	R30,R20
    2338 8022      LDD	R2,Z+2
    2339 8033      LDD	R3,Z+3
    233A 1562      CP	R22,R2
    233B 0573      CPC	R23,R3
    233C F009      BEQ	0x233E
    233D C01D      RJMP	0x235B
    233E 01FB      MOVW	R30,R22
    233F 8020      LDD	R2,Z+0
    2340 8031      LDD	R3,Z+1
    2341 01F5      MOVW	R30,R10
    2342 8231      STD	Z+1,R3
    2343 8220      STD	Z+0,R2
    2344 01CA      MOVW	R24,R20
    2345 9604      ADIW	R24,4
    2346 012C      MOVW	R4,R24
    2347 01FB      MOVW	R30,R22
    2348 8184      LDD	R24,Z+4
    2349 8195      LDD	R25,Z+5
    234A 9606      ADIW	R24,6
    234B 01F2      MOVW	R30,R4
    234C 8020      LDD	R2,Z+0
    234D 8031      LDD	R3,Z+1
    234E 0E28      ADD	R2,R24
    234F 1E39      ADC	R3,R25
    2350 8231      STD	Z+1,R3
    2351 8220      STD	Z+0,R2
    2352 01FB      MOVW	R30,R22
    2353 8022      LDD	R2,Z+2
    2354 8033      LDD	R3,Z+3
    2355 01FA      MOVW	R30,R20
    2356 8233      STD	Z+3,R3
    2357 8222      STD	Z+2,R2
    2358 018F      MOVW	R16,R30
    2359 DFD6      RCALL	0x2330
    235A C02E      RJMP	0x2389
    235B 01FB      MOVW	R30,R22
    235C 8022      LDD	R2,Z+2
    235D 8033      LDD	R3,Z+3
    235E 1542      CP	R20,R2
    235F 0553      CPC	R21,R3
    2360 F009      BEQ	0x2362
    2361 C01C      RJMP	0x237E
    2362 8020      LDD	R2,Z+0
    2363 8031      LDD	R3,Z+1
    2364 01F5      MOVW	R30,R10
    2365 8231      STD	Z+1,R3
    2366 8220      STD	Z+0,R2
    2367 01CB      MOVW	R24,R22
    2368 9604      ADIW	R24,4
    2369 012C      MOVW	R4,R24
    236A 01FA      MOVW	R30,R20
    236B 8184      LDD	R24,Z+4
    236C 8195      LDD	R25,Z+5
    236D 9606      ADIW	R24,6
    236E 01F2      MOVW	R30,R4
    236F 8020      LDD	R2,Z+0
    2370 8031      LDD	R3,Z+1
    2371 0E28      ADD	R2,R24
    2372 1E39      ADC	R3,R25
    2373 8231      STD	Z+1,R3
    2374 8220      STD	Z+0,R2
    2375 01FA      MOVW	R30,R20
    2376 8022      LDD	R2,Z+2
    2377 8033      LDD	R3,Z+3
    2378 01FB      MOVW	R30,R22
    2379 8233      STD	Z+3,R3
    237A 8222      STD	Z+2,R2
    237B 018F      MOVW	R16,R30
    237C DFB3      RCALL	0x2330
    237D C00B      RJMP	0x2389
    237E 01F5      MOVW	R30,R10
    237F 80A0      LDD	R10,Z+0
    2380 80B1      LDD	R11,Z+1
    2381 01F5      MOVW	R30,R10
    2382 80C0      LDD	R12,Z+0
    2383 80D1      LDD	R13,Z+1
    2384 01B6      MOVW	R22,R12
    2385 3060      CPI	R22,0
    2386 0767      CPC	R22,R23
    2387 F009      BEQ	0x2389
    2388 CFAE      RJMP	0x2337
    2389 3060      CPI	R22,0
    238A 0767      CPC	R22,R23
    238B F459      BNE	0x2397
    238C 9020 0E2C LDS	R2,__FreeList
    238E 9030 0E2D LDS	R3,__FreeList+1
    2390 01FA      MOVW	R30,R20
    2391 8231      STD	Z+1,R3
    2392 8220      STD	Z+0,R2
    2393 9350 0E2D STS	__FreeList+1,R21
    2395 9340 0E2C STS	__FreeList,R20
    2397 940C 21F1 JMP	pop_xgsetF03C
_free:
    2399 934A      ST	R20,-Y
    239A 935A      ST	R21,-Y
    239B 01A8      MOVW	R20,R16
    239C 3040      CPI	R20,0
    239D 0745      CPC	R20,R21
    239E F409      BNE	0x23A0
    239F C010      RJMP	0x23B0
    23A0 5046      SUBI	R20,6
    23A1 4050      SBCI	R21,0
    23A2 01FA      MOVW	R30,R20
    23A3 8184      LDD	R24,Z+4
    23A4 8195      LDD	R25,Z+5
    23A5 9606      ADIW	R24,6
    23A6 0F8E      ADD	R24,R30
    23A7 1F9F      ADC	R25,R31
    23A8 8022      LDD	R2,Z+2
    23A9 8033      LDD	R3,Z+3
    23AA 1628      CP	R2,R24
    23AB 0639      CPC	R3,R25
    23AC F408      BCC	0x23AE
    23AD C002      RJMP	0x23B0
    23AE 018A      MOVW	R16,R20
    23AF DF80      RCALL	0x2330
    23B0 9159      LD	R21,Y+
    23B1 9149      LD	R20,Y+
    23B2 9508      RET
_atoi:
    23B3 940E 21CC CALL	push_xgsetF00C
    23B5 0158      MOVW	R10,R16
    23B6 C003      RJMP	0x23BA
    23B7 01C5      MOVW	R24,R10
    23B8 9601      ADIW	R24,1
    23B9 015C      MOVW	R10,R24
    23BA 01F5      MOVW	R30,R10
    23BB 8100      LDD	R16,Z+0
    23BC 2711      CLR	R17
    23BD 940E 25D7 CALL	_isspace
    23BF 3000      CPI	R16,0
    23C0 0701      CPC	R16,R17
    23C1 F7A9      BNE	0x23B7
    23C2 2766      CLR	R22
    23C3 2777      CLR	R23
    23C4 01F5      MOVW	R30,R10
    23C5 8180      LDD	R24,Z+0
    23C6 328D      CPI	R24,0x2D
    23C7 F429      BNE	0x23CD
    23C8 E061      LDI	R22,1
    23C9 01CF      MOVW	R24,R30
    23CA 9601      ADIW	R24,1
    23CB 015C      MOVW	R10,R24
    23CC C007      RJMP	0x23D4
    23CD 01F5      MOVW	R30,R10
    23CE 8180      LDD	R24,Z+0
    23CF 328B      CPI	R24,0x2B
    23D0 F419      BNE	0x23D4
    23D1 01CF      MOVW	R24,R30
    23D2 9601      ADIW	R24,1
    23D3 015C      MOVW	R10,R24
    23D4 2744      CLR	R20
    23D5 2755      CLR	R21
    23D6 C00E      RJMP	0x23E5
    23D7 E00A      LDI	R16,0xA
    23D8 E010      LDI	R17,0
    23D9 019A      MOVW	R18,R20
    23DA 940E 2152 CALL	empy16s
    23DC 01A8      MOVW	R20,R16
    23DD 01F5      MOVW	R30,R10
    23DE 9021      LD	R2,Z+
    23DF 015F      MOVW	R10,R30
    23E0 2433      CLR	R3
    23E1 0D42      ADD	R20,R2
    23E2 1D53      ADC	R21,R3
    23E3 5340      SUBI	R20,0x30
    23E4 4050      SBCI	R21,0
    23E5 01F5      MOVW	R30,R10
    23E6 8100      LDD	R16,Z+0
    23E7 2711      CLR	R17
    23E8 940E 25C3 CALL	_isdigit
    23EA 3000      CPI	R16,0
    23EB 0701      CPC	R16,R17
    23EC F751      BNE	0x23D7
    23ED 3060      CPI	R22,0
    23EE 0767      CPC	R22,R23
    23EF F031      BEQ	0x23F6
    23F0 018A      MOVW	R16,R20
    23F1 9500      COM	R16
    23F2 9510      COM	R17
    23F3 5F0F      SUBI	R16,0xFF
    23F4 4F1F      SBCI	R17,0xFF
    23F5 C001      RJMP	0x23F7
    23F6 018A      MOVW	R16,R20
    23F7 940C 21D3 JMP	pop_xgsetF00C
_itoa:
    23F9 940E 20C0 CALL	push_arg4
    23FB 940E 21AD CALL	push_xgsetF0FC
    23FD 01A9      MOVW	R20,R18
    23FE 84EE      LDD	R14,Y+14
    23FF 84FF      LDD	R15,Y+15
    2400 015A      MOVW	R10,R20
    2401 20AA      TST	R10
    2402 F451      BNE	0x240D
    2403 20BB      TST	R11
    2404 F441      BNE	0x240D
    2405 E380      LDI	R24,0x30
    2406 85EA      LDD	R30,Y+10
    2407 85FB      LDD	R31,Y+11
    2408 8380      STD	Z+0,R24
    2409 2422      CLR	R2
    240A 8221      STD	Z+1,R2
    240B 018F      MOVW	R16,R30
    240C C053      RJMP	0x2460
    240D 3040      CPI	R20,0
    240E E0E0      LDI	R30,0
    240F 075E      CPC	R21,R30
    2410 F46C      BGE	0x241E
    2411 01C7      MOVW	R24,R14
    2412 308A      CPI	R24,0xA
    2413 E0E0      LDI	R30,0
    2414 079E      CPC	R25,R30
    2415 F441      BNE	0x241E
    2416 24CC      CLR	R12
    2417 94C3      INC	R12
    2418 01C5      MOVW	R24,R10
    2419 9580      COM	R24
    241A 9590      COM	R25
    241B 9601      ADIW	R24,1
    241C 015C      MOVW	R10,R24
    241D C001      RJMP	0x241F
    241E 24CC      CLR	R12
    241F 856A      LDD	R22,Y+10
    2420 857B      LDD	R23,Y+11
    2421 0197      MOVW	R18,R14
    2422 0185      MOVW	R16,R10
    2423 940E 20CC CALL	mod16u
    2425 01A8      MOVW	R20,R16
    2426 E089      LDI	R24,0x9
    2427 E090      LDI	R25,0
    2428 1780      CP	R24,R16
    2429 0791      CPC	R25,R17
    242A F034      BLT	0x2431
    242B 01CA      MOVW	R24,R20
    242C 96C0      ADIW	R24,0x30
    242D 01FB      MOVW	R30,R22
    242E 9381      ST	R24,Z+
    242F 01BF      MOVW	R22,R30
    2430 C006      RJMP	0x2437
    2431 01CA      MOVW	R24,R20
    2432 5A89      SUBI	R24,0xA9
    2433 4F9F      SBCI	R25,0xFF
    2434 01FB      MOVW	R30,R22
    2435 9381      ST	R24,Z+
    2436 01BF      MOVW	R22,R30
    2437 0197      MOVW	R18,R14
    2438 0185      MOVW	R16,R10
    2439 940E 20CE CALL	div16u
    243B 0158      MOVW	R10,R16
    243C 20AA      TST	R10
    243D F719      BNE	0x2421
    243E 20BB      TST	R11
    243F F709      BNE	0x2421
    2440 20CC      TST	R12
    2441 F021      BEQ	0x2446
    2442 E28D      LDI	R24,0x2D
    2443 01FB      MOVW	R30,R22
    2444 9381      ST	R24,Z+
    2445 01BF      MOVW	R22,R30
    2446 012B      MOVW	R4,R22
    2447 5061      SUBI	R22,1
    2448 4070      SBCI	R23,0
    2449 2422      CLR	R2
    244A 01F2      MOVW	R30,R4
    244B 8220      STD	Z+0,R2
    244C 84AA      LDD	R10,Y+10
    244D 84BB      LDD	R11,Y+11
    244E C00C      RJMP	0x245B
    244F 01F5      MOVW	R30,R10
    2450 80C0      LDD	R12,Z+0
    2451 01FB      MOVW	R30,R22
    2452 8020      LDD	R2,Z+0
    2453 01F5      MOVW	R30,R10
    2454 9221      ST	R2,Z+
    2455 015F      MOVW	R10,R30
    2456 011B      MOVW	R2,R22
    2457 5061      SUBI	R22,1
    2458 4070      SBCI	R23,0
    2459 01F1      MOVW	R30,R2
    245A 82C0      STD	Z+0,R12
    245B 16A6      CP	R10,R22
    245C 06B7      CPC	R11,R23
    245D F388      BCS	0x244F
    245E 850A      LDD	R16,Y+10
    245F 851B      LDD	R17,Y+11
    2460 940E 21A2 CALL	pop_xgsetF0FC
    2462 9624      ADIW	R28,4
    2463 9508      RET
_ltoa:
    2464 940E 20C0 CALL	push_arg4
    2466 940E 21AD CALL	push_xgsetF0FC
    2468 9724      SBIW	R28,4
    2469 8828      LDD	R2,Y+16
    246A 8839      LDD	R3,Y+17
    246B 884A      LDD	R4,Y+18
    246C 885B      LDD	R5,Y+19
    246D 8228      STD	Y+0,R2
    246E 8239      STD	Y+1,R3
    246F 824A      STD	Y+2,R4
    2470 825B      STD	Y+3,R5
    2471 8828      LDD	R2,Y+16
    2472 8839      LDD	R3,Y+17
    2473 884A      LDD	R4,Y+18
    2474 885B      LDD	R5,Y+19
    2475 9488      BCLR	0
    2476 2022      TST	R2
    2477 0432      CPC	R3,R2
    2478 0442      CPC	R4,R2
    2479 0452      CPC	R5,R2
    247A F441      BNE	0x2483
    247B E380      LDI	R24,0x30
    247C 85EE      LDD	R30,Y+14
    247D 85FF      LDD	R31,Y+15
    247E 8380      STD	Z+0,R24
    247F 2422      CLR	R2
    2480 8221      STD	Z+1,R2
    2481 018F      MOVW	R16,R30
    2482 C094      RJMP	0x2517
    2483 E040      LDI	R20,0
    2484 E050      LDI	R21,0
    2485 E060      LDI	R22,0
    2486 E070      LDI	R23,0
    2487 8828      LDD	R2,Y+16
    2488 8839      LDD	R3,Y+17
    2489 884A      LDD	R4,Y+18
    248A 885B      LDD	R5,Y+19
    248B 1624      CP	R2,R20
    248C 0635      CPC	R3,R21
    248D 0646      CPC	R4,R22
    248E 0657      CPC	R5,R23
    248F F4EC      BGE	0x24AD
    2490 898C      LDD	R24,Y+20
    2491 899D      LDD	R25,Y+21
    2492 308A      CPI	R24,0xA
    2493 E0A0      LDI	R26,0
    2494 079A      CPC	R25,R26
    2495 F4B9      BNE	0x24AD
    2496 24AA      CLR	R10
    2497 94A3      INC	R10
    2498 E041      LDI	R20,1
    2499 E050      LDI	R21,0
    249A E060      LDI	R22,0
    249B E070      LDI	R23,0
    249C 8028      LDD	R2,Y+0
    249D 8039      LDD	R3,Y+1
    249E 804A      LDD	R4,Y+2
    249F 805B      LDD	R5,Y+3
    24A0 9420      COM	R2
    24A1 9430      COM	R3
    24A2 9440      COM	R4
    24A3 9450      COM	R5
    24A4 0E24      ADD	R2,R20
    24A5 1E35      ADC	R3,R21
    24A6 1E46      ADC	R4,R22
    24A7 1E57      ADC	R5,R23
    24A8 8228      STD	Y+0,R2
    24A9 8239      STD	Y+1,R3
    24AA 824A      STD	Y+2,R4
    24AB 825B      STD	Y+3,R5
    24AC C001      RJMP	0x24AE
    24AD 24AA      CLR	R10
    24AE 84CE      LDD	R12,Y+14
    24AF 84DF      LDD	R13,Y+15
    24B0 882C      LDD	R2,Y+20
    24B1 883D      LDD	R3,Y+21
    24B2 2444      CLR	R4
    24B3 FC37      SBRC	R3,7
    24B4 9440      COM	R4
    24B5 2455      CLR	R5
    24B6 FC47      SBRC	R4,7
    24B7 9450      COM	R5
    24B8 8108      LDD	R16,Y+0
    24B9 8119      LDD	R17,Y+1
    24BA 812A      LDD	R18,Y+2
    24BB 813B      LDD	R19,Y+3
    24BC 925A      ST	R5,-Y
    24BD 924A      ST	R4,-Y
    24BE 923A      ST	R3,-Y
    24BF 922A      ST	R2,-Y
    24C0 940E 20EA CALL	mod32u
    24C2 0178      MOVW	R14,R16
    24C3 E089      LDI	R24,0x9
    24C4 E090      LDI	R25,0
    24C5 1780      CP	R24,R16
    24C6 0791      CPC	R25,R17
    24C7 F034      BLT	0x24CE
    24C8 01C7      MOVW	R24,R14
    24C9 96C0      ADIW	R24,0x30
    24CA 01F6      MOVW	R30,R12
    24CB 9381      ST	R24,Z+
    24CC 016F      MOVW	R12,R30
    24CD C006      RJMP	0x24D4
    24CE 01C7      MOVW	R24,R14
    24CF 5A89      SUBI	R24,0xA9
    24D0 4F9F      SBCI	R25,0xFF
    24D1 01F6      MOVW	R30,R12
    24D2 9381      ST	R24,Z+
    24D3 016F      MOVW	R12,R30
    24D4 882C      LDD	R2,Y+20
    24D5 883D      LDD	R3,Y+21
    24D6 2444      CLR	R4
    24D7 FC37      SBRC	R3,7
    24D8 9440      COM	R4
    24D9 2455      CLR	R5
    24DA FC47      SBRC	R4,7
    24DB 9450      COM	R5
    24DC 8108      LDD	R16,Y+0
    24DD 8119      LDD	R17,Y+1
    24DE 812A      LDD	R18,Y+2
    24DF 813B      LDD	R19,Y+3
    24E0 925A      ST	R5,-Y
    24E1 924A      ST	R4,-Y
    24E2 923A      ST	R3,-Y
    24E3 922A      ST	R2,-Y
    24E4 940E 20E8 CALL	div32u
    24E6 8308      STD	Y+0,R16
    24E7 8319      STD	Y+1,R17
    24E8 832A      STD	Y+2,R18
    24E9 833B      STD	Y+3,R19
    24EA 8028      LDD	R2,Y+0
    24EB 8039      LDD	R3,Y+1
    24EC 804A      LDD	R4,Y+2
    24ED 805B      LDD	R5,Y+3
    24EE 9488      BCLR	0
    24EF 2022      TST	R2
    24F0 0432      CPC	R3,R2
    24F1 0442      CPC	R4,R2
    24F2 0452      CPC	R5,R2
    24F3 F009      BEQ	0x24F5
    24F4 CFBB      RJMP	0x24B0
    24F5 20AA      TST	R10
    24F6 F021      BEQ	0x24FB
    24F7 E28D      LDI	R24,0x2D
    24F8 01F6      MOVW	R30,R12
    24F9 9381      ST	R24,Z+
    24FA 016F      MOVW	R12,R30
    24FB 0126      MOVW	R4,R12
    24FC 01C2      MOVW	R24,R4
    24FD 9701      SBIW	R24,1
    24FE 016C      MOVW	R12,R24
    24FF 2422      CLR	R2
    2500 01F2      MOVW	R30,R4
    2501 8220      STD	Z+0,R2
    2502 84EE      LDD	R14,Y+14
    2503 84FF      LDD	R15,Y+15
    2504 C00D      RJMP	0x2512
    2505 01F7      MOVW	R30,R14
    2506 80A0      LDD	R10,Z+0
    2507 01F6      MOVW	R30,R12
    2508 8020      LDD	R2,Z+0
    2509 01F7      MOVW	R30,R14
    250A 9221      ST	R2,Z+
    250B 017F      MOVW	R14,R30
    250C 0116      MOVW	R2,R12
    250D 01C1      MOVW	R24,R2
    250E 9701      SBIW	R24,1
    250F 016C      MOVW	R12,R24
    2510 01F1      MOVW	R30,R2
    2511 82A0      STD	Z+0,R10
    2512 14EC      CP	R14,R12
    2513 04FD      CPC	R15,R13
    2514 F380      BCS	0x2505
    2515 850E      LDD	R16,Y+14
    2516 851F      LDD	R17,Y+15
    2517 9624      ADIW	R28,4
    2518 940E 21A2 CALL	pop_xgsetF0FC
    251A 9624      ADIW	R28,4
    251B 9508      RET
_ultoa:
    251C 933A      ST	R19,-Y
    251D 932A      ST	R18,-Y
    251E 940E 21AD CALL	push_xgsetF0FC
    2520 0158      MOVW	R10,R16
    2521 84CE      LDD	R12,Y+14
    2522 84DF      LDD	R13,Y+15
    2523 01A5      MOVW	R20,R10
    2524 0116      MOVW	R2,R12
    2525 2444      CLR	R4
    2526 FC37      SBRC	R3,7
    2527 9440      COM	R4
    2528 2455      CLR	R5
    2529 FC47      SBRC	R4,7
    252A 9450      COM	R5
    252B 850A      LDD	R16,Y+10
    252C 851B      LDD	R17,Y+11
    252D 852C      LDD	R18,Y+12
    252E 853D      LDD	R19,Y+13
    252F 925A      ST	R5,-Y
    2530 924A      ST	R4,-Y
    2531 923A      ST	R3,-Y
    2532 922A      ST	R2,-Y
    2533 940E 20EA CALL	mod32u
    2535 01B8      MOVW	R22,R16
    2536 E089      LDI	R24,0x9
    2537 E090      LDI	R25,0
    2538 1780      CP	R24,R16
    2539 0791      CPC	R25,R17
    253A F034      BLT	0x2541
    253B 01CB      MOVW	R24,R22
    253C 96C0      ADIW	R24,0x30
    253D 01FA      MOVW	R30,R20
    253E 9381      ST	R24,Z+
    253F 01AF      MOVW	R20,R30
    2540 C006      RJMP	0x2547
    2541 01CB      MOVW	R24,R22
    2542 5A89      SUBI	R24,0xA9
    2543 4F9F      SBCI	R25,0xFF
    2544 01FA      MOVW	R30,R20
    2545 9381      ST	R24,Z+
    2546 01AF      MOVW	R20,R30
    2547 0116      MOVW	R2,R12
    2548 2444      CLR	R4
    2549 FC37      SBRC	R3,7
    254A 9440      COM	R4
    254B 2455      CLR	R5
    254C FC47      SBRC	R4,7
    254D 9450      COM	R5
    254E 850A      LDD	R16,Y+10
    254F 851B      LDD	R17,Y+11
    2550 852C      LDD	R18,Y+12
    2551 853D      LDD	R19,Y+13
    2552 925A      ST	R5,-Y
    2553 924A      ST	R4,-Y
    2554 923A      ST	R3,-Y
    2555 922A      ST	R2,-Y
    2556 940E 20E8 CALL	div32u
    2558 870A      STD	Y+10,R16
    2559 871B      STD	Y+11,R17
    255A 872C      STD	Y+12,R18
    255B 873D      STD	Y+13,R19
    255C 842A      LDD	R2,Y+10
    255D 843B      LDD	R3,Y+11
    255E 844C      LDD	R4,Y+12
    255F 845D      LDD	R5,Y+13
    2560 9488      BCLR	0
    2561 2022      TST	R2
    2562 0432      CPC	R3,R2
    2563 0442      CPC	R4,R2
    2564 0452      CPC	R5,R2
    2565 F009      BEQ	0x2567
    2566 CFBD      RJMP	0x2524
    2567 012A      MOVW	R4,R20
    2568 5041      SUBI	R20,1
    2569 4050      SBCI	R21,0
    256A 2422      CLR	R2
    256B 01F2      MOVW	R30,R4
    256C 8220      STD	Z+0,R2
    256D 0165      MOVW	R12,R10
    256E C00C      RJMP	0x257B
    256F 01F6      MOVW	R30,R12
    2570 80E0      LDD	R14,Z+0
    2571 01FA      MOVW	R30,R20
    2572 8020      LDD	R2,Z+0
    2573 01F6      MOVW	R30,R12
    2574 9221      ST	R2,Z+
    2575 016F      MOVW	R12,R30
    2576 011A      MOVW	R2,R20
    2577 5041      SUBI	R20,1
    2578 4050      SBCI	R21,0
    2579 01F1      MOVW	R30,R2
    257A 82E0      STD	Z+0,R14
    257B 16C4      CP	R12,R20
    257C 06D5      CPC	R13,R21
    257D F388      BCS	0x256F
    257E 0185      MOVW	R16,R10
    257F 940E 21A2 CALL	pop_xgsetF0FC
    2581 9622      ADIW	R28,2
    2582 9508      RET
_utoa:
    2583 940E 21AD CALL	push_xgsetF0FC
    2585 0169      MOVW	R12,R18
    2586 0158      MOVW	R10,R16
    2587 84EA      LDD	R14,Y+10
    2588 84FB      LDD	R15,Y+11
    2589 01A5      MOVW	R20,R10
    258A 0197      MOVW	R18,R14
    258B 0186      MOVW	R16,R12
    258C 940E 20CC CALL	mod16u
    258E 01B8      MOVW	R22,R16
    258F E089      LDI	R24,0x9
    2590 E090      LDI	R25,0
    2591 1780      CP	R24,R16
    2592 0791      CPC	R25,R17
    2593 F034      BLT	0x259A
    2594 01CB      MOVW	R24,R22
    2595 96C0      ADIW	R24,0x30
    2596 01FA      MOVW	R30,R20
    2597 9381      ST	R24,Z+
    2598 01AF      MOVW	R20,R30
    2599 C006      RJMP	0x25A0
    259A 01CB      MOVW	R24,R22
    259B 5A89      SUBI	R24,0xA9
    259C 4F9F      SBCI	R25,0xFF
    259D 01FA      MOVW	R30,R20
    259E 9381      ST	R24,Z+
    259F 01AF      MOVW	R20,R30
    25A0 0197      MOVW	R18,R14
    25A1 0186      MOVW	R16,R12
    25A2 940E 20CE CALL	div16u
    25A4 0168      MOVW	R12,R16
    25A5 20CC      TST	R12
    25A6 F719      BNE	0x258A
    25A7 20DD      TST	R13
    25A8 F709      BNE	0x258A
    25A9 012A      MOVW	R4,R20
    25AA 5041      SUBI	R20,1
    25AB 4050      SBCI	R21,0
    25AC 2422      CLR	R2
    25AD 01F2      MOVW	R30,R4
    25AE 8220      STD	Z+0,R2
    25AF 0165      MOVW	R12,R10
    25B0 C00C      RJMP	0x25BD
    25B1 01F6      MOVW	R30,R12
    25B2 80E0      LDD	R14,Z+0
    25B3 01FA      MOVW	R30,R20
    25B4 8020      LDD	R2,Z+0
    25B5 01F6      MOVW	R30,R12
    25B6 9221      ST	R2,Z+
    25B7 016F      MOVW	R12,R30
    25B8 011A      MOVW	R2,R20
    25B9 5041      SUBI	R20,1
    25BA 4050      SBCI	R21,0
    25BB 01F1      MOVW	R30,R2
    25BC 82E0      STD	Z+0,R14
    25BD 16C4      CP	R12,R20
    25BE 06D5      CPC	R13,R21
    25BF F388      BCS	0x25B1
    25C0 0185      MOVW	R16,R10
    25C1 940C 21A2 JMP	pop_xgsetF0FC
_isdigit:
    25C3 E087      LDI	R24,7
    25C4 E091      LDI	R25,1
    25C5 01F8      MOVW	R30,R16
    25C6 0FE8      ADD	R30,R24
    25C7 1FF9      ADC	R31,R25
    25C8 9106      ELPM	R16,1(Z)
    25C9 2711      CLR	R17
    25CA 7004      ANDI	R16,4
    25CB 7010      ANDI	R17,0
    25CC 9508      RET
_islower:
    25CD E087      LDI	R24,7
    25CE E091      LDI	R25,1
    25CF 01F8      MOVW	R30,R16
    25D0 0FE8      ADD	R30,R24
    25D1 1FF9      ADC	R31,R25
    25D2 9106      ELPM	R16,1(Z)
    25D3 2711      CLR	R17
    25D4 7002      ANDI	R16,2
    25D5 7010      ANDI	R17,0
    25D6 9508      RET
_isspace:
    25D7 E087      LDI	R24,7
    25D8 E091      LDI	R25,1
    25D9 01F8      MOVW	R30,R16
    25DA 0FE8      ADD	R30,R24
    25DB 1FF9      ADC	R31,R25
    25DC 9106      ELPM	R16,1(Z)
    25DD 2711      CLR	R17
    25DE 7100      ANDI	R16,0x10
    25DF 7010      ANDI	R17,0
    25E0 9508      RET
_toupper:
    25E1 934A      ST	R20,-Y
    25E2 935A      ST	R21,-Y
    25E3 01A8      MOVW	R20,R16
    25E4 018A      MOVW	R16,R20
    25E5 940E 25CD CALL	_islower
    25E7 3000      CPI	R16,0
    25E8 0701      CPC	R16,R17
    25E9 F031      BEQ	0x25F0
    25EA 018A      MOVW	R16,R20
    25EB 5601      SUBI	R16,0x61
    25EC 4010      SBCI	R17,0
    25ED 5B0F      SUBI	R16,0xBF
    25EE 4F1F      SBCI	R17,0xFF
    25EF C001      RJMP	0x25F1
    25F0 018A      MOVW	R16,R20
    25F1 9159      LD	R21,Y+
    25F2 9149      LD	R20,Y+
    25F3 9508      RET
_printf:
    25F4 940E 20C0 CALL	push_arg4
    25F6 92AA      ST	R10,-Y
    25F7 92BA      ST	R11,-Y
    25F8 9722      SBIW	R28,2
    25F9 01CE      MOVW	R24,R28
    25FA 9604      ADIW	R24,4
    25FB EFEE      LDI	R30,0xFE
    25FC EFFF      LDI	R31,0xFF
    25FD 70E3      ANDI	R30,3
    25FE 70F0      ANDI	R31,0
    25FF 015F      MOVW	R10,R30
    2600 0EA8      ADD	R10,R24
    2601 1EB9      ADC	R11,R25
    2602 82B9      STD	Y+1,R11
    2603 82A8      STD	Y+0,R10
    2604 812C      LDD	R18,Y+4
    2605 813D      LDD	R19,Y+5
    2606 E900      LDI	R16,0x90
    2607 E010      LDI	R17,0
    2608 940E 1C85 CALL	__print
    260A 0158      MOVW	R10,R16
    260B 9622      ADIW	R28,2
    260C 90B9      LD	R11,Y+
    260D 90A9      LD	R10,Y+
    260E 9624      ADIW	R28,4
    260F 9508      RET
